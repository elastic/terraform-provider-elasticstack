package kibana_oapi

import (
	"context"
	"fmt"
	"net/http"

	"github.com/elastic/terraform-provider-elasticstack/generated/kbapi"
	"github.com/elastic/terraform-provider-elasticstack/internal/models"
	"github.com/elastic/terraform-provider-elasticstack/internal/utils"
	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
)

func CreateSlo(ctx context.Context, apiClient *Client, s models.Slo) (*models.Slo, diag.Diagnostics) {
	// Convert the model indicator to create request indicator type
	indicator, err := convertIndicatorFromDefinitionToCreateRequest(s.Indicator)
	if err != nil {
		return nil, diag.FromErr(err)
	}

	reqModel := kbapi.CreateSloOpJSONRequestBody{
		Name:            s.Name,
		Description:     s.Description,
		TimeWindow:      s.TimeWindow,
		BudgetingMethod: s.BudgetingMethod,
		Objective:       s.Objective,
		Settings:        s.Settings,
		GroupBy:         transformGroupByForCreate(s.GroupBy),
		Tags:            utils.Pointer(utils.NonNilSlice(s.Tags)),
		Indicator:       *indicator,
	}

	// Explicitly set SLO object id if provided, otherwise we'll use the autogenerated ID from the Kibana API response
	if s.SloID != "" {
		reqModel.Id = &s.SloID
	}

	resp, err := apiClient.API.CreateSloOpWithResponse(ctx, s.SpaceID, reqModel)
	if err != nil {
		return nil, diag.FromErr(err)
	}

	switch resp.StatusCode() {
	case http.StatusOK:
		s.SloID = resp.JSON200.Id
		return &s, nil
	default:
		return nil, reportUnknownErrorSDK(resp.StatusCode(), resp.Body)
	}
}

func GetSlo(ctx context.Context, apiClient *Client, spaceID string, sloID string) (*models.Slo, diag.Diagnostics) {
	resp, err := apiClient.API.GetSloOpWithResponse(ctx, spaceID, sloID, &kbapi.GetSloOpParams{})
	if err != nil {
		return nil, diag.FromErr(err)
	}

	switch resp.StatusCode() {
	case http.StatusNotFound:
		return nil, nil
	case http.StatusOK:
		return convertSloWithSummaryResponseToModel(resp.JSON200), nil
	default:
		return nil, reportUnknownErrorSDK(resp.StatusCode(), resp.Body)
	}
}

func UpdateSlo(ctx context.Context, apiClient *Client, s models.Slo) (*models.Slo, diag.Diagnostics) {
	reqModel := kbapi.UpdateSloOpJSONRequestBody{
		Name:            &s.Name,
		Description:     &s.Description,
		TimeWindow:      &s.TimeWindow,
		BudgetingMethod: &s.BudgetingMethod,
		Objective:       &s.Objective,
		Settings:        s.Settings,
		GroupBy:         transformGroupByForCreate(s.GroupBy),
		Tags:            utils.Pointer(utils.NonNilSlice(s.Tags)),
	}

	// Convert the model indicator to update request indicator type
	indicator, err := convertIndicatorFromDefinitionToUpdateRequest(s.Indicator)
	if err != nil {
		return nil, diag.FromErr(err)
	}
	reqModel.Indicator = indicator

	resp, err := apiClient.API.UpdateSloOpWithResponse(ctx, s.SpaceID, s.SloID, reqModel)
	if err != nil {
		return nil, diag.FromErr(err)
	}

	switch resp.StatusCode() {
	case http.StatusOK:
		return &s, nil
	default:
		return nil, reportUnknownErrorSDK(resp.StatusCode(), resp.Body)
	}
}

func DeleteSlo(ctx context.Context, apiClient *Client, spaceID string, sloID string) diag.Diagnostics {
	resp, err := apiClient.API.DeleteSloOpWithResponse(ctx, spaceID, sloID)
	if err != nil {
		return diag.FromErr(err)
	}

	switch resp.StatusCode() {
	case http.StatusNotFound:
		return nil
	case http.StatusOK:
		return nil
	default:
		return reportUnknownErrorSDK(resp.StatusCode(), resp.Body)
	}
}

// Helper functions

func convertSloDefinitionResponseToModel(resp *kbapi.SLOsSloDefinitionResponse) *models.Slo {
	if resp == nil {
		return nil
	}

	return &models.Slo{
		SloID:           resp.Id,
		Name:            resp.Name,
		Description:     resp.Description,
		Indicator:       resp.Indicator,
		TimeWindow:      resp.TimeWindow,
		BudgetingMethod: resp.BudgetingMethod,
		Objective:       resp.Objective,
		Settings:        &resp.Settings,
		GroupBy:         convertGroupByFromResponse(resp.GroupBy),
		Tags:            resp.Tags,
	}
}

func convertIndicatorFromResponseToDefinition(from *kbapi.SLOsSloWithSummaryResponse_Indicator) (*kbapi.SLOsSloDefinitionResponse_Indicator, error) {
	to := &kbapi.SLOsSloDefinitionResponse_Indicator{}
	value, err := from.ValueByDiscriminator()
	if err != nil {
		return nil, fmt.Errorf("failed to get discriminator value: %w", err)
	}

	switch indicatorValue := value.(type) {
	case kbapi.SLOsIndicatorPropertiesApmAvailability:
		if err := to.FromSLOsIndicatorPropertiesApmAvailability(indicatorValue); err != nil {
			return nil, fmt.Errorf("failed to set apm availability indicator: %w", err)
		}
	case kbapi.SLOsIndicatorPropertiesApmLatency:
		if err := to.FromSLOsIndicatorPropertiesApmLatency(indicatorValue); err != nil {
			return nil, fmt.Errorf("failed to set apm latency indicator: %w", err)
		}
	case kbapi.SLOsIndicatorPropertiesCustomKql:
		if err := to.FromSLOsIndicatorPropertiesCustomKql(indicatorValue); err != nil {
			return nil, fmt.Errorf("failed to set custom kql indicator: %w", err)
		}
	case kbapi.SLOsIndicatorPropertiesCustomMetric:
		if err := to.FromSLOsIndicatorPropertiesCustomMetric(indicatorValue); err != nil {
			return nil, fmt.Errorf("failed to set custom metric indicator: %w", err)
		}
	case kbapi.SLOsIndicatorPropertiesHistogram:
		if err := to.FromSLOsIndicatorPropertiesHistogram(indicatorValue); err != nil {
			return nil, fmt.Errorf("failed to set histogram indicator: %w", err)
		}
	case kbapi.SLOsIndicatorPropertiesTimesliceMetric:
		if err := to.FromSLOsIndicatorPropertiesTimesliceMetric(indicatorValue); err != nil {
			return nil, fmt.Errorf("failed to set timeslice metric indicator: %w", err)
		}
	default:
		return nil, fmt.Errorf("unsupported indicator type: %T", indicatorValue)
	}

	return to, nil
}

func convertIndicatorFromDefinitionToCreateRequest(sourceIndicator kbapi.SLOsSloDefinitionResponse_Indicator) (*kbapi.SLOsCreateSloRequest_Indicator, error) {
	createIndicator := &kbapi.SLOsCreateSloRequest_Indicator{}

	value, err := sourceIndicator.ValueByDiscriminator()
	if err != nil {
		return nil, fmt.Errorf("failed to get discriminator value: %w", err)
	}

	switch indicatorValue := value.(type) {
	case kbapi.SLOsIndicatorPropertiesApmAvailability:
		if err := createIndicator.FromSLOsIndicatorPropertiesApmAvailability(indicatorValue); err != nil {
			return nil, fmt.Errorf("failed to set apm availability indicator: %w", err)
		}
	case kbapi.SLOsIndicatorPropertiesApmLatency:
		if err := createIndicator.FromSLOsIndicatorPropertiesApmLatency(indicatorValue); err != nil {
			return nil, fmt.Errorf("failed to set apm latency indicator: %w", err)
		}
	case kbapi.SLOsIndicatorPropertiesCustomKql:
		if err := createIndicator.FromSLOsIndicatorPropertiesCustomKql(indicatorValue); err != nil {
			return nil, fmt.Errorf("failed to set custom kql indicator: %w", err)
		}
	case kbapi.SLOsIndicatorPropertiesCustomMetric:
		if err := createIndicator.FromSLOsIndicatorPropertiesCustomMetric(indicatorValue); err != nil {
			return nil, fmt.Errorf("failed to set custom metric indicator: %w", err)
		}
	case kbapi.SLOsIndicatorPropertiesHistogram:
		if err := createIndicator.FromSLOsIndicatorPropertiesHistogram(indicatorValue); err != nil {
			return nil, fmt.Errorf("failed to set histogram indicator: %w", err)
		}
	case kbapi.SLOsIndicatorPropertiesTimesliceMetric:
		if err := createIndicator.FromSLOsIndicatorPropertiesTimesliceMetric(indicatorValue); err != nil {
			return nil, fmt.Errorf("failed to set timeslice metric indicator: %w", err)
		}
	default:
		return nil, fmt.Errorf("unsupported indicator type: %T", indicatorValue)
	}

	return createIndicator, nil
}

func convertIndicatorFromDefinitionToUpdateRequest(sourceIndicator kbapi.SLOsSloDefinitionResponse_Indicator) (*kbapi.SLOsUpdateSloRequest_Indicator, error) {
	updateIndicator := &kbapi.SLOsUpdateSloRequest_Indicator{}

	value, err := sourceIndicator.ValueByDiscriminator()
	if err != nil {
		return nil, fmt.Errorf("failed to get discriminator value: %w", err)
	}

	switch indicatorValue := value.(type) {
	case kbapi.SLOsIndicatorPropertiesApmAvailability:
		if err := updateIndicator.FromSLOsIndicatorPropertiesApmAvailability(indicatorValue); err != nil {
			return nil, fmt.Errorf("failed to set apm availability indicator: %w", err)
		}
	case kbapi.SLOsIndicatorPropertiesApmLatency:
		if err := updateIndicator.FromSLOsIndicatorPropertiesApmLatency(indicatorValue); err != nil {
			return nil, fmt.Errorf("failed to set apm latency indicator: %w", err)
		}
	case kbapi.SLOsIndicatorPropertiesCustomKql:
		if err := updateIndicator.FromSLOsIndicatorPropertiesCustomKql(indicatorValue); err != nil {
			return nil, fmt.Errorf("failed to set custom kql indicator: %w", err)
		}
	case kbapi.SLOsIndicatorPropertiesCustomMetric:
		if err := updateIndicator.FromSLOsIndicatorPropertiesCustomMetric(indicatorValue); err != nil {
			return nil, fmt.Errorf("failed to set custom metric indicator: %w", err)
		}
	case kbapi.SLOsIndicatorPropertiesHistogram:
		if err := updateIndicator.FromSLOsIndicatorPropertiesHistogram(indicatorValue); err != nil {
			return nil, fmt.Errorf("failed to set histogram indicator: %w", err)
		}
	case kbapi.SLOsIndicatorPropertiesTimesliceMetric:
		if err := updateIndicator.FromSLOsIndicatorPropertiesTimesliceMetric(indicatorValue); err != nil {
			return nil, fmt.Errorf("failed to set timeslice metric indicator: %w", err)
		}
	default:
		return nil, fmt.Errorf("unsupported indicator type: %T", indicatorValue)
	}

	return updateIndicator, nil
}

func convertSloWithSummaryResponseToModel(resp *kbapi.SLOsSloWithSummaryResponse) *models.Slo {
	if resp == nil {
		return nil
	}

	// Convert the response indicator to the definition response indicator type for consistency
	indicator, err := convertIndicatorFromResponseToDefinition(&resp.Indicator)
	if err != nil {
		return nil
	}

	return &models.Slo{
		SloID:           resp.Id,
		Name:            resp.Name,
		Description:     resp.Description,
		Indicator:       *indicator,
		TimeWindow:      resp.TimeWindow,
		BudgetingMethod: resp.BudgetingMethod,
		Objective:       resp.Objective,
		Settings:        &resp.Settings,
		GroupBy:         convertGroupByFromResponse(resp.GroupBy),
		Tags:            resp.Tags,
	}
}

func transformGroupByForCreate(groupBy []string) *kbapi.SLOsGroupBy {
	if len(groupBy) == 0 {
		return nil
	}
	if len(groupBy) == 1 {
		var result kbapi.SLOsGroupBy
		result.FromSLOsGroupBy0(groupBy[0])
		return &result
	}
	var result kbapi.SLOsGroupBy
	result.FromSLOsGroupBy1(groupBy)
	return &result
}

func convertGroupByFromResponse(groupBy kbapi.SLOsGroupBy) []string {
	// Try to convert from string (single value)
	if str, err := groupBy.AsSLOsGroupBy0(); err == nil {
		return []string{str}
	}

	// Try to convert from []string (multiple values)
	if strs, err := groupBy.AsSLOsGroupBy1(); err == nil {
		return strs
	}

	// Default to empty slice
	return []string{}
}
