package exception_item

import (
	"context"
	_ "embed"

	"github.com/hashicorp/terraform-plugin-framework-jsontypes/jsontypes"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

//go:embed resource-description.md
var exceptionItemResourceDescription string

func (r *ExceptionItemResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: exceptionItemResourceDescription,
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				MarkdownDescription: "The unique identifier of the exception item (auto-generated by Kibana).",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"item_id": schema.StringAttribute{
				MarkdownDescription: "The exception item's human readable string identifier.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"list_id": schema.StringAttribute{
				MarkdownDescription: "The exception list's identifier that this item belongs to.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"name": schema.StringAttribute{
				MarkdownDescription: "The name of the exception item.",
				Required:            true,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Describes the exception item.",
				Required:            true,
			},
			"type": schema.StringAttribute{
				MarkdownDescription: "The type of exception item. Must be `simple`.",
				Required:            true,
				Validators: []validator.String{
					stringvalidator.OneOf("simple"),
				},
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"namespace_type": schema.StringAttribute{
				MarkdownDescription: "Determines whether the exception item is available in all Kibana spaces or just the space in which it is created. Can be `single` (default) or `agnostic`.",
				Optional:            true,
				Computed:            true,
				Default:             stringdefault.StaticString("single"),
				Validators: []validator.String{
					stringvalidator.OneOf("single", "agnostic"),
				},
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"os_types": schema.ListAttribute{
				MarkdownDescription: "Array of OS types for which the exceptions apply. Valid values: `linux`, `macos`, `windows`.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"tags": schema.ListAttribute{
				MarkdownDescription: "String array containing words and phrases to help categorize exception items.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"meta": schema.StringAttribute{
				MarkdownDescription: "Placeholder for metadata about the exception item as JSON string.",
				Optional:            true,
			},
			"entries": schema.StringAttribute{
				MarkdownDescription: "The exception item entries as JSON string. This defines the conditions under which the exception applies.",
				Required:            true,
				CustomType:          jsontypes.NormalizedType{},
			},
			"comments": schema.ListNestedAttribute{
				MarkdownDescription: "Array of comments about the exception item.",
				Optional:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"id": schema.StringAttribute{
							MarkdownDescription: "The unique identifier of the comment (auto-generated by Kibana).",
							Computed:            true,
						},
						"comment": schema.StringAttribute{
							MarkdownDescription: "The comment text.",
							Required:            true,
						},
					},
				},
			},
			"expire_time": schema.StringAttribute{
				MarkdownDescription: "The exception item's expiration date in RFC3339 format. This field is only available for regular exception items, not endpoint exceptions.",
				Optional:            true,
			},
			"created_at": schema.StringAttribute{
				MarkdownDescription: "The timestamp of when the exception item was created.",
				Computed:            true,
			},
			"created_by": schema.StringAttribute{
				MarkdownDescription: "The user who created the exception item.",
				Computed:            true,
			},
			"updated_at": schema.StringAttribute{
				MarkdownDescription: "The timestamp of when the exception item was last updated.",
				Computed:            true,
			},
			"updated_by": schema.StringAttribute{
				MarkdownDescription: "The user who last updated the exception item.",
				Computed:            true,
			},
			"tie_breaker_id": schema.StringAttribute{
				MarkdownDescription: "Field used in search to ensure all items are sorted and returned correctly.",
				Computed:            true,
			},
		},
	}
}
