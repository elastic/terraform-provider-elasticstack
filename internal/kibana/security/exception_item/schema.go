package exception_item

import (
	"context"
	_ "embed"

	"github.com/elastic/terraform-provider-elasticstack/internal/utils/validators"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

//go:embed resource-description.md
var exceptionItemResourceDescription string

func (r *ExceptionItemResource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		MarkdownDescription: exceptionItemResourceDescription,
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				MarkdownDescription: "The unique identifier of the exception item (auto-generated by Kibana).",
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"space_id": schema.StringAttribute{
				MarkdownDescription: "An identifier for the space. If space_id is not provided, the default space is used.",
				Optional:            true,
				Computed:            true,
				Default:             stringdefault.StaticString("default"),
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"item_id": schema.StringAttribute{
				MarkdownDescription: "The exception item's human readable string identifier.",
				Optional:            true,
				Computed:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"list_id": schema.StringAttribute{
				MarkdownDescription: "The exception list's identifier that this item belongs to.",
				Required:            true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"name": schema.StringAttribute{
				MarkdownDescription: "The name of the exception item.",
				Required:            true,
			},
			"description": schema.StringAttribute{
				MarkdownDescription: "Describes the exception item.",
				Required:            true,
			},
			"type": schema.StringAttribute{
				MarkdownDescription: "The type of exception item. Must be `simple`.",
				Required:            true,
				Validators: []validator.String{
					stringvalidator.OneOf("simple"),
				},
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"namespace_type": schema.StringAttribute{
				MarkdownDescription: "Determines whether the exception item is available in all Kibana spaces or just the space in which it is created. Can be `single` (default) or `agnostic`.",
				Optional:            true,
				Computed:            true,
				Default:             stringdefault.StaticString("single"),
				Validators: []validator.String{
					stringvalidator.OneOf("single", "agnostic"),
				},
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"os_types": schema.ListAttribute{
				MarkdownDescription: "Array of OS types for which the exceptions apply. Valid values: `linux`, `macos`, `windows`.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"tags": schema.ListAttribute{
				MarkdownDescription: "String array containing words and phrases to help categorize exception items.",
				Optional:            true,
				ElementType:         types.StringType,
			},
			"meta": schema.StringAttribute{
				MarkdownDescription: "Placeholder for metadata about the exception item as JSON string.",
				Optional:            true,
			},
			"entries": schema.ListNestedAttribute{
				MarkdownDescription: "The exception item entries. This defines the conditions under which the exception applies.",
				Required:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"type": schema.StringAttribute{
							MarkdownDescription: "The type of entry. Valid values: `match`, `match_any`, `list`, `exists`, `nested`, `wildcard`.",
							Required:            true,
							Validators: []validator.String{
								stringvalidator.OneOf("match", "match_any", "list", "exists", "nested", "wildcard"),
							},
						},
						"field": schema.StringAttribute{
							MarkdownDescription: "The field name. Required for all entry types.",
							Required:            true,
						},
						"operator": schema.StringAttribute{
							MarkdownDescription: "The operator to use. Valid values: `included`, `excluded`. Note: The operator field is not supported for nested entry types and will be ignored if specified.",
							Optional:            true,
							Validators: []validator.String{
								validators.ForbiddenIfDependentPathOneOf(
									path.Root("type"),
									[]string{"nested"},
								),
								validators.RequiredIfDependentPathOneOf(
									path.Root("type"),
									[]string{"match", "match_any", "list", "exists", "wildcard"},
								),
								stringvalidator.OneOf("included", "excluded"),
							},
						},
						"value": schema.StringAttribute{
							MarkdownDescription: "The value to match (for `match` and `wildcard` types).",
							Optional:            true,
							Validators: []validator.String{
								validators.RequiredIfDependentPathOneOf(
									path.Root("type"),
									[]string{"match", "wildcard"},
								),
							},
						},
						"values": schema.ListAttribute{
							ElementType:         types.StringType,
							MarkdownDescription: "Array of values to match (for `match_any` type).",
							Optional:            true,
							Validators: []validator.List{
								validators.RequiredIfDependentPathOneOf(
									path.Root("type"),
									[]string{"match_any"},
								),
							},
						},
						"list": schema.SingleNestedAttribute{
							MarkdownDescription: "Value list reference (for `list` type).",
							Optional:            true,
							Validators: []validator.Object{
								validators.RequiredIfDependentPathOneOf(
									path.Root("type"),
									[]string{"list"},
								),
							},
							Attributes: map[string]schema.Attribute{
								"id": schema.StringAttribute{
									MarkdownDescription: "The value list ID.",
									Required:            true,
								},
								"type": schema.StringAttribute{
									MarkdownDescription: "The value list type (e.g., `keyword`, `ip`, `ip_range`).",
									Required:            true,
								},
							},
						},
						"entries": schema.ListNestedAttribute{
							MarkdownDescription: "Nested entries (for `nested` type). Only `match`, `match_any`, and `exists` entry types are allowed as nested entries.",
							Optional:            true,
							Validators: []validator.List{
								validators.RequiredIfDependentPathOneOf(
									path.Root("type"),
									[]string{"nested"},
								),
							},
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"type": schema.StringAttribute{
										MarkdownDescription: "The type of nested entry. Valid values: `match`, `match_any`, `exists`.",
										Required:            true,
										Validators: []validator.String{
											stringvalidator.OneOf("match", "match_any", "exists"),
										},
									},
									"field": schema.StringAttribute{
										MarkdownDescription: "The field name.",
										Required:            true,
									},
									"operator": schema.StringAttribute{
										MarkdownDescription: "The operator to use. Valid values: `included`, `excluded`.",
										Required:            true,
										Validators: []validator.String{
											stringvalidator.OneOf("included", "excluded"),
										},
									},
									"value": schema.StringAttribute{
										MarkdownDescription: "The value to match (for `match` type).",
										Optional:            true,
										Validators: []validator.String{
											validators.RequiredIfDependentPathOneOf(
												path.Root("type"),
												[]string{"match"},
											),
										},
									},
									"values": schema.ListAttribute{
										ElementType:         types.StringType,
										MarkdownDescription: "Array of values to match (for `match_any` type).",
										Optional:            true,
										Validators: []validator.List{
											validators.RequiredIfDependentPathOneOf(
												path.Root("type"),
												[]string{"match_any"},
											),
										},
									},
								},
							},
						},
					},
				},
			},
			"comments": schema.ListNestedAttribute{
				MarkdownDescription: "Array of comments about the exception item.",
				Optional:            true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"id": schema.StringAttribute{
							MarkdownDescription: "The unique identifier of the comment (auto-generated by Kibana).",
							Computed:            true,
						},
						"comment": schema.StringAttribute{
							MarkdownDescription: "The comment text.",
							Required:            true,
						},
					},
				},
			},
			"expire_time": schema.StringAttribute{
				MarkdownDescription: "The exception item's expiration date in RFC3339 format. This field is only available for regular exception items, not endpoint exceptions.",
				Optional:            true,
			},
			"created_at": schema.StringAttribute{
				MarkdownDescription: "The timestamp of when the exception item was created.",
				Computed:            true,
			},
			"created_by": schema.StringAttribute{
				MarkdownDescription: "The user who created the exception item.",
				Computed:            true,
			},
			"updated_at": schema.StringAttribute{
				MarkdownDescription: "The timestamp of when the exception item was last updated.",
				Computed:            true,
			},
			"updated_by": schema.StringAttribute{
				MarkdownDescription: "The user who last updated the exception item.",
				Computed:            true,
			},
			"tie_breaker_id": schema.StringAttribute{
				MarkdownDescription: "Field used in search to ensure all items are sorted and returned correctly.",
				Computed:            true,
			},
		},
	}
}
