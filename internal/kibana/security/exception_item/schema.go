package exception_item

import (
	"context"

	"github.com/hashicorp/terraform-plugin-framework-jsontypes/jsontypes"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/objectdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

func (r *exceptionItemResource) Schema(ctx context.Context, req resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Creates and manages Kibana exception list items. Exception items contain the actual exception logic (fields, values, operators) that prevent security detection rules from generating alerts when matched.",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Description: "The unique identifier of the exception item. This is generated by Kibana.",
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"space_id": schema.StringAttribute{
				Description: "The Kibana space ID where the exception item exists. Defaults to 'default'.",
				Optional:    true,
				Computed:    true,
				Default:     stringdefault.StaticString("default"),
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"item_id": schema.StringAttribute{
				Description: "The human-readable unique identifier for the exception item (e.g., 'trusted-linux-process'). If not provided, Kibana will generate one.",
				Optional:    true,
				Computed:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"list_id": schema.StringAttribute{
				Description: "The list_id of the exception list (container) that this item belongs to.",
				Required:    true,
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"name": schema.StringAttribute{
				Description: "The name of the exception item.",
				Required:    true,
			},
			"description": schema.StringAttribute{
				Description: "A description of the exception item.",
				Required:    true,
			},
			"type": schema.StringAttribute{
				Description: "The type of exception item. Must match the type of the parent exception list. Valid values are: 'simple'.",
				Required:    true,
				Validators: []validator.String{
					stringvalidator.OneOf("simple"),
				},
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"namespace_type": schema.StringAttribute{
				Description: "Determines whether the exception item is available in all Kibana spaces or just the space in which it is created. Valid values are: 'single' (only available in the space where created) or 'agnostic' (available in all spaces). Defaults to 'single'.",
				Optional:    true,
				Computed:    true,
				Default:     stringdefault.StaticString("single"),
				Validators: []validator.String{
					stringvalidator.OneOf("single", "agnostic"),
				},
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.RequiresReplace(),
				},
			},
			"entries": schema.StringAttribute{
				Description: "The exception entries as a JSON array. Each entry defines conditions (field, operator, value) that must match for the exception to apply. Use the jsontypes.Normalized custom type for proper JSON comparison.",
				Required:    true,
				CustomType:  jsontypes.NormalizedType{},
			},
			"comments": schema.ListNestedAttribute{
				Description: "Array of comments about the exception item.",
				Optional:    true,
				Computed:    true,
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"comment": schema.StringAttribute{
							Description: "The comment text.",
							Required:    true,
						},
					},
				},
				Default: listdefault.StaticValue(types.ListNull(types.ObjectType{AttrTypes: commentModel{}.attrTypes()})),
			},
			"os_types": schema.ListAttribute{
				Description: "Array of operating system types for which the exception item applies. Valid values include: 'linux', 'macos', 'windows'.",
				Optional:    true,
				Computed:    true,
				ElementType: types.StringType,
				Default:     listdefault.StaticValue(types.ListNull(types.StringType)),
			},
			"tags": schema.ListAttribute{
				Description: "Array of tags to help categorize the exception item.",
				Optional:    true,
				Computed:    true,
				ElementType: types.StringType,
				Default:     listdefault.StaticValue(types.ListNull(types.StringType)),
			},
			"meta": schema.SingleNestedAttribute{
				Description: "Optional metadata about the exception item.",
				Optional:    true,
				Computed:    true,
				Attributes: map[string]schema.Attribute{
					"additional_properties": schema.MapAttribute{
						Description: "Additional metadata properties as key-value pairs.",
						Optional:    true,
						Computed:    true,
						ElementType: types.StringType,
					},
				},
				Default: objectdefault.StaticValue(types.ObjectNull(metaModel{}.attrTypes())),
			},
			"expire_time": schema.StringAttribute{
				Description: "The exception item's expiration date in ISO format (e.g., '2024-12-31T23:59:59Z'). This field is only available for regular exception items, not endpoint exceptions.",
				Optional:    true,
			},
		},
	}
}
