// Code generated by ogen, DO NOT EDIT.

package connectors

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *ActionResponseProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionResponseProperties) encodeFields(e *jx.Encoder) {
	{
		if s.ActionTypeId.Set {
			e.FieldStart("actionTypeId")
			s.ActionTypeId.Encode(e)
		}
	}
	{
		if s.Config != nil {
			e.FieldStart("config")
			s.Config.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.IsDeprecated.Set {
			e.FieldStart("isDeprecated")
			s.IsDeprecated.Encode(e)
		}
	}
	{
		if s.IsMissingSecrets.Set {
			e.FieldStart("isMissingSecrets")
			s.IsMissingSecrets.Encode(e)
		}
	}
	{
		if s.IsPreconfigured.Set {
			e.FieldStart("isPreconfigured")
			s.IsPreconfigured.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfActionResponseProperties = [7]string{
	0: "actionTypeId",
	1: "config",
	2: "id",
	3: "isDeprecated",
	4: "isMissingSecrets",
	5: "isPreconfigured",
	6: "name",
}

// Decode decodes ActionResponseProperties from json.
func (s *ActionResponseProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionResponseProperties to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "actionTypeId":
			if err := func() error {
				s.ActionTypeId.Reset()
				if err := s.ActionTypeId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actionTypeId\"")
			}
		case "config":
			if err := func() error {
				s.Config = nil
				var elem ActionResponsePropertiesConfig
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Config = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "isDeprecated":
			if err := func() error {
				s.IsDeprecated.Reset()
				if err := s.IsDeprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isDeprecated\"")
			}
		case "isMissingSecrets":
			if err := func() error {
				s.IsMissingSecrets.Reset()
				if err := s.IsMissingSecrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isMissingSecrets\"")
			}
		case "isPreconfigured":
			if err := func() error {
				s.IsPreconfigured.Reset()
				if err := s.IsPreconfigured.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isPreconfigured\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionResponseProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionResponseProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionResponseProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionResponsePropertiesConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionResponsePropertiesConfig) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfActionResponsePropertiesConfig = [0]string{}

// Decode decodes ActionResponsePropertiesConfig from json.
func (s *ActionResponsePropertiesConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionResponsePropertiesConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionResponsePropertiesConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionResponsePropertiesConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionResponsePropertiesConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigPropertiesCasesWebhook) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigPropertiesCasesWebhook) encodeFields(e *jx.Encoder) {
	{
		if s.CreateCommentJson.Set {
			e.FieldStart("createCommentJson")
			s.CreateCommentJson.Encode(e)
		}
	}
	{
		if s.CreateCommentMethod.Set {
			e.FieldStart("createCommentMethod")
			s.CreateCommentMethod.Encode(e)
		}
	}
	{
		if s.CreateCommentUrl.Set {
			e.FieldStart("createCommentUrl")
			s.CreateCommentUrl.Encode(e)
		}
	}
	{
		e.FieldStart("createIncidentJson")
		e.Str(s.CreateIncidentJson)
	}
	{
		if s.CreateIncidentMethod.Set {
			e.FieldStart("createIncidentMethod")
			s.CreateIncidentMethod.Encode(e)
		}
	}
	{
		e.FieldStart("createIncidentResponseKey")
		e.Str(s.CreateIncidentResponseKey)
	}
	{
		e.FieldStart("createIncidentUrl")
		e.Str(s.CreateIncidentUrl)
	}
	{
		e.FieldStart("getIncidentResponseExternalTitleKey")
		e.Str(s.GetIncidentResponseExternalTitleKey)
	}
	{
		e.FieldStart("getIncidentUrl")
		e.Str(s.GetIncidentUrl)
	}
	{
		if s.HasAuth.Set {
			e.FieldStart("hasAuth")
			s.HasAuth.Encode(e)
		}
	}
	{
		if s.Headers.Set {
			e.FieldStart("headers")
			s.Headers.Encode(e)
		}
	}
	{
		e.FieldStart("updateIncidentJson")
		e.Str(s.UpdateIncidentJson)
	}
	{
		if s.UpdateIncidentMethod.Set {
			e.FieldStart("updateIncidentMethod")
			s.UpdateIncidentMethod.Encode(e)
		}
	}
	{
		e.FieldStart("updateIncidentUrl")
		e.Str(s.UpdateIncidentUrl)
	}
	{
		e.FieldStart("viewIncidentUrl")
		e.Str(s.ViewIncidentUrl)
	}
}

var jsonFieldsNameOfConfigPropertiesCasesWebhook = [15]string{
	0:  "createCommentJson",
	1:  "createCommentMethod",
	2:  "createCommentUrl",
	3:  "createIncidentJson",
	4:  "createIncidentMethod",
	5:  "createIncidentResponseKey",
	6:  "createIncidentUrl",
	7:  "getIncidentResponseExternalTitleKey",
	8:  "getIncidentUrl",
	9:  "hasAuth",
	10: "headers",
	11: "updateIncidentJson",
	12: "updateIncidentMethod",
	13: "updateIncidentUrl",
	14: "viewIncidentUrl",
}

// Decode decodes ConfigPropertiesCasesWebhook from json.
func (s *ConfigPropertiesCasesWebhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigPropertiesCasesWebhook to nil")
	}
	var requiredBitSet [2]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "createCommentJson":
			if err := func() error {
				s.CreateCommentJson.Reset()
				if err := s.CreateCommentJson.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createCommentJson\"")
			}
		case "createCommentMethod":
			if err := func() error {
				s.CreateCommentMethod.Reset()
				if err := s.CreateCommentMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createCommentMethod\"")
			}
		case "createCommentUrl":
			if err := func() error {
				s.CreateCommentUrl.Reset()
				if err := s.CreateCommentUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createCommentUrl\"")
			}
		case "createIncidentJson":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.CreateIncidentJson = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createIncidentJson\"")
			}
		case "createIncidentMethod":
			if err := func() error {
				s.CreateIncidentMethod.Reset()
				if err := s.CreateIncidentMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createIncidentMethod\"")
			}
		case "createIncidentResponseKey":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.CreateIncidentResponseKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createIncidentResponseKey\"")
			}
		case "createIncidentUrl":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.CreateIncidentUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createIncidentUrl\"")
			}
		case "getIncidentResponseExternalTitleKey":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Str()
				s.GetIncidentResponseExternalTitleKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"getIncidentResponseExternalTitleKey\"")
			}
		case "getIncidentUrl":
			requiredBitSet[1] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.GetIncidentUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"getIncidentUrl\"")
			}
		case "hasAuth":
			if err := func() error {
				s.HasAuth.Reset()
				if err := s.HasAuth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"hasAuth\"")
			}
		case "headers":
			if err := func() error {
				s.Headers.Reset()
				if err := s.Headers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "updateIncidentJson":
			requiredBitSet[1] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.UpdateIncidentJson = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updateIncidentJson\"")
			}
		case "updateIncidentMethod":
			if err := func() error {
				s.UpdateIncidentMethod.Reset()
				if err := s.UpdateIncidentMethod.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updateIncidentMethod\"")
			}
		case "updateIncidentUrl":
			requiredBitSet[1] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.UpdateIncidentUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"updateIncidentUrl\"")
			}
		case "viewIncidentUrl":
			requiredBitSet[1] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.ViewIncidentUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"viewIncidentUrl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigPropertiesCasesWebhook")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b11101000,
		0b01101001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConfigPropertiesCasesWebhook) {
					name = jsonFieldsNameOfConfigPropertiesCasesWebhook[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigPropertiesCasesWebhook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigPropertiesCasesWebhook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConfigPropertiesCasesWebhookCreateCommentMethod as json.
func (s ConfigPropertiesCasesWebhookCreateCommentMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConfigPropertiesCasesWebhookCreateCommentMethod from json.
func (s *ConfigPropertiesCasesWebhookCreateCommentMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigPropertiesCasesWebhookCreateCommentMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConfigPropertiesCasesWebhookCreateCommentMethod(v) {
	case ConfigPropertiesCasesWebhookCreateCommentMethodPatch:
		*s = ConfigPropertiesCasesWebhookCreateCommentMethodPatch
	case ConfigPropertiesCasesWebhookCreateCommentMethodPost:
		*s = ConfigPropertiesCasesWebhookCreateCommentMethodPost
	case ConfigPropertiesCasesWebhookCreateCommentMethodPut:
		*s = ConfigPropertiesCasesWebhookCreateCommentMethodPut
	default:
		*s = ConfigPropertiesCasesWebhookCreateCommentMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConfigPropertiesCasesWebhookCreateCommentMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigPropertiesCasesWebhookCreateCommentMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConfigPropertiesCasesWebhookCreateIncidentMethod as json.
func (s ConfigPropertiesCasesWebhookCreateIncidentMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConfigPropertiesCasesWebhookCreateIncidentMethod from json.
func (s *ConfigPropertiesCasesWebhookCreateIncidentMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigPropertiesCasesWebhookCreateIncidentMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConfigPropertiesCasesWebhookCreateIncidentMethod(v) {
	case ConfigPropertiesCasesWebhookCreateIncidentMethodPatch:
		*s = ConfigPropertiesCasesWebhookCreateIncidentMethodPatch
	case ConfigPropertiesCasesWebhookCreateIncidentMethodPost:
		*s = ConfigPropertiesCasesWebhookCreateIncidentMethodPost
	case ConfigPropertiesCasesWebhookCreateIncidentMethodPut:
		*s = ConfigPropertiesCasesWebhookCreateIncidentMethodPut
	default:
		*s = ConfigPropertiesCasesWebhookCreateIncidentMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConfigPropertiesCasesWebhookCreateIncidentMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigPropertiesCasesWebhookCreateIncidentMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConfigPropertiesCasesWebhookUpdateIncidentMethod as json.
func (s ConfigPropertiesCasesWebhookUpdateIncidentMethod) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConfigPropertiesCasesWebhookUpdateIncidentMethod from json.
func (s *ConfigPropertiesCasesWebhookUpdateIncidentMethod) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigPropertiesCasesWebhookUpdateIncidentMethod to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConfigPropertiesCasesWebhookUpdateIncidentMethod(v) {
	case ConfigPropertiesCasesWebhookUpdateIncidentMethodPatch:
		*s = ConfigPropertiesCasesWebhookUpdateIncidentMethodPatch
	case ConfigPropertiesCasesWebhookUpdateIncidentMethodPost:
		*s = ConfigPropertiesCasesWebhookUpdateIncidentMethodPost
	case ConfigPropertiesCasesWebhookUpdateIncidentMethodPut:
		*s = ConfigPropertiesCasesWebhookUpdateIncidentMethodPut
	default:
		*s = ConfigPropertiesCasesWebhookUpdateIncidentMethod(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConfigPropertiesCasesWebhookUpdateIncidentMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigPropertiesCasesWebhookUpdateIncidentMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ConfigPropertiesEmail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ConfigPropertiesEmail) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ConfigPropertiesEmail from json.
func (s *ConfigPropertiesEmail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigPropertiesEmail to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigPropertiesEmail")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConfigPropertiesEmail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigPropertiesEmail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigPropertiesIndex) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigPropertiesIndex) encodeFields(e *jx.Encoder) {
	{
		if s.ExecutionTimeField.Set {
			e.FieldStart("executionTimeField")
			s.ExecutionTimeField.Encode(e)
		}
	}
	{
		e.FieldStart("index")
		e.Str(s.Index)
	}
	{
		if s.Refresh.Set {
			e.FieldStart("refresh")
			s.Refresh.Encode(e)
		}
	}
}

var jsonFieldsNameOfConfigPropertiesIndex = [3]string{
	0: "executionTimeField",
	1: "index",
	2: "refresh",
}

// Decode decodes ConfigPropertiesIndex from json.
func (s *ConfigPropertiesIndex) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigPropertiesIndex to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "executionTimeField":
			if err := func() error {
				s.ExecutionTimeField.Reset()
				if err := s.ExecutionTimeField.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"executionTimeField\"")
			}
		case "index":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Index = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"index\"")
			}
		case "refresh":
			if err := func() error {
				s.Refresh.Reset()
				if err := s.Refresh.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refresh\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigPropertiesIndex")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConfigPropertiesIndex) {
					name = jsonFieldsNameOfConfigPropertiesIndex[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigPropertiesIndex) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigPropertiesIndex) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigPropertiesJira) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigPropertiesJira) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apiUrl")
		e.Str(s.ApiUrl)
	}
	{
		e.FieldStart("projectKey")
		e.Str(s.ProjectKey)
	}
}

var jsonFieldsNameOfConfigPropertiesJira = [2]string{
	0: "apiUrl",
	1: "projectKey",
}

// Decode decodes ConfigPropertiesJira from json.
func (s *ConfigPropertiesJira) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigPropertiesJira to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiUrl":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ApiUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiUrl\"")
			}
		case "projectKey":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ProjectKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"projectKey\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigPropertiesJira")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConfigPropertiesJira) {
					name = jsonFieldsNameOfConfigPropertiesJira[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigPropertiesJira) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigPropertiesJira) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigPropertiesOpsgenie) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigPropertiesOpsgenie) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apiUrl")
		e.Str(s.ApiUrl)
	}
}

var jsonFieldsNameOfConfigPropertiesOpsgenie = [1]string{
	0: "apiUrl",
}

// Decode decodes ConfigPropertiesOpsgenie from json.
func (s *ConfigPropertiesOpsgenie) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigPropertiesOpsgenie to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiUrl":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ApiUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiUrl\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigPropertiesOpsgenie")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConfigPropertiesOpsgenie) {
					name = jsonFieldsNameOfConfigPropertiesOpsgenie[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigPropertiesOpsgenie) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigPropertiesOpsgenie) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ConfigPropertiesPagerduty) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ConfigPropertiesPagerduty) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ConfigPropertiesPagerduty from json.
func (s *ConfigPropertiesPagerduty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigPropertiesPagerduty to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigPropertiesPagerduty")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConfigPropertiesPagerduty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigPropertiesPagerduty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigPropertiesResilient) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigPropertiesResilient) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apiUrl")
		e.Str(s.ApiUrl)
	}
	{
		e.FieldStart("orgId")
		e.Str(s.OrgId)
	}
}

var jsonFieldsNameOfConfigPropertiesResilient = [2]string{
	0: "apiUrl",
	1: "orgId",
}

// Decode decodes ConfigPropertiesResilient from json.
func (s *ConfigPropertiesResilient) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigPropertiesResilient to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiUrl":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ApiUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiUrl\"")
			}
		case "orgId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.OrgId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"orgId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigPropertiesResilient")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConfigPropertiesResilient) {
					name = jsonFieldsNameOfConfigPropertiesResilient[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigPropertiesResilient) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigPropertiesResilient) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigPropertiesServicenow) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigPropertiesServicenow) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apiUrl")
		e.Str(s.ApiUrl)
	}
	{
		if s.ClientId.Set {
			e.FieldStart("clientId")
			s.ClientId.Encode(e)
		}
	}
	{
		if s.IsOAuth.Set {
			e.FieldStart("isOAuth")
			s.IsOAuth.Encode(e)
		}
	}
	{
		if s.JwtKeyId.Set {
			e.FieldStart("jwtKeyId")
			s.JwtKeyId.Encode(e)
		}
	}
	{
		if s.UserIdentifierValue.Set {
			e.FieldStart("userIdentifierValue")
			s.UserIdentifierValue.Encode(e)
		}
	}
	{
		if s.UsesTableApi.Set {
			e.FieldStart("usesTableApi")
			s.UsesTableApi.Encode(e)
		}
	}
}

var jsonFieldsNameOfConfigPropertiesServicenow = [6]string{
	0: "apiUrl",
	1: "clientId",
	2: "isOAuth",
	3: "jwtKeyId",
	4: "userIdentifierValue",
	5: "usesTableApi",
}

// Decode decodes ConfigPropertiesServicenow from json.
func (s *ConfigPropertiesServicenow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigPropertiesServicenow to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiUrl":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ApiUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiUrl\"")
			}
		case "clientId":
			if err := func() error {
				s.ClientId.Reset()
				if err := s.ClientId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientId\"")
			}
		case "isOAuth":
			if err := func() error {
				s.IsOAuth.Reset()
				if err := s.IsOAuth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isOAuth\"")
			}
		case "jwtKeyId":
			if err := func() error {
				s.JwtKeyId.Reset()
				if err := s.JwtKeyId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jwtKeyId\"")
			}
		case "userIdentifierValue":
			if err := func() error {
				s.UserIdentifierValue.Reset()
				if err := s.UserIdentifierValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userIdentifierValue\"")
			}
		case "usesTableApi":
			if err := func() error {
				s.UsesTableApi.Reset()
				if err := s.UsesTableApi.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"usesTableApi\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigPropertiesServicenow")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConfigPropertiesServicenow) {
					name = jsonFieldsNameOfConfigPropertiesServicenow[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigPropertiesServicenow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigPropertiesServicenow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigPropertiesServicenowItom) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigPropertiesServicenowItom) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apiUrl")
		e.Str(s.ApiUrl)
	}
	{
		if s.ClientId.Set {
			e.FieldStart("clientId")
			s.ClientId.Encode(e)
		}
	}
	{
		if s.IsOAuth.Set {
			e.FieldStart("isOAuth")
			s.IsOAuth.Encode(e)
		}
	}
	{
		if s.JwtKeyId.Set {
			e.FieldStart("jwtKeyId")
			s.JwtKeyId.Encode(e)
		}
	}
	{
		if s.UserIdentifierValue.Set {
			e.FieldStart("userIdentifierValue")
			s.UserIdentifierValue.Encode(e)
		}
	}
}

var jsonFieldsNameOfConfigPropertiesServicenowItom = [5]string{
	0: "apiUrl",
	1: "clientId",
	2: "isOAuth",
	3: "jwtKeyId",
	4: "userIdentifierValue",
}

// Decode decodes ConfigPropertiesServicenowItom from json.
func (s *ConfigPropertiesServicenowItom) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigPropertiesServicenowItom to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiUrl":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ApiUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiUrl\"")
			}
		case "clientId":
			if err := func() error {
				s.ClientId.Reset()
				if err := s.ClientId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientId\"")
			}
		case "isOAuth":
			if err := func() error {
				s.IsOAuth.Reset()
				if err := s.IsOAuth.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isOAuth\"")
			}
		case "jwtKeyId":
			if err := func() error {
				s.JwtKeyId.Reset()
				if err := s.JwtKeyId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"jwtKeyId\"")
			}
		case "userIdentifierValue":
			if err := func() error {
				s.UserIdentifierValue.Reset()
				if err := s.UserIdentifierValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"userIdentifierValue\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigPropertiesServicenowItom")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConfigPropertiesServicenowItom) {
					name = jsonFieldsNameOfConfigPropertiesServicenowItom[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigPropertiesServicenowItom) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigPropertiesServicenowItom) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigPropertiesSwimlane) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigPropertiesSwimlane) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apiUrl")
		e.Str(s.ApiUrl)
	}
	{
		e.FieldStart("appId")
		e.Str(s.AppId)
	}
	{
		e.FieldStart("connectorType")
		s.ConnectorType.Encode(e)
	}
	{
		if s.Mappings.Set {
			e.FieldStart("mappings")
			s.Mappings.Encode(e)
		}
	}
}

var jsonFieldsNameOfConfigPropertiesSwimlane = [4]string{
	0: "apiUrl",
	1: "appId",
	2: "connectorType",
	3: "mappings",
}

// Decode decodes ConfigPropertiesSwimlane from json.
func (s *ConfigPropertiesSwimlane) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigPropertiesSwimlane to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiUrl":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ApiUrl = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiUrl\"")
			}
		case "appId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.AppId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"appId\"")
			}
		case "connectorType":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.ConnectorType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connectorType\"")
			}
		case "mappings":
			if err := func() error {
				s.Mappings.Reset()
				if err := s.Mappings.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mappings\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigPropertiesSwimlane")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConfigPropertiesSwimlane) {
					name = jsonFieldsNameOfConfigPropertiesSwimlane[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigPropertiesSwimlane) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigPropertiesSwimlane) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConfigPropertiesSwimlaneConnectorType as json.
func (s ConfigPropertiesSwimlaneConnectorType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConfigPropertiesSwimlaneConnectorType from json.
func (s *ConfigPropertiesSwimlaneConnectorType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigPropertiesSwimlaneConnectorType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConfigPropertiesSwimlaneConnectorType(v) {
	case ConfigPropertiesSwimlaneConnectorTypeAll:
		*s = ConfigPropertiesSwimlaneConnectorTypeAll
	case ConfigPropertiesSwimlaneConnectorTypeAlerts:
		*s = ConfigPropertiesSwimlaneConnectorTypeAlerts
	case ConfigPropertiesSwimlaneConnectorTypeCases:
		*s = ConfigPropertiesSwimlaneConnectorTypeCases
	default:
		*s = ConfigPropertiesSwimlaneConnectorType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConfigPropertiesSwimlaneConnectorType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigPropertiesSwimlaneConnectorType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigPropertiesSwimlaneMappings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigPropertiesSwimlaneMappings) encodeFields(e *jx.Encoder) {
	{
		if s.AlertIdConfig.Set {
			e.FieldStart("alertIdConfig")
			s.AlertIdConfig.Encode(e)
		}
	}
	{
		if s.CaseIdConfig.Set {
			e.FieldStart("caseIdConfig")
			s.CaseIdConfig.Encode(e)
		}
	}
	{
		if s.CaseNameConfig.Set {
			e.FieldStart("caseNameConfig")
			s.CaseNameConfig.Encode(e)
		}
	}
	{
		if s.CommentsConfig.Set {
			e.FieldStart("commentsConfig")
			s.CommentsConfig.Encode(e)
		}
	}
	{
		if s.DescriptionConfig.Set {
			e.FieldStart("descriptionConfig")
			s.DescriptionConfig.Encode(e)
		}
	}
	{
		if s.RuleNameConfig.Set {
			e.FieldStart("ruleNameConfig")
			s.RuleNameConfig.Encode(e)
		}
	}
	{
		if s.SeverityConfig.Set {
			e.FieldStart("severityConfig")
			s.SeverityConfig.Encode(e)
		}
	}
}

var jsonFieldsNameOfConfigPropertiesSwimlaneMappings = [7]string{
	0: "alertIdConfig",
	1: "caseIdConfig",
	2: "caseNameConfig",
	3: "commentsConfig",
	4: "descriptionConfig",
	5: "ruleNameConfig",
	6: "severityConfig",
}

// Decode decodes ConfigPropertiesSwimlaneMappings from json.
func (s *ConfigPropertiesSwimlaneMappings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigPropertiesSwimlaneMappings to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "alertIdConfig":
			if err := func() error {
				s.AlertIdConfig.Reset()
				if err := s.AlertIdConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"alertIdConfig\"")
			}
		case "caseIdConfig":
			if err := func() error {
				s.CaseIdConfig.Reset()
				if err := s.CaseIdConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caseIdConfig\"")
			}
		case "caseNameConfig":
			if err := func() error {
				s.CaseNameConfig.Reset()
				if err := s.CaseNameConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"caseNameConfig\"")
			}
		case "commentsConfig":
			if err := func() error {
				s.CommentsConfig.Reset()
				if err := s.CommentsConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"commentsConfig\"")
			}
		case "descriptionConfig":
			if err := func() error {
				s.DescriptionConfig.Reset()
				if err := s.DescriptionConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"descriptionConfig\"")
			}
		case "ruleNameConfig":
			if err := func() error {
				s.RuleNameConfig.Reset()
				if err := s.RuleNameConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"ruleNameConfig\"")
			}
		case "severityConfig":
			if err := func() error {
				s.SeverityConfig.Reset()
				if err := s.SeverityConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"severityConfig\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigPropertiesSwimlaneMappings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigPropertiesSwimlaneMappings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigPropertiesSwimlaneMappings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigPropertiesSwimlaneMappingsAlertIdConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigPropertiesSwimlaneMappingsAlertIdConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("fieldType")
		e.Str(s.FieldType)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfConfigPropertiesSwimlaneMappingsAlertIdConfig = [4]string{
	0: "fieldType",
	1: "id",
	2: "key",
	3: "name",
}

// Decode decodes ConfigPropertiesSwimlaneMappingsAlertIdConfig from json.
func (s *ConfigPropertiesSwimlaneMappingsAlertIdConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigPropertiesSwimlaneMappingsAlertIdConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fieldType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FieldType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fieldType\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigPropertiesSwimlaneMappingsAlertIdConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConfigPropertiesSwimlaneMappingsAlertIdConfig) {
					name = jsonFieldsNameOfConfigPropertiesSwimlaneMappingsAlertIdConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigPropertiesSwimlaneMappingsAlertIdConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigPropertiesSwimlaneMappingsAlertIdConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigPropertiesSwimlaneMappingsCaseIdConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigPropertiesSwimlaneMappingsCaseIdConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("fieldType")
		e.Str(s.FieldType)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfConfigPropertiesSwimlaneMappingsCaseIdConfig = [4]string{
	0: "fieldType",
	1: "id",
	2: "key",
	3: "name",
}

// Decode decodes ConfigPropertiesSwimlaneMappingsCaseIdConfig from json.
func (s *ConfigPropertiesSwimlaneMappingsCaseIdConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigPropertiesSwimlaneMappingsCaseIdConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fieldType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FieldType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fieldType\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigPropertiesSwimlaneMappingsCaseIdConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConfigPropertiesSwimlaneMappingsCaseIdConfig) {
					name = jsonFieldsNameOfConfigPropertiesSwimlaneMappingsCaseIdConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigPropertiesSwimlaneMappingsCaseIdConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigPropertiesSwimlaneMappingsCaseIdConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigPropertiesSwimlaneMappingsCaseNameConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigPropertiesSwimlaneMappingsCaseNameConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("fieldType")
		e.Str(s.FieldType)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfConfigPropertiesSwimlaneMappingsCaseNameConfig = [4]string{
	0: "fieldType",
	1: "id",
	2: "key",
	3: "name",
}

// Decode decodes ConfigPropertiesSwimlaneMappingsCaseNameConfig from json.
func (s *ConfigPropertiesSwimlaneMappingsCaseNameConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigPropertiesSwimlaneMappingsCaseNameConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fieldType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FieldType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fieldType\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigPropertiesSwimlaneMappingsCaseNameConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConfigPropertiesSwimlaneMappingsCaseNameConfig) {
					name = jsonFieldsNameOfConfigPropertiesSwimlaneMappingsCaseNameConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigPropertiesSwimlaneMappingsCaseNameConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigPropertiesSwimlaneMappingsCaseNameConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigPropertiesSwimlaneMappingsCommentsConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigPropertiesSwimlaneMappingsCommentsConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("fieldType")
		e.Str(s.FieldType)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfConfigPropertiesSwimlaneMappingsCommentsConfig = [4]string{
	0: "fieldType",
	1: "id",
	2: "key",
	3: "name",
}

// Decode decodes ConfigPropertiesSwimlaneMappingsCommentsConfig from json.
func (s *ConfigPropertiesSwimlaneMappingsCommentsConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigPropertiesSwimlaneMappingsCommentsConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fieldType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FieldType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fieldType\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigPropertiesSwimlaneMappingsCommentsConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConfigPropertiesSwimlaneMappingsCommentsConfig) {
					name = jsonFieldsNameOfConfigPropertiesSwimlaneMappingsCommentsConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigPropertiesSwimlaneMappingsCommentsConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigPropertiesSwimlaneMappingsCommentsConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigPropertiesSwimlaneMappingsDescriptionConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigPropertiesSwimlaneMappingsDescriptionConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("fieldType")
		e.Str(s.FieldType)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfConfigPropertiesSwimlaneMappingsDescriptionConfig = [4]string{
	0: "fieldType",
	1: "id",
	2: "key",
	3: "name",
}

// Decode decodes ConfigPropertiesSwimlaneMappingsDescriptionConfig from json.
func (s *ConfigPropertiesSwimlaneMappingsDescriptionConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigPropertiesSwimlaneMappingsDescriptionConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fieldType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FieldType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fieldType\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigPropertiesSwimlaneMappingsDescriptionConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConfigPropertiesSwimlaneMappingsDescriptionConfig) {
					name = jsonFieldsNameOfConfigPropertiesSwimlaneMappingsDescriptionConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigPropertiesSwimlaneMappingsDescriptionConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigPropertiesSwimlaneMappingsDescriptionConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigPropertiesSwimlaneMappingsRuleNameConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigPropertiesSwimlaneMappingsRuleNameConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("fieldType")
		e.Str(s.FieldType)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfConfigPropertiesSwimlaneMappingsRuleNameConfig = [4]string{
	0: "fieldType",
	1: "id",
	2: "key",
	3: "name",
}

// Decode decodes ConfigPropertiesSwimlaneMappingsRuleNameConfig from json.
func (s *ConfigPropertiesSwimlaneMappingsRuleNameConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigPropertiesSwimlaneMappingsRuleNameConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fieldType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FieldType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fieldType\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigPropertiesSwimlaneMappingsRuleNameConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConfigPropertiesSwimlaneMappingsRuleNameConfig) {
					name = jsonFieldsNameOfConfigPropertiesSwimlaneMappingsRuleNameConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigPropertiesSwimlaneMappingsRuleNameConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigPropertiesSwimlaneMappingsRuleNameConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConfigPropertiesSwimlaneMappingsSeverityConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConfigPropertiesSwimlaneMappingsSeverityConfig) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("fieldType")
		e.Str(s.FieldType)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		e.FieldStart("key")
		e.Str(s.Key)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfConfigPropertiesSwimlaneMappingsSeverityConfig = [4]string{
	0: "fieldType",
	1: "id",
	2: "key",
	3: "name",
}

// Decode decodes ConfigPropertiesSwimlaneMappingsSeverityConfig from json.
func (s *ConfigPropertiesSwimlaneMappingsSeverityConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigPropertiesSwimlaneMappingsSeverityConfig to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "fieldType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.FieldType = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"fieldType\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "key":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.Key = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"key\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigPropertiesSwimlaneMappingsSeverityConfig")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConfigPropertiesSwimlaneMappingsSeverityConfig) {
					name = jsonFieldsNameOfConfigPropertiesSwimlaneMappingsSeverityConfig[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConfigPropertiesSwimlaneMappingsSeverityConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigPropertiesSwimlaneMappingsSeverityConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ConfigPropertiesTines) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ConfigPropertiesTines) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ConfigPropertiesTines from json.
func (s *ConfigPropertiesTines) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigPropertiesTines to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigPropertiesTines")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConfigPropertiesTines) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigPropertiesTines) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ConfigPropertiesWebhook) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ConfigPropertiesWebhook) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ConfigPropertiesWebhook from json.
func (s *ConfigPropertiesWebhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigPropertiesWebhook to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigPropertiesWebhook")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConfigPropertiesWebhook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigPropertiesWebhook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s ConfigPropertiesXmatters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s ConfigPropertiesXmatters) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes ConfigPropertiesXmatters from json.
func (s *ConfigPropertiesXmatters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConfigPropertiesXmatters to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConfigPropertiesXmatters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConfigPropertiesXmatters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConfigPropertiesXmatters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConnectorResponseProperties as json.
func (s ConnectorResponseProperties) Encode(e *jx.Encoder) {
	switch s.Type {
	case ConnectorResponsePropertiesCasesWebhookConnectorResponseProperties:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".cases-webhook")
		s.ConnectorResponsePropertiesCasesWebhook.encodeFields(e)
		e.ObjEnd()
	case ConnectorResponsePropertiesEmailConnectorResponseProperties:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".email")
		s.ConnectorResponsePropertiesEmail.encodeFields(e)
		e.ObjEnd()
	case ConnectorResponsePropertiesIndexConnectorResponseProperties:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".index")
		s.ConnectorResponsePropertiesIndex.encodeFields(e)
		e.ObjEnd()
	case ConnectorResponsePropertiesJiraConnectorResponseProperties:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".jira")
		s.ConnectorResponsePropertiesJira.encodeFields(e)
		e.ObjEnd()
	case ConnectorResponsePropertiesOpsgenieConnectorResponseProperties:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".opsgenie")
		s.ConnectorResponsePropertiesOpsgenie.encodeFields(e)
		e.ObjEnd()
	case ConnectorResponsePropertiesPagerdutyConnectorResponseProperties:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".pagerduty")
		s.ConnectorResponsePropertiesPagerduty.encodeFields(e)
		e.ObjEnd()
	case ConnectorResponsePropertiesResilientConnectorResponseProperties:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".resilient")
		s.ConnectorResponsePropertiesResilient.encodeFields(e)
		e.ObjEnd()
	case ConnectorResponsePropertiesServerlogConnectorResponseProperties:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".server-log")
		s.ConnectorResponsePropertiesServerlog.encodeFields(e)
		e.ObjEnd()
	case ConnectorResponsePropertiesServicenowConnectorResponseProperties:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".servicenow")
		s.ConnectorResponsePropertiesServicenow.encodeFields(e)
		e.ObjEnd()
	case ConnectorResponsePropertiesServicenowItomConnectorResponseProperties:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".servicenow-itom")
		s.ConnectorResponsePropertiesServicenowItom.encodeFields(e)
		e.ObjEnd()
	case ConnectorResponsePropertiesServicenowSirConnectorResponseProperties:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".servicenow-sir")
		s.ConnectorResponsePropertiesServicenowSir.encodeFields(e)
		e.ObjEnd()
	case ConnectorResponsePropertiesSlackConnectorResponseProperties:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".slack")
		s.ConnectorResponsePropertiesSlack.encodeFields(e)
		e.ObjEnd()
	case ConnectorResponsePropertiesSwimlaneConnectorResponseProperties:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".swimlane")
		s.ConnectorResponsePropertiesSwimlane.encodeFields(e)
		e.ObjEnd()
	case ConnectorResponsePropertiesTeamsConnectorResponseProperties:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".teams")
		s.ConnectorResponsePropertiesTeams.encodeFields(e)
		e.ObjEnd()
	case ConnectorResponsePropertiesTinesConnectorResponseProperties:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".tines")
		s.ConnectorResponsePropertiesTines.encodeFields(e)
		e.ObjEnd()
	case ConnectorResponsePropertiesWebhookConnectorResponseProperties:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".webhook")
		s.ConnectorResponsePropertiesWebhook.encodeFields(e)
		e.ObjEnd()
	case ConnectorResponsePropertiesXmattersConnectorResponseProperties:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".xmatters")
		s.ConnectorResponsePropertiesXmatters.encodeFields(e)
		e.ObjEnd()
	}
}

// Decode decodes ConnectorResponseProperties from json.
func (s *ConnectorResponseProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConnectorResponseProperties to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "connector_type_id":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case ".cases-webhook":
					s.Type = ConnectorResponsePropertiesCasesWebhookConnectorResponseProperties
					found = true
				case ".email":
					s.Type = ConnectorResponsePropertiesEmailConnectorResponseProperties
					found = true
				case ".index":
					s.Type = ConnectorResponsePropertiesIndexConnectorResponseProperties
					found = true
				case ".jira":
					s.Type = ConnectorResponsePropertiesJiraConnectorResponseProperties
					found = true
				case ".opsgenie":
					s.Type = ConnectorResponsePropertiesOpsgenieConnectorResponseProperties
					found = true
				case ".pagerduty":
					s.Type = ConnectorResponsePropertiesPagerdutyConnectorResponseProperties
					found = true
				case ".resilient":
					s.Type = ConnectorResponsePropertiesResilientConnectorResponseProperties
					found = true
				case ".server-log":
					s.Type = ConnectorResponsePropertiesServerlogConnectorResponseProperties
					found = true
				case ".servicenow":
					s.Type = ConnectorResponsePropertiesServicenowConnectorResponseProperties
					found = true
				case ".servicenow-itom":
					s.Type = ConnectorResponsePropertiesServicenowItomConnectorResponseProperties
					found = true
				case ".servicenow-sir":
					s.Type = ConnectorResponsePropertiesServicenowSirConnectorResponseProperties
					found = true
				case ".slack":
					s.Type = ConnectorResponsePropertiesSlackConnectorResponseProperties
					found = true
				case ".swimlane":
					s.Type = ConnectorResponsePropertiesSwimlaneConnectorResponseProperties
					found = true
				case ".teams":
					s.Type = ConnectorResponsePropertiesTeamsConnectorResponseProperties
					found = true
				case ".tines":
					s.Type = ConnectorResponsePropertiesTinesConnectorResponseProperties
					found = true
				case ".webhook":
					s.Type = ConnectorResponsePropertiesWebhookConnectorResponseProperties
					found = true
				case ".xmatters":
					s.Type = ConnectorResponsePropertiesXmattersConnectorResponseProperties
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case ConnectorResponsePropertiesCasesWebhookConnectorResponseProperties:
		if err := s.ConnectorResponsePropertiesCasesWebhook.Decode(d); err != nil {
			return err
		}
	case ConnectorResponsePropertiesEmailConnectorResponseProperties:
		if err := s.ConnectorResponsePropertiesEmail.Decode(d); err != nil {
			return err
		}
	case ConnectorResponsePropertiesIndexConnectorResponseProperties:
		if err := s.ConnectorResponsePropertiesIndex.Decode(d); err != nil {
			return err
		}
	case ConnectorResponsePropertiesJiraConnectorResponseProperties:
		if err := s.ConnectorResponsePropertiesJira.Decode(d); err != nil {
			return err
		}
	case ConnectorResponsePropertiesOpsgenieConnectorResponseProperties:
		if err := s.ConnectorResponsePropertiesOpsgenie.Decode(d); err != nil {
			return err
		}
	case ConnectorResponsePropertiesPagerdutyConnectorResponseProperties:
		if err := s.ConnectorResponsePropertiesPagerduty.Decode(d); err != nil {
			return err
		}
	case ConnectorResponsePropertiesResilientConnectorResponseProperties:
		if err := s.ConnectorResponsePropertiesResilient.Decode(d); err != nil {
			return err
		}
	case ConnectorResponsePropertiesServerlogConnectorResponseProperties:
		if err := s.ConnectorResponsePropertiesServerlog.Decode(d); err != nil {
			return err
		}
	case ConnectorResponsePropertiesServicenowConnectorResponseProperties:
		if err := s.ConnectorResponsePropertiesServicenow.Decode(d); err != nil {
			return err
		}
	case ConnectorResponsePropertiesServicenowItomConnectorResponseProperties:
		if err := s.ConnectorResponsePropertiesServicenowItom.Decode(d); err != nil {
			return err
		}
	case ConnectorResponsePropertiesServicenowSirConnectorResponseProperties:
		if err := s.ConnectorResponsePropertiesServicenowSir.Decode(d); err != nil {
			return err
		}
	case ConnectorResponsePropertiesSlackConnectorResponseProperties:
		if err := s.ConnectorResponsePropertiesSlack.Decode(d); err != nil {
			return err
		}
	case ConnectorResponsePropertiesSwimlaneConnectorResponseProperties:
		if err := s.ConnectorResponsePropertiesSwimlane.Decode(d); err != nil {
			return err
		}
	case ConnectorResponsePropertiesTeamsConnectorResponseProperties:
		if err := s.ConnectorResponsePropertiesTeams.Decode(d); err != nil {
			return err
		}
	case ConnectorResponsePropertiesTinesConnectorResponseProperties:
		if err := s.ConnectorResponsePropertiesTines.Decode(d); err != nil {
			return err
		}
	case ConnectorResponsePropertiesWebhookConnectorResponseProperties:
		if err := s.ConnectorResponsePropertiesWebhook.Decode(d); err != nil {
			return err
		}
	case ConnectorResponsePropertiesXmattersConnectorResponseProperties:
		if err := s.ConnectorResponsePropertiesXmatters.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConnectorResponseProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConnectorResponseProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConnectorResponsePropertiesCasesWebhook) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConnectorResponsePropertiesCasesWebhook) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.IsDeprecated.Set {
			e.FieldStart("is_deprecated")
			s.IsDeprecated.Encode(e)
		}
	}
	{
		if s.IsMissingSecrets.Set {
			e.FieldStart("is_missing_secrets")
			s.IsMissingSecrets.Encode(e)
		}
	}
	{
		e.FieldStart("is_preconfigured")
		s.IsPreconfigured.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfConnectorResponsePropertiesCasesWebhook = [6]string{
	0: "config",
	1: "id",
	2: "is_deprecated",
	3: "is_missing_secrets",
	4: "is_preconfigured",
	5: "name",
}

// Decode decodes ConnectorResponsePropertiesCasesWebhook from json.
func (s *ConnectorResponsePropertiesCasesWebhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConnectorResponsePropertiesCasesWebhook to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "is_deprecated":
			if err := func() error {
				s.IsDeprecated.Reset()
				if err := s.IsDeprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_deprecated\"")
			}
		case "is_missing_secrets":
			if err := func() error {
				s.IsMissingSecrets.Reset()
				if err := s.IsMissingSecrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_missing_secrets\"")
			}
		case "is_preconfigured":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.IsPreconfigured.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_preconfigured\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConnectorResponsePropertiesCasesWebhook")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConnectorResponsePropertiesCasesWebhook) {
					name = jsonFieldsNameOfConnectorResponsePropertiesCasesWebhook[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConnectorResponsePropertiesCasesWebhook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConnectorResponsePropertiesCasesWebhook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConnectorResponsePropertiesEmail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConnectorResponsePropertiesEmail) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.IsDeprecated.Set {
			e.FieldStart("is_deprecated")
			s.IsDeprecated.Encode(e)
		}
	}
	{
		if s.IsMissingSecrets.Set {
			e.FieldStart("is_missing_secrets")
			s.IsMissingSecrets.Encode(e)
		}
	}
	{
		e.FieldStart("is_preconfigured")
		s.IsPreconfigured.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfConnectorResponsePropertiesEmail = [6]string{
	0: "config",
	1: "id",
	2: "is_deprecated",
	3: "is_missing_secrets",
	4: "is_preconfigured",
	5: "name",
}

// Decode decodes ConnectorResponsePropertiesEmail from json.
func (s *ConnectorResponsePropertiesEmail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConnectorResponsePropertiesEmail to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "is_deprecated":
			if err := func() error {
				s.IsDeprecated.Reset()
				if err := s.IsDeprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_deprecated\"")
			}
		case "is_missing_secrets":
			if err := func() error {
				s.IsMissingSecrets.Reset()
				if err := s.IsMissingSecrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_missing_secrets\"")
			}
		case "is_preconfigured":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.IsPreconfigured.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_preconfigured\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConnectorResponsePropertiesEmail")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConnectorResponsePropertiesEmail) {
					name = jsonFieldsNameOfConnectorResponsePropertiesEmail[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConnectorResponsePropertiesEmail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConnectorResponsePropertiesEmail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConnectorResponsePropertiesIndex) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConnectorResponsePropertiesIndex) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.IsDeprecated.Set {
			e.FieldStart("is_deprecated")
			s.IsDeprecated.Encode(e)
		}
	}
	{
		if s.IsMissingSecrets.Set {
			e.FieldStart("is_missing_secrets")
			s.IsMissingSecrets.Encode(e)
		}
	}
	{
		e.FieldStart("is_preconfigured")
		s.IsPreconfigured.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfConnectorResponsePropertiesIndex = [6]string{
	0: "config",
	1: "id",
	2: "is_deprecated",
	3: "is_missing_secrets",
	4: "is_preconfigured",
	5: "name",
}

// Decode decodes ConnectorResponsePropertiesIndex from json.
func (s *ConnectorResponsePropertiesIndex) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConnectorResponsePropertiesIndex to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "is_deprecated":
			if err := func() error {
				s.IsDeprecated.Reset()
				if err := s.IsDeprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_deprecated\"")
			}
		case "is_missing_secrets":
			if err := func() error {
				s.IsMissingSecrets.Reset()
				if err := s.IsMissingSecrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_missing_secrets\"")
			}
		case "is_preconfigured":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.IsPreconfigured.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_preconfigured\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConnectorResponsePropertiesIndex")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConnectorResponsePropertiesIndex) {
					name = jsonFieldsNameOfConnectorResponsePropertiesIndex[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConnectorResponsePropertiesIndex) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConnectorResponsePropertiesIndex) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConnectorResponsePropertiesJira) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConnectorResponsePropertiesJira) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.IsDeprecated.Set {
			e.FieldStart("is_deprecated")
			s.IsDeprecated.Encode(e)
		}
	}
	{
		if s.IsMissingSecrets.Set {
			e.FieldStart("is_missing_secrets")
			s.IsMissingSecrets.Encode(e)
		}
	}
	{
		e.FieldStart("is_preconfigured")
		s.IsPreconfigured.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfConnectorResponsePropertiesJira = [6]string{
	0: "config",
	1: "id",
	2: "is_deprecated",
	3: "is_missing_secrets",
	4: "is_preconfigured",
	5: "name",
}

// Decode decodes ConnectorResponsePropertiesJira from json.
func (s *ConnectorResponsePropertiesJira) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConnectorResponsePropertiesJira to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "is_deprecated":
			if err := func() error {
				s.IsDeprecated.Reset()
				if err := s.IsDeprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_deprecated\"")
			}
		case "is_missing_secrets":
			if err := func() error {
				s.IsMissingSecrets.Reset()
				if err := s.IsMissingSecrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_missing_secrets\"")
			}
		case "is_preconfigured":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.IsPreconfigured.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_preconfigured\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConnectorResponsePropertiesJira")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConnectorResponsePropertiesJira) {
					name = jsonFieldsNameOfConnectorResponsePropertiesJira[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConnectorResponsePropertiesJira) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConnectorResponsePropertiesJira) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConnectorResponsePropertiesOpsgenie) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConnectorResponsePropertiesOpsgenie) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.IsDeprecated.Set {
			e.FieldStart("is_deprecated")
			s.IsDeprecated.Encode(e)
		}
	}
	{
		if s.IsMissingSecrets.Set {
			e.FieldStart("is_missing_secrets")
			s.IsMissingSecrets.Encode(e)
		}
	}
	{
		e.FieldStart("is_preconfigured")
		s.IsPreconfigured.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfConnectorResponsePropertiesOpsgenie = [6]string{
	0: "config",
	1: "id",
	2: "is_deprecated",
	3: "is_missing_secrets",
	4: "is_preconfigured",
	5: "name",
}

// Decode decodes ConnectorResponsePropertiesOpsgenie from json.
func (s *ConnectorResponsePropertiesOpsgenie) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConnectorResponsePropertiesOpsgenie to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "is_deprecated":
			if err := func() error {
				s.IsDeprecated.Reset()
				if err := s.IsDeprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_deprecated\"")
			}
		case "is_missing_secrets":
			if err := func() error {
				s.IsMissingSecrets.Reset()
				if err := s.IsMissingSecrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_missing_secrets\"")
			}
		case "is_preconfigured":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.IsPreconfigured.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_preconfigured\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConnectorResponsePropertiesOpsgenie")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConnectorResponsePropertiesOpsgenie) {
					name = jsonFieldsNameOfConnectorResponsePropertiesOpsgenie[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConnectorResponsePropertiesOpsgenie) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConnectorResponsePropertiesOpsgenie) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConnectorResponsePropertiesPagerduty) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConnectorResponsePropertiesPagerduty) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.IsDeprecated.Set {
			e.FieldStart("is_deprecated")
			s.IsDeprecated.Encode(e)
		}
	}
	{
		if s.IsMissingSecrets.Set {
			e.FieldStart("is_missing_secrets")
			s.IsMissingSecrets.Encode(e)
		}
	}
	{
		e.FieldStart("is_preconfigured")
		s.IsPreconfigured.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfConnectorResponsePropertiesPagerduty = [6]string{
	0: "config",
	1: "id",
	2: "is_deprecated",
	3: "is_missing_secrets",
	4: "is_preconfigured",
	5: "name",
}

// Decode decodes ConnectorResponsePropertiesPagerduty from json.
func (s *ConnectorResponsePropertiesPagerduty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConnectorResponsePropertiesPagerduty to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "is_deprecated":
			if err := func() error {
				s.IsDeprecated.Reset()
				if err := s.IsDeprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_deprecated\"")
			}
		case "is_missing_secrets":
			if err := func() error {
				s.IsMissingSecrets.Reset()
				if err := s.IsMissingSecrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_missing_secrets\"")
			}
		case "is_preconfigured":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.IsPreconfigured.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_preconfigured\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConnectorResponsePropertiesPagerduty")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConnectorResponsePropertiesPagerduty) {
					name = jsonFieldsNameOfConnectorResponsePropertiesPagerduty[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConnectorResponsePropertiesPagerduty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConnectorResponsePropertiesPagerduty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConnectorResponsePropertiesResilient) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConnectorResponsePropertiesResilient) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.IsDeprecated.Set {
			e.FieldStart("is_deprecated")
			s.IsDeprecated.Encode(e)
		}
	}
	{
		if s.IsMissingSecrets.Set {
			e.FieldStart("is_missing_secrets")
			s.IsMissingSecrets.Encode(e)
		}
	}
	{
		e.FieldStart("is_preconfigured")
		s.IsPreconfigured.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfConnectorResponsePropertiesResilient = [6]string{
	0: "config",
	1: "id",
	2: "is_deprecated",
	3: "is_missing_secrets",
	4: "is_preconfigured",
	5: "name",
}

// Decode decodes ConnectorResponsePropertiesResilient from json.
func (s *ConnectorResponsePropertiesResilient) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConnectorResponsePropertiesResilient to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "is_deprecated":
			if err := func() error {
				s.IsDeprecated.Reset()
				if err := s.IsDeprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_deprecated\"")
			}
		case "is_missing_secrets":
			if err := func() error {
				s.IsMissingSecrets.Reset()
				if err := s.IsMissingSecrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_missing_secrets\"")
			}
		case "is_preconfigured":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.IsPreconfigured.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_preconfigured\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConnectorResponsePropertiesResilient")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConnectorResponsePropertiesResilient) {
					name = jsonFieldsNameOfConnectorResponsePropertiesResilient[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConnectorResponsePropertiesResilient) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConnectorResponsePropertiesResilient) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConnectorResponsePropertiesServerlog) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConnectorResponsePropertiesServerlog) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		if s.Config == nil {
			e.Null()
		} else {
			s.Config.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.IsDeprecated.Set {
			e.FieldStart("is_deprecated")
			s.IsDeprecated.Encode(e)
		}
	}
	{
		if s.IsMissingSecrets.Set {
			e.FieldStart("is_missing_secrets")
			s.IsMissingSecrets.Encode(e)
		}
	}
	{
		e.FieldStart("is_preconfigured")
		s.IsPreconfigured.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfConnectorResponsePropertiesServerlog = [6]string{
	0: "config",
	1: "id",
	2: "is_deprecated",
	3: "is_missing_secrets",
	4: "is_preconfigured",
	5: "name",
}

// Decode decodes ConnectorResponsePropertiesServerlog from json.
func (s *ConnectorResponsePropertiesServerlog) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConnectorResponsePropertiesServerlog to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Config = nil
				var elem ConnectorResponsePropertiesServerlogConfig
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Config = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "is_deprecated":
			if err := func() error {
				s.IsDeprecated.Reset()
				if err := s.IsDeprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_deprecated\"")
			}
		case "is_missing_secrets":
			if err := func() error {
				s.IsMissingSecrets.Reset()
				if err := s.IsMissingSecrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_missing_secrets\"")
			}
		case "is_preconfigured":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.IsPreconfigured.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_preconfigured\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConnectorResponsePropertiesServerlog")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConnectorResponsePropertiesServerlog) {
					name = jsonFieldsNameOfConnectorResponsePropertiesServerlog[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConnectorResponsePropertiesServerlog) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConnectorResponsePropertiesServerlog) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConnectorResponsePropertiesServerlogConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConnectorResponsePropertiesServerlogConfig) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfConnectorResponsePropertiesServerlogConfig = [0]string{}

// Decode decodes ConnectorResponsePropertiesServerlogConfig from json.
func (s *ConnectorResponsePropertiesServerlogConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConnectorResponsePropertiesServerlogConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConnectorResponsePropertiesServerlogConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConnectorResponsePropertiesServerlogConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConnectorResponsePropertiesServerlogConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConnectorResponsePropertiesServicenow) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConnectorResponsePropertiesServicenow) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.IsDeprecated.Set {
			e.FieldStart("is_deprecated")
			s.IsDeprecated.Encode(e)
		}
	}
	{
		if s.IsMissingSecrets.Set {
			e.FieldStart("is_missing_secrets")
			s.IsMissingSecrets.Encode(e)
		}
	}
	{
		e.FieldStart("is_preconfigured")
		s.IsPreconfigured.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfConnectorResponsePropertiesServicenow = [6]string{
	0: "config",
	1: "id",
	2: "is_deprecated",
	3: "is_missing_secrets",
	4: "is_preconfigured",
	5: "name",
}

// Decode decodes ConnectorResponsePropertiesServicenow from json.
func (s *ConnectorResponsePropertiesServicenow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConnectorResponsePropertiesServicenow to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "is_deprecated":
			if err := func() error {
				s.IsDeprecated.Reset()
				if err := s.IsDeprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_deprecated\"")
			}
		case "is_missing_secrets":
			if err := func() error {
				s.IsMissingSecrets.Reset()
				if err := s.IsMissingSecrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_missing_secrets\"")
			}
		case "is_preconfigured":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.IsPreconfigured.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_preconfigured\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConnectorResponsePropertiesServicenow")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConnectorResponsePropertiesServicenow) {
					name = jsonFieldsNameOfConnectorResponsePropertiesServicenow[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConnectorResponsePropertiesServicenow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConnectorResponsePropertiesServicenow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConnectorResponsePropertiesServicenowItom) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConnectorResponsePropertiesServicenowItom) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.IsDeprecated.Set {
			e.FieldStart("is_deprecated")
			s.IsDeprecated.Encode(e)
		}
	}
	{
		if s.IsMissingSecrets.Set {
			e.FieldStart("is_missing_secrets")
			s.IsMissingSecrets.Encode(e)
		}
	}
	{
		e.FieldStart("is_preconfigured")
		s.IsPreconfigured.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfConnectorResponsePropertiesServicenowItom = [6]string{
	0: "config",
	1: "id",
	2: "is_deprecated",
	3: "is_missing_secrets",
	4: "is_preconfigured",
	5: "name",
}

// Decode decodes ConnectorResponsePropertiesServicenowItom from json.
func (s *ConnectorResponsePropertiesServicenowItom) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConnectorResponsePropertiesServicenowItom to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "is_deprecated":
			if err := func() error {
				s.IsDeprecated.Reset()
				if err := s.IsDeprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_deprecated\"")
			}
		case "is_missing_secrets":
			if err := func() error {
				s.IsMissingSecrets.Reset()
				if err := s.IsMissingSecrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_missing_secrets\"")
			}
		case "is_preconfigured":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.IsPreconfigured.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_preconfigured\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConnectorResponsePropertiesServicenowItom")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConnectorResponsePropertiesServicenowItom) {
					name = jsonFieldsNameOfConnectorResponsePropertiesServicenowItom[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConnectorResponsePropertiesServicenowItom) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConnectorResponsePropertiesServicenowItom) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConnectorResponsePropertiesServicenowSir) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConnectorResponsePropertiesServicenowSir) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.IsDeprecated.Set {
			e.FieldStart("is_deprecated")
			s.IsDeprecated.Encode(e)
		}
	}
	{
		if s.IsMissingSecrets.Set {
			e.FieldStart("is_missing_secrets")
			s.IsMissingSecrets.Encode(e)
		}
	}
	{
		e.FieldStart("is_preconfigured")
		s.IsPreconfigured.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfConnectorResponsePropertiesServicenowSir = [6]string{
	0: "config",
	1: "id",
	2: "is_deprecated",
	3: "is_missing_secrets",
	4: "is_preconfigured",
	5: "name",
}

// Decode decodes ConnectorResponsePropertiesServicenowSir from json.
func (s *ConnectorResponsePropertiesServicenowSir) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConnectorResponsePropertiesServicenowSir to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "is_deprecated":
			if err := func() error {
				s.IsDeprecated.Reset()
				if err := s.IsDeprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_deprecated\"")
			}
		case "is_missing_secrets":
			if err := func() error {
				s.IsMissingSecrets.Reset()
				if err := s.IsMissingSecrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_missing_secrets\"")
			}
		case "is_preconfigured":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.IsPreconfigured.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_preconfigured\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConnectorResponsePropertiesServicenowSir")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConnectorResponsePropertiesServicenowSir) {
					name = jsonFieldsNameOfConnectorResponsePropertiesServicenowSir[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConnectorResponsePropertiesServicenowSir) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConnectorResponsePropertiesServicenowSir) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConnectorResponsePropertiesSlack) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConnectorResponsePropertiesSlack) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.IsDeprecated.Set {
			e.FieldStart("is_deprecated")
			s.IsDeprecated.Encode(e)
		}
	}
	{
		if s.IsMissingSecrets.Set {
			e.FieldStart("is_missing_secrets")
			s.IsMissingSecrets.Encode(e)
		}
	}
	{
		e.FieldStart("is_preconfigured")
		s.IsPreconfigured.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfConnectorResponsePropertiesSlack = [5]string{
	0: "id",
	1: "is_deprecated",
	2: "is_missing_secrets",
	3: "is_preconfigured",
	4: "name",
}

// Decode decodes ConnectorResponsePropertiesSlack from json.
func (s *ConnectorResponsePropertiesSlack) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConnectorResponsePropertiesSlack to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "is_deprecated":
			if err := func() error {
				s.IsDeprecated.Reset()
				if err := s.IsDeprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_deprecated\"")
			}
		case "is_missing_secrets":
			if err := func() error {
				s.IsMissingSecrets.Reset()
				if err := s.IsMissingSecrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_missing_secrets\"")
			}
		case "is_preconfigured":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.IsPreconfigured.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_preconfigured\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConnectorResponsePropertiesSlack")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConnectorResponsePropertiesSlack) {
					name = jsonFieldsNameOfConnectorResponsePropertiesSlack[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConnectorResponsePropertiesSlack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConnectorResponsePropertiesSlack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConnectorResponsePropertiesSwimlane) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConnectorResponsePropertiesSwimlane) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.IsDeprecated.Set {
			e.FieldStart("is_deprecated")
			s.IsDeprecated.Encode(e)
		}
	}
	{
		if s.IsMissingSecrets.Set {
			e.FieldStart("is_missing_secrets")
			s.IsMissingSecrets.Encode(e)
		}
	}
	{
		e.FieldStart("is_preconfigured")
		s.IsPreconfigured.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfConnectorResponsePropertiesSwimlane = [6]string{
	0: "config",
	1: "id",
	2: "is_deprecated",
	3: "is_missing_secrets",
	4: "is_preconfigured",
	5: "name",
}

// Decode decodes ConnectorResponsePropertiesSwimlane from json.
func (s *ConnectorResponsePropertiesSwimlane) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConnectorResponsePropertiesSwimlane to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "is_deprecated":
			if err := func() error {
				s.IsDeprecated.Reset()
				if err := s.IsDeprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_deprecated\"")
			}
		case "is_missing_secrets":
			if err := func() error {
				s.IsMissingSecrets.Reset()
				if err := s.IsMissingSecrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_missing_secrets\"")
			}
		case "is_preconfigured":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.IsPreconfigured.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_preconfigured\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConnectorResponsePropertiesSwimlane")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConnectorResponsePropertiesSwimlane) {
					name = jsonFieldsNameOfConnectorResponsePropertiesSwimlane[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConnectorResponsePropertiesSwimlane) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConnectorResponsePropertiesSwimlane) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConnectorResponsePropertiesTeams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConnectorResponsePropertiesTeams) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.IsDeprecated.Set {
			e.FieldStart("is_deprecated")
			s.IsDeprecated.Encode(e)
		}
	}
	{
		if s.IsMissingSecrets.Set {
			e.FieldStart("is_missing_secrets")
			s.IsMissingSecrets.Encode(e)
		}
	}
	{
		e.FieldStart("is_preconfigured")
		s.IsPreconfigured.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfConnectorResponsePropertiesTeams = [5]string{
	0: "id",
	1: "is_deprecated",
	2: "is_missing_secrets",
	3: "is_preconfigured",
	4: "name",
}

// Decode decodes ConnectorResponsePropertiesTeams from json.
func (s *ConnectorResponsePropertiesTeams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConnectorResponsePropertiesTeams to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "is_deprecated":
			if err := func() error {
				s.IsDeprecated.Reset()
				if err := s.IsDeprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_deprecated\"")
			}
		case "is_missing_secrets":
			if err := func() error {
				s.IsMissingSecrets.Reset()
				if err := s.IsMissingSecrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_missing_secrets\"")
			}
		case "is_preconfigured":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.IsPreconfigured.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_preconfigured\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConnectorResponsePropertiesTeams")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConnectorResponsePropertiesTeams) {
					name = jsonFieldsNameOfConnectorResponsePropertiesTeams[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConnectorResponsePropertiesTeams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConnectorResponsePropertiesTeams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConnectorResponsePropertiesTines) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConnectorResponsePropertiesTines) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.IsDeprecated.Set {
			e.FieldStart("is_deprecated")
			s.IsDeprecated.Encode(e)
		}
	}
	{
		if s.IsMissingSecrets.Set {
			e.FieldStart("is_missing_secrets")
			s.IsMissingSecrets.Encode(e)
		}
	}
	{
		e.FieldStart("is_preconfigured")
		s.IsPreconfigured.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfConnectorResponsePropertiesTines = [6]string{
	0: "config",
	1: "id",
	2: "is_deprecated",
	3: "is_missing_secrets",
	4: "is_preconfigured",
	5: "name",
}

// Decode decodes ConnectorResponsePropertiesTines from json.
func (s *ConnectorResponsePropertiesTines) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConnectorResponsePropertiesTines to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "is_deprecated":
			if err := func() error {
				s.IsDeprecated.Reset()
				if err := s.IsDeprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_deprecated\"")
			}
		case "is_missing_secrets":
			if err := func() error {
				s.IsMissingSecrets.Reset()
				if err := s.IsMissingSecrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_missing_secrets\"")
			}
		case "is_preconfigured":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.IsPreconfigured.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_preconfigured\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConnectorResponsePropertiesTines")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConnectorResponsePropertiesTines) {
					name = jsonFieldsNameOfConnectorResponsePropertiesTines[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConnectorResponsePropertiesTines) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConnectorResponsePropertiesTines) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConnectorResponsePropertiesWebhook) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConnectorResponsePropertiesWebhook) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.IsDeprecated.Set {
			e.FieldStart("is_deprecated")
			s.IsDeprecated.Encode(e)
		}
	}
	{
		if s.IsMissingSecrets.Set {
			e.FieldStart("is_missing_secrets")
			s.IsMissingSecrets.Encode(e)
		}
	}
	{
		e.FieldStart("is_preconfigured")
		s.IsPreconfigured.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfConnectorResponsePropertiesWebhook = [6]string{
	0: "config",
	1: "id",
	2: "is_deprecated",
	3: "is_missing_secrets",
	4: "is_preconfigured",
	5: "name",
}

// Decode decodes ConnectorResponsePropertiesWebhook from json.
func (s *ConnectorResponsePropertiesWebhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConnectorResponsePropertiesWebhook to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "is_deprecated":
			if err := func() error {
				s.IsDeprecated.Reset()
				if err := s.IsDeprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_deprecated\"")
			}
		case "is_missing_secrets":
			if err := func() error {
				s.IsMissingSecrets.Reset()
				if err := s.IsMissingSecrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_missing_secrets\"")
			}
		case "is_preconfigured":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.IsPreconfigured.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_preconfigured\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConnectorResponsePropertiesWebhook")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConnectorResponsePropertiesWebhook) {
					name = jsonFieldsNameOfConnectorResponsePropertiesWebhook[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConnectorResponsePropertiesWebhook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConnectorResponsePropertiesWebhook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ConnectorResponsePropertiesXmatters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ConnectorResponsePropertiesXmatters) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.IsDeprecated.Set {
			e.FieldStart("is_deprecated")
			s.IsDeprecated.Encode(e)
		}
	}
	{
		if s.IsMissingSecrets.Set {
			e.FieldStart("is_missing_secrets")
			s.IsMissingSecrets.Encode(e)
		}
	}
	{
		e.FieldStart("is_preconfigured")
		s.IsPreconfigured.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfConnectorResponsePropertiesXmatters = [6]string{
	0: "config",
	1: "id",
	2: "is_deprecated",
	3: "is_missing_secrets",
	4: "is_preconfigured",
	5: "name",
}

// Decode decodes ConnectorResponsePropertiesXmatters from json.
func (s *ConnectorResponsePropertiesXmatters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConnectorResponsePropertiesXmatters to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "is_deprecated":
			if err := func() error {
				s.IsDeprecated.Reset()
				if err := s.IsDeprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_deprecated\"")
			}
		case "is_missing_secrets":
			if err := func() error {
				s.IsMissingSecrets.Reset()
				if err := s.IsMissingSecrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_missing_secrets\"")
			}
		case "is_preconfigured":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				if err := s.IsPreconfigured.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_preconfigured\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ConnectorResponsePropertiesXmatters")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00110011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfConnectorResponsePropertiesXmatters) {
					name = jsonFieldsNameOfConnectorResponsePropertiesXmatters[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ConnectorResponsePropertiesXmatters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConnectorResponsePropertiesXmatters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConnectorTypes as json.
func (s ConnectorTypes) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConnectorTypes from json.
func (s *ConnectorTypes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConnectorTypes to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConnectorTypes(v) {
	case ConnectorTypesDotCasesMinusWebhook:
		*s = ConnectorTypesDotCasesMinusWebhook
	case ConnectorTypesDotEmail:
		*s = ConnectorTypesDotEmail
	case ConnectorTypesDotIndex:
		*s = ConnectorTypesDotIndex
	case ConnectorTypesDotJira:
		*s = ConnectorTypesDotJira
	case ConnectorTypesDotOpsgenie:
		*s = ConnectorTypesDotOpsgenie
	case ConnectorTypesDotPagerduty:
		*s = ConnectorTypesDotPagerduty
	case ConnectorTypesDotResilient:
		*s = ConnectorTypesDotResilient
	case ConnectorTypesDotServicenow:
		*s = ConnectorTypesDotServicenow
	case ConnectorTypesDotServicenowMinusItom:
		*s = ConnectorTypesDotServicenowMinusItom
	case ConnectorTypesDotServicenowMinusSir:
		*s = ConnectorTypesDotServicenowMinusSir
	case ConnectorTypesDotServerMinusLog:
		*s = ConnectorTypesDotServerMinusLog
	case ConnectorTypesDotSlack:
		*s = ConnectorTypesDotSlack
	case ConnectorTypesDotSwimlane:
		*s = ConnectorTypesDotSwimlane
	case ConnectorTypesDotTeams:
		*s = ConnectorTypesDotTeams
	case ConnectorTypesDotTines:
		*s = ConnectorTypesDotTines
	case ConnectorTypesDotWebhook:
		*s = ConnectorTypesDotWebhook
	case ConnectorTypesDotXmatters:
		*s = ConnectorTypesDotXmatters
	default:
		*s = ConnectorTypes(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConnectorTypes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConnectorTypes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes CreateConnectorReq as json.
func (s CreateConnectorReq) Encode(e *jx.Encoder) {
	switch s.Type {
	case CreateConnectorRequestCasesWebhookCreateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".cases-webhook")
		s.CreateConnectorRequestCasesWebhook.encodeFields(e)
		e.ObjEnd()
	case CreateConnectorRequestEmailCreateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".email")
		s.CreateConnectorRequestEmail.encodeFields(e)
		e.ObjEnd()
	case CreateConnectorRequestIndexCreateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".index")
		s.CreateConnectorRequestIndex.encodeFields(e)
		e.ObjEnd()
	case CreateConnectorRequestJiraCreateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".jira")
		s.CreateConnectorRequestJira.encodeFields(e)
		e.ObjEnd()
	case CreateConnectorRequestOpsgenieCreateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".opsgenie")
		s.CreateConnectorRequestOpsgenie.encodeFields(e)
		e.ObjEnd()
	case CreateConnectorRequestPagerdutyCreateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".pagerduty")
		s.CreateConnectorRequestPagerduty.encodeFields(e)
		e.ObjEnd()
	case CreateConnectorRequestResilientCreateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".resilient")
		s.CreateConnectorRequestResilient.encodeFields(e)
		e.ObjEnd()
	case CreateConnectorRequestServerlogCreateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".server-log")
		s.CreateConnectorRequestServerlog.encodeFields(e)
		e.ObjEnd()
	case CreateConnectorRequestServicenowCreateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".servicenow")
		s.CreateConnectorRequestServicenow.encodeFields(e)
		e.ObjEnd()
	case CreateConnectorRequestServicenowItomCreateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".servicenow-itom")
		s.CreateConnectorRequestServicenowItom.encodeFields(e)
		e.ObjEnd()
	case CreateConnectorRequestServicenowSirCreateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".servicenow-sir")
		s.CreateConnectorRequestServicenowSir.encodeFields(e)
		e.ObjEnd()
	case CreateConnectorRequestSlackCreateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".slack")
		s.CreateConnectorRequestSlack.encodeFields(e)
		e.ObjEnd()
	case CreateConnectorRequestSwimlaneCreateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".swimlane")
		s.CreateConnectorRequestSwimlane.encodeFields(e)
		e.ObjEnd()
	case CreateConnectorRequestTeamsCreateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".teams")
		s.CreateConnectorRequestTeams.encodeFields(e)
		e.ObjEnd()
	case CreateConnectorRequestTinesCreateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".tines")
		s.CreateConnectorRequestTines.encodeFields(e)
		e.ObjEnd()
	case CreateConnectorRequestWebhookCreateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".webhook")
		s.CreateConnectorRequestWebhook.encodeFields(e)
		e.ObjEnd()
	case CreateConnectorRequestXmattersCreateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".xmatters")
		s.CreateConnectorRequestXmatters.encodeFields(e)
		e.ObjEnd()
	}
}

// Decode decodes CreateConnectorReq from json.
func (s *CreateConnectorReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConnectorReq to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "connector_type_id":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case ".cases-webhook":
					s.Type = CreateConnectorRequestCasesWebhookCreateConnectorReq
					found = true
				case ".email":
					s.Type = CreateConnectorRequestEmailCreateConnectorReq
					found = true
				case ".index":
					s.Type = CreateConnectorRequestIndexCreateConnectorReq
					found = true
				case ".jira":
					s.Type = CreateConnectorRequestJiraCreateConnectorReq
					found = true
				case ".opsgenie":
					s.Type = CreateConnectorRequestOpsgenieCreateConnectorReq
					found = true
				case ".pagerduty":
					s.Type = CreateConnectorRequestPagerdutyCreateConnectorReq
					found = true
				case ".resilient":
					s.Type = CreateConnectorRequestResilientCreateConnectorReq
					found = true
				case ".server-log":
					s.Type = CreateConnectorRequestServerlogCreateConnectorReq
					found = true
				case ".servicenow":
					s.Type = CreateConnectorRequestServicenowCreateConnectorReq
					found = true
				case ".servicenow-itom":
					s.Type = CreateConnectorRequestServicenowItomCreateConnectorReq
					found = true
				case ".servicenow-sir":
					s.Type = CreateConnectorRequestServicenowSirCreateConnectorReq
					found = true
				case ".slack":
					s.Type = CreateConnectorRequestSlackCreateConnectorReq
					found = true
				case ".swimlane":
					s.Type = CreateConnectorRequestSwimlaneCreateConnectorReq
					found = true
				case ".teams":
					s.Type = CreateConnectorRequestTeamsCreateConnectorReq
					found = true
				case ".tines":
					s.Type = CreateConnectorRequestTinesCreateConnectorReq
					found = true
				case ".webhook":
					s.Type = CreateConnectorRequestWebhookCreateConnectorReq
					found = true
				case ".xmatters":
					s.Type = CreateConnectorRequestXmattersCreateConnectorReq
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case CreateConnectorRequestCasesWebhookCreateConnectorReq:
		if err := s.CreateConnectorRequestCasesWebhook.Decode(d); err != nil {
			return err
		}
	case CreateConnectorRequestEmailCreateConnectorReq:
		if err := s.CreateConnectorRequestEmail.Decode(d); err != nil {
			return err
		}
	case CreateConnectorRequestIndexCreateConnectorReq:
		if err := s.CreateConnectorRequestIndex.Decode(d); err != nil {
			return err
		}
	case CreateConnectorRequestJiraCreateConnectorReq:
		if err := s.CreateConnectorRequestJira.Decode(d); err != nil {
			return err
		}
	case CreateConnectorRequestOpsgenieCreateConnectorReq:
		if err := s.CreateConnectorRequestOpsgenie.Decode(d); err != nil {
			return err
		}
	case CreateConnectorRequestPagerdutyCreateConnectorReq:
		if err := s.CreateConnectorRequestPagerduty.Decode(d); err != nil {
			return err
		}
	case CreateConnectorRequestResilientCreateConnectorReq:
		if err := s.CreateConnectorRequestResilient.Decode(d); err != nil {
			return err
		}
	case CreateConnectorRequestServerlogCreateConnectorReq:
		if err := s.CreateConnectorRequestServerlog.Decode(d); err != nil {
			return err
		}
	case CreateConnectorRequestServicenowCreateConnectorReq:
		if err := s.CreateConnectorRequestServicenow.Decode(d); err != nil {
			return err
		}
	case CreateConnectorRequestServicenowItomCreateConnectorReq:
		if err := s.CreateConnectorRequestServicenowItom.Decode(d); err != nil {
			return err
		}
	case CreateConnectorRequestServicenowSirCreateConnectorReq:
		if err := s.CreateConnectorRequestServicenowSir.Decode(d); err != nil {
			return err
		}
	case CreateConnectorRequestSlackCreateConnectorReq:
		if err := s.CreateConnectorRequestSlack.Decode(d); err != nil {
			return err
		}
	case CreateConnectorRequestSwimlaneCreateConnectorReq:
		if err := s.CreateConnectorRequestSwimlane.Decode(d); err != nil {
			return err
		}
	case CreateConnectorRequestTeamsCreateConnectorReq:
		if err := s.CreateConnectorRequestTeams.Decode(d); err != nil {
			return err
		}
	case CreateConnectorRequestTinesCreateConnectorReq:
		if err := s.CreateConnectorRequestTines.Decode(d); err != nil {
			return err
		}
	case CreateConnectorRequestWebhookCreateConnectorReq:
		if err := s.CreateConnectorRequestWebhook.Decode(d); err != nil {
			return err
		}
	case CreateConnectorRequestXmattersCreateConnectorReq:
		if err := s.CreateConnectorRequestXmatters.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s CreateConnectorReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConnectorReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConnectorRequestCasesWebhook) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConnectorRequestCasesWebhook) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Secrets.Set {
			e.FieldStart("secrets")
			s.Secrets.Encode(e)
		}
	}
}

var jsonFieldsNameOfCreateConnectorRequestCasesWebhook = [3]string{
	0: "config",
	1: "name",
	2: "secrets",
}

// Decode decodes CreateConnectorRequestCasesWebhook from json.
func (s *CreateConnectorRequestCasesWebhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConnectorRequestCasesWebhook to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secrets":
			if err := func() error {
				s.Secrets.Reset()
				if err := s.Secrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConnectorRequestCasesWebhook")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConnectorRequestCasesWebhook) {
					name = jsonFieldsNameOfCreateConnectorRequestCasesWebhook[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConnectorRequestCasesWebhook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConnectorRequestCasesWebhook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConnectorRequestEmail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConnectorRequestEmail) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("secrets")
		s.Secrets.Encode(e)
	}
}

var jsonFieldsNameOfCreateConnectorRequestEmail = [3]string{
	0: "config",
	1: "name",
	2: "secrets",
}

// Decode decodes CreateConnectorRequestEmail from json.
func (s *CreateConnectorRequestEmail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConnectorRequestEmail to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Secrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConnectorRequestEmail")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConnectorRequestEmail) {
					name = jsonFieldsNameOfCreateConnectorRequestEmail[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConnectorRequestEmail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConnectorRequestEmail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConnectorRequestIndex) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConnectorRequestIndex) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfCreateConnectorRequestIndex = [2]string{
	0: "config",
	1: "name",
}

// Decode decodes CreateConnectorRequestIndex from json.
func (s *CreateConnectorRequestIndex) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConnectorRequestIndex to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConnectorRequestIndex")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConnectorRequestIndex) {
					name = jsonFieldsNameOfCreateConnectorRequestIndex[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConnectorRequestIndex) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConnectorRequestIndex) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConnectorRequestJira) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConnectorRequestJira) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("secrets")
		s.Secrets.Encode(e)
	}
}

var jsonFieldsNameOfCreateConnectorRequestJira = [3]string{
	0: "config",
	1: "name",
	2: "secrets",
}

// Decode decodes CreateConnectorRequestJira from json.
func (s *CreateConnectorRequestJira) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConnectorRequestJira to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Secrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConnectorRequestJira")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConnectorRequestJira) {
					name = jsonFieldsNameOfCreateConnectorRequestJira[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConnectorRequestJira) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConnectorRequestJira) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConnectorRequestOpsgenie) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConnectorRequestOpsgenie) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("secrets")
		s.Secrets.Encode(e)
	}
}

var jsonFieldsNameOfCreateConnectorRequestOpsgenie = [3]string{
	0: "config",
	1: "name",
	2: "secrets",
}

// Decode decodes CreateConnectorRequestOpsgenie from json.
func (s *CreateConnectorRequestOpsgenie) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConnectorRequestOpsgenie to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Secrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConnectorRequestOpsgenie")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConnectorRequestOpsgenie) {
					name = jsonFieldsNameOfCreateConnectorRequestOpsgenie[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConnectorRequestOpsgenie) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConnectorRequestOpsgenie) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConnectorRequestPagerduty) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConnectorRequestPagerduty) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("secrets")
		s.Secrets.Encode(e)
	}
}

var jsonFieldsNameOfCreateConnectorRequestPagerduty = [3]string{
	0: "config",
	1: "name",
	2: "secrets",
}

// Decode decodes CreateConnectorRequestPagerduty from json.
func (s *CreateConnectorRequestPagerduty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConnectorRequestPagerduty to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Secrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConnectorRequestPagerduty")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConnectorRequestPagerduty) {
					name = jsonFieldsNameOfCreateConnectorRequestPagerduty[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConnectorRequestPagerduty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConnectorRequestPagerduty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConnectorRequestResilient) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConnectorRequestResilient) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("secrets")
		s.Secrets.Encode(e)
	}
}

var jsonFieldsNameOfCreateConnectorRequestResilient = [3]string{
	0: "config",
	1: "name",
	2: "secrets",
}

// Decode decodes CreateConnectorRequestResilient from json.
func (s *CreateConnectorRequestResilient) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConnectorRequestResilient to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Secrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConnectorRequestResilient")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConnectorRequestResilient) {
					name = jsonFieldsNameOfCreateConnectorRequestResilient[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConnectorRequestResilient) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConnectorRequestResilient) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConnectorRequestServerlog) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConnectorRequestServerlog) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfCreateConnectorRequestServerlog = [1]string{
	0: "name",
}

// Decode decodes CreateConnectorRequestServerlog from json.
func (s *CreateConnectorRequestServerlog) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConnectorRequestServerlog to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConnectorRequestServerlog")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConnectorRequestServerlog) {
					name = jsonFieldsNameOfCreateConnectorRequestServerlog[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConnectorRequestServerlog) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConnectorRequestServerlog) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConnectorRequestServicenow) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConnectorRequestServicenow) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("secrets")
		s.Secrets.Encode(e)
	}
}

var jsonFieldsNameOfCreateConnectorRequestServicenow = [3]string{
	0: "config",
	1: "name",
	2: "secrets",
}

// Decode decodes CreateConnectorRequestServicenow from json.
func (s *CreateConnectorRequestServicenow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConnectorRequestServicenow to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Secrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConnectorRequestServicenow")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConnectorRequestServicenow) {
					name = jsonFieldsNameOfCreateConnectorRequestServicenow[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConnectorRequestServicenow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConnectorRequestServicenow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConnectorRequestServicenowItom) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConnectorRequestServicenowItom) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("secrets")
		s.Secrets.Encode(e)
	}
}

var jsonFieldsNameOfCreateConnectorRequestServicenowItom = [3]string{
	0: "config",
	1: "name",
	2: "secrets",
}

// Decode decodes CreateConnectorRequestServicenowItom from json.
func (s *CreateConnectorRequestServicenowItom) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConnectorRequestServicenowItom to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Secrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConnectorRequestServicenowItom")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConnectorRequestServicenowItom) {
					name = jsonFieldsNameOfCreateConnectorRequestServicenowItom[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConnectorRequestServicenowItom) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConnectorRequestServicenowItom) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConnectorRequestServicenowSir) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConnectorRequestServicenowSir) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("secrets")
		s.Secrets.Encode(e)
	}
}

var jsonFieldsNameOfCreateConnectorRequestServicenowSir = [3]string{
	0: "config",
	1: "name",
	2: "secrets",
}

// Decode decodes CreateConnectorRequestServicenowSir from json.
func (s *CreateConnectorRequestServicenowSir) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConnectorRequestServicenowSir to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Secrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConnectorRequestServicenowSir")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConnectorRequestServicenowSir) {
					name = jsonFieldsNameOfCreateConnectorRequestServicenowSir[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConnectorRequestServicenowSir) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConnectorRequestServicenowSir) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConnectorRequestSlack) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConnectorRequestSlack) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("secrets")
		s.Secrets.Encode(e)
	}
}

var jsonFieldsNameOfCreateConnectorRequestSlack = [2]string{
	0: "name",
	1: "secrets",
}

// Decode decodes CreateConnectorRequestSlack from json.
func (s *CreateConnectorRequestSlack) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConnectorRequestSlack to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Secrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConnectorRequestSlack")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConnectorRequestSlack) {
					name = jsonFieldsNameOfCreateConnectorRequestSlack[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConnectorRequestSlack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConnectorRequestSlack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConnectorRequestSwimlane) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConnectorRequestSwimlane) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("secrets")
		s.Secrets.Encode(e)
	}
}

var jsonFieldsNameOfCreateConnectorRequestSwimlane = [3]string{
	0: "config",
	1: "name",
	2: "secrets",
}

// Decode decodes CreateConnectorRequestSwimlane from json.
func (s *CreateConnectorRequestSwimlane) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConnectorRequestSwimlane to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Secrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConnectorRequestSwimlane")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConnectorRequestSwimlane) {
					name = jsonFieldsNameOfCreateConnectorRequestSwimlane[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConnectorRequestSwimlane) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConnectorRequestSwimlane) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConnectorRequestTeams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConnectorRequestTeams) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("secrets")
		s.Secrets.Encode(e)
	}
}

var jsonFieldsNameOfCreateConnectorRequestTeams = [2]string{
	0: "name",
	1: "secrets",
}

// Decode decodes CreateConnectorRequestTeams from json.
func (s *CreateConnectorRequestTeams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConnectorRequestTeams to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Secrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConnectorRequestTeams")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConnectorRequestTeams) {
					name = jsonFieldsNameOfCreateConnectorRequestTeams[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConnectorRequestTeams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConnectorRequestTeams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConnectorRequestTines) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConnectorRequestTines) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("secrets")
		s.Secrets.Encode(e)
	}
}

var jsonFieldsNameOfCreateConnectorRequestTines = [3]string{
	0: "config",
	1: "name",
	2: "secrets",
}

// Decode decodes CreateConnectorRequestTines from json.
func (s *CreateConnectorRequestTines) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConnectorRequestTines to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Secrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConnectorRequestTines")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConnectorRequestTines) {
					name = jsonFieldsNameOfCreateConnectorRequestTines[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConnectorRequestTines) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConnectorRequestTines) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConnectorRequestWebhook) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConnectorRequestWebhook) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("secrets")
		s.Secrets.Encode(e)
	}
}

var jsonFieldsNameOfCreateConnectorRequestWebhook = [3]string{
	0: "config",
	1: "name",
	2: "secrets",
}

// Decode decodes CreateConnectorRequestWebhook from json.
func (s *CreateConnectorRequestWebhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConnectorRequestWebhook to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Secrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConnectorRequestWebhook")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConnectorRequestWebhook) {
					name = jsonFieldsNameOfCreateConnectorRequestWebhook[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConnectorRequestWebhook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConnectorRequestWebhook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *CreateConnectorRequestXmatters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *CreateConnectorRequestXmatters) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("secrets")
		s.Secrets.Encode(e)
	}
}

var jsonFieldsNameOfCreateConnectorRequestXmatters = [3]string{
	0: "config",
	1: "name",
	2: "secrets",
}

// Decode decodes CreateConnectorRequestXmatters from json.
func (s *CreateConnectorRequestXmatters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode CreateConnectorRequestXmatters to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Secrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode CreateConnectorRequestXmatters")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfCreateConnectorRequestXmatters) {
					name = jsonFieldsNameOfCreateConnectorRequestXmatters[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *CreateConnectorRequestXmatters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *CreateConnectorRequestXmatters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DeleteConnectorNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DeleteConnectorNotFound) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfDeleteConnectorNotFound = [3]string{
	0: "error",
	1: "message",
	2: "statusCode",
}

// Decode decodes DeleteConnectorNotFound from json.
func (s *DeleteConnectorNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DeleteConnectorNotFound to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DeleteConnectorNotFound")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DeleteConnectorNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DeleteConnectorNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes Features as json.
func (s Features) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes Features from json.
func (s *Features) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Features to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch Features(v) {
	case FeaturesAlerting:
		*s = FeaturesAlerting
	case FeaturesCases:
		*s = FeaturesCases
	case FeaturesUptime:
		*s = FeaturesUptime
	case FeaturesSiem:
		*s = FeaturesSiem
	default:
		*s = Features(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Features) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Features) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConnectorNotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConnectorNotFound) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfGetConnectorNotFound = [3]string{
	0: "error",
	1: "message",
	2: "statusCode",
}

// Decode decodes GetConnectorNotFound from json.
func (s *GetConnectorNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConnectorNotFound to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConnectorNotFound")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConnectorNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConnectorNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetConnectorTypesOKApplicationJSON as json.
func (s GetConnectorTypesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []GetConnectorTypesOKItem(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetConnectorTypesOKApplicationJSON from json.
func (s *GetConnectorTypesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConnectorTypesOKApplicationJSON to nil")
	}
	var unwrapped []GetConnectorTypesOKItem
	if err := func() error {
		unwrapped = make([]GetConnectorTypesOKItem, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem GetConnectorTypesOKItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetConnectorTypesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetConnectorTypesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConnectorTypesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConnectorTypesOKItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConnectorTypesOKItem) encodeFields(e *jx.Encoder) {
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.EnabledInConfig.Set {
			e.FieldStart("enabled_in_config")
			s.EnabledInConfig.Encode(e)
		}
	}
	{
		if s.EnabledInLicense.Set {
			e.FieldStart("enabled_in_license")
			s.EnabledInLicense.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.MinimumLicenseRequired.Set {
			e.FieldStart("minimum_license_required")
			s.MinimumLicenseRequired.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.SupportedFeatureIds != nil {
			e.FieldStart("supported_feature_ids")
			e.ArrStart()
			for _, elem := range s.SupportedFeatureIds {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfGetConnectorTypesOKItem = [7]string{
	0: "enabled",
	1: "enabled_in_config",
	2: "enabled_in_license",
	3: "id",
	4: "minimum_license_required",
	5: "name",
	6: "supported_feature_ids",
}

// Decode decodes GetConnectorTypesOKItem from json.
func (s *GetConnectorTypesOKItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConnectorTypesOKItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "enabled_in_config":
			if err := func() error {
				s.EnabledInConfig.Reset()
				if err := s.EnabledInConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled_in_config\"")
			}
		case "enabled_in_license":
			if err := func() error {
				s.EnabledInLicense.Reset()
				if err := s.EnabledInLicense.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled_in_license\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "minimum_license_required":
			if err := func() error {
				s.MinimumLicenseRequired.Reset()
				if err := s.MinimumLicenseRequired.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minimum_license_required\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "supported_feature_ids":
			if err := func() error {
				s.SupportedFeatureIds = make([]Features, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem Features
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.SupportedFeatureIds = append(s.SupportedFeatureIds, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"supported_feature_ids\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConnectorTypesOKItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConnectorTypesOKItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConnectorTypesOKItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetConnectorsOKApplicationJSON as json.
func (s GetConnectorsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []GetConnectorsOKItem(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes GetConnectorsOKApplicationJSON from json.
func (s *GetConnectorsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConnectorsOKApplicationJSON to nil")
	}
	var unwrapped []GetConnectorsOKItem
	if err := func() error {
		unwrapped = make([]GetConnectorsOKItem, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem GetConnectorsOKItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = GetConnectorsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetConnectorsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConnectorsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *GetConnectorsOKItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *GetConnectorsOKItem) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("connector_type_id")
		s.ConnectorTypeID.Encode(e)
	}
	{
		if s.Config.Set {
			e.FieldStart("config")
			s.Config.Encode(e)
		}
	}
	{
		e.FieldStart("id")
		e.Str(s.ID)
	}
	{
		if s.IsDeprecated.Set {
			e.FieldStart("is_deprecated")
			s.IsDeprecated.Encode(e)
		}
	}
	{
		if s.IsMissingSecrets.Set {
			e.FieldStart("is_missing_secrets")
			s.IsMissingSecrets.Encode(e)
		}
	}
	{
		e.FieldStart("is_preconfigured")
		s.IsPreconfigured.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("referenced_by_count")
		e.Int(s.ReferencedByCount)
	}
}

var jsonFieldsNameOfGetConnectorsOKItem = [8]string{
	0: "connector_type_id",
	1: "config",
	2: "id",
	3: "is_deprecated",
	4: "is_missing_secrets",
	5: "is_preconfigured",
	6: "name",
	7: "referenced_by_count",
}

// Decode decodes GetConnectorsOKItem from json.
func (s *GetConnectorsOKItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConnectorsOKItem to nil")
	}
	var requiredBitSet [1]uint8
	s.setDefaults()

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "connector_type_id":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ConnectorTypeID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"connector_type_id\"")
			}
		case "config":
			if err := func() error {
				s.Config.Reset()
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "id":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Str()
				s.ID = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "is_deprecated":
			if err := func() error {
				s.IsDeprecated.Reset()
				if err := s.IsDeprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_deprecated\"")
			}
		case "is_missing_secrets":
			if err := func() error {
				s.IsMissingSecrets.Reset()
				if err := s.IsMissingSecrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_missing_secrets\"")
			}
		case "is_preconfigured":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				if err := s.IsPreconfigured.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"is_preconfigured\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "referenced_by_count":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				v, err := d.Int()
				s.ReferencedByCount = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"referenced_by_count\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConnectorsOKItem")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b11100101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfGetConnectorsOKItem) {
					name = jsonFieldsNameOfGetConnectorsOKItem[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *GetConnectorsOKItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConnectorsOKItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s GetConnectorsOKItemConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s GetConnectorsOKItemConfig) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes GetConnectorsOKItemConfig from json.
func (s *GetConnectorsOKItemConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode GetConnectorsOKItemConfig to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode GetConnectorsOKItemConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s GetConnectorsOKItemConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *GetConnectorsOKItemConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IsDeprecated as json.
func (s IsDeprecated) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes IsDeprecated from json.
func (s *IsDeprecated) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IsDeprecated to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IsDeprecated(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IsDeprecated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IsDeprecated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IsMissingSecrets as json.
func (s IsMissingSecrets) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes IsMissingSecrets from json.
func (s *IsMissingSecrets) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IsMissingSecrets to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IsMissingSecrets(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IsMissingSecrets) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IsMissingSecrets) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IsPreconfigured as json.
func (s IsPreconfigured) Encode(e *jx.Encoder) {
	unwrapped := bool(s)

	e.Bool(unwrapped)
}

// Decode decodes IsPreconfigured from json.
func (s *IsPreconfigured) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IsPreconfigured to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = IsPreconfigured(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IsPreconfigured) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IsPreconfigured) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LegacyCreateConnectorReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LegacyCreateConnectorReq) encodeFields(e *jx.Encoder) {
	{
		if s.ActionTypeId.Set {
			e.FieldStart("actionTypeId")
			s.ActionTypeId.Encode(e)
		}
	}
	{
		if s.Config != nil {
			e.FieldStart("config")
			s.Config.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Secrets != nil {
			e.FieldStart("secrets")
			s.Secrets.Encode(e)
		}
	}
}

var jsonFieldsNameOfLegacyCreateConnectorReq = [4]string{
	0: "actionTypeId",
	1: "config",
	2: "name",
	3: "secrets",
}

// Decode decodes LegacyCreateConnectorReq from json.
func (s *LegacyCreateConnectorReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LegacyCreateConnectorReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "actionTypeId":
			if err := func() error {
				s.ActionTypeId.Reset()
				if err := s.ActionTypeId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actionTypeId\"")
			}
		case "config":
			if err := func() error {
				s.Config = nil
				var elem LegacyCreateConnectorReqConfig
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Config = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secrets":
			if err := func() error {
				s.Secrets = nil
				var elem LegacyCreateConnectorReqSecrets
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Secrets = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LegacyCreateConnectorReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LegacyCreateConnectorReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LegacyCreateConnectorReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LegacyCreateConnectorReqConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LegacyCreateConnectorReqConfig) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfLegacyCreateConnectorReqConfig = [0]string{}

// Decode decodes LegacyCreateConnectorReqConfig from json.
func (s *LegacyCreateConnectorReqConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LegacyCreateConnectorReqConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LegacyCreateConnectorReqConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LegacyCreateConnectorReqConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LegacyCreateConnectorReqConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LegacyCreateConnectorReqSecrets) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LegacyCreateConnectorReqSecrets) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfLegacyCreateConnectorReqSecrets = [0]string{}

// Decode decodes LegacyCreateConnectorReqSecrets from json.
func (s *LegacyCreateConnectorReqSecrets) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LegacyCreateConnectorReqSecrets to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LegacyCreateConnectorReqSecrets")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LegacyCreateConnectorReqSecrets) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LegacyCreateConnectorReqSecrets) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LegacyGetConnectorTypesOKApplicationJSON as json.
func (s LegacyGetConnectorTypesOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []LegacyGetConnectorTypesOKItem(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes LegacyGetConnectorTypesOKApplicationJSON from json.
func (s *LegacyGetConnectorTypesOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LegacyGetConnectorTypesOKApplicationJSON to nil")
	}
	var unwrapped []LegacyGetConnectorTypesOKItem
	if err := func() error {
		unwrapped = make([]LegacyGetConnectorTypesOKItem, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem LegacyGetConnectorTypesOKItem
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LegacyGetConnectorTypesOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LegacyGetConnectorTypesOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LegacyGetConnectorTypesOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LegacyGetConnectorTypesOKItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LegacyGetConnectorTypesOKItem) encodeFields(e *jx.Encoder) {
	{
		if s.Enabled.Set {
			e.FieldStart("enabled")
			s.Enabled.Encode(e)
		}
	}
	{
		if s.EnabledInConfig.Set {
			e.FieldStart("enabledInConfig")
			s.EnabledInConfig.Encode(e)
		}
	}
	{
		if s.EnabledInLicense.Set {
			e.FieldStart("enabledInLicense")
			s.EnabledInLicense.Encode(e)
		}
	}
	{
		if s.ID.Set {
			e.FieldStart("id")
			s.ID.Encode(e)
		}
	}
	{
		if s.MinimumLicenseRequired.Set {
			e.FieldStart("minimumLicenseRequired")
			s.MinimumLicenseRequired.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfLegacyGetConnectorTypesOKItem = [6]string{
	0: "enabled",
	1: "enabledInConfig",
	2: "enabledInLicense",
	3: "id",
	4: "minimumLicenseRequired",
	5: "name",
}

// Decode decodes LegacyGetConnectorTypesOKItem from json.
func (s *LegacyGetConnectorTypesOKItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LegacyGetConnectorTypesOKItem to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enabled":
			if err := func() error {
				s.Enabled.Reset()
				if err := s.Enabled.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabled\"")
			}
		case "enabledInConfig":
			if err := func() error {
				s.EnabledInConfig.Reset()
				if err := s.EnabledInConfig.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabledInConfig\"")
			}
		case "enabledInLicense":
			if err := func() error {
				s.EnabledInLicense.Reset()
				if err := s.EnabledInLicense.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enabledInLicense\"")
			}
		case "id":
			if err := func() error {
				s.ID.Reset()
				if err := s.ID.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"id\"")
			}
		case "minimumLicenseRequired":
			if err := func() error {
				s.MinimumLicenseRequired.Reset()
				if err := s.MinimumLicenseRequired.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minimumLicenseRequired\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LegacyGetConnectorTypesOKItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LegacyGetConnectorTypesOKItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LegacyGetConnectorTypesOKItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LegacyGetConnectorsOKApplicationJSON as json.
func (s LegacyGetConnectorsOKApplicationJSON) Encode(e *jx.Encoder) {
	unwrapped := []ActionResponseProperties(s)

	e.ArrStart()
	for _, elem := range unwrapped {
		elem.Encode(e)
	}
	e.ArrEnd()
}

// Decode decodes LegacyGetConnectorsOKApplicationJSON from json.
func (s *LegacyGetConnectorsOKApplicationJSON) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LegacyGetConnectorsOKApplicationJSON to nil")
	}
	var unwrapped []ActionResponseProperties
	if err := func() error {
		unwrapped = make([]ActionResponseProperties, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem ActionResponseProperties
			if err := elem.Decode(d); err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = LegacyGetConnectorsOKApplicationJSON(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LegacyGetConnectorsOKApplicationJSON) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LegacyGetConnectorsOKApplicationJSON) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LegacyRunConnectorOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LegacyRunConnectorOK) encodeFields(e *jx.Encoder) {
	{
		if s.ActionId.Set {
			e.FieldStart("actionId")
			s.ActionId.Encode(e)
		}
	}
	{
		if s.Data.Set {
			e.FieldStart("data")
			s.Data.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
}

var jsonFieldsNameOfLegacyRunConnectorOK = [3]string{
	0: "actionId",
	1: "data",
	2: "status",
}

// Decode decodes LegacyRunConnectorOK from json.
func (s *LegacyRunConnectorOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LegacyRunConnectorOK to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "actionId":
			if err := func() error {
				s.ActionId.Reset()
				if err := s.ActionId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actionId\"")
			}
		case "data":
			if err := func() error {
				s.Data.Reset()
				if err := s.Data.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"data\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LegacyRunConnectorOK")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LegacyRunConnectorOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LegacyRunConnectorOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LegacyRunConnectorOKData as json.
func (s LegacyRunConnectorOKData) Encode(e *jx.Encoder) {
	switch s.Type {
	case LegacyRunConnectorOKData0LegacyRunConnectorOKData:
		s.LegacyRunConnectorOKData0.Encode(e)
	case LegacyRunConnectorOKData1ItemArrayLegacyRunConnectorOKData:
		e.ArrStart()
		for _, elem := range s.LegacyRunConnectorOKData1ItemArray {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
}

// Decode decodes LegacyRunConnectorOKData from json.
func (s *LegacyRunConnectorOKData) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LegacyRunConnectorOKData to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Array:
		s.LegacyRunConnectorOKData1ItemArray = make([]LegacyRunConnectorOKData1Item, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem LegacyRunConnectorOKData1Item
			if err := elem.Decode(d); err != nil {
				return err
			}
			s.LegacyRunConnectorOKData1ItemArray = append(s.LegacyRunConnectorOKData1ItemArray, elem)
			return nil
		}); err != nil {
			return err
		}
		s.Type = LegacyRunConnectorOKData1ItemArrayLegacyRunConnectorOKData
	case jx.Object:
		if err := s.LegacyRunConnectorOKData0.Decode(d); err != nil {
			return err
		}
		s.Type = LegacyRunConnectorOKData0LegacyRunConnectorOKData
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LegacyRunConnectorOKData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LegacyRunConnectorOKData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s LegacyRunConnectorOKData0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s LegacyRunConnectorOKData0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes LegacyRunConnectorOKData0 from json.
func (s *LegacyRunConnectorOKData0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LegacyRunConnectorOKData0 to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LegacyRunConnectorOKData0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s LegacyRunConnectorOKData0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LegacyRunConnectorOKData0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LegacyRunConnectorOKData1Item) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LegacyRunConnectorOKData1Item) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfLegacyRunConnectorOKData1Item = [0]string{}

// Decode decodes LegacyRunConnectorOKData1Item from json.
func (s *LegacyRunConnectorOKData1Item) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LegacyRunConnectorOKData1Item to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LegacyRunConnectorOKData1Item")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LegacyRunConnectorOKData1Item) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LegacyRunConnectorOKData1Item) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LegacyRunConnectorReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LegacyRunConnectorReq) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("params")
		s.Params.Encode(e)
	}
}

var jsonFieldsNameOfLegacyRunConnectorReq = [1]string{
	0: "params",
}

// Decode decodes LegacyRunConnectorReq from json.
func (s *LegacyRunConnectorReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LegacyRunConnectorReq to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "params":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Params.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"params\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LegacyRunConnectorReq")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfLegacyRunConnectorReq) {
					name = jsonFieldsNameOfLegacyRunConnectorReq[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LegacyRunConnectorReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LegacyRunConnectorReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LegacyRunConnectorReqParams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LegacyRunConnectorReqParams) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfLegacyRunConnectorReqParams = [0]string{}

// Decode decodes LegacyRunConnectorReqParams from json.
func (s *LegacyRunConnectorReqParams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LegacyRunConnectorReqParams to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LegacyRunConnectorReqParams")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LegacyRunConnectorReqParams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LegacyRunConnectorReqParams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LegacyUpdateConnectorReq) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LegacyUpdateConnectorReq) encodeFields(e *jx.Encoder) {
	{
		if s.Config != nil {
			e.FieldStart("config")
			s.Config.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Secrets != nil {
			e.FieldStart("secrets")
			s.Secrets.Encode(e)
		}
	}
}

var jsonFieldsNameOfLegacyUpdateConnectorReq = [3]string{
	0: "config",
	1: "name",
	2: "secrets",
}

// Decode decodes LegacyUpdateConnectorReq from json.
func (s *LegacyUpdateConnectorReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LegacyUpdateConnectorReq to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			if err := func() error {
				s.Config = nil
				var elem LegacyUpdateConnectorReqConfig
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Config = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secrets":
			if err := func() error {
				s.Secrets = nil
				var elem LegacyUpdateConnectorReqSecrets
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Secrets = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LegacyUpdateConnectorReq")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LegacyUpdateConnectorReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LegacyUpdateConnectorReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LegacyUpdateConnectorReqConfig) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LegacyUpdateConnectorReqConfig) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfLegacyUpdateConnectorReqConfig = [0]string{}

// Decode decodes LegacyUpdateConnectorReqConfig from json.
func (s *LegacyUpdateConnectorReqConfig) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LegacyUpdateConnectorReqConfig to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LegacyUpdateConnectorReqConfig")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LegacyUpdateConnectorReqConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LegacyUpdateConnectorReqConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *LegacyUpdateConnectorReqSecrets) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *LegacyUpdateConnectorReqSecrets) encodeFields(e *jx.Encoder) {
}

var jsonFieldsNameOfLegacyUpdateConnectorReqSecrets = [0]string{}

// Decode decodes LegacyUpdateConnectorReqSecrets from json.
func (s *LegacyUpdateConnectorReqSecrets) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode LegacyUpdateConnectorReqSecrets to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode LegacyUpdateConnectorReqSecrets")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *LegacyUpdateConnectorReqSecrets) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *LegacyUpdateConnectorReqSecrets) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConfigPropertiesCasesWebhookCreateCommentMethod as json.
func (o OptConfigPropertiesCasesWebhookCreateCommentMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConfigPropertiesCasesWebhookCreateCommentMethod from json.
func (o *OptConfigPropertiesCasesWebhookCreateCommentMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConfigPropertiesCasesWebhookCreateCommentMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConfigPropertiesCasesWebhookCreateCommentMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConfigPropertiesCasesWebhookCreateCommentMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConfigPropertiesCasesWebhookCreateIncidentMethod as json.
func (o OptConfigPropertiesCasesWebhookCreateIncidentMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConfigPropertiesCasesWebhookCreateIncidentMethod from json.
func (o *OptConfigPropertiesCasesWebhookCreateIncidentMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConfigPropertiesCasesWebhookCreateIncidentMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConfigPropertiesCasesWebhookCreateIncidentMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConfigPropertiesCasesWebhookCreateIncidentMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConfigPropertiesCasesWebhookUpdateIncidentMethod as json.
func (o OptConfigPropertiesCasesWebhookUpdateIncidentMethod) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConfigPropertiesCasesWebhookUpdateIncidentMethod from json.
func (o *OptConfigPropertiesCasesWebhookUpdateIncidentMethod) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConfigPropertiesCasesWebhookUpdateIncidentMethod to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConfigPropertiesCasesWebhookUpdateIncidentMethod) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConfigPropertiesCasesWebhookUpdateIncidentMethod) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConfigPropertiesSwimlaneMappings as json.
func (o OptConfigPropertiesSwimlaneMappings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConfigPropertiesSwimlaneMappings from json.
func (o *OptConfigPropertiesSwimlaneMappings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConfigPropertiesSwimlaneMappings to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConfigPropertiesSwimlaneMappings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConfigPropertiesSwimlaneMappings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConfigPropertiesSwimlaneMappingsAlertIdConfig as json.
func (o OptConfigPropertiesSwimlaneMappingsAlertIdConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConfigPropertiesSwimlaneMappingsAlertIdConfig from json.
func (o *OptConfigPropertiesSwimlaneMappingsAlertIdConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConfigPropertiesSwimlaneMappingsAlertIdConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConfigPropertiesSwimlaneMappingsAlertIdConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConfigPropertiesSwimlaneMappingsAlertIdConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConfigPropertiesSwimlaneMappingsCaseIdConfig as json.
func (o OptConfigPropertiesSwimlaneMappingsCaseIdConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConfigPropertiesSwimlaneMappingsCaseIdConfig from json.
func (o *OptConfigPropertiesSwimlaneMappingsCaseIdConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConfigPropertiesSwimlaneMappingsCaseIdConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConfigPropertiesSwimlaneMappingsCaseIdConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConfigPropertiesSwimlaneMappingsCaseIdConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConfigPropertiesSwimlaneMappingsCaseNameConfig as json.
func (o OptConfigPropertiesSwimlaneMappingsCaseNameConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConfigPropertiesSwimlaneMappingsCaseNameConfig from json.
func (o *OptConfigPropertiesSwimlaneMappingsCaseNameConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConfigPropertiesSwimlaneMappingsCaseNameConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConfigPropertiesSwimlaneMappingsCaseNameConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConfigPropertiesSwimlaneMappingsCaseNameConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConfigPropertiesSwimlaneMappingsCommentsConfig as json.
func (o OptConfigPropertiesSwimlaneMappingsCommentsConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConfigPropertiesSwimlaneMappingsCommentsConfig from json.
func (o *OptConfigPropertiesSwimlaneMappingsCommentsConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConfigPropertiesSwimlaneMappingsCommentsConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConfigPropertiesSwimlaneMappingsCommentsConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConfigPropertiesSwimlaneMappingsCommentsConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConfigPropertiesSwimlaneMappingsDescriptionConfig as json.
func (o OptConfigPropertiesSwimlaneMappingsDescriptionConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConfigPropertiesSwimlaneMappingsDescriptionConfig from json.
func (o *OptConfigPropertiesSwimlaneMappingsDescriptionConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConfigPropertiesSwimlaneMappingsDescriptionConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConfigPropertiesSwimlaneMappingsDescriptionConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConfigPropertiesSwimlaneMappingsDescriptionConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConfigPropertiesSwimlaneMappingsRuleNameConfig as json.
func (o OptConfigPropertiesSwimlaneMappingsRuleNameConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConfigPropertiesSwimlaneMappingsRuleNameConfig from json.
func (o *OptConfigPropertiesSwimlaneMappingsRuleNameConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConfigPropertiesSwimlaneMappingsRuleNameConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConfigPropertiesSwimlaneMappingsRuleNameConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConfigPropertiesSwimlaneMappingsRuleNameConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConfigPropertiesSwimlaneMappingsSeverityConfig as json.
func (o OptConfigPropertiesSwimlaneMappingsSeverityConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes ConfigPropertiesSwimlaneMappingsSeverityConfig from json.
func (o *OptConfigPropertiesSwimlaneMappingsSeverityConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConfigPropertiesSwimlaneMappingsSeverityConfig to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConfigPropertiesSwimlaneMappingsSeverityConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConfigPropertiesSwimlaneMappingsSeverityConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConnectorTypes as json.
func (o OptConnectorTypes) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConnectorTypes from json.
func (o *OptConnectorTypes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConnectorTypes to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConnectorTypes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConnectorTypes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IsDeprecated as json.
func (o OptIsDeprecated) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IsDeprecated from json.
func (o *OptIsDeprecated) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIsDeprecated to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIsDeprecated) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIsDeprecated) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IsMissingSecrets as json.
func (o OptIsMissingSecrets) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes IsMissingSecrets from json.
func (o *OptIsMissingSecrets) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptIsMissingSecrets to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptIsMissingSecrets) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptIsMissingSecrets) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes LegacyRunConnectorOKData as json.
func (o OptLegacyRunConnectorOKData) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes LegacyRunConnectorOKData from json.
func (o *OptLegacyRunConnectorOKData) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptLegacyRunConnectorOKData to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptLegacyRunConnectorOKData) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptLegacyRunConnectorOKData) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes GetConnectorsOKItemConfig as json.
func (o OptNilGetConnectorsOKItemConfig) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	o.Value.Encode(e)
}

// Decode decodes GetConnectorsOKItemConfig from json.
func (o *OptNilGetConnectorsOKItemConfig) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilGetConnectorsOKItemConfig to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v GetConnectorsOKItemConfig
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	o.Value = make(GetConnectorsOKItemConfig)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilGetConnectorsOKItemConfig) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilGetConnectorsOKItemConfig) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptNilString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	if o.Null {
		e.Null()
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptNilString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNilString to nil")
	}
	if d.Next() == jx.Null {
		if err := d.Null(); err != nil {
			return err
		}

		var v string
		o.Value = v
		o.Set = true
		o.Null = true
		return nil
	}
	o.Set = true
	o.Null = false
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNilString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNilString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes R400Error as json.
func (o OptR400Error) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes R400Error from json.
func (o *OptR400Error) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptR400Error to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptR400Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptR400Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes R400StatusCode as json.
func (o OptR400StatusCode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes R400StatusCode from json.
func (o *OptR400StatusCode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptR400StatusCode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptR400StatusCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptR400StatusCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes R401Error as json.
func (o OptR401Error) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes R401Error from json.
func (o *OptR401Error) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptR401Error to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptR401Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptR401Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes R401StatusCode as json.
func (o OptR401StatusCode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes R401StatusCode from json.
func (o *OptR401StatusCode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptR401StatusCode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptR401StatusCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptR401StatusCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes R404Error as json.
func (o OptR404Error) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes R404Error from json.
func (o *OptR404Error) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptR404Error to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptR404Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptR404Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes R404StatusCode as json.
func (o OptR404StatusCode) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes R404StatusCode from json.
func (o *OptR404StatusCode) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptR404StatusCode to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptR404StatusCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptR404StatusCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes SecretsPropertiesCasesWebhook as json.
func (o OptSecretsPropertiesCasesWebhook) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes SecretsPropertiesCasesWebhook from json.
func (o *OptSecretsPropertiesCasesWebhook) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptSecretsPropertiesCasesWebhook to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptSecretsPropertiesCasesWebhook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptSecretsPropertiesCasesWebhook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *R400) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *R400) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfR400 = [3]string{
	0: "error",
	1: "message",
	2: "statusCode",
}

// Decode decodes R400 from json.
func (s *R400) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R400 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R400")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *R400) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *R400) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes R400Error as json.
func (s R400Error) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes R400Error from json.
func (s *R400Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R400Error to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch R400Error(v) {
	case R400ErrorBadRequest:
		*s = R400ErrorBadRequest
	default:
		*s = R400Error(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s R400Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *R400Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes R400StatusCode as json.
func (s R400StatusCode) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes R400StatusCode from json.
func (s *R400StatusCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R400StatusCode to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = R400StatusCode(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s R400StatusCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *R400StatusCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *R401) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *R401) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfR401 = [3]string{
	0: "error",
	1: "message",
	2: "statusCode",
}

// Decode decodes R401 from json.
func (s *R401) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R401 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R401")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *R401) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *R401) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes R401Error as json.
func (s R401Error) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes R401Error from json.
func (s *R401Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R401Error to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch R401Error(v) {
	case R401ErrorUnauthorized:
		*s = R401ErrorUnauthorized
	default:
		*s = R401Error(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s R401Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *R401Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes R401StatusCode as json.
func (s R401StatusCode) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes R401StatusCode from json.
func (s *R401StatusCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R401StatusCode to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = R401StatusCode(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s R401StatusCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *R401StatusCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *R404) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *R404) encodeFields(e *jx.Encoder) {
	{
		if s.Error.Set {
			e.FieldStart("error")
			s.Error.Encode(e)
		}
	}
	{
		if s.Message.Set {
			e.FieldStart("message")
			s.Message.Encode(e)
		}
	}
	{
		if s.StatusCode.Set {
			e.FieldStart("statusCode")
			s.StatusCode.Encode(e)
		}
	}
}

var jsonFieldsNameOfR404 = [3]string{
	0: "error",
	1: "message",
	2: "statusCode",
}

// Decode decodes R404 from json.
func (s *R404) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R404 to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "error":
			if err := func() error {
				s.Error.Reset()
				if err := s.Error.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"error\"")
			}
		case "message":
			if err := func() error {
				s.Message.Reset()
				if err := s.Message.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"message\"")
			}
		case "statusCode":
			if err := func() error {
				s.StatusCode.Reset()
				if err := s.StatusCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"statusCode\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode R404")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *R404) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *R404) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes R404Error as json.
func (s R404Error) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes R404Error from json.
func (s *R404Error) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R404Error to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch R404Error(v) {
	case R404ErrorNotFound:
		*s = R404ErrorNotFound
	default:
		*s = R404Error(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s R404Error) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *R404Error) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes R404StatusCode as json.
func (s R404StatusCode) Encode(e *jx.Encoder) {
	e.Int(int(s))
}

// Decode decodes R404StatusCode from json.
func (s *R404StatusCode) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode R404StatusCode to nil")
	}
	v, err := d.Int()
	if err != nil {
		return err
	}
	*s = R404StatusCode(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s R404StatusCode) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *R404StatusCode) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SecretsPropertiesCasesWebhook) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SecretsPropertiesCasesWebhook) encodeFields(e *jx.Encoder) {
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.User.Set {
			e.FieldStart("user")
			s.User.Encode(e)
		}
	}
}

var jsonFieldsNameOfSecretsPropertiesCasesWebhook = [2]string{
	0: "password",
	1: "user",
}

// Decode decodes SecretsPropertiesCasesWebhook from json.
func (s *SecretsPropertiesCasesWebhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretsPropertiesCasesWebhook to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "user":
			if err := func() error {
				s.User.Reset()
				if err := s.User.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"user\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecretsPropertiesCasesWebhook")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SecretsPropertiesCasesWebhook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecretsPropertiesCasesWebhook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SecretsPropertiesEmail) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SecretsPropertiesEmail) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SecretsPropertiesEmail from json.
func (s *SecretsPropertiesEmail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretsPropertiesEmail to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecretsPropertiesEmail")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SecretsPropertiesEmail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecretsPropertiesEmail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SecretsPropertiesJira) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SecretsPropertiesJira) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apiToken")
		e.Str(s.ApiToken)
	}
	{
		e.FieldStart("email")
		e.Str(s.Email)
	}
}

var jsonFieldsNameOfSecretsPropertiesJira = [2]string{
	0: "apiToken",
	1: "email",
}

// Decode decodes SecretsPropertiesJira from json.
func (s *SecretsPropertiesJira) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretsPropertiesJira to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiToken":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ApiToken = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiToken\"")
			}
		case "email":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Email = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecretsPropertiesJira")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSecretsPropertiesJira) {
					name = jsonFieldsNameOfSecretsPropertiesJira[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SecretsPropertiesJira) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecretsPropertiesJira) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SecretsPropertiesOpsgenie) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SecretsPropertiesOpsgenie) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apiKey")
		e.Str(s.ApiKey)
	}
}

var jsonFieldsNameOfSecretsPropertiesOpsgenie = [1]string{
	0: "apiKey",
}

// Decode decodes SecretsPropertiesOpsgenie from json.
func (s *SecretsPropertiesOpsgenie) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretsPropertiesOpsgenie to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiKey":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ApiKey = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiKey\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecretsPropertiesOpsgenie")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSecretsPropertiesOpsgenie) {
					name = jsonFieldsNameOfSecretsPropertiesOpsgenie[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SecretsPropertiesOpsgenie) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecretsPropertiesOpsgenie) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SecretsPropertiesPagerduty) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SecretsPropertiesPagerduty) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SecretsPropertiesPagerduty from json.
func (s *SecretsPropertiesPagerduty) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretsPropertiesPagerduty to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecretsPropertiesPagerduty")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SecretsPropertiesPagerduty) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecretsPropertiesPagerduty) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SecretsPropertiesResilient) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SecretsPropertiesResilient) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("apiKeyId")
		e.Str(s.ApiKeyId)
	}
	{
		e.FieldStart("apiKeySecret")
		e.Str(s.ApiKeySecret)
	}
}

var jsonFieldsNameOfSecretsPropertiesResilient = [2]string{
	0: "apiKeyId",
	1: "apiKeySecret",
}

// Decode decodes SecretsPropertiesResilient from json.
func (s *SecretsPropertiesResilient) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretsPropertiesResilient to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiKeyId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ApiKeyId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiKeyId\"")
			}
		case "apiKeySecret":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.ApiKeySecret = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiKeySecret\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecretsPropertiesResilient")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSecretsPropertiesResilient) {
					name = jsonFieldsNameOfSecretsPropertiesResilient[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SecretsPropertiesResilient) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecretsPropertiesResilient) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SecretsPropertiesServicenow) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SecretsPropertiesServicenow) encodeFields(e *jx.Encoder) {
	{
		if s.ClientSecret.Set {
			e.FieldStart("clientSecret")
			s.ClientSecret.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.PrivateKey.Set {
			e.FieldStart("privateKey")
			s.PrivateKey.Encode(e)
		}
	}
	{
		if s.PrivateKeyPassword.Set {
			e.FieldStart("privateKeyPassword")
			s.PrivateKeyPassword.Encode(e)
		}
	}
	{
		if s.Username.Set {
			e.FieldStart("username")
			s.Username.Encode(e)
		}
	}
}

var jsonFieldsNameOfSecretsPropertiesServicenow = [5]string{
	0: "clientSecret",
	1: "password",
	2: "privateKey",
	3: "privateKeyPassword",
	4: "username",
}

// Decode decodes SecretsPropertiesServicenow from json.
func (s *SecretsPropertiesServicenow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretsPropertiesServicenow to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "clientSecret":
			if err := func() error {
				s.ClientSecret.Reset()
				if err := s.ClientSecret.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientSecret\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "privateKey":
			if err := func() error {
				s.PrivateKey.Reset()
				if err := s.PrivateKey.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privateKey\"")
			}
		case "privateKeyPassword":
			if err := func() error {
				s.PrivateKeyPassword.Reset()
				if err := s.PrivateKeyPassword.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"privateKeyPassword\"")
			}
		case "username":
			if err := func() error {
				s.Username.Reset()
				if err := s.Username.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"username\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecretsPropertiesServicenow")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SecretsPropertiesServicenow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecretsPropertiesServicenow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SecretsPropertiesSlack) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SecretsPropertiesSlack) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SecretsPropertiesSlack from json.
func (s *SecretsPropertiesSlack) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretsPropertiesSlack to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecretsPropertiesSlack")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SecretsPropertiesSlack) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecretsPropertiesSlack) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SecretsPropertiesSwimlane) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SecretsPropertiesSwimlane) encodeFields(e *jx.Encoder) {
	{
		if s.ApiToken.Set {
			e.FieldStart("apiToken")
			s.ApiToken.Encode(e)
		}
	}
}

var jsonFieldsNameOfSecretsPropertiesSwimlane = [1]string{
	0: "apiToken",
}

// Decode decodes SecretsPropertiesSwimlane from json.
func (s *SecretsPropertiesSwimlane) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretsPropertiesSwimlane to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "apiToken":
			if err := func() error {
				s.ApiToken.Reset()
				if err := s.ApiToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"apiToken\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecretsPropertiesSwimlane")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SecretsPropertiesSwimlane) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecretsPropertiesSwimlane) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SecretsPropertiesTeams) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SecretsPropertiesTeams) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SecretsPropertiesTeams from json.
func (s *SecretsPropertiesTeams) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretsPropertiesTeams to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecretsPropertiesTeams")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SecretsPropertiesTeams) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecretsPropertiesTeams) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SecretsPropertiesTines) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SecretsPropertiesTines) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SecretsPropertiesTines from json.
func (s *SecretsPropertiesTines) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretsPropertiesTines to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecretsPropertiesTines")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SecretsPropertiesTines) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecretsPropertiesTines) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SecretsPropertiesWebhook) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SecretsPropertiesWebhook) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SecretsPropertiesWebhook from json.
func (s *SecretsPropertiesWebhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretsPropertiesWebhook to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecretsPropertiesWebhook")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SecretsPropertiesWebhook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecretsPropertiesWebhook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SecretsPropertiesXmatters) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SecretsPropertiesXmatters) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SecretsPropertiesXmatters from json.
func (s *SecretsPropertiesXmatters) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SecretsPropertiesXmatters to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SecretsPropertiesXmatters")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SecretsPropertiesXmatters) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SecretsPropertiesXmatters) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UpdateConnectorReq as json.
func (s UpdateConnectorReq) Encode(e *jx.Encoder) {
	switch s.Type {
	case UpdateConnectorRequestCasesWebhookUpdateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".cases-webhook")
		s.UpdateConnectorRequestCasesWebhook.encodeFields(e)
		e.ObjEnd()
	case UpdateConnectorRequestIndexUpdateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".index")
		s.UpdateConnectorRequestIndex.encodeFields(e)
		e.ObjEnd()
	case UpdateConnectorRequestJiraUpdateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".jira")
		s.UpdateConnectorRequestJira.encodeFields(e)
		e.ObjEnd()
	case UpdateConnectorRequestOpsgenieUpdateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".opsgenie")
		s.UpdateConnectorRequestOpsgenie.encodeFields(e)
		e.ObjEnd()
	case UpdateConnectorRequestResilientUpdateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".resilient")
		s.UpdateConnectorRequestResilient.encodeFields(e)
		e.ObjEnd()
	case UpdateConnectorRequestServerlogUpdateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".server-log")
		s.UpdateConnectorRequestServerlog.encodeFields(e)
		e.ObjEnd()
	case UpdateConnectorRequestServicenowUpdateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".servicenow")
		s.UpdateConnectorRequestServicenow.encodeFields(e)
		e.ObjEnd()
	case UpdateConnectorRequestServicenowItomUpdateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".servicenow-itom")
		s.UpdateConnectorRequestServicenowItom.encodeFields(e)
		e.ObjEnd()
	case UpdateConnectorRequestSwimlaneUpdateConnectorReq:
		e.ObjStart()
		e.FieldStart("connector_type_id")
		e.Str(".swimlane")
		s.UpdateConnectorRequestSwimlane.encodeFields(e)
		e.ObjEnd()
	}
}

// Decode decodes UpdateConnectorReq from json.
func (s *UpdateConnectorReq) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateConnectorReq to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "connector_type_id":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case ".cases-webhook":
					s.Type = UpdateConnectorRequestCasesWebhookUpdateConnectorReq
					found = true
				case ".index":
					s.Type = UpdateConnectorRequestIndexUpdateConnectorReq
					found = true
				case ".jira":
					s.Type = UpdateConnectorRequestJiraUpdateConnectorReq
					found = true
				case ".opsgenie":
					s.Type = UpdateConnectorRequestOpsgenieUpdateConnectorReq
					found = true
				case ".resilient":
					s.Type = UpdateConnectorRequestResilientUpdateConnectorReq
					found = true
				case ".server-log":
					s.Type = UpdateConnectorRequestServerlogUpdateConnectorReq
					found = true
				case ".servicenow":
					s.Type = UpdateConnectorRequestServicenowUpdateConnectorReq
					found = true
				case ".servicenow-itom":
					s.Type = UpdateConnectorRequestServicenowItomUpdateConnectorReq
					found = true
				case ".swimlane":
					s.Type = UpdateConnectorRequestSwimlaneUpdateConnectorReq
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case UpdateConnectorRequestCasesWebhookUpdateConnectorReq:
		if err := s.UpdateConnectorRequestCasesWebhook.Decode(d); err != nil {
			return err
		}
	case UpdateConnectorRequestIndexUpdateConnectorReq:
		if err := s.UpdateConnectorRequestIndex.Decode(d); err != nil {
			return err
		}
	case UpdateConnectorRequestJiraUpdateConnectorReq:
		if err := s.UpdateConnectorRequestJira.Decode(d); err != nil {
			return err
		}
	case UpdateConnectorRequestOpsgenieUpdateConnectorReq:
		if err := s.UpdateConnectorRequestOpsgenie.Decode(d); err != nil {
			return err
		}
	case UpdateConnectorRequestResilientUpdateConnectorReq:
		if err := s.UpdateConnectorRequestResilient.Decode(d); err != nil {
			return err
		}
	case UpdateConnectorRequestServerlogUpdateConnectorReq:
		if err := s.UpdateConnectorRequestServerlog.Decode(d); err != nil {
			return err
		}
	case UpdateConnectorRequestServicenowUpdateConnectorReq:
		if err := s.UpdateConnectorRequestServicenow.Decode(d); err != nil {
			return err
		}
	case UpdateConnectorRequestServicenowItomUpdateConnectorReq:
		if err := s.UpdateConnectorRequestServicenowItom.Decode(d); err != nil {
			return err
		}
	case UpdateConnectorRequestSwimlaneUpdateConnectorReq:
		if err := s.UpdateConnectorRequestSwimlane.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UpdateConnectorReq) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateConnectorReq) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateConnectorRequestCasesWebhook) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateConnectorRequestCasesWebhook) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Secrets.Set {
			e.FieldStart("secrets")
			s.Secrets.Encode(e)
		}
	}
}

var jsonFieldsNameOfUpdateConnectorRequestCasesWebhook = [3]string{
	0: "config",
	1: "name",
	2: "secrets",
}

// Decode decodes UpdateConnectorRequestCasesWebhook from json.
func (s *UpdateConnectorRequestCasesWebhook) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateConnectorRequestCasesWebhook to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secrets":
			if err := func() error {
				s.Secrets.Reset()
				if err := s.Secrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateConnectorRequestCasesWebhook")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateConnectorRequestCasesWebhook) {
					name = jsonFieldsNameOfUpdateConnectorRequestCasesWebhook[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateConnectorRequestCasesWebhook) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateConnectorRequestCasesWebhook) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateConnectorRequestIndex) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateConnectorRequestIndex) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfUpdateConnectorRequestIndex = [2]string{
	0: "config",
	1: "name",
}

// Decode decodes UpdateConnectorRequestIndex from json.
func (s *UpdateConnectorRequestIndex) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateConnectorRequestIndex to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateConnectorRequestIndex")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateConnectorRequestIndex) {
					name = jsonFieldsNameOfUpdateConnectorRequestIndex[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateConnectorRequestIndex) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateConnectorRequestIndex) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateConnectorRequestJira) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateConnectorRequestJira) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("secrets")
		s.Secrets.Encode(e)
	}
}

var jsonFieldsNameOfUpdateConnectorRequestJira = [3]string{
	0: "config",
	1: "name",
	2: "secrets",
}

// Decode decodes UpdateConnectorRequestJira from json.
func (s *UpdateConnectorRequestJira) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateConnectorRequestJira to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Secrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateConnectorRequestJira")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateConnectorRequestJira) {
					name = jsonFieldsNameOfUpdateConnectorRequestJira[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateConnectorRequestJira) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateConnectorRequestJira) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateConnectorRequestOpsgenie) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateConnectorRequestOpsgenie) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("secrets")
		s.Secrets.Encode(e)
	}
}

var jsonFieldsNameOfUpdateConnectorRequestOpsgenie = [3]string{
	0: "config",
	1: "name",
	2: "secrets",
}

// Decode decodes UpdateConnectorRequestOpsgenie from json.
func (s *UpdateConnectorRequestOpsgenie) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateConnectorRequestOpsgenie to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Secrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateConnectorRequestOpsgenie")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateConnectorRequestOpsgenie) {
					name = jsonFieldsNameOfUpdateConnectorRequestOpsgenie[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateConnectorRequestOpsgenie) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateConnectorRequestOpsgenie) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateConnectorRequestResilient) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateConnectorRequestResilient) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("secrets")
		s.Secrets.Encode(e)
	}
}

var jsonFieldsNameOfUpdateConnectorRequestResilient = [3]string{
	0: "config",
	1: "name",
	2: "secrets",
}

// Decode decodes UpdateConnectorRequestResilient from json.
func (s *UpdateConnectorRequestResilient) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateConnectorRequestResilient to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Secrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateConnectorRequestResilient")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateConnectorRequestResilient) {
					name = jsonFieldsNameOfUpdateConnectorRequestResilient[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateConnectorRequestResilient) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateConnectorRequestResilient) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateConnectorRequestServerlog) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateConnectorRequestServerlog) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
}

var jsonFieldsNameOfUpdateConnectorRequestServerlog = [1]string{
	0: "name",
}

// Decode decodes UpdateConnectorRequestServerlog from json.
func (s *UpdateConnectorRequestServerlog) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateConnectorRequestServerlog to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateConnectorRequestServerlog")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateConnectorRequestServerlog) {
					name = jsonFieldsNameOfUpdateConnectorRequestServerlog[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateConnectorRequestServerlog) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateConnectorRequestServerlog) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateConnectorRequestServicenow) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateConnectorRequestServicenow) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("secrets")
		s.Secrets.Encode(e)
	}
}

var jsonFieldsNameOfUpdateConnectorRequestServicenow = [3]string{
	0: "config",
	1: "name",
	2: "secrets",
}

// Decode decodes UpdateConnectorRequestServicenow from json.
func (s *UpdateConnectorRequestServicenow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateConnectorRequestServicenow to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Secrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateConnectorRequestServicenow")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateConnectorRequestServicenow) {
					name = jsonFieldsNameOfUpdateConnectorRequestServicenow[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateConnectorRequestServicenow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateConnectorRequestServicenow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateConnectorRequestServicenowItom) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateConnectorRequestServicenowItom) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("secrets")
		s.Secrets.Encode(e)
	}
}

var jsonFieldsNameOfUpdateConnectorRequestServicenowItom = [3]string{
	0: "config",
	1: "name",
	2: "secrets",
}

// Decode decodes UpdateConnectorRequestServicenowItom from json.
func (s *UpdateConnectorRequestServicenowItom) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateConnectorRequestServicenowItom to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Secrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateConnectorRequestServicenowItom")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateConnectorRequestServicenowItom) {
					name = jsonFieldsNameOfUpdateConnectorRequestServicenowItom[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateConnectorRequestServicenowItom) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateConnectorRequestServicenowItom) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UpdateConnectorRequestSwimlane) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UpdateConnectorRequestSwimlane) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("config")
		s.Config.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		e.FieldStart("secrets")
		s.Secrets.Encode(e)
	}
}

var jsonFieldsNameOfUpdateConnectorRequestSwimlane = [3]string{
	0: "config",
	1: "name",
	2: "secrets",
}

// Decode decodes UpdateConnectorRequestSwimlane from json.
func (s *UpdateConnectorRequestSwimlane) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UpdateConnectorRequestSwimlane to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "config":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Config.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"config\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "secrets":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Secrets.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"secrets\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UpdateConnectorRequestSwimlane")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfUpdateConnectorRequestSwimlane) {
					name = jsonFieldsNameOfUpdateConnectorRequestSwimlane[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UpdateConnectorRequestSwimlane) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UpdateConnectorRequestSwimlane) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
