// Code generated by ogen, DO NOT EDIT.

package connectors

import (
	"net/http"
	"net/url"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
	"github.com/ogen-go/ogen/validate"
)

// CreateConnectorParams is parameters of createConnector operation.
type CreateConnectorParams struct {
	// Cross-site request forgery protection.
	KbnXSRF string
	// An identifier for the space. If `/s/` and the identifier are omitted from the path, the default
	// space is used.
	SpaceId string
}

func unpackCreateConnectorParams(packed middleware.Parameters) (params CreateConnectorParams) {
	{
		key := middleware.ParameterKey{
			Name: "kbn-xsrf",
			In:   "header",
		}
		params.KbnXSRF = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "spaceId",
			In:   "path",
		}
		params.SpaceId = packed[key].(string)
	}
	return params
}

func decodeCreateConnectorParams(args [1]string, argsEscaped bool, r *http.Request) (params CreateConnectorParams, _ error) {
	h := uri.NewHeaderDecoder(r.Header)
	// Decode header: kbn-xsrf.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "kbn-xsrf",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.KbnXSRF = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "kbn-xsrf",
			In:   "header",
			Err:  err,
		}
	}
	// Decode path: spaceId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "spaceId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SpaceId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "spaceId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// DeleteConnectorParams is parameters of deleteConnector operation.
type DeleteConnectorParams struct {
	// Cross-site request forgery protection.
	KbnXSRF string
	// An identifier for the connector.
	ConnectorId string
	// An identifier for the space. If `/s/` and the identifier are omitted from the path, the default
	// space is used.
	SpaceId string
}

func unpackDeleteConnectorParams(packed middleware.Parameters) (params DeleteConnectorParams) {
	{
		key := middleware.ParameterKey{
			Name: "kbn-xsrf",
			In:   "header",
		}
		params.KbnXSRF = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "connectorId",
			In:   "path",
		}
		params.ConnectorId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "spaceId",
			In:   "path",
		}
		params.SpaceId = packed[key].(string)
	}
	return params
}

func decodeDeleteConnectorParams(args [2]string, argsEscaped bool, r *http.Request) (params DeleteConnectorParams, _ error) {
	h := uri.NewHeaderDecoder(r.Header)
	// Decode header: kbn-xsrf.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "kbn-xsrf",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.KbnXSRF = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "kbn-xsrf",
			In:   "header",
			Err:  err,
		}
	}
	// Decode path: connectorId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "connectorId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ConnectorId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "connectorId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: spaceId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "spaceId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SpaceId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "spaceId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetConnectorParams is parameters of getConnector operation.
type GetConnectorParams struct {
	// An identifier for the connector.
	ConnectorId string
	// An identifier for the space. If `/s/` and the identifier are omitted from the path, the default
	// space is used.
	SpaceId string
}

func unpackGetConnectorParams(packed middleware.Parameters) (params GetConnectorParams) {
	{
		key := middleware.ParameterKey{
			Name: "connectorId",
			In:   "path",
		}
		params.ConnectorId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "spaceId",
			In:   "path",
		}
		params.SpaceId = packed[key].(string)
	}
	return params
}

func decodeGetConnectorParams(args [2]string, argsEscaped bool, r *http.Request) (params GetConnectorParams, _ error) {
	// Decode path: connectorId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "connectorId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ConnectorId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "connectorId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: spaceId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "spaceId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SpaceId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "spaceId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// GetConnectorTypesParams is parameters of getConnectorTypes operation.
type GetConnectorTypesParams struct {
	// An identifier for the space. If `/s/` and the identifier are omitted from the path, the default
	// space is used.
	SpaceId string
	// A filter to limit the retrieved connector types to those that support a specific feature (such as
	// alerting or cases).
	FeatureID OptFeatures
}

func unpackGetConnectorTypesParams(packed middleware.Parameters) (params GetConnectorTypesParams) {
	{
		key := middleware.ParameterKey{
			Name: "spaceId",
			In:   "path",
		}
		params.SpaceId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "feature_id",
			In:   "query",
		}
		if v, ok := packed[key]; ok {
			params.FeatureID = v.(OptFeatures)
		}
	}
	return params
}

func decodeGetConnectorTypesParams(args [1]string, argsEscaped bool, r *http.Request) (params GetConnectorTypesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: spaceId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "spaceId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SpaceId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "spaceId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode query: feature_id.
	if err := func() error {
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "feature_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFeatureIDVal Features
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFeatureIDVal = Features(c)
					return nil
				}(); err != nil {
					return err
				}
				params.FeatureID.SetTo(paramsDotFeatureIDVal)
				return nil
			}); err != nil {
				return err
			}
			if err := func() error {
				if params.FeatureID.Set {
					if err := func() error {
						if err := params.FeatureID.Value.Validate(); err != nil {
							return err
						}
						return nil
					}(); err != nil {
						return err
					}
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "feature_id",
			In:   "query",
			Err:  err,
		}
	}
	return params, nil
}

// GetConnectorsParams is parameters of getConnectors operation.
type GetConnectorsParams struct {
	// An identifier for the space. If `/s/` and the identifier are omitted from the path, the default
	// space is used.
	SpaceId string
}

func unpackGetConnectorsParams(packed middleware.Parameters) (params GetConnectorsParams) {
	{
		key := middleware.ParameterKey{
			Name: "spaceId",
			In:   "path",
		}
		params.SpaceId = packed[key].(string)
	}
	return params
}

func decodeGetConnectorsParams(args [1]string, argsEscaped bool, r *http.Request) (params GetConnectorsParams, _ error) {
	// Decode path: spaceId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "spaceId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SpaceId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "spaceId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// LegacyCreateConnectorParams is parameters of legacyCreateConnector operation.
type LegacyCreateConnectorParams struct {
	// Cross-site request forgery protection.
	KbnXSRF string
	// An identifier for the space. If `/s/` and the identifier are omitted from the path, the default
	// space is used.
	SpaceId string
}

func unpackLegacyCreateConnectorParams(packed middleware.Parameters) (params LegacyCreateConnectorParams) {
	{
		key := middleware.ParameterKey{
			Name: "kbn-xsrf",
			In:   "header",
		}
		params.KbnXSRF = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "spaceId",
			In:   "path",
		}
		params.SpaceId = packed[key].(string)
	}
	return params
}

func decodeLegacyCreateConnectorParams(args [1]string, argsEscaped bool, r *http.Request) (params LegacyCreateConnectorParams, _ error) {
	h := uri.NewHeaderDecoder(r.Header)
	// Decode header: kbn-xsrf.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "kbn-xsrf",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.KbnXSRF = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "kbn-xsrf",
			In:   "header",
			Err:  err,
		}
	}
	// Decode path: spaceId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "spaceId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SpaceId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "spaceId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// LegacyDeleteConnectorParams is parameters of legacyDeleteConnector operation.
type LegacyDeleteConnectorParams struct {
	// Cross-site request forgery protection.
	KbnXSRF string
	// An identifier for the action.
	ActionId string
	// An identifier for the space. If `/s/` and the identifier are omitted from the path, the default
	// space is used.
	SpaceId string
}

func unpackLegacyDeleteConnectorParams(packed middleware.Parameters) (params LegacyDeleteConnectorParams) {
	{
		key := middleware.ParameterKey{
			Name: "kbn-xsrf",
			In:   "header",
		}
		params.KbnXSRF = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "actionId",
			In:   "path",
		}
		params.ActionId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "spaceId",
			In:   "path",
		}
		params.SpaceId = packed[key].(string)
	}
	return params
}

func decodeLegacyDeleteConnectorParams(args [2]string, argsEscaped bool, r *http.Request) (params LegacyDeleteConnectorParams, _ error) {
	h := uri.NewHeaderDecoder(r.Header)
	// Decode header: kbn-xsrf.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "kbn-xsrf",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.KbnXSRF = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "kbn-xsrf",
			In:   "header",
			Err:  err,
		}
	}
	// Decode path: actionId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "actionId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ActionId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "actionId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: spaceId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "spaceId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SpaceId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "spaceId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// LegacyGetConnectorParams is parameters of legacyGetConnector operation.
type LegacyGetConnectorParams struct {
	// An identifier for the action.
	ActionId string
	// An identifier for the space. If `/s/` and the identifier are omitted from the path, the default
	// space is used.
	SpaceId string
}

func unpackLegacyGetConnectorParams(packed middleware.Parameters) (params LegacyGetConnectorParams) {
	{
		key := middleware.ParameterKey{
			Name: "actionId",
			In:   "path",
		}
		params.ActionId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "spaceId",
			In:   "path",
		}
		params.SpaceId = packed[key].(string)
	}
	return params
}

func decodeLegacyGetConnectorParams(args [2]string, argsEscaped bool, r *http.Request) (params LegacyGetConnectorParams, _ error) {
	// Decode path: actionId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "actionId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ActionId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "actionId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: spaceId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "spaceId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SpaceId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "spaceId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// LegacyGetConnectorTypesParams is parameters of legacyGetConnectorTypes operation.
type LegacyGetConnectorTypesParams struct {
	// An identifier for the space. If `/s/` and the identifier are omitted from the path, the default
	// space is used.
	SpaceId string
}

func unpackLegacyGetConnectorTypesParams(packed middleware.Parameters) (params LegacyGetConnectorTypesParams) {
	{
		key := middleware.ParameterKey{
			Name: "spaceId",
			In:   "path",
		}
		params.SpaceId = packed[key].(string)
	}
	return params
}

func decodeLegacyGetConnectorTypesParams(args [1]string, argsEscaped bool, r *http.Request) (params LegacyGetConnectorTypesParams, _ error) {
	// Decode path: spaceId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "spaceId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SpaceId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "spaceId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// LegacyGetConnectorsParams is parameters of legacyGetConnectors operation.
type LegacyGetConnectorsParams struct {
	// An identifier for the space. If `/s/` and the identifier are omitted from the path, the default
	// space is used.
	SpaceId string
}

func unpackLegacyGetConnectorsParams(packed middleware.Parameters) (params LegacyGetConnectorsParams) {
	{
		key := middleware.ParameterKey{
			Name: "spaceId",
			In:   "path",
		}
		params.SpaceId = packed[key].(string)
	}
	return params
}

func decodeLegacyGetConnectorsParams(args [1]string, argsEscaped bool, r *http.Request) (params LegacyGetConnectorsParams, _ error) {
	// Decode path: spaceId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "spaceId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SpaceId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "spaceId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// LegacyRunConnectorParams is parameters of legacyRunConnector operation.
type LegacyRunConnectorParams struct {
	// Cross-site request forgery protection.
	KbnXSRF string
	// An identifier for the action.
	ActionId string
	// An identifier for the space. If `/s/` and the identifier are omitted from the path, the default
	// space is used.
	SpaceId string
}

func unpackLegacyRunConnectorParams(packed middleware.Parameters) (params LegacyRunConnectorParams) {
	{
		key := middleware.ParameterKey{
			Name: "kbn-xsrf",
			In:   "header",
		}
		params.KbnXSRF = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "actionId",
			In:   "path",
		}
		params.ActionId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "spaceId",
			In:   "path",
		}
		params.SpaceId = packed[key].(string)
	}
	return params
}

func decodeLegacyRunConnectorParams(args [2]string, argsEscaped bool, r *http.Request) (params LegacyRunConnectorParams, _ error) {
	h := uri.NewHeaderDecoder(r.Header)
	// Decode header: kbn-xsrf.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "kbn-xsrf",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.KbnXSRF = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "kbn-xsrf",
			In:   "header",
			Err:  err,
		}
	}
	// Decode path: actionId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "actionId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ActionId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "actionId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: spaceId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "spaceId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SpaceId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "spaceId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// LegacyUpdateConnectorParams is parameters of legacyUpdateConnector operation.
type LegacyUpdateConnectorParams struct {
	// Cross-site request forgery protection.
	KbnXSRF string
	// An identifier for the action.
	ActionId string
	// An identifier for the space. If `/s/` and the identifier are omitted from the path, the default
	// space is used.
	SpaceId string
}

func unpackLegacyUpdateConnectorParams(packed middleware.Parameters) (params LegacyUpdateConnectorParams) {
	{
		key := middleware.ParameterKey{
			Name: "kbn-xsrf",
			In:   "header",
		}
		params.KbnXSRF = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "actionId",
			In:   "path",
		}
		params.ActionId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "spaceId",
			In:   "path",
		}
		params.SpaceId = packed[key].(string)
	}
	return params
}

func decodeLegacyUpdateConnectorParams(args [2]string, argsEscaped bool, r *http.Request) (params LegacyUpdateConnectorParams, _ error) {
	h := uri.NewHeaderDecoder(r.Header)
	// Decode header: kbn-xsrf.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "kbn-xsrf",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.KbnXSRF = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "kbn-xsrf",
			In:   "header",
			Err:  err,
		}
	}
	// Decode path: actionId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "actionId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ActionId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "actionId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: spaceId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "spaceId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SpaceId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "spaceId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}

// UpdateConnectorParams is parameters of updateConnector operation.
type UpdateConnectorParams struct {
	// Cross-site request forgery protection.
	KbnXSRF string
	// An identifier for the connector.
	ConnectorId string
	// An identifier for the space. If `/s/` and the identifier are omitted from the path, the default
	// space is used.
	SpaceId string
}

func unpackUpdateConnectorParams(packed middleware.Parameters) (params UpdateConnectorParams) {
	{
		key := middleware.ParameterKey{
			Name: "kbn-xsrf",
			In:   "header",
		}
		params.KbnXSRF = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "connectorId",
			In:   "path",
		}
		params.ConnectorId = packed[key].(string)
	}
	{
		key := middleware.ParameterKey{
			Name: "spaceId",
			In:   "path",
		}
		params.SpaceId = packed[key].(string)
	}
	return params
}

func decodeUpdateConnectorParams(args [2]string, argsEscaped bool, r *http.Request) (params UpdateConnectorParams, _ error) {
	h := uri.NewHeaderDecoder(r.Header)
	// Decode header: kbn-xsrf.
	if err := func() error {
		cfg := uri.HeaderParameterDecodingConfig{
			Name:    "kbn-xsrf",
			Explode: false,
		}
		if err := h.HasParam(cfg); err == nil {
			if err := h.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.KbnXSRF = c
				return nil
			}); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "kbn-xsrf",
			In:   "header",
			Err:  err,
		}
	}
	// Decode path: connectorId.
	if err := func() error {
		param := args[1]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[1])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "connectorId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ConnectorId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "connectorId",
			In:   "path",
			Err:  err,
		}
	}
	// Decode path: spaceId.
	if err := func() error {
		param := args[0]
		if argsEscaped {
			unescaped, err := url.PathUnescape(args[0])
			if err != nil {
				return errors.Wrap(err, "unescape path")
			}
			param = unescaped
		}
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "spaceId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.SpaceId = c
				return nil
			}(); err != nil {
				return err
			}
		} else {
			return validate.ErrFieldRequired
		}
		return nil
	}(); err != nil {
		return params, &ogenerrors.DecodeParamError{
			Name: "spaceId",
			In:   "path",
			Err:  err,
		}
	}
	return params, nil
}
