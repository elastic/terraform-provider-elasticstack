// Package connectors provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package connectors

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyAuthScopes = "apiKeyAuth.Scopes"
	BasicAuthScopes  = "basicAuth.Scopes"
)

// Defines values for AuthorizationErrorError.
const (
	Unauthorized AuthorizationErrorError = "Unauthorized"
)

// Defines values for AuthorizationErrorStatusCode.
const (
	N401 AuthorizationErrorStatusCode = 401
)

// Defines values for BadRequestErrorError.
const (
	BadRequest BadRequestErrorError = "Bad Request"
)

// Defines values for BadRequestErrorStatusCode.
const (
	N400 BadRequestErrorStatusCode = 400
)

// Defines values for ConfigPropertiesCasesWebhookCreateCommentMethod.
const (
	ConfigPropertiesCasesWebhookCreateCommentMethodPatch ConfigPropertiesCasesWebhookCreateCommentMethod = "patch"
	ConfigPropertiesCasesWebhookCreateCommentMethodPost  ConfigPropertiesCasesWebhookCreateCommentMethod = "post"
	ConfigPropertiesCasesWebhookCreateCommentMethodPut   ConfigPropertiesCasesWebhookCreateCommentMethod = "put"
)

// Defines values for ConfigPropertiesCasesWebhookCreateIncidentMethod.
const (
	ConfigPropertiesCasesWebhookCreateIncidentMethodPatch ConfigPropertiesCasesWebhookCreateIncidentMethod = "patch"
	ConfigPropertiesCasesWebhookCreateIncidentMethodPost  ConfigPropertiesCasesWebhookCreateIncidentMethod = "post"
	ConfigPropertiesCasesWebhookCreateIncidentMethodPut   ConfigPropertiesCasesWebhookCreateIncidentMethod = "put"
)

// Defines values for ConfigPropertiesCasesWebhookUpdateIncidentMethod.
const (
	ConfigPropertiesCasesWebhookUpdateIncidentMethodPatch ConfigPropertiesCasesWebhookUpdateIncidentMethod = "patch"
	ConfigPropertiesCasesWebhookUpdateIncidentMethodPost  ConfigPropertiesCasesWebhookUpdateIncidentMethod = "post"
	ConfigPropertiesCasesWebhookUpdateIncidentMethodPut   ConfigPropertiesCasesWebhookUpdateIncidentMethod = "put"
)

// Defines values for ConfigPropertiesSwimlaneConnectorType.
const (
	ConfigPropertiesSwimlaneConnectorTypeAlerts ConfigPropertiesSwimlaneConnectorType = "alerts"
	ConfigPropertiesSwimlaneConnectorTypeAll    ConfigPropertiesSwimlaneConnectorType = "all"
	ConfigPropertiesSwimlaneConnectorTypeCases  ConfigPropertiesSwimlaneConnectorType = "cases"
)

// Defines values for ConfigPropertiesWebhookMethod.
const (
	ConfigPropertiesWebhookMethodPatch ConfigPropertiesWebhookMethod = "patch"
	ConfigPropertiesWebhookMethodPost  ConfigPropertiesWebhookMethod = "post"
	ConfigPropertiesWebhookMethodPut   ConfigPropertiesWebhookMethod = "put"
)

// Defines values for ConnectorResponsePropertiesCasesWebhookConnectorTypeId.
const (
	ConnectorResponsePropertiesCasesWebhookConnectorTypeIdDotCasesWebhook ConnectorResponsePropertiesCasesWebhookConnectorTypeId = ".cases-webhook"
)

// Defines values for ConnectorResponsePropertiesEmailConnectorTypeId.
const (
	ConnectorResponsePropertiesEmailConnectorTypeIdDotEmail ConnectorResponsePropertiesEmailConnectorTypeId = ".email"
)

// Defines values for ConnectorResponsePropertiesGeminiConnectorTypeId.
const (
	ConnectorResponsePropertiesGeminiConnectorTypeIdDotGemini ConnectorResponsePropertiesGeminiConnectorTypeId = ".gemini"
)

// Defines values for ConnectorResponsePropertiesIndexConnectorTypeId.
const (
	ConnectorResponsePropertiesIndexConnectorTypeIdDotIndex ConnectorResponsePropertiesIndexConnectorTypeId = ".index"
)

// Defines values for ConnectorResponsePropertiesJiraConnectorTypeId.
const (
	ConnectorResponsePropertiesJiraConnectorTypeIdDotJira ConnectorResponsePropertiesJiraConnectorTypeId = ".jira"
)

// Defines values for ConnectorResponsePropertiesOpsgenieConnectorTypeId.
const (
	ConnectorResponsePropertiesOpsgenieConnectorTypeIdDotOpsgenie ConnectorResponsePropertiesOpsgenieConnectorTypeId = ".opsgenie"
)

// Defines values for ConnectorResponsePropertiesPagerdutyConnectorTypeId.
const (
	ConnectorResponsePropertiesPagerdutyConnectorTypeIdDotPagerduty ConnectorResponsePropertiesPagerdutyConnectorTypeId = ".pagerduty"
)

// Defines values for ConnectorResponsePropertiesResilientConnectorTypeId.
const (
	ConnectorResponsePropertiesResilientConnectorTypeIdDotResilient ConnectorResponsePropertiesResilientConnectorTypeId = ".resilient"
)

// Defines values for ConnectorResponsePropertiesServerlogConnectorTypeId.
const (
	ConnectorResponsePropertiesServerlogConnectorTypeIdDotServerLog ConnectorResponsePropertiesServerlogConnectorTypeId = ".server-log"
)

// Defines values for ConnectorResponsePropertiesServicenowConnectorTypeId.
const (
	ConnectorResponsePropertiesServicenowConnectorTypeIdDotServicenow ConnectorResponsePropertiesServicenowConnectorTypeId = ".servicenow"
)

// Defines values for ConnectorResponsePropertiesServicenowItomConnectorTypeId.
const (
	ConnectorResponsePropertiesServicenowItomConnectorTypeIdDotServicenowItom ConnectorResponsePropertiesServicenowItomConnectorTypeId = ".servicenow-itom"
)

// Defines values for ConnectorResponsePropertiesServicenowSirConnectorTypeId.
const (
	ConnectorResponsePropertiesServicenowSirConnectorTypeIdDotServicenowSir ConnectorResponsePropertiesServicenowSirConnectorTypeId = ".servicenow-sir"
)

// Defines values for ConnectorResponsePropertiesSlackConnectorTypeId.
const (
	ConnectorResponsePropertiesSlackConnectorTypeIdDotSlack ConnectorResponsePropertiesSlackConnectorTypeId = ".slack"
)

// Defines values for ConnectorResponsePropertiesSlackApiConnectorTypeId.
const (
	ConnectorResponsePropertiesSlackApiConnectorTypeIdDotSlackApi ConnectorResponsePropertiesSlackApiConnectorTypeId = ".slack_api"
)

// Defines values for ConnectorResponsePropertiesSwimlaneConnectorTypeId.
const (
	ConnectorResponsePropertiesSwimlaneConnectorTypeIdDotSwimlane ConnectorResponsePropertiesSwimlaneConnectorTypeId = ".swimlane"
)

// Defines values for ConnectorResponsePropertiesTeamsConnectorTypeId.
const (
	ConnectorResponsePropertiesTeamsConnectorTypeIdDotTeams ConnectorResponsePropertiesTeamsConnectorTypeId = ".teams"
)

// Defines values for ConnectorResponsePropertiesTinesConnectorTypeId.
const (
	ConnectorResponsePropertiesTinesConnectorTypeIdDotTines ConnectorResponsePropertiesTinesConnectorTypeId = ".tines"
)

// Defines values for ConnectorResponsePropertiesWebhookConnectorTypeId.
const (
	ConnectorResponsePropertiesWebhookConnectorTypeIdDotWebhook ConnectorResponsePropertiesWebhookConnectorTypeId = ".webhook"
)

// Defines values for ConnectorResponsePropertiesXmattersConnectorTypeId.
const (
	ConnectorResponsePropertiesXmattersConnectorTypeIdDotXmatters ConnectorResponsePropertiesXmattersConnectorTypeId = ".xmatters"
)

// Defines values for ConnectorTypes.
const (
	ConnectorTypesDotCasesWebhook   ConnectorTypes = ".cases-webhook"
	ConnectorTypesDotEmail          ConnectorTypes = ".email"
	ConnectorTypesDotGemini         ConnectorTypes = ".gemini"
	ConnectorTypesDotIndex          ConnectorTypes = ".index"
	ConnectorTypesDotJira           ConnectorTypes = ".jira"
	ConnectorTypesDotOpsgenie       ConnectorTypes = ".opsgenie"
	ConnectorTypesDotPagerduty      ConnectorTypes = ".pagerduty"
	ConnectorTypesDotResilient      ConnectorTypes = ".resilient"
	ConnectorTypesDotServerLog      ConnectorTypes = ".server-log"
	ConnectorTypesDotServicenow     ConnectorTypes = ".servicenow"
	ConnectorTypesDotServicenowItom ConnectorTypes = ".servicenow-itom"
	ConnectorTypesDotServicenowSir  ConnectorTypes = ".servicenow-sir"
	ConnectorTypesDotSlack          ConnectorTypes = ".slack"
	ConnectorTypesDotSlackApi       ConnectorTypes = ".slack_api"
	ConnectorTypesDotSwimlane       ConnectorTypes = ".swimlane"
	ConnectorTypesDotTeams          ConnectorTypes = ".teams"
	ConnectorTypesDotTines          ConnectorTypes = ".tines"
	ConnectorTypesDotWebhook        ConnectorTypes = ".webhook"
	ConnectorTypesDotXmatters       ConnectorTypes = ".xmatters"
)

// Defines values for CreateConnectorRequestCasesWebhookConnectorTypeId.
const (
	DotCasesWebhook CreateConnectorRequestCasesWebhookConnectorTypeId = ".cases-webhook"
)

// Defines values for CreateConnectorRequestEmailConnectorTypeId.
const (
	CreateConnectorRequestEmailConnectorTypeIdDotEmail CreateConnectorRequestEmailConnectorTypeId = ".email"
)

// Defines values for CreateConnectorRequestGeminiConnectorTypeId.
const (
	CreateConnectorRequestGeminiConnectorTypeIdDotGemini CreateConnectorRequestGeminiConnectorTypeId = ".gemini"
)

// Defines values for CreateConnectorRequestIndexConnectorTypeId.
const (
	CreateConnectorRequestIndexConnectorTypeIdDotIndex CreateConnectorRequestIndexConnectorTypeId = ".index"
)

// Defines values for CreateConnectorRequestJiraConnectorTypeId.
const (
	CreateConnectorRequestJiraConnectorTypeIdDotJira CreateConnectorRequestJiraConnectorTypeId = ".jira"
)

// Defines values for CreateConnectorRequestOpsgenieConnectorTypeId.
const (
	CreateConnectorRequestOpsgenieConnectorTypeIdDotOpsgenie CreateConnectorRequestOpsgenieConnectorTypeId = ".opsgenie"
)

// Defines values for CreateConnectorRequestPagerdutyConnectorTypeId.
const (
	CreateConnectorRequestPagerdutyConnectorTypeIdDotPagerduty CreateConnectorRequestPagerdutyConnectorTypeId = ".pagerduty"
)

// Defines values for CreateConnectorRequestResilientConnectorTypeId.
const (
	CreateConnectorRequestResilientConnectorTypeIdDotResilient CreateConnectorRequestResilientConnectorTypeId = ".resilient"
)

// Defines values for CreateConnectorRequestServerlogConnectorTypeId.
const (
	CreateConnectorRequestServerlogConnectorTypeIdDotServerLog CreateConnectorRequestServerlogConnectorTypeId = ".server-log"
)

// Defines values for CreateConnectorRequestServicenowConnectorTypeId.
const (
	CreateConnectorRequestServicenowConnectorTypeIdDotServicenow CreateConnectorRequestServicenowConnectorTypeId = ".servicenow"
)

// Defines values for CreateConnectorRequestServicenowItomConnectorTypeId.
const (
	CreateConnectorRequestServicenowItomConnectorTypeIdDotServicenowItom CreateConnectorRequestServicenowItomConnectorTypeId = ".servicenow-itom"
)

// Defines values for CreateConnectorRequestServicenowSirConnectorTypeId.
const (
	CreateConnectorRequestServicenowSirConnectorTypeIdDotServicenowSir CreateConnectorRequestServicenowSirConnectorTypeId = ".servicenow-sir"
)

// Defines values for CreateConnectorRequestSlackConnectorTypeId.
const (
	CreateConnectorRequestSlackConnectorTypeIdDotSlack CreateConnectorRequestSlackConnectorTypeId = ".slack"
)

// Defines values for CreateConnectorRequestSlackApiConnectorTypeId.
const (
	CreateConnectorRequestSlackApiConnectorTypeIdDotSlackApi CreateConnectorRequestSlackApiConnectorTypeId = ".slack_api"
)

// Defines values for CreateConnectorRequestSwimlaneConnectorTypeId.
const (
	CreateConnectorRequestSwimlaneConnectorTypeIdDotSwimlane CreateConnectorRequestSwimlaneConnectorTypeId = ".swimlane"
)

// Defines values for CreateConnectorRequestTeamsConnectorTypeId.
const (
	CreateConnectorRequestTeamsConnectorTypeIdDotTeams CreateConnectorRequestTeamsConnectorTypeId = ".teams"
)

// Defines values for CreateConnectorRequestTinesConnectorTypeId.
const (
	CreateConnectorRequestTinesConnectorTypeIdDotTines CreateConnectorRequestTinesConnectorTypeId = ".tines"
)

// Defines values for CreateConnectorRequestWebhookConnectorTypeId.
const (
	CreateConnectorRequestWebhookConnectorTypeIdDotWebhook CreateConnectorRequestWebhookConnectorTypeId = ".webhook"
)

// Defines values for CreateConnectorRequestXmattersConnectorTypeId.
const (
	CreateConnectorRequestXmattersConnectorTypeIdDotXmatters CreateConnectorRequestXmattersConnectorTypeId = ".xmatters"
)

// Defines values for Features.
const (
	FeaturesAlerting Features = "alerting"
	FeaturesCases    Features = "cases"
	FeaturesSiem     Features = "siem"
	FeaturesUptime   Features = "uptime"
)

// Defines values for ObjectNotFoundErrorError.
const (
	NotFound ObjectNotFoundErrorError = "Not Found"
)

// Defines values for ObjectNotFoundErrorStatusCode.
const (
	N404 ObjectNotFoundErrorStatusCode = 404
)

// Defines values for RunConnectorGeneralResponseStatus.
const (
	RunConnectorGeneralResponseStatusError RunConnectorGeneralResponseStatus = "error"
	RunConnectorGeneralResponseStatusOk    RunConnectorGeneralResponseStatus = "ok"
)

// Defines values for RunConnectorParamsLevelMessageLevel.
const (
	RunConnectorParamsLevelMessageLevelDebug RunConnectorParamsLevelMessageLevel = "debug"
	RunConnectorParamsLevelMessageLevelError RunConnectorParamsLevelMessageLevel = "error"
	RunConnectorParamsLevelMessageLevelFatal RunConnectorParamsLevelMessageLevel = "fatal"
	RunConnectorParamsLevelMessageLevelInfo  RunConnectorParamsLevelMessageLevel = "info"
	RunConnectorParamsLevelMessageLevelTrace RunConnectorParamsLevelMessageLevel = "trace"
	RunConnectorParamsLevelMessageLevelWarn  RunConnectorParamsLevelMessageLevel = "warn"
)

// Defines values for RunConnectorSubactionAddeventSubAction.
const (
	AddEvent RunConnectorSubactionAddeventSubAction = "addEvent"
)

// Defines values for RunConnectorSubactionClosealertSubAction.
const (
	CloseAlert RunConnectorSubactionClosealertSubAction = "closeAlert"
)

// Defines values for RunConnectorSubactionCreatealertSubAction.
const (
	CreateAlert RunConnectorSubactionCreatealertSubAction = "createAlert"
)

// Defines values for RunConnectorSubactionCreatealertSubActionParamsPriority.
const (
	P1 RunConnectorSubactionCreatealertSubActionParamsPriority = "P1"
	P2 RunConnectorSubactionCreatealertSubActionParamsPriority = "P2"
	P3 RunConnectorSubactionCreatealertSubActionParamsPriority = "P3"
	P4 RunConnectorSubactionCreatealertSubActionParamsPriority = "P4"
	P5 RunConnectorSubactionCreatealertSubActionParamsPriority = "P5"
)

// Defines values for RunConnectorSubactionCreatealertSubActionParamsRespondersType.
const (
	RunConnectorSubactionCreatealertSubActionParamsRespondersTypeEscalation RunConnectorSubactionCreatealertSubActionParamsRespondersType = "escalation"
	RunConnectorSubactionCreatealertSubActionParamsRespondersTypeSchedule   RunConnectorSubactionCreatealertSubActionParamsRespondersType = "schedule"
	RunConnectorSubactionCreatealertSubActionParamsRespondersTypeTeam       RunConnectorSubactionCreatealertSubActionParamsRespondersType = "team"
	RunConnectorSubactionCreatealertSubActionParamsRespondersTypeUser       RunConnectorSubactionCreatealertSubActionParamsRespondersType = "user"
)

// Defines values for RunConnectorSubactionCreatealertSubActionParamsVisibleToType.
const (
	RunConnectorSubactionCreatealertSubActionParamsVisibleToTypeTeam RunConnectorSubactionCreatealertSubActionParamsVisibleToType = "team"
	RunConnectorSubactionCreatealertSubActionParamsVisibleToTypeUser RunConnectorSubactionCreatealertSubActionParamsVisibleToType = "user"
)

// Defines values for RunConnectorSubactionFieldsbyissuetypeSubAction.
const (
	FieldsByIssueType RunConnectorSubactionFieldsbyissuetypeSubAction = "fieldsByIssueType"
)

// Defines values for RunConnectorSubactionGetchoicesSubAction.
const (
	GetChoices RunConnectorSubactionGetchoicesSubAction = "getChoices"
)

// Defines values for RunConnectorSubactionGetfieldsSubAction.
const (
	GetFields RunConnectorSubactionGetfieldsSubAction = "getFields"
)

// Defines values for RunConnectorSubactionGetincidentSubAction.
const (
	GetIncident RunConnectorSubactionGetincidentSubAction = "getIncident"
)

// Defines values for RunConnectorSubactionIssueSubAction.
const (
	Issue RunConnectorSubactionIssueSubAction = "issue"
)

// Defines values for RunConnectorSubactionIssuesSubAction.
const (
	Issues RunConnectorSubactionIssuesSubAction = "issues"
)

// Defines values for RunConnectorSubactionIssuetypesSubAction.
const (
	IssueTypes RunConnectorSubactionIssuetypesSubAction = "issueTypes"
)

// Defines values for RunConnectorSubactionPushtoserviceSubAction.
const (
	PushToService RunConnectorSubactionPushtoserviceSubAction = "pushToService"
)

// ActionResponseProperties The properties vary depending on the action type.
type ActionResponseProperties struct {
	ActionTypeId *string                 `json:"actionTypeId,omitempty"`
	Config       *map[string]interface{} `json:"config,omitempty"`
	Id           *string                 `json:"id,omitempty"`

	// IsDeprecated Indicates whether the action type is deprecated.
	IsDeprecated *bool `json:"isDeprecated,omitempty"`

	// IsMissingSecrets Indicates whether secrets are missing for the action.
	IsMissingSecrets *bool `json:"isMissingSecrets,omitempty"`

	// IsPreconfigured Indicates whether it is a preconfigured action.
	IsPreconfigured *bool   `json:"isPreconfigured,omitempty"`
	Name            *string `json:"name,omitempty"`
}

// AuthorizationError defines model for authorization_error.
type AuthorizationError struct {
	Error      *AuthorizationErrorError      `json:"error,omitempty"`
	Message    *string                       `json:"message,omitempty"`
	StatusCode *AuthorizationErrorStatusCode `json:"statusCode,omitempty"`
}

// AuthorizationErrorError defines model for AuthorizationError.Error.
type AuthorizationErrorError string

// AuthorizationErrorStatusCode defines model for AuthorizationError.StatusCode.
type AuthorizationErrorStatusCode int

// BadRequestError defines model for bad_request_error.
type BadRequestError struct {
	Error      *BadRequestErrorError      `json:"error,omitempty"`
	Message    *string                    `json:"message,omitempty"`
	StatusCode *BadRequestErrorStatusCode `json:"statusCode,omitempty"`
}

// BadRequestErrorError defines model for BadRequestError.Error.
type BadRequestErrorError string

// BadRequestErrorStatusCode defines model for BadRequestError.StatusCode.
type BadRequestErrorStatusCode int

// ConfigPropertiesCasesWebhook Defines properties for connectors when type is `.cases-webhook`.
type ConfigPropertiesCasesWebhook struct {
	// CreateCommentJson A JSON payload sent to the create comment URL to create a case comment. You can use variables to add Kibana Cases data to the payload. The required variable is `case.comment`. Due to Mustache template variables (the text enclosed in triple braces, for example, `{{{case.title}}}`), the JSON is not validated when you create the connector. The JSON is validated once the Mustache variables have been placed when the REST method runs. Manually ensure that the JSON is valid, disregarding the Mustache variables, so the later validation will pass.
	CreateCommentJson *string `json:"createCommentJson,omitempty"`

	// CreateCommentMethod The REST API HTTP request method to create a case comment in the third-party system. Valid values are `patch`, `post`, and `put`.
	CreateCommentMethod *ConfigPropertiesCasesWebhookCreateCommentMethod `json:"createCommentMethod,omitempty"`

	// CreateCommentUrl The REST API URL to create a case comment by ID in the third-party system. You can use a variable to add the external system ID to the URL. If you are using the `xpack.actions.allowedHosts setting`, add the hostname to the allowed hosts.
	CreateCommentUrl *string `json:"createCommentUrl,omitempty"`

	// CreateIncidentJson A JSON payload sent to the create case URL to create a case. You can use variables to add case data to the payload. Required variables are `case.title` and `case.description`. Due to Mustache template variables (which is the text enclosed in triple braces, for example, `{{{case.title}}}`), the JSON is not validated when you create the connector. The JSON is validated after the Mustache variables have been placed when REST method runs. Manually ensure that the JSON is valid to avoid future validation errors; disregard Mustache variables during your review.
	CreateIncidentJson string `json:"createIncidentJson"`

	// CreateIncidentMethod The REST API HTTP request method to create a case in the third-party system. Valid values are `patch`, `post`, and `put`.
	CreateIncidentMethod *ConfigPropertiesCasesWebhookCreateIncidentMethod `json:"createIncidentMethod,omitempty"`

	// CreateIncidentResponseKey The JSON key in the create case response that contains the external case ID.
	CreateIncidentResponseKey string `json:"createIncidentResponseKey"`

	// CreateIncidentUrl The REST API URL to create a case in the third-party system. If you are using the `xpack.actions.allowedHosts` setting, add the hostname to the allowed hosts.
	CreateIncidentUrl string `json:"createIncidentUrl"`

	// GetIncidentResponseExternalTitleKey The JSON key in get case response that contains the external case title.
	GetIncidentResponseExternalTitleKey string `json:"getIncidentResponseExternalTitleKey"`

	// GetIncidentUrl The REST API URL to get the case by ID from the third-party system. If you are using the `xpack.actions.allowedHosts` setting, add the hostname to the allowed hosts. You can use a variable to add the external system ID to the URL. Due to Mustache template variables (the text enclosed in triple braces, for example, `{{{case.title}}}`), the JSON is not validated when you create the connector. The JSON is validated after the Mustache variables have been placed when REST method runs. Manually ensure that the JSON is valid, disregarding the Mustache variables, so the later validation will pass.
	GetIncidentUrl string `json:"getIncidentUrl"`

	// HasAuth If true, a username and password for login type authentication must be provided.
	HasAuth *bool `json:"hasAuth,omitempty"`

	// Headers A set of key-value pairs sent as headers with the request URLs for the create case, update case, get case, and create comment methods.
	Headers *string `json:"headers,omitempty"`

	// UpdateIncidentJson The JSON payload sent to the update case URL to update the case. You can use variables to add Kibana Cases data to the payload. Required variables are `case.title` and `case.description`. Due to Mustache template variables (which is the text enclosed in triple braces, for example, `{{{case.title}}}`), the JSON is not validated when you create the connector. The JSON is validated after the Mustache variables have been placed when REST method runs. Manually ensure that the JSON is valid to avoid future validation errors; disregard Mustache variables during your review.
	UpdateIncidentJson string `json:"updateIncidentJson"`

	// UpdateIncidentMethod The REST API HTTP request method to update the case in the third-party system. Valid values are `patch`, `post`, and `put`.
	UpdateIncidentMethod *ConfigPropertiesCasesWebhookUpdateIncidentMethod `json:"updateIncidentMethod,omitempty"`

	// UpdateIncidentUrl The REST API URL to update the case by ID in the third-party system. You can use a variable to add the external system ID to the URL. If you are using the `xpack.actions.allowedHosts` setting, add the hostname to the allowed hosts.
	UpdateIncidentUrl string `json:"updateIncidentUrl"`

	// ViewIncidentUrl The URL to view the case in the external system. You can use variables to add the external system ID or external system title to the URL.
	ViewIncidentUrl string `json:"viewIncidentUrl"`
}

// ConfigPropertiesCasesWebhookCreateCommentMethod The REST API HTTP request method to create a case comment in the third-party system. Valid values are `patch`, `post`, and `put`.
type ConfigPropertiesCasesWebhookCreateCommentMethod string

// ConfigPropertiesCasesWebhookCreateIncidentMethod The REST API HTTP request method to create a case in the third-party system. Valid values are `patch`, `post`, and `put`.
type ConfigPropertiesCasesWebhookCreateIncidentMethod string

// ConfigPropertiesCasesWebhookUpdateIncidentMethod The REST API HTTP request method to update the case in the third-party system. Valid values are `patch`, `post`, and `put`.
type ConfigPropertiesCasesWebhookUpdateIncidentMethod string

// ConfigPropertiesEmail Defines properties for connectors when type is `.email`.
type ConfigPropertiesEmail struct {
	ClientId      *string `json:"clientId"`
	From          *string `json:"from,omitempty"`
	HasAuth       *bool   `json:"hasAuth,omitempty"`
	Host          *string `json:"host,omitempty"`
	OauthTokenUrl *string `json:"oauthTokenUrl"`
	Port          *int    `json:"port,omitempty"`
	Secure        *bool   `json:"secure"`
	Service       *string `json:"service,omitempty"`
	TenantId      *string `json:"tenantId"`
}

// ConfigPropertiesGemini Defines properties for connectors when type is `.gemini`.
type ConfigPropertiesGemini struct {
	// ApiUrl The Google Gemini request URL.
	ApiUrl string `json:"apiUrl"`

	// DefaultModel The generative artificial intelligence model for Google Gemini to use.
	DefaultModel *string `json:"defaultModel,omitempty"`

	// GcpProjectID The Google ProjectID that has Vertex AI endpoint enabled.
	GcpProjectID string `json:"gcpProjectID"`

	// GcpRegion The GCP region where the Vertex AI endpoint enabled.
	GcpRegion string `json:"gcpRegion"`
}

// ConfigPropertiesIndex Defines properties for connectors when type is `.index`.
type ConfigPropertiesIndex struct {
	// ExecutionTimeField Specifies a field that will contain the time the alert condition was detected.
	ExecutionTimeField *string `json:"executionTimeField"`

	// Index The Elasticsearch index to be written to.
	Index string `json:"index"`

	// Refresh The refresh policy for the write request, which affects when changes are made visible to search. Refer to the refresh setting for Elasticsearch document APIs.
	Refresh *bool `json:"refresh,omitempty"`
}

// ConfigPropertiesJira Defines properties for connectors when type is `.jira`.
type ConfigPropertiesJira struct {
	// ApiUrl The Jira instance URL.
	ApiUrl string `json:"apiUrl"`

	// ProjectKey The Jira project key.
	ProjectKey string `json:"projectKey"`
}

// ConfigPropertiesOpsgenie Defines properties for connectors when type is `.opsgenie`.
type ConfigPropertiesOpsgenie struct {
	// ApiUrl The Opsgenie URL. For example, `https://api.opsgenie.com` or `https://api.eu.opsgenie.com`. If you are using the `xpack.actions.allowedHosts` setting, add the hostname to the allowed hosts.
	ApiUrl string `json:"apiUrl"`
}

// ConfigPropertiesPagerduty Defines properties for connectors when type is `.pagerduty`.
type ConfigPropertiesPagerduty struct {
	ApiUrl *string `json:"apiUrl"`
}

// ConfigPropertiesResilient Defines properties for connectors when type is `.resilient`.
type ConfigPropertiesResilient struct {
	// ApiUrl The IBM Resilient instance URL.
	ApiUrl string `json:"apiUrl"`

	// OrgId The IBM Resilient organization ID.
	OrgId string `json:"orgId"`
}

// ConfigPropertiesServicenow Defines properties for connectors when type is `.servicenow`.
type ConfigPropertiesServicenow struct {
	// ApiUrl The ServiceNow instance URL.
	ApiUrl string `json:"apiUrl"`

	// ClientId The client ID assigned to your OAuth application. This property is required when `isOAuth` is `true`.
	ClientId *string `json:"clientId,omitempty"`

	// IsOAuth The type of authentication to use. The default value is false, which means basic authentication is used instead of open authorization (OAuth).
	IsOAuth *bool `json:"isOAuth,omitempty"`

	// JwtKeyId The key identifier assigned to the JWT verifier map of your OAuth application. This property is required when `isOAuth` is `true`.
	JwtKeyId *string `json:"jwtKeyId,omitempty"`

	// UserIdentifierValue The identifier to use for OAuth authentication. This identifier should be the user field you selected when you created an OAuth JWT API endpoint for external clients in your ServiceNow instance. For example, if the selected user field is `Email`, the user identifier should be the user's email address. This property is required when `isOAuth` is `true`.
	UserIdentifierValue *string `json:"userIdentifierValue,omitempty"`

	// UsesTableApi Determines whether the connector uses the Table API or the Import Set API. This property is supported only for ServiceNow ITSM and ServiceNow SecOps connectors.  NOTE: If this property is set to `false`, the Elastic application should be installed in ServiceNow.
	UsesTableApi *bool `json:"usesTableApi,omitempty"`
}

// ConfigPropertiesServicenowItom Defines properties for connectors when type is `.servicenow`.
type ConfigPropertiesServicenowItom struct {
	// ApiUrl The ServiceNow instance URL.
	ApiUrl string `json:"apiUrl"`

	// ClientId The client ID assigned to your OAuth application. This property is required when `isOAuth` is `true`.
	ClientId *string `json:"clientId,omitempty"`

	// IsOAuth The type of authentication to use. The default value is false, which means basic authentication is used instead of open authorization (OAuth).
	IsOAuth *bool `json:"isOAuth,omitempty"`

	// JwtKeyId The key identifier assigned to the JWT verifier map of your OAuth application. This property is required when `isOAuth` is `true`.
	JwtKeyId *string `json:"jwtKeyId,omitempty"`

	// UserIdentifierValue The identifier to use for OAuth authentication. This identifier should be the user field you selected when you created an OAuth JWT API endpoint for external clients in your ServiceNow instance. For example, if the selected user field is `Email`, the user identifier should be the user's email address. This property is required when `isOAuth` is `true`.
	UserIdentifierValue *string `json:"userIdentifierValue,omitempty"`
}

// ConfigPropertiesSwimlane Defines properties for connectors when type is `.swimlane`.
type ConfigPropertiesSwimlane struct {
	// ApiUrl The Swimlane instance URL.
	ApiUrl string `json:"apiUrl"`

	// AppId The Swimlane application ID.
	AppId string `json:"appId"`

	// ConnectorType The type of connector. Valid values are `all`, `alerts`, and `cases`.
	ConnectorType ConfigPropertiesSwimlaneConnectorType `json:"connectorType"`

	// Mappings The field mapping.
	Mappings *ConfigPropertiesSwimlaneMappings `json:"mappings,omitempty"`
}

// ConfigPropertiesSwimlaneConnectorType The type of connector. Valid values are `all`, `alerts`, and `cases`.
type ConfigPropertiesSwimlaneConnectorType string

// ConfigPropertiesSwimlaneMappings The field mapping.
type ConfigPropertiesSwimlaneMappings struct {
	// AlertIdConfig Mapping for the alert ID.
	AlertIdConfig *struct {
		// FieldType The type of field in Swimlane.
		FieldType string `json:"fieldType"`

		// Id The identifier for the field in Swimlane.
		Id string `json:"id"`

		// Key The key for the field in Swimlane.
		Key string `json:"key"`

		// Name The name of the field in Swimlane.
		Name string `json:"name"`
	} `json:"alertIdConfig,omitempty"`

	// CaseIdConfig Mapping for the case ID.
	CaseIdConfig *struct {
		// FieldType The type of field in Swimlane.
		FieldType string `json:"fieldType"`

		// Id The identifier for the field in Swimlane.
		Id string `json:"id"`

		// Key The key for the field in Swimlane.
		Key string `json:"key"`

		// Name The name of the field in Swimlane.
		Name string `json:"name"`
	} `json:"caseIdConfig,omitempty"`

	// CaseNameConfig Mapping for the case name.
	CaseNameConfig *struct {
		// FieldType The type of field in Swimlane.
		FieldType string `json:"fieldType"`

		// Id The identifier for the field in Swimlane.
		Id string `json:"id"`

		// Key The key for the field in Swimlane.
		Key string `json:"key"`

		// Name The name of the field in Swimlane.
		Name string `json:"name"`
	} `json:"caseNameConfig,omitempty"`

	// CommentsConfig Mapping for the case comments.
	CommentsConfig *struct {
		// FieldType The type of field in Swimlane.
		FieldType string `json:"fieldType"`

		// Id The identifier for the field in Swimlane.
		Id string `json:"id"`

		// Key The key for the field in Swimlane.
		Key string `json:"key"`

		// Name The name of the field in Swimlane.
		Name string `json:"name"`
	} `json:"commentsConfig,omitempty"`

	// DescriptionConfig Mapping for the case description.
	DescriptionConfig *struct {
		// FieldType The type of field in Swimlane.
		FieldType string `json:"fieldType"`

		// Id The identifier for the field in Swimlane.
		Id string `json:"id"`

		// Key The key for the field in Swimlane.
		Key string `json:"key"`

		// Name The name of the field in Swimlane.
		Name string `json:"name"`
	} `json:"descriptionConfig,omitempty"`

	// RuleNameConfig Mapping for the name of the alert's rule.
	RuleNameConfig *struct {
		// FieldType The type of field in Swimlane.
		FieldType string `json:"fieldType"`

		// Id The identifier for the field in Swimlane.
		Id string `json:"id"`

		// Key The key for the field in Swimlane.
		Key string `json:"key"`

		// Name The name of the field in Swimlane.
		Name string `json:"name"`
	} `json:"ruleNameConfig,omitempty"`

	// SeverityConfig Mapping for the severity.
	SeverityConfig *struct {
		// FieldType The type of field in Swimlane.
		FieldType string `json:"fieldType"`

		// Id The identifier for the field in Swimlane.
		Id string `json:"id"`

		// Key The key for the field in Swimlane.
		Key string `json:"key"`

		// Name The name of the field in Swimlane.
		Name string `json:"name"`
	} `json:"severityConfig,omitempty"`
}

// ConfigPropertiesTines Defines properties for connectors when type is `.tines`.
type ConfigPropertiesTines struct {
	Url string `json:"url"`
}

// ConfigPropertiesWebhook Defines properties for connectors when type is `.webhook`.
type ConfigPropertiesWebhook struct {
	HasAuth *bool                          `json:"hasAuth,omitempty"`
	Headers *map[string]interface{}        `json:"headers,omitempty"`
	Method  *ConfigPropertiesWebhookMethod `json:"method,omitempty"`
	Url     string                         `json:"url"`
}

// ConfigPropertiesWebhookMethod defines model for ConfigPropertiesWebhook.Method.
type ConfigPropertiesWebhookMethod string

// ConfigPropertiesXmatters Defines properties for connectors when type is `.xmatters`.
type ConfigPropertiesXmatters struct {
	ConfigUrl *string `json:"configUrl"`
	UsesBasic *bool   `json:"usesBasic,omitempty"`
}

// ConnectorResponseProperties The properties vary depending on the connector type.
type ConnectorResponseProperties struct {
	union json.RawMessage
}

// ConnectorResponsePropertiesCasesWebhook defines model for connector_response_properties_cases_webhook.
type ConnectorResponsePropertiesCasesWebhook struct {
	// Config Defines properties for connectors when type is `.cases-webhook`.
	Config ConfigPropertiesCasesWebhook `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId ConnectorResponsePropertiesCasesWebhookConnectorTypeId `json:"connector_type_id"`

	// Id The identifier for the connector.
	Id string `json:"id"`

	// IsDeprecated Indicates whether the connector type is deprecated.
	IsDeprecated *IsDeprecated `json:"is_deprecated,omitempty"`

	// IsMissingSecrets Indicates whether secrets are missing for the connector. Secrets configuration properties vary depending on the connector type.
	IsMissingSecrets *IsMissingSecrets `json:"is_missing_secrets,omitempty"`

	// IsPreconfigured Indicates whether it is a preconfigured connector. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
	IsPreconfigured IsPreconfigured `json:"is_preconfigured"`

	// Name The display name for the connector.
	Name string `json:"name"`
}

// ConnectorResponsePropertiesCasesWebhookConnectorTypeId The type of connector.
type ConnectorResponsePropertiesCasesWebhookConnectorTypeId string

// ConnectorResponsePropertiesEmail defines model for connector_response_properties_email.
type ConnectorResponsePropertiesEmail struct {
	// Config Defines properties for connectors when type is `.email`.
	Config ConfigPropertiesEmail `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId ConnectorResponsePropertiesEmailConnectorTypeId `json:"connector_type_id"`

	// Id The identifier for the connector.
	Id string `json:"id"`

	// IsDeprecated Indicates whether the connector type is deprecated.
	IsDeprecated *IsDeprecated `json:"is_deprecated,omitempty"`

	// IsMissingSecrets Indicates whether secrets are missing for the connector. Secrets configuration properties vary depending on the connector type.
	IsMissingSecrets *IsMissingSecrets `json:"is_missing_secrets,omitempty"`

	// IsPreconfigured Indicates whether it is a preconfigured connector. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
	IsPreconfigured IsPreconfigured `json:"is_preconfigured"`

	// Name The display name for the connector.
	Name string `json:"name"`
}

// ConnectorResponsePropertiesEmailConnectorTypeId The type of connector.
type ConnectorResponsePropertiesEmailConnectorTypeId string

// ConnectorResponsePropertiesGemini defines model for connector_response_properties_gemini.
type ConnectorResponsePropertiesGemini struct {
	// Config Defines properties for connectors when type is `.gemini`.
	Config ConfigPropertiesGemini `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId ConnectorResponsePropertiesGeminiConnectorTypeId `json:"connector_type_id"`

	// Id The identifier for the connector.
	Id string `json:"id"`

	// IsDeprecated Indicates whether the connector type is deprecated.
	IsDeprecated *IsDeprecated `json:"is_deprecated,omitempty"`

	// IsMissingSecrets Indicates whether secrets are missing for the connector. Secrets configuration properties vary depending on the connector type.
	IsMissingSecrets *IsMissingSecrets `json:"is_missing_secrets,omitempty"`

	// IsPreconfigured Indicates whether it is a preconfigured connector. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
	IsPreconfigured IsPreconfigured `json:"is_preconfigured"`

	// Name The display name for the connector.
	Name string `json:"name"`
}

// ConnectorResponsePropertiesGeminiConnectorTypeId The type of connector.
type ConnectorResponsePropertiesGeminiConnectorTypeId string

// ConnectorResponsePropertiesIndex defines model for connector_response_properties_index.
type ConnectorResponsePropertiesIndex struct {
	// Config Defines properties for connectors when type is `.index`.
	Config ConfigPropertiesIndex `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId ConnectorResponsePropertiesIndexConnectorTypeId `json:"connector_type_id"`

	// Id The identifier for the connector.
	Id string `json:"id"`

	// IsDeprecated Indicates whether the connector type is deprecated.
	IsDeprecated *IsDeprecated `json:"is_deprecated,omitempty"`

	// IsMissingSecrets Indicates whether secrets are missing for the connector. Secrets configuration properties vary depending on the connector type.
	IsMissingSecrets *IsMissingSecrets `json:"is_missing_secrets,omitempty"`

	// IsPreconfigured Indicates whether it is a preconfigured connector. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
	IsPreconfigured IsPreconfigured `json:"is_preconfigured"`

	// Name The display name for the connector.
	Name string `json:"name"`
}

// ConnectorResponsePropertiesIndexConnectorTypeId The type of connector.
type ConnectorResponsePropertiesIndexConnectorTypeId string

// ConnectorResponsePropertiesJira defines model for connector_response_properties_jira.
type ConnectorResponsePropertiesJira struct {
	// Config Defines properties for connectors when type is `.jira`.
	Config ConfigPropertiesJira `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId ConnectorResponsePropertiesJiraConnectorTypeId `json:"connector_type_id"`

	// Id The identifier for the connector.
	Id string `json:"id"`

	// IsDeprecated Indicates whether the connector type is deprecated.
	IsDeprecated *IsDeprecated `json:"is_deprecated,omitempty"`

	// IsMissingSecrets Indicates whether secrets are missing for the connector. Secrets configuration properties vary depending on the connector type.
	IsMissingSecrets *IsMissingSecrets `json:"is_missing_secrets,omitempty"`

	// IsPreconfigured Indicates whether it is a preconfigured connector. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
	IsPreconfigured IsPreconfigured `json:"is_preconfigured"`

	// Name The display name for the connector.
	Name string `json:"name"`
}

// ConnectorResponsePropertiesJiraConnectorTypeId The type of connector.
type ConnectorResponsePropertiesJiraConnectorTypeId string

// ConnectorResponsePropertiesOpsgenie defines model for connector_response_properties_opsgenie.
type ConnectorResponsePropertiesOpsgenie struct {
	// Config Defines properties for connectors when type is `.opsgenie`.
	Config ConfigPropertiesOpsgenie `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId ConnectorResponsePropertiesOpsgenieConnectorTypeId `json:"connector_type_id"`

	// Id The identifier for the connector.
	Id string `json:"id"`

	// IsDeprecated Indicates whether the connector type is deprecated.
	IsDeprecated *IsDeprecated `json:"is_deprecated,omitempty"`

	// IsMissingSecrets Indicates whether secrets are missing for the connector. Secrets configuration properties vary depending on the connector type.
	IsMissingSecrets *IsMissingSecrets `json:"is_missing_secrets,omitempty"`

	// IsPreconfigured Indicates whether it is a preconfigured connector. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
	IsPreconfigured IsPreconfigured `json:"is_preconfigured"`

	// Name The display name for the connector.
	Name string `json:"name"`
}

// ConnectorResponsePropertiesOpsgenieConnectorTypeId The type of connector.
type ConnectorResponsePropertiesOpsgenieConnectorTypeId string

// ConnectorResponsePropertiesPagerduty defines model for connector_response_properties_pagerduty.
type ConnectorResponsePropertiesPagerduty struct {
	// Config Defines properties for connectors when type is `.pagerduty`.
	Config ConfigPropertiesPagerduty `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId ConnectorResponsePropertiesPagerdutyConnectorTypeId `json:"connector_type_id"`

	// Id The identifier for the connector.
	Id string `json:"id"`

	// IsDeprecated Indicates whether the connector type is deprecated.
	IsDeprecated *IsDeprecated `json:"is_deprecated,omitempty"`

	// IsMissingSecrets Indicates whether secrets are missing for the connector. Secrets configuration properties vary depending on the connector type.
	IsMissingSecrets *IsMissingSecrets `json:"is_missing_secrets,omitempty"`

	// IsPreconfigured Indicates whether it is a preconfigured connector. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
	IsPreconfigured IsPreconfigured `json:"is_preconfigured"`

	// Name The display name for the connector.
	Name string `json:"name"`
}

// ConnectorResponsePropertiesPagerdutyConnectorTypeId The type of connector.
type ConnectorResponsePropertiesPagerdutyConnectorTypeId string

// ConnectorResponsePropertiesResilient defines model for connector_response_properties_resilient.
type ConnectorResponsePropertiesResilient struct {
	// Config Defines properties for connectors when type is `.resilient`.
	Config ConfigPropertiesResilient `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId ConnectorResponsePropertiesResilientConnectorTypeId `json:"connector_type_id"`

	// Id The identifier for the connector.
	Id string `json:"id"`

	// IsDeprecated Indicates whether the connector type is deprecated.
	IsDeprecated *IsDeprecated `json:"is_deprecated,omitempty"`

	// IsMissingSecrets Indicates whether secrets are missing for the connector. Secrets configuration properties vary depending on the connector type.
	IsMissingSecrets *IsMissingSecrets `json:"is_missing_secrets,omitempty"`

	// IsPreconfigured Indicates whether it is a preconfigured connector. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
	IsPreconfigured IsPreconfigured `json:"is_preconfigured"`

	// Name The display name for the connector.
	Name string `json:"name"`
}

// ConnectorResponsePropertiesResilientConnectorTypeId The type of connector.
type ConnectorResponsePropertiesResilientConnectorTypeId string

// ConnectorResponsePropertiesServerlog defines model for connector_response_properties_serverlog.
type ConnectorResponsePropertiesServerlog struct {
	Config *map[string]interface{} `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId ConnectorResponsePropertiesServerlogConnectorTypeId `json:"connector_type_id"`

	// Id The identifier for the connector.
	Id string `json:"id"`

	// IsDeprecated Indicates whether the connector type is deprecated.
	IsDeprecated *IsDeprecated `json:"is_deprecated,omitempty"`

	// IsMissingSecrets Indicates whether secrets are missing for the connector. Secrets configuration properties vary depending on the connector type.
	IsMissingSecrets *IsMissingSecrets `json:"is_missing_secrets,omitempty"`

	// IsPreconfigured Indicates whether it is a preconfigured connector. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
	IsPreconfigured IsPreconfigured `json:"is_preconfigured"`

	// Name The display name for the connector.
	Name string `json:"name"`
}

// ConnectorResponsePropertiesServerlogConnectorTypeId The type of connector.
type ConnectorResponsePropertiesServerlogConnectorTypeId string

// ConnectorResponsePropertiesServicenow defines model for connector_response_properties_servicenow.
type ConnectorResponsePropertiesServicenow struct {
	// Config Defines properties for connectors when type is `.servicenow`.
	Config ConfigPropertiesServicenow `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId ConnectorResponsePropertiesServicenowConnectorTypeId `json:"connector_type_id"`

	// Id The identifier for the connector.
	Id string `json:"id"`

	// IsDeprecated Indicates whether the connector type is deprecated.
	IsDeprecated *IsDeprecated `json:"is_deprecated,omitempty"`

	// IsMissingSecrets Indicates whether secrets are missing for the connector. Secrets configuration properties vary depending on the connector type.
	IsMissingSecrets *IsMissingSecrets `json:"is_missing_secrets,omitempty"`

	// IsPreconfigured Indicates whether it is a preconfigured connector. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
	IsPreconfigured IsPreconfigured `json:"is_preconfigured"`

	// Name The display name for the connector.
	Name string `json:"name"`
}

// ConnectorResponsePropertiesServicenowConnectorTypeId The type of connector.
type ConnectorResponsePropertiesServicenowConnectorTypeId string

// ConnectorResponsePropertiesServicenowItom defines model for connector_response_properties_servicenow_itom.
type ConnectorResponsePropertiesServicenowItom struct {
	// Config Defines properties for connectors when type is `.servicenow`.
	Config ConfigPropertiesServicenowItom `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId ConnectorResponsePropertiesServicenowItomConnectorTypeId `json:"connector_type_id"`

	// Id The identifier for the connector.
	Id string `json:"id"`

	// IsDeprecated Indicates whether the connector type is deprecated.
	IsDeprecated *IsDeprecated `json:"is_deprecated,omitempty"`

	// IsMissingSecrets Indicates whether secrets are missing for the connector. Secrets configuration properties vary depending on the connector type.
	IsMissingSecrets *IsMissingSecrets `json:"is_missing_secrets,omitempty"`

	// IsPreconfigured Indicates whether it is a preconfigured connector. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
	IsPreconfigured IsPreconfigured `json:"is_preconfigured"`

	// Name The display name for the connector.
	Name string `json:"name"`
}

// ConnectorResponsePropertiesServicenowItomConnectorTypeId The type of connector.
type ConnectorResponsePropertiesServicenowItomConnectorTypeId string

// ConnectorResponsePropertiesServicenowSir defines model for connector_response_properties_servicenow_sir.
type ConnectorResponsePropertiesServicenowSir struct {
	// Config Defines properties for connectors when type is `.servicenow`.
	Config ConfigPropertiesServicenow `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId ConnectorResponsePropertiesServicenowSirConnectorTypeId `json:"connector_type_id"`

	// Id The identifier for the connector.
	Id string `json:"id"`

	// IsDeprecated Indicates whether the connector type is deprecated.
	IsDeprecated *IsDeprecated `json:"is_deprecated,omitempty"`

	// IsMissingSecrets Indicates whether secrets are missing for the connector. Secrets configuration properties vary depending on the connector type.
	IsMissingSecrets *IsMissingSecrets `json:"is_missing_secrets,omitempty"`

	// IsPreconfigured Indicates whether it is a preconfigured connector. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
	IsPreconfigured IsPreconfigured `json:"is_preconfigured"`

	// Name The display name for the connector.
	Name string `json:"name"`
}

// ConnectorResponsePropertiesServicenowSirConnectorTypeId The type of connector.
type ConnectorResponsePropertiesServicenowSirConnectorTypeId string

// ConnectorResponsePropertiesSlack defines model for connector_response_properties_slack.
type ConnectorResponsePropertiesSlack struct {
	// ConnectorTypeId The type of connector.
	ConnectorTypeId ConnectorResponsePropertiesSlackConnectorTypeId `json:"connector_type_id"`

	// Id The identifier for the connector.
	Id string `json:"id"`

	// IsDeprecated Indicates whether the connector type is deprecated.
	IsDeprecated *IsDeprecated `json:"is_deprecated,omitempty"`

	// IsMissingSecrets Indicates whether secrets are missing for the connector. Secrets configuration properties vary depending on the connector type.
	IsMissingSecrets *IsMissingSecrets `json:"is_missing_secrets,omitempty"`

	// IsPreconfigured Indicates whether it is a preconfigured connector. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
	IsPreconfigured IsPreconfigured `json:"is_preconfigured"`

	// Name The display name for the connector.
	Name string `json:"name"`
}

// ConnectorResponsePropertiesSlackConnectorTypeId The type of connector.
type ConnectorResponsePropertiesSlackConnectorTypeId string

// ConnectorResponsePropertiesSlackApi defines model for connector_response_properties_slack_api.
type ConnectorResponsePropertiesSlackApi struct {
	// ConnectorTypeId The type of connector.
	ConnectorTypeId ConnectorResponsePropertiesSlackApiConnectorTypeId `json:"connector_type_id"`

	// Id The identifier for the connector.
	Id string `json:"id"`

	// IsDeprecated Indicates whether the connector type is deprecated.
	IsDeprecated *IsDeprecated `json:"is_deprecated,omitempty"`

	// IsMissingSecrets Indicates whether secrets are missing for the connector. Secrets configuration properties vary depending on the connector type.
	IsMissingSecrets *IsMissingSecrets `json:"is_missing_secrets,omitempty"`

	// IsPreconfigured Indicates whether it is a preconfigured connector. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
	IsPreconfigured IsPreconfigured `json:"is_preconfigured"`

	// Name The display name for the connector.
	Name string `json:"name"`
}

// ConnectorResponsePropertiesSlackApiConnectorTypeId The type of connector.
type ConnectorResponsePropertiesSlackApiConnectorTypeId string

// ConnectorResponsePropertiesSwimlane defines model for connector_response_properties_swimlane.
type ConnectorResponsePropertiesSwimlane struct {
	// Config Defines properties for connectors when type is `.swimlane`.
	Config ConfigPropertiesSwimlane `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId ConnectorResponsePropertiesSwimlaneConnectorTypeId `json:"connector_type_id"`

	// Id The identifier for the connector.
	Id string `json:"id"`

	// IsDeprecated Indicates whether the connector type is deprecated.
	IsDeprecated *IsDeprecated `json:"is_deprecated,omitempty"`

	// IsMissingSecrets Indicates whether secrets are missing for the connector. Secrets configuration properties vary depending on the connector type.
	IsMissingSecrets *IsMissingSecrets `json:"is_missing_secrets,omitempty"`

	// IsPreconfigured Indicates whether it is a preconfigured connector. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
	IsPreconfigured IsPreconfigured `json:"is_preconfigured"`

	// Name The display name for the connector.
	Name string `json:"name"`
}

// ConnectorResponsePropertiesSwimlaneConnectorTypeId The type of connector.
type ConnectorResponsePropertiesSwimlaneConnectorTypeId string

// ConnectorResponsePropertiesTeams defines model for connector_response_properties_teams.
type ConnectorResponsePropertiesTeams struct {
	// ConnectorTypeId The type of connector.
	ConnectorTypeId ConnectorResponsePropertiesTeamsConnectorTypeId `json:"connector_type_id"`

	// Id The identifier for the connector.
	Id string `json:"id"`

	// IsDeprecated Indicates whether the connector type is deprecated.
	IsDeprecated *IsDeprecated `json:"is_deprecated,omitempty"`

	// IsMissingSecrets Indicates whether secrets are missing for the connector. Secrets configuration properties vary depending on the connector type.
	IsMissingSecrets *IsMissingSecrets `json:"is_missing_secrets,omitempty"`

	// IsPreconfigured Indicates whether it is a preconfigured connector. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
	IsPreconfigured IsPreconfigured `json:"is_preconfigured"`

	// Name The display name for the connector.
	Name string `json:"name"`
}

// ConnectorResponsePropertiesTeamsConnectorTypeId The type of connector.
type ConnectorResponsePropertiesTeamsConnectorTypeId string

// ConnectorResponsePropertiesTines defines model for connector_response_properties_tines.
type ConnectorResponsePropertiesTines struct {
	// Config Defines properties for connectors when type is `.tines`.
	Config ConfigPropertiesTines `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId ConnectorResponsePropertiesTinesConnectorTypeId `json:"connector_type_id"`

	// Id The identifier for the connector.
	Id string `json:"id"`

	// IsDeprecated Indicates whether the connector type is deprecated.
	IsDeprecated *IsDeprecated `json:"is_deprecated,omitempty"`

	// IsMissingSecrets Indicates whether secrets are missing for the connector. Secrets configuration properties vary depending on the connector type.
	IsMissingSecrets *IsMissingSecrets `json:"is_missing_secrets,omitempty"`

	// IsPreconfigured Indicates whether it is a preconfigured connector. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
	IsPreconfigured IsPreconfigured `json:"is_preconfigured"`

	// Name The display name for the connector.
	Name string `json:"name"`
}

// ConnectorResponsePropertiesTinesConnectorTypeId The type of connector.
type ConnectorResponsePropertiesTinesConnectorTypeId string

// ConnectorResponsePropertiesWebhook defines model for connector_response_properties_webhook.
type ConnectorResponsePropertiesWebhook struct {
	// Config Defines properties for connectors when type is `.webhook`.
	Config ConfigPropertiesWebhook `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId ConnectorResponsePropertiesWebhookConnectorTypeId `json:"connector_type_id"`

	// Id The identifier for the connector.
	Id string `json:"id"`

	// IsDeprecated Indicates whether the connector type is deprecated.
	IsDeprecated *IsDeprecated `json:"is_deprecated,omitempty"`

	// IsMissingSecrets Indicates whether secrets are missing for the connector. Secrets configuration properties vary depending on the connector type.
	IsMissingSecrets *IsMissingSecrets `json:"is_missing_secrets,omitempty"`

	// IsPreconfigured Indicates whether it is a preconfigured connector. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
	IsPreconfigured IsPreconfigured `json:"is_preconfigured"`

	// Name The display name for the connector.
	Name string `json:"name"`
}

// ConnectorResponsePropertiesWebhookConnectorTypeId The type of connector.
type ConnectorResponsePropertiesWebhookConnectorTypeId string

// ConnectorResponsePropertiesXmatters defines model for connector_response_properties_xmatters.
type ConnectorResponsePropertiesXmatters struct {
	// Config Defines properties for connectors when type is `.xmatters`.
	Config ConfigPropertiesXmatters `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId ConnectorResponsePropertiesXmattersConnectorTypeId `json:"connector_type_id"`

	// Id The identifier for the connector.
	Id string `json:"id"`

	// IsDeprecated Indicates whether the connector type is deprecated.
	IsDeprecated *IsDeprecated `json:"is_deprecated,omitempty"`

	// IsMissingSecrets Indicates whether secrets are missing for the connector. Secrets configuration properties vary depending on the connector type.
	IsMissingSecrets *IsMissingSecrets `json:"is_missing_secrets,omitempty"`

	// IsPreconfigured Indicates whether it is a preconfigured connector. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
	IsPreconfigured IsPreconfigured `json:"is_preconfigured"`

	// Name The display name for the connector.
	Name string `json:"name"`
}

// ConnectorResponsePropertiesXmattersConnectorTypeId The type of connector.
type ConnectorResponsePropertiesXmattersConnectorTypeId string

// ConnectorTypes The type of connector. For example, `.email`, `.index`, `.jira`, `.opsgenie`, or `.server-log`.
type ConnectorTypes string

// CreateConnectorRequestCasesWebhook The Webhook - Case Management connector uses axios to send POST, PUT, and GET requests to a case management RESTful API web service.
type CreateConnectorRequestCasesWebhook struct {
	// Config Defines properties for connectors when type is `.cases-webhook`.
	Config ConfigPropertiesCasesWebhook `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId CreateConnectorRequestCasesWebhookConnectorTypeId `json:"connector_type_id"`

	// Name The display name for the connector.
	Name    string                         `json:"name"`
	Secrets *SecretsPropertiesCasesWebhook `json:"secrets,omitempty"`
}

// CreateConnectorRequestCasesWebhookConnectorTypeId The type of connector.
type CreateConnectorRequestCasesWebhookConnectorTypeId string

// CreateConnectorRequestEmail The email connector uses the SMTP protocol to send mail messages, using an integration of Nodemailer. An exception is Microsoft Exchange, which uses HTTP protocol for sending emails, Send mail. Email message text is sent as both plain text and html text.
type CreateConnectorRequestEmail struct {
	// Config Defines properties for connectors when type is `.email`.
	Config ConfigPropertiesEmail `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId CreateConnectorRequestEmailConnectorTypeId `json:"connector_type_id"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.email`.
	Secrets SecretsPropertiesEmail `json:"secrets"`
}

// CreateConnectorRequestEmailConnectorTypeId The type of connector.
type CreateConnectorRequestEmailConnectorTypeId string

// CreateConnectorRequestGemini The Google Gemini connector uses axios to send a POST request to Google Gemini.
type CreateConnectorRequestGemini struct {
	// Config Defines properties for connectors when type is `.gemini`.
	Config ConfigPropertiesGemini `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId CreateConnectorRequestGeminiConnectorTypeId `json:"connector_type_id"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.gemini`.
	Secrets SecretsPropertiesGemini `json:"secrets"`
}

// CreateConnectorRequestGeminiConnectorTypeId The type of connector.
type CreateConnectorRequestGeminiConnectorTypeId string

// CreateConnectorRequestIndex The index connector indexes a document into Elasticsearch.
type CreateConnectorRequestIndex struct {
	// Config Defines properties for connectors when type is `.index`.
	Config ConfigPropertiesIndex `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId CreateConnectorRequestIndexConnectorTypeId `json:"connector_type_id"`

	// Name The display name for the connector.
	Name string `json:"name"`
}

// CreateConnectorRequestIndexConnectorTypeId The type of connector.
type CreateConnectorRequestIndexConnectorTypeId string

// CreateConnectorRequestJira The Jira connector uses the REST API v2 to create Jira issues.
type CreateConnectorRequestJira struct {
	// Config Defines properties for connectors when type is `.jira`.
	Config ConfigPropertiesJira `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId CreateConnectorRequestJiraConnectorTypeId `json:"connector_type_id"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.jira`.
	Secrets SecretsPropertiesJira `json:"secrets"`
}

// CreateConnectorRequestJiraConnectorTypeId The type of connector.
type CreateConnectorRequestJiraConnectorTypeId string

// CreateConnectorRequestOpsgenie The Opsgenie connector uses the Opsgenie alert API.
type CreateConnectorRequestOpsgenie struct {
	// Config Defines properties for connectors when type is `.opsgenie`.
	Config ConfigPropertiesOpsgenie `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId CreateConnectorRequestOpsgenieConnectorTypeId `json:"connector_type_id"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.opsgenie`.
	Secrets SecretsPropertiesOpsgenie `json:"secrets"`
}

// CreateConnectorRequestOpsgenieConnectorTypeId The type of connector.
type CreateConnectorRequestOpsgenieConnectorTypeId string

// CreateConnectorRequestPagerduty The PagerDuty connector uses the v2 Events API to trigger, acknowledge, and resolve PagerDuty alerts.
type CreateConnectorRequestPagerduty struct {
	// Config Defines properties for connectors when type is `.pagerduty`.
	Config ConfigPropertiesPagerduty `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId CreateConnectorRequestPagerdutyConnectorTypeId `json:"connector_type_id"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.pagerduty`.
	Secrets SecretsPropertiesPagerduty `json:"secrets"`
}

// CreateConnectorRequestPagerdutyConnectorTypeId The type of connector.
type CreateConnectorRequestPagerdutyConnectorTypeId string

// CreateConnectorRequestResilient The IBM Resilient connector uses the RESILIENT REST v2 to create IBM Resilient incidents.
type CreateConnectorRequestResilient struct {
	// Config Defines properties for connectors when type is `.resilient`.
	Config ConfigPropertiesResilient `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId CreateConnectorRequestResilientConnectorTypeId `json:"connector_type_id"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.resilient`.
	Secrets SecretsPropertiesResilient `json:"secrets"`
}

// CreateConnectorRequestResilientConnectorTypeId The type of connector.
type CreateConnectorRequestResilientConnectorTypeId string

// CreateConnectorRequestServerlog This connector writes an entry to the Kibana server log.
type CreateConnectorRequestServerlog struct {
	// ConnectorTypeId The type of connector.
	ConnectorTypeId CreateConnectorRequestServerlogConnectorTypeId `json:"connector_type_id"`

	// Name The display name for the connector.
	Name string `json:"name"`
}

// CreateConnectorRequestServerlogConnectorTypeId The type of connector.
type CreateConnectorRequestServerlogConnectorTypeId string

// CreateConnectorRequestServicenow The ServiceNow ITSM connector uses the import set API to create ServiceNow incidents. You can use the connector for rule actions and cases.
type CreateConnectorRequestServicenow struct {
	// Config Defines properties for connectors when type is `.servicenow`.
	Config ConfigPropertiesServicenow `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId CreateConnectorRequestServicenowConnectorTypeId `json:"connector_type_id"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.servicenow`, `.servicenow-sir`, or `.servicenow-itom`.
	Secrets SecretsPropertiesServicenow `json:"secrets"`
}

// CreateConnectorRequestServicenowConnectorTypeId The type of connector.
type CreateConnectorRequestServicenowConnectorTypeId string

// CreateConnectorRequestServicenowItom The ServiceNow ITOM connector uses the event API to create ServiceNow events. You can use the connector for rule actions.
type CreateConnectorRequestServicenowItom struct {
	// Config Defines properties for connectors when type is `.servicenow`.
	Config ConfigPropertiesServicenowItom `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId CreateConnectorRequestServicenowItomConnectorTypeId `json:"connector_type_id"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.servicenow`, `.servicenow-sir`, or `.servicenow-itom`.
	Secrets SecretsPropertiesServicenow `json:"secrets"`
}

// CreateConnectorRequestServicenowItomConnectorTypeId The type of connector.
type CreateConnectorRequestServicenowItomConnectorTypeId string

// CreateConnectorRequestServicenowSir The ServiceNow SecOps connector uses the import set API to create ServiceNow security incidents. You can use the connector for rule actions and cases.
type CreateConnectorRequestServicenowSir struct {
	// Config Defines properties for connectors when type is `.servicenow`.
	Config ConfigPropertiesServicenow `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId CreateConnectorRequestServicenowSirConnectorTypeId `json:"connector_type_id"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.servicenow`, `.servicenow-sir`, or `.servicenow-itom`.
	Secrets SecretsPropertiesServicenow `json:"secrets"`
}

// CreateConnectorRequestServicenowSirConnectorTypeId The type of connector.
type CreateConnectorRequestServicenowSirConnectorTypeId string

// CreateConnectorRequestSlack The Slack connector uses Slack Incoming Webhooks.
type CreateConnectorRequestSlack struct {
	// ConnectorTypeId The type of connector.
	ConnectorTypeId CreateConnectorRequestSlackConnectorTypeId `json:"connector_type_id"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.slack`.
	Secrets SecretsPropertiesSlack `json:"secrets"`
}

// CreateConnectorRequestSlackConnectorTypeId The type of connector.
type CreateConnectorRequestSlackConnectorTypeId string

// CreateConnectorRequestSlackApi The Slack connector uses Slack Incoming Webhooks.
type CreateConnectorRequestSlackApi struct {
	// ConnectorTypeId The type of connector.
	ConnectorTypeId CreateConnectorRequestSlackApiConnectorTypeId `json:"connector_type_id"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.slack`.
	Secrets SecretsPropertiesSlackApi `json:"secrets"`
}

// CreateConnectorRequestSlackApiConnectorTypeId The type of connector.
type CreateConnectorRequestSlackApiConnectorTypeId string

// CreateConnectorRequestSwimlane The Swimlane connector uses the Swimlane REST API to create Swimlane records.
type CreateConnectorRequestSwimlane struct {
	// Config Defines properties for connectors when type is `.swimlane`.
	Config ConfigPropertiesSwimlane `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId CreateConnectorRequestSwimlaneConnectorTypeId `json:"connector_type_id"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.swimlane`.
	Secrets SecretsPropertiesSwimlane `json:"secrets"`
}

// CreateConnectorRequestSwimlaneConnectorTypeId The type of connector.
type CreateConnectorRequestSwimlaneConnectorTypeId string

// CreateConnectorRequestTeams The Microsoft Teams connector uses Incoming Webhooks.
type CreateConnectorRequestTeams struct {
	// ConnectorTypeId The type of connector.
	ConnectorTypeId CreateConnectorRequestTeamsConnectorTypeId `json:"connector_type_id"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.teams`.
	Secrets SecretsPropertiesTeams `json:"secrets"`
}

// CreateConnectorRequestTeamsConnectorTypeId The type of connector.
type CreateConnectorRequestTeamsConnectorTypeId string

// CreateConnectorRequestTines The Tines connector uses Tines Webhook actions to send events via POST request.
type CreateConnectorRequestTines struct {
	// Config Defines properties for connectors when type is `.tines`.
	Config ConfigPropertiesTines `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId CreateConnectorRequestTinesConnectorTypeId `json:"connector_type_id"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.tines`.
	Secrets SecretsPropertiesTines `json:"secrets"`
}

// CreateConnectorRequestTinesConnectorTypeId The type of connector.
type CreateConnectorRequestTinesConnectorTypeId string

// CreateConnectorRequestWebhook The Webhook connector uses axios to send a POST or PUT request to a web service.
type CreateConnectorRequestWebhook struct {
	// Config Defines properties for connectors when type is `.webhook`.
	Config ConfigPropertiesWebhook `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId CreateConnectorRequestWebhookConnectorTypeId `json:"connector_type_id"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.webhook`.
	Secrets SecretsPropertiesWebhook `json:"secrets"`
}

// CreateConnectorRequestWebhookConnectorTypeId The type of connector.
type CreateConnectorRequestWebhookConnectorTypeId string

// CreateConnectorRequestXmatters The xMatters connector uses the xMatters Workflow for Elastic to send actionable alerts to on-call xMatters resources.
type CreateConnectorRequestXmatters struct {
	// Config Defines properties for connectors when type is `.xmatters`.
	Config ConfigPropertiesXmatters `json:"config"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId CreateConnectorRequestXmattersConnectorTypeId `json:"connector_type_id"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.xmatters`.
	Secrets SecretsPropertiesXmatters `json:"secrets"`
}

// CreateConnectorRequestXmattersConnectorTypeId The type of connector.
type CreateConnectorRequestXmattersConnectorTypeId string

// Features The feature that uses the connector. Valid values are `alerting`, `cases`, `uptime`, and `siem`.
type Features string

// IsDeprecated Indicates whether the connector type is deprecated.
type IsDeprecated = bool

// IsMissingSecrets Indicates whether secrets are missing for the connector. Secrets configuration properties vary depending on the connector type.
type IsMissingSecrets = bool

// IsPreconfigured Indicates whether it is a preconfigured connector. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
type IsPreconfigured = bool

// LegacyRunConnectorGeneralResponse defines model for legacy_run_connector_general_response.
type LegacyRunConnectorGeneralResponse struct {
	ActionId *string                                 `json:"actionId,omitempty"`
	Data     *LegacyRunConnectorGeneralResponse_Data `json:"data,omitempty"`

	// Status The status of the action.
	Status *string `json:"status,omitempty"`
}

// LegacyRunConnectorGeneralResponseData0 Information returned from the action.
type LegacyRunConnectorGeneralResponseData0 map[string]interface{}

// LegacyRunConnectorGeneralResponseData1 An array of information returned from the action.
type LegacyRunConnectorGeneralResponseData1 = []map[string]interface{}

// LegacyRunConnectorGeneralResponse_Data defines model for LegacyRunConnectorGeneralResponse.Data.
type LegacyRunConnectorGeneralResponse_Data struct {
	union json.RawMessage
}

// ObjectNotFoundError defines model for object_not_found_error.
type ObjectNotFoundError struct {
	Error      *ObjectNotFoundErrorError      `json:"error,omitempty"`
	Message    *string                        `json:"message,omitempty"`
	StatusCode *ObjectNotFoundErrorStatusCode `json:"statusCode,omitempty"`
}

// ObjectNotFoundErrorError defines model for ObjectNotFoundError.Error.
type ObjectNotFoundErrorError string

// ObjectNotFoundErrorStatusCode defines model for ObjectNotFoundError.StatusCode.
type ObjectNotFoundErrorStatusCode int

// RunConnectorGeneralResponse defines model for run_connector_general_response.
type RunConnectorGeneralResponse struct {
	// ConnectorId The identifier for the connector.
	ConnectorId string                            `json:"connector_id"`
	Data        *RunConnectorGeneralResponse_Data `json:"data,omitempty"`

	// Status The status of the action.
	Status RunConnectorGeneralResponseStatus `json:"status"`
}

// RunConnectorGeneralResponseData0 Information returned from the action.
type RunConnectorGeneralResponseData0 map[string]interface{}

// RunConnectorGeneralResponseData1 An array of information returned from the action.
type RunConnectorGeneralResponseData1 = []map[string]interface{}

// RunConnectorGeneralResponse_Data defines model for RunConnectorGeneralResponse.Data.
type RunConnectorGeneralResponse_Data struct {
	union json.RawMessage
}

// RunConnectorGeneralResponseStatus The status of the action.
type RunConnectorGeneralResponseStatus string

// RunConnectorParamsDocuments Test an action that indexes a document into Elasticsearch.
type RunConnectorParamsDocuments struct {
	// Documents The documents in JSON format for index connectors.
	Documents []map[string]interface{} `json:"documents"`
}

// RunConnectorParamsLevelMessage Test an action that writes an entry to the Kibana server log.
type RunConnectorParamsLevelMessage struct {
	// Level The log level of the message for server log connectors.
	Level *RunConnectorParamsLevelMessageLevel `json:"level,omitempty"`

	// Message The message for server log connectors.
	Message string `json:"message"`
}

// RunConnectorParamsLevelMessageLevel The log level of the message for server log connectors.
type RunConnectorParamsLevelMessageLevel string

// RunConnectorSubactionAddevent The `addEvent` subaction for ServiceNow ITOM connectors.
type RunConnectorSubactionAddevent struct {
	// SubAction The action to test.
	SubAction RunConnectorSubactionAddeventSubAction `json:"subAction"`

	// SubActionParams The set of configuration properties for the action.
	SubActionParams *struct {
		// AdditionalInfo Additional information about the event.
		AdditionalInfo *string `json:"additional_info,omitempty"`

		// Description The details about the event.
		Description *string `json:"description,omitempty"`

		// EventClass A specific instance of the source.
		EventClass *string `json:"event_class,omitempty"`

		// MessageKey All actions sharing this key are associated with the same ServiceNow alert. The default value is `<rule ID>:<alert instance ID>`.
		MessageKey *string `json:"message_key,omitempty"`

		// MetricName The name of the metric.
		MetricName *string `json:"metric_name,omitempty"`

		// Node The host that the event was triggered for.
		Node *string `json:"node,omitempty"`

		// Resource The name of the resource.
		Resource *string `json:"resource,omitempty"`

		// Severity The severity of the event.
		Severity *string `json:"severity,omitempty"`

		// Source The name of the event source type.
		Source *string `json:"source,omitempty"`

		// TimeOfEvent The time of the event.
		TimeOfEvent *string `json:"time_of_event,omitempty"`

		// Type The type of event.
		Type *string `json:"type,omitempty"`
	} `json:"subActionParams,omitempty"`
}

// RunConnectorSubactionAddeventSubAction The action to test.
type RunConnectorSubactionAddeventSubAction string

// RunConnectorSubactionClosealert The `closeAlert` subaction for Opsgenie connectors.
type RunConnectorSubactionClosealert struct {
	// SubAction The action to test.
	SubAction       RunConnectorSubactionClosealertSubAction `json:"subAction"`
	SubActionParams struct {
		// Alias The unique identifier used for alert deduplication in Opsgenie. The alias must match the value used when creating the alert.
		Alias string `json:"alias"`

		// Note Additional information for the alert.
		Note *string `json:"note,omitempty"`

		// Source The display name for the source of the alert.
		Source *string `json:"source,omitempty"`

		// User The display name for the owner.
		User *string `json:"user,omitempty"`
	} `json:"subActionParams"`
}

// RunConnectorSubactionClosealertSubAction The action to test.
type RunConnectorSubactionClosealertSubAction string

// RunConnectorSubactionCreatealert The `createAlert` subaction for Opsgenie connectors.
type RunConnectorSubactionCreatealert struct {
	// SubAction The action to test.
	SubAction       RunConnectorSubactionCreatealertSubAction `json:"subAction"`
	SubActionParams struct {
		// Actions The custom actions available to the alert.
		Actions *[]string `json:"actions,omitempty"`

		// Alias The unique identifier used for alert deduplication in Opsgenie.
		Alias *string `json:"alias,omitempty"`

		// Description A description that provides detailed information about the alert.
		Description *string `json:"description,omitempty"`

		// Details The custom properties of the alert.
		Details *map[string]interface{} `json:"details,omitempty"`

		// Entity The domain of the alert. For example, the application or server name.
		Entity *string `json:"entity,omitempty"`

		// Message The alert message.
		Message string `json:"message"`

		// Note Additional information for the alert.
		Note *string `json:"note,omitempty"`

		// Priority The priority level for the alert.
		Priority *RunConnectorSubactionCreatealertSubActionParamsPriority `json:"priority,omitempty"`

		// Responders The entities to receive notifications about the alert. If `type` is `user`, either `id` or `username` is required. If `type` is `team`, either `id` or `name` is required.
		Responders *[]struct {
			// Id The identifier for the entity.
			Id *string `json:"id,omitempty"`

			// Name The name of the entity.
			Name *string `json:"name,omitempty"`

			// Type The type of responders, in this case `escalation`.
			Type *RunConnectorSubactionCreatealertSubActionParamsRespondersType `json:"type,omitempty"`

			// Username A valid email address for the user.
			Username *string `json:"username,omitempty"`
		} `json:"responders,omitempty"`

		// Source The display name for the source of the alert.
		Source *string `json:"source,omitempty"`

		// Tags The tags for the alert.
		Tags *[]string `json:"tags,omitempty"`

		// User The display name for the owner.
		User *string `json:"user,omitempty"`

		// VisibleTo The teams and users that the alert will be visible to without sending a notification. Only one of `id`, `name`, or `username` is required.
		VisibleTo *[]struct {
			// Id The identifier for the entity.
			Id *string `json:"id,omitempty"`

			// Name The name of the entity.
			Name *string `json:"name,omitempty"`

			// Type Valid values are `team` and `user`.
			Type RunConnectorSubactionCreatealertSubActionParamsVisibleToType `json:"type"`

			// Username The user name. This property is required only when the `type` is `user`.
			Username *string `json:"username,omitempty"`
		} `json:"visibleTo,omitempty"`
	} `json:"subActionParams"`
}

// RunConnectorSubactionCreatealertSubAction The action to test.
type RunConnectorSubactionCreatealertSubAction string

// RunConnectorSubactionCreatealertSubActionParamsPriority The priority level for the alert.
type RunConnectorSubactionCreatealertSubActionParamsPriority string

// RunConnectorSubactionCreatealertSubActionParamsRespondersType The type of responders, in this case `escalation`.
type RunConnectorSubactionCreatealertSubActionParamsRespondersType string

// RunConnectorSubactionCreatealertSubActionParamsVisibleToType Valid values are `team` and `user`.
type RunConnectorSubactionCreatealertSubActionParamsVisibleToType string

// RunConnectorSubactionFieldsbyissuetype The `fieldsByIssueType` subaction for Jira connectors.
type RunConnectorSubactionFieldsbyissuetype struct {
	// SubAction The action to test.
	SubAction       RunConnectorSubactionFieldsbyissuetypeSubAction `json:"subAction"`
	SubActionParams struct {
		// Id The Jira issue type identifier.
		Id string `json:"id"`
	} `json:"subActionParams"`
}

// RunConnectorSubactionFieldsbyissuetypeSubAction The action to test.
type RunConnectorSubactionFieldsbyissuetypeSubAction string

// RunConnectorSubactionGetchoices The `getChoices` subaction for ServiceNow ITOM, ServiceNow ITSM, and ServiceNow SecOps connectors.
type RunConnectorSubactionGetchoices struct {
	// SubAction The action to test.
	SubAction RunConnectorSubactionGetchoicesSubAction `json:"subAction"`

	// SubActionParams The set of configuration properties for the action.
	SubActionParams struct {
		// Fields An array of fields.
		Fields []string `json:"fields"`
	} `json:"subActionParams"`
}

// RunConnectorSubactionGetchoicesSubAction The action to test.
type RunConnectorSubactionGetchoicesSubAction string

// RunConnectorSubactionGetfields The `getFields` subaction for Jira, ServiceNow ITSM, and ServiceNow SecOps connectors.
type RunConnectorSubactionGetfields struct {
	// SubAction The action to test.
	SubAction RunConnectorSubactionGetfieldsSubAction `json:"subAction"`
}

// RunConnectorSubactionGetfieldsSubAction The action to test.
type RunConnectorSubactionGetfieldsSubAction string

// RunConnectorSubactionGetincident The `getIncident` subaction for Jira, ServiceNow ITSM, and ServiceNow SecOps connectors.
type RunConnectorSubactionGetincident struct {
	// SubAction The action to test.
	SubAction       RunConnectorSubactionGetincidentSubAction `json:"subAction"`
	SubActionParams struct {
		// ExternalId The Jira, ServiceNow ITSM, or ServiceNow SecOps issue identifier.
		ExternalId string `json:"externalId"`
	} `json:"subActionParams"`
}

// RunConnectorSubactionGetincidentSubAction The action to test.
type RunConnectorSubactionGetincidentSubAction string

// RunConnectorSubactionIssue The `issue` subaction for Jira connectors.
type RunConnectorSubactionIssue struct {
	// SubAction The action to test.
	SubAction       RunConnectorSubactionIssueSubAction `json:"subAction"`
	SubActionParams *struct {
		// Id The Jira issue identifier.
		Id string `json:"id"`
	} `json:"subActionParams,omitempty"`
}

// RunConnectorSubactionIssueSubAction The action to test.
type RunConnectorSubactionIssueSubAction string

// RunConnectorSubactionIssues The `issues` subaction for Jira connectors.
type RunConnectorSubactionIssues struct {
	// SubAction The action to test.
	SubAction       RunConnectorSubactionIssuesSubAction `json:"subAction"`
	SubActionParams struct {
		// Title The title of the Jira issue.
		Title string `json:"title"`
	} `json:"subActionParams"`
}

// RunConnectorSubactionIssuesSubAction The action to test.
type RunConnectorSubactionIssuesSubAction string

// RunConnectorSubactionIssuetypes The `issueTypes` subaction for Jira connectors.
type RunConnectorSubactionIssuetypes struct {
	// SubAction The action to test.
	SubAction RunConnectorSubactionIssuetypesSubAction `json:"subAction"`
}

// RunConnectorSubactionIssuetypesSubAction The action to test.
type RunConnectorSubactionIssuetypesSubAction string

// RunConnectorSubactionPushtoservice The `pushToService` subaction for Jira, ServiceNow ITSM, ServiceNow SecOps, and Swimlane connectors.
type RunConnectorSubactionPushtoservice struct {
	// SubAction The action to test.
	SubAction RunConnectorSubactionPushtoserviceSubAction `json:"subAction"`

	// SubActionParams The set of configuration properties for the action.
	SubActionParams struct {
		// Comments Additional information that is sent to Jira, ServiceNow ITSM, ServiceNow SecOps, or Swimlane.
		Comments *[]struct {
			// Comment A comment related to the incident. For example, describe how to troubleshoot the issue.
			Comment *string `json:"comment,omitempty"`

			// CommentId A unique identifier for the comment.
			CommentId *int `json:"commentId,omitempty"`
		} `json:"comments,omitempty"`

		// Incident Information necessary to create or update a Jira, ServiceNow ITSM, ServiveNow SecOps, or Swimlane incident.
		Incident *struct {
			// AlertId The alert identifier for Swimlane connectors.
			AlertId *string `json:"alertId,omitempty"`

			// CaseId The case identifier for the incident for Swimlane connectors.
			CaseId *string `json:"caseId,omitempty"`

			// CaseName The case name for the incident for Swimlane connectors.
			CaseName *string `json:"caseName,omitempty"`

			// Category The category of the incident for ServiceNow ITSM and ServiceNow SecOps connectors.
			Category *string `json:"category,omitempty"`

			// CorrelationDisplay A descriptive label of the alert for correlation purposes for ServiceNow ITSM and ServiceNow SecOps connectors.
			CorrelationDisplay *string `json:"correlation_display,omitempty"`

			// CorrelationId The correlation identifier for the security incident for ServiceNow ITSM and ServiveNow SecOps connectors. Connectors using the same correlation ID are associated with the same ServiceNow incident. This value determines whether a new ServiceNow incident is created or an existing one is updated. Modifying this value is optional; if not modified, the rule ID and alert ID are combined as `{{ruleID}}:{{alert ID}}` to form the correlation ID value in ServiceNow. The maximum character length for this value is 100 characters. NOTE: Using the default configuration of `{{ruleID}}:{{alert ID}}` ensures that ServiceNow creates a separate incident record for every generated alert that uses a unique alert ID. If the rule generates multiple alerts that use the same alert IDs, ServiceNow creates and continually updates a single incident record for the alert.
			CorrelationId *string `json:"correlation_id,omitempty"`

			// Description The description of the incident for Jira, ServiceNow ITSM, ServiceNow SecOps, and Swimlane connectors.
			Description *string `json:"description,omitempty"`

			// DestIp A list of destination IP addresses related to the security incident for ServiceNow SecOps connectors. The IPs are added as observables to the security incident.
			DestIp *RunConnectorSubactionPushtoservice_SubActionParams_Incident_DestIp `json:"dest_ip,omitempty"`

			// ExternalId The Jira, ServiceNow ITSM, or ServiceNow SecOps issue identifier. If present, the incident is updated. Otherwise, a new incident is created.
			ExternalId *string `json:"externalId,omitempty"`

			// Impact The impact of the incident for ServiceNow ITSM connectors.
			Impact *string `json:"impact,omitempty"`

			// IssueType The type of incident for Jira connectors. For example, 10006. To obtain the list of valid values, set `subAction` to `issueTypes`.
			IssueType *int `json:"issueType,omitempty"`

			// Labels The labels for the incident for Jira connectors. NOTE: Labels cannot contain spaces.
			Labels *[]string `json:"labels,omitempty"`

			// MalwareHash A list of malware hashes related to the security incident for ServiceNow SecOps connectors. The hashes are added as observables to the security incident.
			MalwareHash *RunConnectorSubactionPushtoservice_SubActionParams_Incident_MalwareHash `json:"malware_hash,omitempty"`

			// MalwareUrl A list of malware URLs related to the security incident for ServiceNow SecOps connectors. The URLs are added as observables to the security incident.
			MalwareUrl *string `json:"malware_url,omitempty"`

			// Parent The ID or key of the parent issue for Jira connectors. Applies only to `Sub-task` types of issues.
			Parent *string `json:"parent,omitempty"`

			// Priority The priority of the incident in Jira and ServiceNow SecOps connectors.
			Priority *string `json:"priority,omitempty"`

			// RuleName The rule name for Swimlane connectors.
			RuleName *string `json:"ruleName,omitempty"`

			// Severity The severity of the incident for ServiceNow ITSM and Swimlane connectors.
			Severity *string `json:"severity,omitempty"`

			// ShortDescription A short description of the incident for ServiceNow ITSM and ServiceNow SecOps connectors. It is used for searching the contents of the knowledge base.
			ShortDescription *string `json:"short_description,omitempty"`

			// SourceIp A list of source IP addresses related to the security incident for ServiceNow SecOps connectors. The IPs are added as observables to the security incident.
			SourceIp *RunConnectorSubactionPushtoservice_SubActionParams_Incident_SourceIp `json:"source_ip,omitempty"`

			// Subcategory The subcategory of the incident for ServiceNow ITSM and ServiceNow SecOps connectors.
			Subcategory *string `json:"subcategory,omitempty"`

			// Summary A summary of the incident for Jira connectors.
			Summary *string `json:"summary,omitempty"`

			// Title A title for the incident for Jira connectors. It is used for searching the contents of the knowledge base.
			Title *string `json:"title,omitempty"`

			// Urgency The urgency of the incident for ServiceNow ITSM connectors.
			Urgency *string `json:"urgency,omitempty"`
		} `json:"incident,omitempty"`
	} `json:"subActionParams"`
}

// RunConnectorSubactionPushtoserviceSubAction The action to test.
type RunConnectorSubactionPushtoserviceSubAction string

// RunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp0 defines model for .
type RunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp0 = string

// RunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp1 defines model for .
type RunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp1 = []string

// RunConnectorSubactionPushtoservice_SubActionParams_Incident_DestIp A list of destination IP addresses related to the security incident for ServiceNow SecOps connectors. The IPs are added as observables to the security incident.
type RunConnectorSubactionPushtoservice_SubActionParams_Incident_DestIp struct {
	union json.RawMessage
}

// RunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash0 defines model for .
type RunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash0 = string

// RunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash1 defines model for .
type RunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash1 = []string

// RunConnectorSubactionPushtoservice_SubActionParams_Incident_MalwareHash A list of malware hashes related to the security incident for ServiceNow SecOps connectors. The hashes are added as observables to the security incident.
type RunConnectorSubactionPushtoservice_SubActionParams_Incident_MalwareHash struct {
	union json.RawMessage
}

// RunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp0 defines model for .
type RunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp0 = string

// RunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp1 defines model for .
type RunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp1 = []string

// RunConnectorSubactionPushtoservice_SubActionParams_Incident_SourceIp A list of source IP addresses related to the security incident for ServiceNow SecOps connectors. The IPs are added as observables to the security incident.
type RunConnectorSubactionPushtoservice_SubActionParams_Incident_SourceIp struct {
	union json.RawMessage
}

// SecretsPropertiesCasesWebhook defines model for secrets_properties_cases_webhook.
type SecretsPropertiesCasesWebhook struct {
	// Password The password for HTTP basic authentication. If `hasAuth` is set to `true`, this property is required.
	Password *string `json:"password,omitempty"`

	// User The username for HTTP basic authentication. If `hasAuth` is set to `true`, this property is required.
	User *string `json:"user,omitempty"`
}

// SecretsPropertiesEmail Defines secrets for connectors when type is `.email`.
type SecretsPropertiesEmail map[string]interface{}

// SecretsPropertiesGemini Defines secrets for connectors when type is `.gemini`.
type SecretsPropertiesGemini struct {
	// CredentialsJson The service account credentials JSON file. The service account should have Vertex AI user IAM role assigned to it.
	CredentialsJson string `json:"credentialsJson"`
}

// SecretsPropertiesJira Defines secrets for connectors when type is `.jira`.
type SecretsPropertiesJira struct {
	// ApiToken The Jira API authentication token for HTTP basic authentication.
	ApiToken string `json:"apiToken"`

	// Email The account email for HTTP Basic authentication.
	Email string `json:"email"`
}

// SecretsPropertiesOpsgenie Defines secrets for connectors when type is `.opsgenie`.
type SecretsPropertiesOpsgenie struct {
	// ApiKey The Opsgenie API authentication key for HTTP Basic authentication.
	ApiKey string `json:"apiKey"`
}

// SecretsPropertiesPagerduty Defines secrets for connectors when type is `.pagerduty`.
type SecretsPropertiesPagerduty map[string]interface{}

// SecretsPropertiesResilient Defines secrets for connectors when type is `.resilient`.
type SecretsPropertiesResilient struct {
	// ApiKeyId The authentication key ID for HTTP Basic authentication.
	ApiKeyId string `json:"apiKeyId"`

	// ApiKeySecret The authentication key secret for HTTP Basic authentication.
	ApiKeySecret string `json:"apiKeySecret"`
}

// SecretsPropertiesServicenow Defines secrets for connectors when type is `.servicenow`, `.servicenow-sir`, or `.servicenow-itom`.
type SecretsPropertiesServicenow struct {
	// ClientSecret The client secret assigned to your OAuth application. This property is required when `isOAuth` is `true`.
	ClientSecret *string `json:"clientSecret,omitempty"`

	// Password The password for HTTP basic authentication. This property is required when `isOAuth` is `false`.
	Password *string `json:"password,omitempty"`

	// PrivateKey The RSA private key that you created for use in ServiceNow. This property is required when `isOAuth` is `true`.
	PrivateKey *string `json:"privateKey,omitempty"`

	// PrivateKeyPassword The password for the RSA private key. This property is required when `isOAuth` is `true` and you set a password on your private key.
	PrivateKeyPassword *string `json:"privateKeyPassword,omitempty"`

	// Username The username for HTTP basic authentication. This property is required when `isOAuth` is `false`.
	Username *string `json:"username,omitempty"`
}

// SecretsPropertiesSlack Defines secrets for connectors when type is `.slack`.
type SecretsPropertiesSlack map[string]interface{}

// SecretsPropertiesSlackApi Defines secrets for connectors when type is `.slack`.
type SecretsPropertiesSlackApi struct {
	// Token Slack bot user OAuth token.
	Token string `json:"token"`
}

// SecretsPropertiesSwimlane Defines secrets for connectors when type is `.swimlane`.
type SecretsPropertiesSwimlane struct {
	// ApiToken Swimlane API authentication token.
	ApiToken *string `json:"apiToken,omitempty"`
}

// SecretsPropertiesTeams Defines secrets for connectors when type is `.teams`.
type SecretsPropertiesTeams map[string]interface{}

// SecretsPropertiesTines Defines secrets for connectors when type is `.tines`.
type SecretsPropertiesTines map[string]interface{}

// SecretsPropertiesWebhook Defines secrets for connectors when type is `.webhook`.
type SecretsPropertiesWebhook map[string]interface{}

// SecretsPropertiesXmatters Defines secrets for connectors when type is `.xmatters`.
type SecretsPropertiesXmatters map[string]interface{}

// UpdateConnectorRequestCasesWebhook defines model for update_connector_request_cases_webhook.
type UpdateConnectorRequestCasesWebhook struct {
	// Config Defines properties for connectors when type is `.cases-webhook`.
	Config ConfigPropertiesCasesWebhook `json:"config"`

	// Name The display name for the connector.
	Name    string                         `json:"name"`
	Secrets *SecretsPropertiesCasesWebhook `json:"secrets,omitempty"`
}

// UpdateConnectorRequestEmail defines model for update_connector_request_email.
type UpdateConnectorRequestEmail struct {
	// Config Defines properties for connectors when type is `.email`.
	Config ConfigPropertiesEmail `json:"config"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.email`.
	Secrets SecretsPropertiesEmail `json:"secrets"`
}

// UpdateConnectorRequestGemini defines model for update_connector_request_gemini.
type UpdateConnectorRequestGemini struct {
	// Config Defines properties for connectors when type is `.gemini`.
	Config ConfigPropertiesGemini `json:"config"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.gemini`.
	Secrets *SecretsPropertiesGemini `json:"secrets,omitempty"`
}

// UpdateConnectorRequestIndex defines model for update_connector_request_index.
type UpdateConnectorRequestIndex struct {
	// Config Defines properties for connectors when type is `.index`.
	Config ConfigPropertiesIndex `json:"config"`

	// Name The display name for the connector.
	Name string `json:"name"`
}

// UpdateConnectorRequestJira defines model for update_connector_request_jira.
type UpdateConnectorRequestJira struct {
	// Config Defines properties for connectors when type is `.jira`.
	Config ConfigPropertiesJira `json:"config"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.jira`.
	Secrets SecretsPropertiesJira `json:"secrets"`
}

// UpdateConnectorRequestOpsgenie defines model for update_connector_request_opsgenie.
type UpdateConnectorRequestOpsgenie struct {
	// Config Defines properties for connectors when type is `.opsgenie`.
	Config ConfigPropertiesOpsgenie `json:"config"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.opsgenie`.
	Secrets SecretsPropertiesOpsgenie `json:"secrets"`
}

// UpdateConnectorRequestPagerduty The PagerDuty connector uses the v2 Events API to trigger, acknowledge, and resolve PagerDuty alerts.
type UpdateConnectorRequestPagerduty struct {
	// Config Defines properties for connectors when type is `.pagerduty`.
	Config ConfigPropertiesPagerduty `json:"config"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.pagerduty`.
	Secrets SecretsPropertiesPagerduty `json:"secrets"`
}

// UpdateConnectorRequestResilient defines model for update_connector_request_resilient.
type UpdateConnectorRequestResilient struct {
	// Config Defines properties for connectors when type is `.resilient`.
	Config ConfigPropertiesResilient `json:"config"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.resilient`.
	Secrets SecretsPropertiesResilient `json:"secrets"`
}

// UpdateConnectorRequestServerlog defines model for update_connector_request_serverlog.
type UpdateConnectorRequestServerlog struct {
	// Name The display name for the connector.
	Name string `json:"name"`
}

// UpdateConnectorRequestServicenow defines model for update_connector_request_servicenow.
type UpdateConnectorRequestServicenow struct {
	// Config Defines properties for connectors when type is `.servicenow`.
	Config ConfigPropertiesServicenow `json:"config"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.servicenow`, `.servicenow-sir`, or `.servicenow-itom`.
	Secrets SecretsPropertiesServicenow `json:"secrets"`
}

// UpdateConnectorRequestServicenowItom defines model for update_connector_request_servicenow_itom.
type UpdateConnectorRequestServicenowItom struct {
	// Config Defines properties for connectors when type is `.servicenow`.
	Config ConfigPropertiesServicenowItom `json:"config"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.servicenow`, `.servicenow-sir`, or `.servicenow-itom`.
	Secrets SecretsPropertiesServicenow `json:"secrets"`
}

// UpdateConnectorRequestServicenowSir The ServiceNow SecOps connector uses the import set API to create ServiceNow security incidents. You can use the connector for rule actions and cases.
type UpdateConnectorRequestServicenowSir struct {
	// Config Defines properties for connectors when type is `.servicenow`.
	Config ConfigPropertiesServicenow `json:"config"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.servicenow`, `.servicenow-sir`, or `.servicenow-itom`.
	Secrets SecretsPropertiesServicenow `json:"secrets"`
}

// UpdateConnectorRequestSlack The Slack connector uses Slack Incoming Webhooks.
type UpdateConnectorRequestSlack struct {
	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.slack`.
	Secrets SecretsPropertiesSlack `json:"secrets"`
}

// UpdateConnectorRequestSlackApi defines model for update_connector_request_slack_api.
type UpdateConnectorRequestSlackApi struct {
	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.slack`.
	Secrets SecretsPropertiesSlackApi `json:"secrets"`
}

// UpdateConnectorRequestSwimlane defines model for update_connector_request_swimlane.
type UpdateConnectorRequestSwimlane struct {
	// Config Defines properties for connectors when type is `.swimlane`.
	Config ConfigPropertiesSwimlane `json:"config"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.swimlane`.
	Secrets SecretsPropertiesSwimlane `json:"secrets"`
}

// UpdateConnectorRequestTeams The Microsoft Teams connector uses Incoming Webhooks.
type UpdateConnectorRequestTeams struct {
	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.teams`.
	Secrets SecretsPropertiesTeams `json:"secrets"`
}

// UpdateConnectorRequestTines The Tines connector uses Tines Webhook actions to send events via POST request.
type UpdateConnectorRequestTines struct {
	// Config Defines properties for connectors when type is `.tines`.
	Config ConfigPropertiesTines `json:"config"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.tines`.
	Secrets SecretsPropertiesTines `json:"secrets"`
}

// UpdateConnectorRequestWebhook The Webhook connector uses axios to send a POST or PUT request to a web service.
type UpdateConnectorRequestWebhook struct {
	// Config Defines properties for connectors when type is `.webhook`.
	Config ConfigPropertiesWebhook `json:"config"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.webhook`.
	Secrets SecretsPropertiesWebhook `json:"secrets"`
}

// UpdateConnectorRequestXmatters The xMatters connector uses the xMatters Workflow for Elastic to send actionable alerts to on-call xMatters resources.
type UpdateConnectorRequestXmatters struct {
	// Config Defines properties for connectors when type is `.xmatters`.
	Config ConfigPropertiesXmatters `json:"config"`

	// Name The display name for the connector.
	Name string `json:"name"`

	// Secrets Defines secrets for connectors when type is `.xmatters`.
	Secrets SecretsPropertiesXmatters `json:"secrets"`
}

// ActionId defines model for action_id.
type ActionId = string

// ConnectorId defines model for connector_id.
type ConnectorId = string

// KbnXsrf defines model for kbn_xsrf.
type KbnXsrf = string

// SpaceId defines model for space_id.
type SpaceId = string

// N200Actions The properties vary depending on the action type.
type N200Actions = ActionResponseProperties

// LegacyCreateConnectorJSONBody defines parameters for LegacyCreateConnector.
type LegacyCreateConnectorJSONBody struct {
	// ActionTypeId The connector type identifier.
	ActionTypeId *string `json:"actionTypeId,omitempty"`

	// Config The configuration for the connector. Configuration properties vary depending on the connector type.
	Config *map[string]interface{} `json:"config,omitempty"`

	// Name The display name for the connector.
	Name *string `json:"name,omitempty"`

	// Secrets The secrets configuration for the connector. Secrets configuration properties vary depending on the connector type. NOTE: Remember these values. You must provide them each time you update the connector.
	Secrets *map[string]interface{} `json:"secrets,omitempty"`
}

// LegacyCreateConnectorParams defines parameters for LegacyCreateConnector.
type LegacyCreateConnectorParams struct {
	// KbnXsrf Cross-site request forgery protection
	KbnXsrf KbnXsrf `json:"kbn-xsrf"`
}

// LegacyDeleteConnectorParams defines parameters for LegacyDeleteConnector.
type LegacyDeleteConnectorParams struct {
	// KbnXsrf Cross-site request forgery protection
	KbnXsrf KbnXsrf `json:"kbn-xsrf"`
}

// LegacyUpdateConnectorJSONBody defines parameters for LegacyUpdateConnector.
type LegacyUpdateConnectorJSONBody struct {
	// Config The new connector configuration. Configuration properties vary depending on the connector type.
	Config *map[string]interface{} `json:"config,omitempty"`

	// Name The new name for the connector.
	Name *string `json:"name,omitempty"`

	// Secrets The updated secrets configuration for the connector. Secrets properties vary depending on the connector type.
	Secrets *map[string]interface{} `json:"secrets,omitempty"`
}

// LegacyUpdateConnectorParams defines parameters for LegacyUpdateConnector.
type LegacyUpdateConnectorParams struct {
	// KbnXsrf Cross-site request forgery protection
	KbnXsrf KbnXsrf `json:"kbn-xsrf"`
}

// LegacyRunConnectorJSONBody defines parameters for LegacyRunConnector.
type LegacyRunConnectorJSONBody struct {
	// Params The parameters of the connector. Parameter properties vary depending on the connector type.
	Params map[string]interface{} `json:"params"`
}

// LegacyRunConnectorParams defines parameters for LegacyRunConnector.
type LegacyRunConnectorParams struct {
	// KbnXsrf Cross-site request forgery protection
	KbnXsrf KbnXsrf `json:"kbn-xsrf"`
}

// CreateConnectorJSONBody defines parameters for CreateConnector.
type CreateConnectorJSONBody struct {
	union json.RawMessage
}

// CreateConnectorParams defines parameters for CreateConnector.
type CreateConnectorParams struct {
	// KbnXsrf Cross-site request forgery protection
	KbnXsrf KbnXsrf `json:"kbn-xsrf"`
}

// DeleteConnectorParams defines parameters for DeleteConnector.
type DeleteConnectorParams struct {
	// KbnXsrf Cross-site request forgery protection
	KbnXsrf KbnXsrf `json:"kbn-xsrf"`
}

// UpdateConnectorJSONBody defines parameters for UpdateConnector.
type UpdateConnectorJSONBody struct {
	union json.RawMessage
}

// UpdateConnectorParams defines parameters for UpdateConnector.
type UpdateConnectorParams struct {
	// KbnXsrf Cross-site request forgery protection
	KbnXsrf KbnXsrf `json:"kbn-xsrf"`
}

// RunConnectorJSONBody defines parameters for RunConnector.
type RunConnectorJSONBody struct {
	Params RunConnectorJSONBody_Params `json:"params"`
}

// RunConnectorParams defines parameters for RunConnector.
type RunConnectorParams struct {
	// KbnXsrf Cross-site request forgery protection
	KbnXsrf KbnXsrf `json:"kbn-xsrf"`
}

// RunConnectorJSONBodyParams2 defines parameters for RunConnector.
type RunConnectorJSONBodyParams2 struct {
	union json.RawMessage
}

// RunConnectorJSONBody_Params defines parameters for RunConnector.
type RunConnectorJSONBody_Params struct {
	union json.RawMessage
}

// GetConnectorTypesParams defines parameters for GetConnectorTypes.
type GetConnectorTypesParams struct {
	// FeatureId A filter to limit the retrieved connector types to those that support a specific feature (such as alerting or cases).
	FeatureId *Features `form:"feature_id,omitempty" json:"feature_id,omitempty"`
}

// LegacyCreateConnectorJSONRequestBody defines body for LegacyCreateConnector for application/json ContentType.
type LegacyCreateConnectorJSONRequestBody LegacyCreateConnectorJSONBody

// LegacyUpdateConnectorJSONRequestBody defines body for LegacyUpdateConnector for application/json ContentType.
type LegacyUpdateConnectorJSONRequestBody LegacyUpdateConnectorJSONBody

// LegacyRunConnectorJSONRequestBody defines body for LegacyRunConnector for application/json ContentType.
type LegacyRunConnectorJSONRequestBody LegacyRunConnectorJSONBody

// CreateConnectorJSONRequestBody defines body for CreateConnector for application/json ContentType.
type CreateConnectorJSONRequestBody CreateConnectorJSONBody

// UpdateConnectorJSONRequestBody defines body for UpdateConnector for application/json ContentType.
type UpdateConnectorJSONRequestBody UpdateConnectorJSONBody

// RunConnectorJSONRequestBody defines body for RunConnector for application/json ContentType.
type RunConnectorJSONRequestBody RunConnectorJSONBody

// AsConnectorResponsePropertiesCasesWebhook returns the union data inside the ConnectorResponseProperties as a ConnectorResponsePropertiesCasesWebhook
func (t ConnectorResponseProperties) AsConnectorResponsePropertiesCasesWebhook() (ConnectorResponsePropertiesCasesWebhook, error) {
	var body ConnectorResponsePropertiesCasesWebhook
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectorResponsePropertiesCasesWebhook overwrites any union data inside the ConnectorResponseProperties as the provided ConnectorResponsePropertiesCasesWebhook
func (t *ConnectorResponseProperties) FromConnectorResponsePropertiesCasesWebhook(v ConnectorResponsePropertiesCasesWebhook) error {
	v.ConnectorTypeId = ".cases-webhook"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectorResponsePropertiesCasesWebhook performs a merge with any union data inside the ConnectorResponseProperties, using the provided ConnectorResponsePropertiesCasesWebhook
func (t *ConnectorResponseProperties) MergeConnectorResponsePropertiesCasesWebhook(v ConnectorResponsePropertiesCasesWebhook) error {
	v.ConnectorTypeId = ".cases-webhook"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnectorResponsePropertiesEmail returns the union data inside the ConnectorResponseProperties as a ConnectorResponsePropertiesEmail
func (t ConnectorResponseProperties) AsConnectorResponsePropertiesEmail() (ConnectorResponsePropertiesEmail, error) {
	var body ConnectorResponsePropertiesEmail
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectorResponsePropertiesEmail overwrites any union data inside the ConnectorResponseProperties as the provided ConnectorResponsePropertiesEmail
func (t *ConnectorResponseProperties) FromConnectorResponsePropertiesEmail(v ConnectorResponsePropertiesEmail) error {
	v.ConnectorTypeId = ".email"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectorResponsePropertiesEmail performs a merge with any union data inside the ConnectorResponseProperties, using the provided ConnectorResponsePropertiesEmail
func (t *ConnectorResponseProperties) MergeConnectorResponsePropertiesEmail(v ConnectorResponsePropertiesEmail) error {
	v.ConnectorTypeId = ".email"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnectorResponsePropertiesGemini returns the union data inside the ConnectorResponseProperties as a ConnectorResponsePropertiesGemini
func (t ConnectorResponseProperties) AsConnectorResponsePropertiesGemini() (ConnectorResponsePropertiesGemini, error) {
	var body ConnectorResponsePropertiesGemini
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectorResponsePropertiesGemini overwrites any union data inside the ConnectorResponseProperties as the provided ConnectorResponsePropertiesGemini
func (t *ConnectorResponseProperties) FromConnectorResponsePropertiesGemini(v ConnectorResponsePropertiesGemini) error {
	v.ConnectorTypeId = ".gemini"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectorResponsePropertiesGemini performs a merge with any union data inside the ConnectorResponseProperties, using the provided ConnectorResponsePropertiesGemini
func (t *ConnectorResponseProperties) MergeConnectorResponsePropertiesGemini(v ConnectorResponsePropertiesGemini) error {
	v.ConnectorTypeId = ".gemini"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnectorResponsePropertiesIndex returns the union data inside the ConnectorResponseProperties as a ConnectorResponsePropertiesIndex
func (t ConnectorResponseProperties) AsConnectorResponsePropertiesIndex() (ConnectorResponsePropertiesIndex, error) {
	var body ConnectorResponsePropertiesIndex
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectorResponsePropertiesIndex overwrites any union data inside the ConnectorResponseProperties as the provided ConnectorResponsePropertiesIndex
func (t *ConnectorResponseProperties) FromConnectorResponsePropertiesIndex(v ConnectorResponsePropertiesIndex) error {
	v.ConnectorTypeId = ".index"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectorResponsePropertiesIndex performs a merge with any union data inside the ConnectorResponseProperties, using the provided ConnectorResponsePropertiesIndex
func (t *ConnectorResponseProperties) MergeConnectorResponsePropertiesIndex(v ConnectorResponsePropertiesIndex) error {
	v.ConnectorTypeId = ".index"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnectorResponsePropertiesJira returns the union data inside the ConnectorResponseProperties as a ConnectorResponsePropertiesJira
func (t ConnectorResponseProperties) AsConnectorResponsePropertiesJira() (ConnectorResponsePropertiesJira, error) {
	var body ConnectorResponsePropertiesJira
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectorResponsePropertiesJira overwrites any union data inside the ConnectorResponseProperties as the provided ConnectorResponsePropertiesJira
func (t *ConnectorResponseProperties) FromConnectorResponsePropertiesJira(v ConnectorResponsePropertiesJira) error {
	v.ConnectorTypeId = ".jira"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectorResponsePropertiesJira performs a merge with any union data inside the ConnectorResponseProperties, using the provided ConnectorResponsePropertiesJira
func (t *ConnectorResponseProperties) MergeConnectorResponsePropertiesJira(v ConnectorResponsePropertiesJira) error {
	v.ConnectorTypeId = ".jira"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnectorResponsePropertiesOpsgenie returns the union data inside the ConnectorResponseProperties as a ConnectorResponsePropertiesOpsgenie
func (t ConnectorResponseProperties) AsConnectorResponsePropertiesOpsgenie() (ConnectorResponsePropertiesOpsgenie, error) {
	var body ConnectorResponsePropertiesOpsgenie
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectorResponsePropertiesOpsgenie overwrites any union data inside the ConnectorResponseProperties as the provided ConnectorResponsePropertiesOpsgenie
func (t *ConnectorResponseProperties) FromConnectorResponsePropertiesOpsgenie(v ConnectorResponsePropertiesOpsgenie) error {
	v.ConnectorTypeId = ".opsgenie"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectorResponsePropertiesOpsgenie performs a merge with any union data inside the ConnectorResponseProperties, using the provided ConnectorResponsePropertiesOpsgenie
func (t *ConnectorResponseProperties) MergeConnectorResponsePropertiesOpsgenie(v ConnectorResponsePropertiesOpsgenie) error {
	v.ConnectorTypeId = ".opsgenie"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnectorResponsePropertiesPagerduty returns the union data inside the ConnectorResponseProperties as a ConnectorResponsePropertiesPagerduty
func (t ConnectorResponseProperties) AsConnectorResponsePropertiesPagerduty() (ConnectorResponsePropertiesPagerduty, error) {
	var body ConnectorResponsePropertiesPagerduty
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectorResponsePropertiesPagerduty overwrites any union data inside the ConnectorResponseProperties as the provided ConnectorResponsePropertiesPagerduty
func (t *ConnectorResponseProperties) FromConnectorResponsePropertiesPagerduty(v ConnectorResponsePropertiesPagerduty) error {
	v.ConnectorTypeId = ".pagerduty"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectorResponsePropertiesPagerduty performs a merge with any union data inside the ConnectorResponseProperties, using the provided ConnectorResponsePropertiesPagerduty
func (t *ConnectorResponseProperties) MergeConnectorResponsePropertiesPagerduty(v ConnectorResponsePropertiesPagerduty) error {
	v.ConnectorTypeId = ".pagerduty"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnectorResponsePropertiesResilient returns the union data inside the ConnectorResponseProperties as a ConnectorResponsePropertiesResilient
func (t ConnectorResponseProperties) AsConnectorResponsePropertiesResilient() (ConnectorResponsePropertiesResilient, error) {
	var body ConnectorResponsePropertiesResilient
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectorResponsePropertiesResilient overwrites any union data inside the ConnectorResponseProperties as the provided ConnectorResponsePropertiesResilient
func (t *ConnectorResponseProperties) FromConnectorResponsePropertiesResilient(v ConnectorResponsePropertiesResilient) error {
	v.ConnectorTypeId = ".resilient"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectorResponsePropertiesResilient performs a merge with any union data inside the ConnectorResponseProperties, using the provided ConnectorResponsePropertiesResilient
func (t *ConnectorResponseProperties) MergeConnectorResponsePropertiesResilient(v ConnectorResponsePropertiesResilient) error {
	v.ConnectorTypeId = ".resilient"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnectorResponsePropertiesServerlog returns the union data inside the ConnectorResponseProperties as a ConnectorResponsePropertiesServerlog
func (t ConnectorResponseProperties) AsConnectorResponsePropertiesServerlog() (ConnectorResponsePropertiesServerlog, error) {
	var body ConnectorResponsePropertiesServerlog
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectorResponsePropertiesServerlog overwrites any union data inside the ConnectorResponseProperties as the provided ConnectorResponsePropertiesServerlog
func (t *ConnectorResponseProperties) FromConnectorResponsePropertiesServerlog(v ConnectorResponsePropertiesServerlog) error {
	v.ConnectorTypeId = ".server-log"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectorResponsePropertiesServerlog performs a merge with any union data inside the ConnectorResponseProperties, using the provided ConnectorResponsePropertiesServerlog
func (t *ConnectorResponseProperties) MergeConnectorResponsePropertiesServerlog(v ConnectorResponsePropertiesServerlog) error {
	v.ConnectorTypeId = ".server-log"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnectorResponsePropertiesServicenow returns the union data inside the ConnectorResponseProperties as a ConnectorResponsePropertiesServicenow
func (t ConnectorResponseProperties) AsConnectorResponsePropertiesServicenow() (ConnectorResponsePropertiesServicenow, error) {
	var body ConnectorResponsePropertiesServicenow
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectorResponsePropertiesServicenow overwrites any union data inside the ConnectorResponseProperties as the provided ConnectorResponsePropertiesServicenow
func (t *ConnectorResponseProperties) FromConnectorResponsePropertiesServicenow(v ConnectorResponsePropertiesServicenow) error {
	v.ConnectorTypeId = ".servicenow"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectorResponsePropertiesServicenow performs a merge with any union data inside the ConnectorResponseProperties, using the provided ConnectorResponsePropertiesServicenow
func (t *ConnectorResponseProperties) MergeConnectorResponsePropertiesServicenow(v ConnectorResponsePropertiesServicenow) error {
	v.ConnectorTypeId = ".servicenow"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnectorResponsePropertiesServicenowItom returns the union data inside the ConnectorResponseProperties as a ConnectorResponsePropertiesServicenowItom
func (t ConnectorResponseProperties) AsConnectorResponsePropertiesServicenowItom() (ConnectorResponsePropertiesServicenowItom, error) {
	var body ConnectorResponsePropertiesServicenowItom
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectorResponsePropertiesServicenowItom overwrites any union data inside the ConnectorResponseProperties as the provided ConnectorResponsePropertiesServicenowItom
func (t *ConnectorResponseProperties) FromConnectorResponsePropertiesServicenowItom(v ConnectorResponsePropertiesServicenowItom) error {
	v.ConnectorTypeId = ".servicenow-itom"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectorResponsePropertiesServicenowItom performs a merge with any union data inside the ConnectorResponseProperties, using the provided ConnectorResponsePropertiesServicenowItom
func (t *ConnectorResponseProperties) MergeConnectorResponsePropertiesServicenowItom(v ConnectorResponsePropertiesServicenowItom) error {
	v.ConnectorTypeId = ".servicenow-itom"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnectorResponsePropertiesServicenowSir returns the union data inside the ConnectorResponseProperties as a ConnectorResponsePropertiesServicenowSir
func (t ConnectorResponseProperties) AsConnectorResponsePropertiesServicenowSir() (ConnectorResponsePropertiesServicenowSir, error) {
	var body ConnectorResponsePropertiesServicenowSir
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectorResponsePropertiesServicenowSir overwrites any union data inside the ConnectorResponseProperties as the provided ConnectorResponsePropertiesServicenowSir
func (t *ConnectorResponseProperties) FromConnectorResponsePropertiesServicenowSir(v ConnectorResponsePropertiesServicenowSir) error {
	v.ConnectorTypeId = ".servicenow-sir"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectorResponsePropertiesServicenowSir performs a merge with any union data inside the ConnectorResponseProperties, using the provided ConnectorResponsePropertiesServicenowSir
func (t *ConnectorResponseProperties) MergeConnectorResponsePropertiesServicenowSir(v ConnectorResponsePropertiesServicenowSir) error {
	v.ConnectorTypeId = ".servicenow-sir"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnectorResponsePropertiesSlack returns the union data inside the ConnectorResponseProperties as a ConnectorResponsePropertiesSlack
func (t ConnectorResponseProperties) AsConnectorResponsePropertiesSlack() (ConnectorResponsePropertiesSlack, error) {
	var body ConnectorResponsePropertiesSlack
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectorResponsePropertiesSlack overwrites any union data inside the ConnectorResponseProperties as the provided ConnectorResponsePropertiesSlack
func (t *ConnectorResponseProperties) FromConnectorResponsePropertiesSlack(v ConnectorResponsePropertiesSlack) error {
	v.ConnectorTypeId = ".slack"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectorResponsePropertiesSlack performs a merge with any union data inside the ConnectorResponseProperties, using the provided ConnectorResponsePropertiesSlack
func (t *ConnectorResponseProperties) MergeConnectorResponsePropertiesSlack(v ConnectorResponsePropertiesSlack) error {
	v.ConnectorTypeId = ".slack"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnectorResponsePropertiesSlackApi returns the union data inside the ConnectorResponseProperties as a ConnectorResponsePropertiesSlackApi
func (t ConnectorResponseProperties) AsConnectorResponsePropertiesSlackApi() (ConnectorResponsePropertiesSlackApi, error) {
	var body ConnectorResponsePropertiesSlackApi
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectorResponsePropertiesSlackApi overwrites any union data inside the ConnectorResponseProperties as the provided ConnectorResponsePropertiesSlackApi
func (t *ConnectorResponseProperties) FromConnectorResponsePropertiesSlackApi(v ConnectorResponsePropertiesSlackApi) error {
	v.ConnectorTypeId = ".slack_api"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectorResponsePropertiesSlackApi performs a merge with any union data inside the ConnectorResponseProperties, using the provided ConnectorResponsePropertiesSlackApi
func (t *ConnectorResponseProperties) MergeConnectorResponsePropertiesSlackApi(v ConnectorResponsePropertiesSlackApi) error {
	v.ConnectorTypeId = ".slack_api"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnectorResponsePropertiesSwimlane returns the union data inside the ConnectorResponseProperties as a ConnectorResponsePropertiesSwimlane
func (t ConnectorResponseProperties) AsConnectorResponsePropertiesSwimlane() (ConnectorResponsePropertiesSwimlane, error) {
	var body ConnectorResponsePropertiesSwimlane
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectorResponsePropertiesSwimlane overwrites any union data inside the ConnectorResponseProperties as the provided ConnectorResponsePropertiesSwimlane
func (t *ConnectorResponseProperties) FromConnectorResponsePropertiesSwimlane(v ConnectorResponsePropertiesSwimlane) error {
	v.ConnectorTypeId = ".swimlane"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectorResponsePropertiesSwimlane performs a merge with any union data inside the ConnectorResponseProperties, using the provided ConnectorResponsePropertiesSwimlane
func (t *ConnectorResponseProperties) MergeConnectorResponsePropertiesSwimlane(v ConnectorResponsePropertiesSwimlane) error {
	v.ConnectorTypeId = ".swimlane"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnectorResponsePropertiesTeams returns the union data inside the ConnectorResponseProperties as a ConnectorResponsePropertiesTeams
func (t ConnectorResponseProperties) AsConnectorResponsePropertiesTeams() (ConnectorResponsePropertiesTeams, error) {
	var body ConnectorResponsePropertiesTeams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectorResponsePropertiesTeams overwrites any union data inside the ConnectorResponseProperties as the provided ConnectorResponsePropertiesTeams
func (t *ConnectorResponseProperties) FromConnectorResponsePropertiesTeams(v ConnectorResponsePropertiesTeams) error {
	v.ConnectorTypeId = ".teams"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectorResponsePropertiesTeams performs a merge with any union data inside the ConnectorResponseProperties, using the provided ConnectorResponsePropertiesTeams
func (t *ConnectorResponseProperties) MergeConnectorResponsePropertiesTeams(v ConnectorResponsePropertiesTeams) error {
	v.ConnectorTypeId = ".teams"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnectorResponsePropertiesTines returns the union data inside the ConnectorResponseProperties as a ConnectorResponsePropertiesTines
func (t ConnectorResponseProperties) AsConnectorResponsePropertiesTines() (ConnectorResponsePropertiesTines, error) {
	var body ConnectorResponsePropertiesTines
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectorResponsePropertiesTines overwrites any union data inside the ConnectorResponseProperties as the provided ConnectorResponsePropertiesTines
func (t *ConnectorResponseProperties) FromConnectorResponsePropertiesTines(v ConnectorResponsePropertiesTines) error {
	v.ConnectorTypeId = ".tines"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectorResponsePropertiesTines performs a merge with any union data inside the ConnectorResponseProperties, using the provided ConnectorResponsePropertiesTines
func (t *ConnectorResponseProperties) MergeConnectorResponsePropertiesTines(v ConnectorResponsePropertiesTines) error {
	v.ConnectorTypeId = ".tines"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnectorResponsePropertiesWebhook returns the union data inside the ConnectorResponseProperties as a ConnectorResponsePropertiesWebhook
func (t ConnectorResponseProperties) AsConnectorResponsePropertiesWebhook() (ConnectorResponsePropertiesWebhook, error) {
	var body ConnectorResponsePropertiesWebhook
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectorResponsePropertiesWebhook overwrites any union data inside the ConnectorResponseProperties as the provided ConnectorResponsePropertiesWebhook
func (t *ConnectorResponseProperties) FromConnectorResponsePropertiesWebhook(v ConnectorResponsePropertiesWebhook) error {
	v.ConnectorTypeId = ".webhook"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectorResponsePropertiesWebhook performs a merge with any union data inside the ConnectorResponseProperties, using the provided ConnectorResponsePropertiesWebhook
func (t *ConnectorResponseProperties) MergeConnectorResponsePropertiesWebhook(v ConnectorResponsePropertiesWebhook) error {
	v.ConnectorTypeId = ".webhook"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsConnectorResponsePropertiesXmatters returns the union data inside the ConnectorResponseProperties as a ConnectorResponsePropertiesXmatters
func (t ConnectorResponseProperties) AsConnectorResponsePropertiesXmatters() (ConnectorResponsePropertiesXmatters, error) {
	var body ConnectorResponsePropertiesXmatters
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromConnectorResponsePropertiesXmatters overwrites any union data inside the ConnectorResponseProperties as the provided ConnectorResponsePropertiesXmatters
func (t *ConnectorResponseProperties) FromConnectorResponsePropertiesXmatters(v ConnectorResponsePropertiesXmatters) error {
	v.ConnectorTypeId = ".xmatters"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeConnectorResponsePropertiesXmatters performs a merge with any union data inside the ConnectorResponseProperties, using the provided ConnectorResponsePropertiesXmatters
func (t *ConnectorResponseProperties) MergeConnectorResponsePropertiesXmatters(v ConnectorResponsePropertiesXmatters) error {
	v.ConnectorTypeId = ".xmatters"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ConnectorResponseProperties) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"connector_type_id"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t ConnectorResponseProperties) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case ".cases-webhook":
		return t.AsConnectorResponsePropertiesCasesWebhook()
	case ".email":
		return t.AsConnectorResponsePropertiesEmail()
	case ".gemini":
		return t.AsConnectorResponsePropertiesGemini()
	case ".index":
		return t.AsConnectorResponsePropertiesIndex()
	case ".jira":
		return t.AsConnectorResponsePropertiesJira()
	case ".opsgenie":
		return t.AsConnectorResponsePropertiesOpsgenie()
	case ".pagerduty":
		return t.AsConnectorResponsePropertiesPagerduty()
	case ".resilient":
		return t.AsConnectorResponsePropertiesResilient()
	case ".server-log":
		return t.AsConnectorResponsePropertiesServerlog()
	case ".servicenow":
		return t.AsConnectorResponsePropertiesServicenow()
	case ".servicenow-itom":
		return t.AsConnectorResponsePropertiesServicenowItom()
	case ".servicenow-sir":
		return t.AsConnectorResponsePropertiesServicenowSir()
	case ".slack":
		return t.AsConnectorResponsePropertiesSlack()
	case ".slack_api":
		return t.AsConnectorResponsePropertiesSlackApi()
	case ".swimlane":
		return t.AsConnectorResponsePropertiesSwimlane()
	case ".teams":
		return t.AsConnectorResponsePropertiesTeams()
	case ".tines":
		return t.AsConnectorResponsePropertiesTines()
	case ".webhook":
		return t.AsConnectorResponsePropertiesWebhook()
	case ".xmatters":
		return t.AsConnectorResponsePropertiesXmatters()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t ConnectorResponseProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ConnectorResponseProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLegacyRunConnectorGeneralResponseData0 returns the union data inside the LegacyRunConnectorGeneralResponse_Data as a LegacyRunConnectorGeneralResponseData0
func (t LegacyRunConnectorGeneralResponse_Data) AsLegacyRunConnectorGeneralResponseData0() (LegacyRunConnectorGeneralResponseData0, error) {
	var body LegacyRunConnectorGeneralResponseData0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLegacyRunConnectorGeneralResponseData0 overwrites any union data inside the LegacyRunConnectorGeneralResponse_Data as the provided LegacyRunConnectorGeneralResponseData0
func (t *LegacyRunConnectorGeneralResponse_Data) FromLegacyRunConnectorGeneralResponseData0(v LegacyRunConnectorGeneralResponseData0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLegacyRunConnectorGeneralResponseData0 performs a merge with any union data inside the LegacyRunConnectorGeneralResponse_Data, using the provided LegacyRunConnectorGeneralResponseData0
func (t *LegacyRunConnectorGeneralResponse_Data) MergeLegacyRunConnectorGeneralResponseData0(v LegacyRunConnectorGeneralResponseData0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLegacyRunConnectorGeneralResponseData1 returns the union data inside the LegacyRunConnectorGeneralResponse_Data as a LegacyRunConnectorGeneralResponseData1
func (t LegacyRunConnectorGeneralResponse_Data) AsLegacyRunConnectorGeneralResponseData1() (LegacyRunConnectorGeneralResponseData1, error) {
	var body LegacyRunConnectorGeneralResponseData1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLegacyRunConnectorGeneralResponseData1 overwrites any union data inside the LegacyRunConnectorGeneralResponse_Data as the provided LegacyRunConnectorGeneralResponseData1
func (t *LegacyRunConnectorGeneralResponse_Data) FromLegacyRunConnectorGeneralResponseData1(v LegacyRunConnectorGeneralResponseData1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLegacyRunConnectorGeneralResponseData1 performs a merge with any union data inside the LegacyRunConnectorGeneralResponse_Data, using the provided LegacyRunConnectorGeneralResponseData1
func (t *LegacyRunConnectorGeneralResponse_Data) MergeLegacyRunConnectorGeneralResponseData1(v LegacyRunConnectorGeneralResponseData1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t LegacyRunConnectorGeneralResponse_Data) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *LegacyRunConnectorGeneralResponse_Data) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRunConnectorGeneralResponseData0 returns the union data inside the RunConnectorGeneralResponse_Data as a RunConnectorGeneralResponseData0
func (t RunConnectorGeneralResponse_Data) AsRunConnectorGeneralResponseData0() (RunConnectorGeneralResponseData0, error) {
	var body RunConnectorGeneralResponseData0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunConnectorGeneralResponseData0 overwrites any union data inside the RunConnectorGeneralResponse_Data as the provided RunConnectorGeneralResponseData0
func (t *RunConnectorGeneralResponse_Data) FromRunConnectorGeneralResponseData0(v RunConnectorGeneralResponseData0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunConnectorGeneralResponseData0 performs a merge with any union data inside the RunConnectorGeneralResponse_Data, using the provided RunConnectorGeneralResponseData0
func (t *RunConnectorGeneralResponse_Data) MergeRunConnectorGeneralResponseData0(v RunConnectorGeneralResponseData0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRunConnectorGeneralResponseData1 returns the union data inside the RunConnectorGeneralResponse_Data as a RunConnectorGeneralResponseData1
func (t RunConnectorGeneralResponse_Data) AsRunConnectorGeneralResponseData1() (RunConnectorGeneralResponseData1, error) {
	var body RunConnectorGeneralResponseData1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunConnectorGeneralResponseData1 overwrites any union data inside the RunConnectorGeneralResponse_Data as the provided RunConnectorGeneralResponseData1
func (t *RunConnectorGeneralResponse_Data) FromRunConnectorGeneralResponseData1(v RunConnectorGeneralResponseData1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunConnectorGeneralResponseData1 performs a merge with any union data inside the RunConnectorGeneralResponse_Data, using the provided RunConnectorGeneralResponseData1
func (t *RunConnectorGeneralResponse_Data) MergeRunConnectorGeneralResponseData1(v RunConnectorGeneralResponseData1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RunConnectorGeneralResponse_Data) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RunConnectorGeneralResponse_Data) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp0 returns the union data inside the RunConnectorSubactionPushtoservice_SubActionParams_Incident_DestIp as a RunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp0
func (t RunConnectorSubactionPushtoservice_SubActionParams_Incident_DestIp) AsRunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp0() (RunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp0, error) {
	var body RunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp0 overwrites any union data inside the RunConnectorSubactionPushtoservice_SubActionParams_Incident_DestIp as the provided RunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp0
func (t *RunConnectorSubactionPushtoservice_SubActionParams_Incident_DestIp) FromRunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp0(v RunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp0 performs a merge with any union data inside the RunConnectorSubactionPushtoservice_SubActionParams_Incident_DestIp, using the provided RunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp0
func (t *RunConnectorSubactionPushtoservice_SubActionParams_Incident_DestIp) MergeRunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp0(v RunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp1 returns the union data inside the RunConnectorSubactionPushtoservice_SubActionParams_Incident_DestIp as a RunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp1
func (t RunConnectorSubactionPushtoservice_SubActionParams_Incident_DestIp) AsRunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp1() (RunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp1, error) {
	var body RunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp1 overwrites any union data inside the RunConnectorSubactionPushtoservice_SubActionParams_Incident_DestIp as the provided RunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp1
func (t *RunConnectorSubactionPushtoservice_SubActionParams_Incident_DestIp) FromRunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp1(v RunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp1 performs a merge with any union data inside the RunConnectorSubactionPushtoservice_SubActionParams_Incident_DestIp, using the provided RunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp1
func (t *RunConnectorSubactionPushtoservice_SubActionParams_Incident_DestIp) MergeRunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp1(v RunConnectorSubactionPushtoserviceSubActionParamsIncidentDestIp1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RunConnectorSubactionPushtoservice_SubActionParams_Incident_DestIp) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RunConnectorSubactionPushtoservice_SubActionParams_Incident_DestIp) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash0 returns the union data inside the RunConnectorSubactionPushtoservice_SubActionParams_Incident_MalwareHash as a RunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash0
func (t RunConnectorSubactionPushtoservice_SubActionParams_Incident_MalwareHash) AsRunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash0() (RunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash0, error) {
	var body RunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash0 overwrites any union data inside the RunConnectorSubactionPushtoservice_SubActionParams_Incident_MalwareHash as the provided RunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash0
func (t *RunConnectorSubactionPushtoservice_SubActionParams_Incident_MalwareHash) FromRunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash0(v RunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash0 performs a merge with any union data inside the RunConnectorSubactionPushtoservice_SubActionParams_Incident_MalwareHash, using the provided RunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash0
func (t *RunConnectorSubactionPushtoservice_SubActionParams_Incident_MalwareHash) MergeRunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash0(v RunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash1 returns the union data inside the RunConnectorSubactionPushtoservice_SubActionParams_Incident_MalwareHash as a RunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash1
func (t RunConnectorSubactionPushtoservice_SubActionParams_Incident_MalwareHash) AsRunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash1() (RunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash1, error) {
	var body RunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash1 overwrites any union data inside the RunConnectorSubactionPushtoservice_SubActionParams_Incident_MalwareHash as the provided RunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash1
func (t *RunConnectorSubactionPushtoservice_SubActionParams_Incident_MalwareHash) FromRunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash1(v RunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash1 performs a merge with any union data inside the RunConnectorSubactionPushtoservice_SubActionParams_Incident_MalwareHash, using the provided RunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash1
func (t *RunConnectorSubactionPushtoservice_SubActionParams_Incident_MalwareHash) MergeRunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash1(v RunConnectorSubactionPushtoserviceSubActionParamsIncidentMalwareHash1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RunConnectorSubactionPushtoservice_SubActionParams_Incident_MalwareHash) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RunConnectorSubactionPushtoservice_SubActionParams_Incident_MalwareHash) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsRunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp0 returns the union data inside the RunConnectorSubactionPushtoservice_SubActionParams_Incident_SourceIp as a RunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp0
func (t RunConnectorSubactionPushtoservice_SubActionParams_Incident_SourceIp) AsRunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp0() (RunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp0, error) {
	var body RunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp0 overwrites any union data inside the RunConnectorSubactionPushtoservice_SubActionParams_Incident_SourceIp as the provided RunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp0
func (t *RunConnectorSubactionPushtoservice_SubActionParams_Incident_SourceIp) FromRunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp0(v RunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp0 performs a merge with any union data inside the RunConnectorSubactionPushtoservice_SubActionParams_Incident_SourceIp, using the provided RunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp0
func (t *RunConnectorSubactionPushtoservice_SubActionParams_Incident_SourceIp) MergeRunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp0(v RunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsRunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp1 returns the union data inside the RunConnectorSubactionPushtoservice_SubActionParams_Incident_SourceIp as a RunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp1
func (t RunConnectorSubactionPushtoservice_SubActionParams_Incident_SourceIp) AsRunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp1() (RunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp1, error) {
	var body RunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp1 overwrites any union data inside the RunConnectorSubactionPushtoservice_SubActionParams_Incident_SourceIp as the provided RunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp1
func (t *RunConnectorSubactionPushtoservice_SubActionParams_Incident_SourceIp) FromRunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp1(v RunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp1 performs a merge with any union data inside the RunConnectorSubactionPushtoservice_SubActionParams_Incident_SourceIp, using the provided RunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp1
func (t *RunConnectorSubactionPushtoservice_SubActionParams_Incident_SourceIp) MergeRunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp1(v RunConnectorSubactionPushtoserviceSubActionParamsIncidentSourceIp1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t RunConnectorSubactionPushtoservice_SubActionParams_Incident_SourceIp) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *RunConnectorSubactionPushtoservice_SubActionParams_Incident_SourceIp) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// LegacyGetConnectors request
	LegacyGetConnectors(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LegacyCreateConnectorWithBody request with any body
	LegacyCreateConnectorWithBody(ctx context.Context, spaceId SpaceId, params *LegacyCreateConnectorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LegacyCreateConnector(ctx context.Context, spaceId SpaceId, params *LegacyCreateConnectorParams, body LegacyCreateConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LegacyDeleteConnector request
	LegacyDeleteConnector(ctx context.Context, spaceId SpaceId, actionId ActionId, params *LegacyDeleteConnectorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LegacyGetConnector request
	LegacyGetConnector(ctx context.Context, spaceId SpaceId, actionId ActionId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LegacyUpdateConnectorWithBody request with any body
	LegacyUpdateConnectorWithBody(ctx context.Context, spaceId SpaceId, actionId ActionId, params *LegacyUpdateConnectorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LegacyUpdateConnector(ctx context.Context, spaceId SpaceId, actionId ActionId, params *LegacyUpdateConnectorParams, body LegacyUpdateConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LegacyRunConnectorWithBody request with any body
	LegacyRunConnectorWithBody(ctx context.Context, spaceId SpaceId, actionId ActionId, params *LegacyRunConnectorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LegacyRunConnector(ctx context.Context, spaceId SpaceId, actionId ActionId, params *LegacyRunConnectorParams, body LegacyRunConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateConnectorWithBody request with any body
	CreateConnectorWithBody(ctx context.Context, spaceId SpaceId, params *CreateConnectorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateConnector(ctx context.Context, spaceId SpaceId, params *CreateConnectorParams, body CreateConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteConnector request
	DeleteConnector(ctx context.Context, spaceId SpaceId, connectorId ConnectorId, params *DeleteConnectorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConnector request
	GetConnector(ctx context.Context, spaceId SpaceId, connectorId ConnectorId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateConnectorWithBody request with any body
	UpdateConnectorWithBody(ctx context.Context, spaceId SpaceId, connectorId ConnectorId, params *UpdateConnectorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateConnector(ctx context.Context, spaceId SpaceId, connectorId ConnectorId, params *UpdateConnectorParams, body UpdateConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RunConnectorWithBody request with any body
	RunConnectorWithBody(ctx context.Context, spaceId SpaceId, connectorId ConnectorId, params *RunConnectorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RunConnector(ctx context.Context, spaceId SpaceId, connectorId ConnectorId, params *RunConnectorParams, body RunConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConnectorTypes request
	GetConnectorTypes(ctx context.Context, spaceId SpaceId, params *GetConnectorTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConnectors request
	GetConnectors(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LegacyGetConnectorTypes request
	LegacyGetConnectorTypes(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) LegacyGetConnectors(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLegacyGetConnectorsRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LegacyCreateConnectorWithBody(ctx context.Context, spaceId SpaceId, params *LegacyCreateConnectorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLegacyCreateConnectorRequestWithBody(c.Server, spaceId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LegacyCreateConnector(ctx context.Context, spaceId SpaceId, params *LegacyCreateConnectorParams, body LegacyCreateConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLegacyCreateConnectorRequest(c.Server, spaceId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LegacyDeleteConnector(ctx context.Context, spaceId SpaceId, actionId ActionId, params *LegacyDeleteConnectorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLegacyDeleteConnectorRequest(c.Server, spaceId, actionId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LegacyGetConnector(ctx context.Context, spaceId SpaceId, actionId ActionId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLegacyGetConnectorRequest(c.Server, spaceId, actionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LegacyUpdateConnectorWithBody(ctx context.Context, spaceId SpaceId, actionId ActionId, params *LegacyUpdateConnectorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLegacyUpdateConnectorRequestWithBody(c.Server, spaceId, actionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LegacyUpdateConnector(ctx context.Context, spaceId SpaceId, actionId ActionId, params *LegacyUpdateConnectorParams, body LegacyUpdateConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLegacyUpdateConnectorRequest(c.Server, spaceId, actionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LegacyRunConnectorWithBody(ctx context.Context, spaceId SpaceId, actionId ActionId, params *LegacyRunConnectorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLegacyRunConnectorRequestWithBody(c.Server, spaceId, actionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LegacyRunConnector(ctx context.Context, spaceId SpaceId, actionId ActionId, params *LegacyRunConnectorParams, body LegacyRunConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLegacyRunConnectorRequest(c.Server, spaceId, actionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConnectorWithBody(ctx context.Context, spaceId SpaceId, params *CreateConnectorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConnectorRequestWithBody(c.Server, spaceId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateConnector(ctx context.Context, spaceId SpaceId, params *CreateConnectorParams, body CreateConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateConnectorRequest(c.Server, spaceId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteConnector(ctx context.Context, spaceId SpaceId, connectorId ConnectorId, params *DeleteConnectorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteConnectorRequest(c.Server, spaceId, connectorId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConnector(ctx context.Context, spaceId SpaceId, connectorId ConnectorId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConnectorRequest(c.Server, spaceId, connectorId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConnectorWithBody(ctx context.Context, spaceId SpaceId, connectorId ConnectorId, params *UpdateConnectorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConnectorRequestWithBody(c.Server, spaceId, connectorId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConnector(ctx context.Context, spaceId SpaceId, connectorId ConnectorId, params *UpdateConnectorParams, body UpdateConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConnectorRequest(c.Server, spaceId, connectorId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunConnectorWithBody(ctx context.Context, spaceId SpaceId, connectorId ConnectorId, params *RunConnectorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunConnectorRequestWithBody(c.Server, spaceId, connectorId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RunConnector(ctx context.Context, spaceId SpaceId, connectorId ConnectorId, params *RunConnectorParams, body RunConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRunConnectorRequest(c.Server, spaceId, connectorId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConnectorTypes(ctx context.Context, spaceId SpaceId, params *GetConnectorTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConnectorTypesRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConnectors(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConnectorsRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LegacyGetConnectorTypes(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLegacyGetConnectorTypesRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewLegacyGetConnectorsRequest generates requests for LegacyGetConnectors
func NewLegacyGetConnectorsRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/actions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLegacyCreateConnectorRequest calls the generic LegacyCreateConnector builder with application/json body
func NewLegacyCreateConnectorRequest(server string, spaceId SpaceId, params *LegacyCreateConnectorParams, body LegacyCreateConnectorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLegacyCreateConnectorRequestWithBody(server, spaceId, params, "application/json", bodyReader)
}

// NewLegacyCreateConnectorRequestWithBody generates requests for LegacyCreateConnector with any type of body
func NewLegacyCreateConnectorRequestWithBody(server string, spaceId SpaceId, params *LegacyCreateConnectorParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/actions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "kbn-xsrf", runtime.ParamLocationHeader, params.KbnXsrf)
		if err != nil {
			return nil, err
		}

		req.Header.Set("kbn-xsrf", headerParam0)

	}

	return req, nil
}

// NewLegacyDeleteConnectorRequest generates requests for LegacyDeleteConnector
func NewLegacyDeleteConnectorRequest(server string, spaceId SpaceId, actionId ActionId, params *LegacyDeleteConnectorParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "actionId", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/actions/action/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "kbn-xsrf", runtime.ParamLocationHeader, params.KbnXsrf)
		if err != nil {
			return nil, err
		}

		req.Header.Set("kbn-xsrf", headerParam0)

	}

	return req, nil
}

// NewLegacyGetConnectorRequest generates requests for LegacyGetConnector
func NewLegacyGetConnectorRequest(server string, spaceId SpaceId, actionId ActionId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "actionId", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/actions/action/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLegacyUpdateConnectorRequest calls the generic LegacyUpdateConnector builder with application/json body
func NewLegacyUpdateConnectorRequest(server string, spaceId SpaceId, actionId ActionId, params *LegacyUpdateConnectorParams, body LegacyUpdateConnectorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLegacyUpdateConnectorRequestWithBody(server, spaceId, actionId, params, "application/json", bodyReader)
}

// NewLegacyUpdateConnectorRequestWithBody generates requests for LegacyUpdateConnector with any type of body
func NewLegacyUpdateConnectorRequestWithBody(server string, spaceId SpaceId, actionId ActionId, params *LegacyUpdateConnectorParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "actionId", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/actions/action/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "kbn-xsrf", runtime.ParamLocationHeader, params.KbnXsrf)
		if err != nil {
			return nil, err
		}

		req.Header.Set("kbn-xsrf", headerParam0)

	}

	return req, nil
}

// NewLegacyRunConnectorRequest calls the generic LegacyRunConnector builder with application/json body
func NewLegacyRunConnectorRequest(server string, spaceId SpaceId, actionId ActionId, params *LegacyRunConnectorParams, body LegacyRunConnectorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLegacyRunConnectorRequestWithBody(server, spaceId, actionId, params, "application/json", bodyReader)
}

// NewLegacyRunConnectorRequestWithBody generates requests for LegacyRunConnector with any type of body
func NewLegacyRunConnectorRequestWithBody(server string, spaceId SpaceId, actionId ActionId, params *LegacyRunConnectorParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "actionId", runtime.ParamLocationPath, actionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/actions/action/%s/_execute", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "kbn-xsrf", runtime.ParamLocationHeader, params.KbnXsrf)
		if err != nil {
			return nil, err
		}

		req.Header.Set("kbn-xsrf", headerParam0)

	}

	return req, nil
}

// NewCreateConnectorRequest calls the generic CreateConnector builder with application/json body
func NewCreateConnectorRequest(server string, spaceId SpaceId, params *CreateConnectorParams, body CreateConnectorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateConnectorRequestWithBody(server, spaceId, params, "application/json", bodyReader)
}

// NewCreateConnectorRequestWithBody generates requests for CreateConnector with any type of body
func NewCreateConnectorRequestWithBody(server string, spaceId SpaceId, params *CreateConnectorParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/actions/connector", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "kbn-xsrf", runtime.ParamLocationHeader, params.KbnXsrf)
		if err != nil {
			return nil, err
		}

		req.Header.Set("kbn-xsrf", headerParam0)

	}

	return req, nil
}

// NewDeleteConnectorRequest generates requests for DeleteConnector
func NewDeleteConnectorRequest(server string, spaceId SpaceId, connectorId ConnectorId, params *DeleteConnectorParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "connectorId", runtime.ParamLocationPath, connectorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/actions/connector/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "kbn-xsrf", runtime.ParamLocationHeader, params.KbnXsrf)
		if err != nil {
			return nil, err
		}

		req.Header.Set("kbn-xsrf", headerParam0)

	}

	return req, nil
}

// NewGetConnectorRequest generates requests for GetConnector
func NewGetConnectorRequest(server string, spaceId SpaceId, connectorId ConnectorId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "connectorId", runtime.ParamLocationPath, connectorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/actions/connector/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateConnectorRequest calls the generic UpdateConnector builder with application/json body
func NewUpdateConnectorRequest(server string, spaceId SpaceId, connectorId ConnectorId, params *UpdateConnectorParams, body UpdateConnectorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateConnectorRequestWithBody(server, spaceId, connectorId, params, "application/json", bodyReader)
}

// NewUpdateConnectorRequestWithBody generates requests for UpdateConnector with any type of body
func NewUpdateConnectorRequestWithBody(server string, spaceId SpaceId, connectorId ConnectorId, params *UpdateConnectorParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "connectorId", runtime.ParamLocationPath, connectorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/actions/connector/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "kbn-xsrf", runtime.ParamLocationHeader, params.KbnXsrf)
		if err != nil {
			return nil, err
		}

		req.Header.Set("kbn-xsrf", headerParam0)

	}

	return req, nil
}

// NewRunConnectorRequest calls the generic RunConnector builder with application/json body
func NewRunConnectorRequest(server string, spaceId SpaceId, connectorId ConnectorId, params *RunConnectorParams, body RunConnectorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRunConnectorRequestWithBody(server, spaceId, connectorId, params, "application/json", bodyReader)
}

// NewRunConnectorRequestWithBody generates requests for RunConnector with any type of body
func NewRunConnectorRequestWithBody(server string, spaceId SpaceId, connectorId ConnectorId, params *RunConnectorParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "connectorId", runtime.ParamLocationPath, connectorId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/actions/connector/%s/_execute", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "kbn-xsrf", runtime.ParamLocationHeader, params.KbnXsrf)
		if err != nil {
			return nil, err
		}

		req.Header.Set("kbn-xsrf", headerParam0)

	}

	return req, nil
}

// NewGetConnectorTypesRequest generates requests for GetConnectorTypes
func NewGetConnectorTypesRequest(server string, spaceId SpaceId, params *GetConnectorTypesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/actions/connector_types", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FeatureId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "feature_id", runtime.ParamLocationQuery, *params.FeatureId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetConnectorsRequest generates requests for GetConnectors
func NewGetConnectorsRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/actions/connectors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLegacyGetConnectorTypesRequest generates requests for LegacyGetConnectorTypes
func NewLegacyGetConnectorTypesRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/actions/list_action_types", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// LegacyGetConnectorsWithResponse request
	LegacyGetConnectorsWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*LegacyGetConnectorsResponse, error)

	// LegacyCreateConnectorWithBodyWithResponse request with any body
	LegacyCreateConnectorWithBodyWithResponse(ctx context.Context, spaceId SpaceId, params *LegacyCreateConnectorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LegacyCreateConnectorResponse, error)

	LegacyCreateConnectorWithResponse(ctx context.Context, spaceId SpaceId, params *LegacyCreateConnectorParams, body LegacyCreateConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*LegacyCreateConnectorResponse, error)

	// LegacyDeleteConnectorWithResponse request
	LegacyDeleteConnectorWithResponse(ctx context.Context, spaceId SpaceId, actionId ActionId, params *LegacyDeleteConnectorParams, reqEditors ...RequestEditorFn) (*LegacyDeleteConnectorResponse, error)

	// LegacyGetConnectorWithResponse request
	LegacyGetConnectorWithResponse(ctx context.Context, spaceId SpaceId, actionId ActionId, reqEditors ...RequestEditorFn) (*LegacyGetConnectorResponse, error)

	// LegacyUpdateConnectorWithBodyWithResponse request with any body
	LegacyUpdateConnectorWithBodyWithResponse(ctx context.Context, spaceId SpaceId, actionId ActionId, params *LegacyUpdateConnectorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LegacyUpdateConnectorResponse, error)

	LegacyUpdateConnectorWithResponse(ctx context.Context, spaceId SpaceId, actionId ActionId, params *LegacyUpdateConnectorParams, body LegacyUpdateConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*LegacyUpdateConnectorResponse, error)

	// LegacyRunConnectorWithBodyWithResponse request with any body
	LegacyRunConnectorWithBodyWithResponse(ctx context.Context, spaceId SpaceId, actionId ActionId, params *LegacyRunConnectorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LegacyRunConnectorResponse, error)

	LegacyRunConnectorWithResponse(ctx context.Context, spaceId SpaceId, actionId ActionId, params *LegacyRunConnectorParams, body LegacyRunConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*LegacyRunConnectorResponse, error)

	// CreateConnectorWithBodyWithResponse request with any body
	CreateConnectorWithBodyWithResponse(ctx context.Context, spaceId SpaceId, params *CreateConnectorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConnectorResponse, error)

	CreateConnectorWithResponse(ctx context.Context, spaceId SpaceId, params *CreateConnectorParams, body CreateConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConnectorResponse, error)

	// DeleteConnectorWithResponse request
	DeleteConnectorWithResponse(ctx context.Context, spaceId SpaceId, connectorId ConnectorId, params *DeleteConnectorParams, reqEditors ...RequestEditorFn) (*DeleteConnectorResponse, error)

	// GetConnectorWithResponse request
	GetConnectorWithResponse(ctx context.Context, spaceId SpaceId, connectorId ConnectorId, reqEditors ...RequestEditorFn) (*GetConnectorResponse, error)

	// UpdateConnectorWithBodyWithResponse request with any body
	UpdateConnectorWithBodyWithResponse(ctx context.Context, spaceId SpaceId, connectorId ConnectorId, params *UpdateConnectorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConnectorResponse, error)

	UpdateConnectorWithResponse(ctx context.Context, spaceId SpaceId, connectorId ConnectorId, params *UpdateConnectorParams, body UpdateConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConnectorResponse, error)

	// RunConnectorWithBodyWithResponse request with any body
	RunConnectorWithBodyWithResponse(ctx context.Context, spaceId SpaceId, connectorId ConnectorId, params *RunConnectorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunConnectorResponse, error)

	RunConnectorWithResponse(ctx context.Context, spaceId SpaceId, connectorId ConnectorId, params *RunConnectorParams, body RunConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*RunConnectorResponse, error)

	// GetConnectorTypesWithResponse request
	GetConnectorTypesWithResponse(ctx context.Context, spaceId SpaceId, params *GetConnectorTypesParams, reqEditors ...RequestEditorFn) (*GetConnectorTypesResponse, error)

	// GetConnectorsWithResponse request
	GetConnectorsWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*GetConnectorsResponse, error)

	// LegacyGetConnectorTypesWithResponse request
	LegacyGetConnectorTypesWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*LegacyGetConnectorTypesResponse, error)
}

type LegacyGetConnectorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ActionResponseProperties
	JSON401      *AuthorizationError
}

// Status returns HTTPResponse.Status
func (r LegacyGetConnectorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LegacyGetConnectorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LegacyCreateConnectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *N200Actions
	JSON401      *AuthorizationError
}

// Status returns HTTPResponse.Status
func (r LegacyCreateConnectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LegacyCreateConnectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LegacyDeleteConnectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *AuthorizationError
}

// Status returns HTTPResponse.Status
func (r LegacyDeleteConnectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LegacyDeleteConnectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LegacyGetConnectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *N200Actions
	JSON401      *AuthorizationError
}

// Status returns HTTPResponse.Status
func (r LegacyGetConnectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LegacyGetConnectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LegacyUpdateConnectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *N200Actions
	JSON404      *ObjectNotFoundError
}

// Status returns HTTPResponse.Status
func (r LegacyUpdateConnectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LegacyUpdateConnectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LegacyRunConnectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LegacyRunConnectorGeneralResponse
	JSON401      *AuthorizationError
}

// Status returns HTTPResponse.Status
func (r LegacyRunConnectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LegacyRunConnectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateConnectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConnectorResponseProperties
	JSON400      *BadRequestError
	JSON401      *AuthorizationError
}

// Status returns HTTPResponse.Status
func (r CreateConnectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateConnectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteConnectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *AuthorizationError
	JSON404      *struct {
		Error      *string `json:"error,omitempty"`
		Message    *string `json:"message,omitempty"`
		StatusCode *int    `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteConnectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteConnectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConnectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConnectorResponseProperties
	JSON401      *AuthorizationError
	JSON404      *struct {
		Error      *string `json:"error,omitempty"`
		Message    *string `json:"message,omitempty"`
		StatusCode *int    `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetConnectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConnectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateConnectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConnectorResponseProperties
	JSON400      *BadRequestError
	JSON401      *AuthorizationError
	JSON404      *ObjectNotFoundError
}

// Status returns HTTPResponse.Status
func (r UpdateConnectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConnectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RunConnectorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RunConnectorGeneralResponse
	JSON401      *AuthorizationError
}

// Status returns HTTPResponse.Status
func (r RunConnectorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RunConnectorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConnectorTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Enabled Indicates whether the connector type is enabled in Kibana.
		Enabled *bool `json:"enabled,omitempty"`

		// EnabledInConfig Indicates whether the connector type is enabled in the Kibana `.yml` file.
		EnabledInConfig *bool `json:"enabled_in_config,omitempty"`

		// EnabledInLicense Indicates whether the connector is enabled in the license.
		EnabledInLicense *bool `json:"enabled_in_license,omitempty"`

		// Id The type of connector. For example, `.email`, `.index`, `.jira`, `.opsgenie`, or `.server-log`.
		Id *ConnectorTypes `json:"id,omitempty"`

		// MinimumLicenseRequired The license that is required to use the connector type.
		MinimumLicenseRequired *string `json:"minimum_license_required,omitempty"`

		// Name The name of the connector type.
		Name *string `json:"name,omitempty"`

		// SupportedFeatureIds The Kibana features that are supported by the connector type.
		SupportedFeatureIds *[]Features `json:"supported_feature_ids,omitempty"`
	}
	JSON401 *AuthorizationError
}

// Status returns HTTPResponse.Status
func (r GetConnectorTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConnectorTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConnectorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Config The configuration for the connector. Configuration properties vary depending on the connector type.
		Config *map[string]interface{} `json:"config"`

		// ConnectorTypeId The type of connector. For example, `.email`, `.index`, `.jira`, `.opsgenie`, or `.server-log`.
		ConnectorTypeId ConnectorTypes `json:"connector_type_id"`

		// Id The identifier for the connector.
		Id string `json:"id"`

		// IsDeprecated Indicates whether the connector type is deprecated.
		IsDeprecated *IsDeprecated `json:"is_deprecated,omitempty"`

		// IsMissingSecrets Indicates whether secrets are missing for the connector. Secrets configuration properties vary depending on the connector type.
		IsMissingSecrets *IsMissingSecrets `json:"is_missing_secrets,omitempty"`

		// IsPreconfigured Indicates whether it is a preconfigured connector. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
		IsPreconfigured IsPreconfigured `json:"is_preconfigured"`

		// Name The display name for the connector.
		Name string `json:"name"`

		// ReferencedByCount Indicates the number of saved objects that reference the connector. If `is_preconfigured` is true, this value is not calculated.
		ReferencedByCount int `json:"referenced_by_count"`
	}
	JSON401 *AuthorizationError
}

// Status returns HTTPResponse.Status
func (r GetConnectorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConnectorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LegacyGetConnectorTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// Enabled Indicates whether the connector type is enabled in Kibana.
		Enabled *bool `json:"enabled,omitempty"`

		// EnabledInConfig Indicates whether the connector type is enabled in the Kibana `.yml` file.
		EnabledInConfig *bool `json:"enabledInConfig,omitempty"`

		// EnabledInLicense Indicates whether the connector is enabled in the license.
		EnabledInLicense *bool `json:"enabledInLicense,omitempty"`

		// Id The unique identifier for the connector type.
		Id *string `json:"id,omitempty"`

		// MinimumLicenseRequired The license that is required to use the connector type.
		MinimumLicenseRequired *string `json:"minimumLicenseRequired,omitempty"`

		// Name The name of the connector type.
		Name *string `json:"name,omitempty"`
	}
	JSON401 *AuthorizationError
}

// Status returns HTTPResponse.Status
func (r LegacyGetConnectorTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LegacyGetConnectorTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// LegacyGetConnectorsWithResponse request returning *LegacyGetConnectorsResponse
func (c *ClientWithResponses) LegacyGetConnectorsWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*LegacyGetConnectorsResponse, error) {
	rsp, err := c.LegacyGetConnectors(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLegacyGetConnectorsResponse(rsp)
}

// LegacyCreateConnectorWithBodyWithResponse request with arbitrary body returning *LegacyCreateConnectorResponse
func (c *ClientWithResponses) LegacyCreateConnectorWithBodyWithResponse(ctx context.Context, spaceId SpaceId, params *LegacyCreateConnectorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LegacyCreateConnectorResponse, error) {
	rsp, err := c.LegacyCreateConnectorWithBody(ctx, spaceId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLegacyCreateConnectorResponse(rsp)
}

func (c *ClientWithResponses) LegacyCreateConnectorWithResponse(ctx context.Context, spaceId SpaceId, params *LegacyCreateConnectorParams, body LegacyCreateConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*LegacyCreateConnectorResponse, error) {
	rsp, err := c.LegacyCreateConnector(ctx, spaceId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLegacyCreateConnectorResponse(rsp)
}

// LegacyDeleteConnectorWithResponse request returning *LegacyDeleteConnectorResponse
func (c *ClientWithResponses) LegacyDeleteConnectorWithResponse(ctx context.Context, spaceId SpaceId, actionId ActionId, params *LegacyDeleteConnectorParams, reqEditors ...RequestEditorFn) (*LegacyDeleteConnectorResponse, error) {
	rsp, err := c.LegacyDeleteConnector(ctx, spaceId, actionId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLegacyDeleteConnectorResponse(rsp)
}

// LegacyGetConnectorWithResponse request returning *LegacyGetConnectorResponse
func (c *ClientWithResponses) LegacyGetConnectorWithResponse(ctx context.Context, spaceId SpaceId, actionId ActionId, reqEditors ...RequestEditorFn) (*LegacyGetConnectorResponse, error) {
	rsp, err := c.LegacyGetConnector(ctx, spaceId, actionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLegacyGetConnectorResponse(rsp)
}

// LegacyUpdateConnectorWithBodyWithResponse request with arbitrary body returning *LegacyUpdateConnectorResponse
func (c *ClientWithResponses) LegacyUpdateConnectorWithBodyWithResponse(ctx context.Context, spaceId SpaceId, actionId ActionId, params *LegacyUpdateConnectorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LegacyUpdateConnectorResponse, error) {
	rsp, err := c.LegacyUpdateConnectorWithBody(ctx, spaceId, actionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLegacyUpdateConnectorResponse(rsp)
}

func (c *ClientWithResponses) LegacyUpdateConnectorWithResponse(ctx context.Context, spaceId SpaceId, actionId ActionId, params *LegacyUpdateConnectorParams, body LegacyUpdateConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*LegacyUpdateConnectorResponse, error) {
	rsp, err := c.LegacyUpdateConnector(ctx, spaceId, actionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLegacyUpdateConnectorResponse(rsp)
}

// LegacyRunConnectorWithBodyWithResponse request with arbitrary body returning *LegacyRunConnectorResponse
func (c *ClientWithResponses) LegacyRunConnectorWithBodyWithResponse(ctx context.Context, spaceId SpaceId, actionId ActionId, params *LegacyRunConnectorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LegacyRunConnectorResponse, error) {
	rsp, err := c.LegacyRunConnectorWithBody(ctx, spaceId, actionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLegacyRunConnectorResponse(rsp)
}

func (c *ClientWithResponses) LegacyRunConnectorWithResponse(ctx context.Context, spaceId SpaceId, actionId ActionId, params *LegacyRunConnectorParams, body LegacyRunConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*LegacyRunConnectorResponse, error) {
	rsp, err := c.LegacyRunConnector(ctx, spaceId, actionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLegacyRunConnectorResponse(rsp)
}

// CreateConnectorWithBodyWithResponse request with arbitrary body returning *CreateConnectorResponse
func (c *ClientWithResponses) CreateConnectorWithBodyWithResponse(ctx context.Context, spaceId SpaceId, params *CreateConnectorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateConnectorResponse, error) {
	rsp, err := c.CreateConnectorWithBody(ctx, spaceId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateConnectorResponse(rsp)
}

func (c *ClientWithResponses) CreateConnectorWithResponse(ctx context.Context, spaceId SpaceId, params *CreateConnectorParams, body CreateConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateConnectorResponse, error) {
	rsp, err := c.CreateConnector(ctx, spaceId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateConnectorResponse(rsp)
}

// DeleteConnectorWithResponse request returning *DeleteConnectorResponse
func (c *ClientWithResponses) DeleteConnectorWithResponse(ctx context.Context, spaceId SpaceId, connectorId ConnectorId, params *DeleteConnectorParams, reqEditors ...RequestEditorFn) (*DeleteConnectorResponse, error) {
	rsp, err := c.DeleteConnector(ctx, spaceId, connectorId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteConnectorResponse(rsp)
}

// GetConnectorWithResponse request returning *GetConnectorResponse
func (c *ClientWithResponses) GetConnectorWithResponse(ctx context.Context, spaceId SpaceId, connectorId ConnectorId, reqEditors ...RequestEditorFn) (*GetConnectorResponse, error) {
	rsp, err := c.GetConnector(ctx, spaceId, connectorId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConnectorResponse(rsp)
}

// UpdateConnectorWithBodyWithResponse request with arbitrary body returning *UpdateConnectorResponse
func (c *ClientWithResponses) UpdateConnectorWithBodyWithResponse(ctx context.Context, spaceId SpaceId, connectorId ConnectorId, params *UpdateConnectorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConnectorResponse, error) {
	rsp, err := c.UpdateConnectorWithBody(ctx, spaceId, connectorId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConnectorResponse(rsp)
}

func (c *ClientWithResponses) UpdateConnectorWithResponse(ctx context.Context, spaceId SpaceId, connectorId ConnectorId, params *UpdateConnectorParams, body UpdateConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConnectorResponse, error) {
	rsp, err := c.UpdateConnector(ctx, spaceId, connectorId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConnectorResponse(rsp)
}

// RunConnectorWithBodyWithResponse request with arbitrary body returning *RunConnectorResponse
func (c *ClientWithResponses) RunConnectorWithBodyWithResponse(ctx context.Context, spaceId SpaceId, connectorId ConnectorId, params *RunConnectorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RunConnectorResponse, error) {
	rsp, err := c.RunConnectorWithBody(ctx, spaceId, connectorId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunConnectorResponse(rsp)
}

func (c *ClientWithResponses) RunConnectorWithResponse(ctx context.Context, spaceId SpaceId, connectorId ConnectorId, params *RunConnectorParams, body RunConnectorJSONRequestBody, reqEditors ...RequestEditorFn) (*RunConnectorResponse, error) {
	rsp, err := c.RunConnector(ctx, spaceId, connectorId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRunConnectorResponse(rsp)
}

// GetConnectorTypesWithResponse request returning *GetConnectorTypesResponse
func (c *ClientWithResponses) GetConnectorTypesWithResponse(ctx context.Context, spaceId SpaceId, params *GetConnectorTypesParams, reqEditors ...RequestEditorFn) (*GetConnectorTypesResponse, error) {
	rsp, err := c.GetConnectorTypes(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConnectorTypesResponse(rsp)
}

// GetConnectorsWithResponse request returning *GetConnectorsResponse
func (c *ClientWithResponses) GetConnectorsWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*GetConnectorsResponse, error) {
	rsp, err := c.GetConnectors(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConnectorsResponse(rsp)
}

// LegacyGetConnectorTypesWithResponse request returning *LegacyGetConnectorTypesResponse
func (c *ClientWithResponses) LegacyGetConnectorTypesWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*LegacyGetConnectorTypesResponse, error) {
	rsp, err := c.LegacyGetConnectorTypes(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLegacyGetConnectorTypesResponse(rsp)
}

// ParseLegacyGetConnectorsResponse parses an HTTP response from a LegacyGetConnectorsWithResponse call
func ParseLegacyGetConnectorsResponse(rsp *http.Response) (*LegacyGetConnectorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LegacyGetConnectorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ActionResponseProperties
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthorizationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseLegacyCreateConnectorResponse parses an HTTP response from a LegacyCreateConnectorWithResponse call
func ParseLegacyCreateConnectorResponse(rsp *http.Response) (*LegacyCreateConnectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LegacyCreateConnectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest N200Actions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthorizationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseLegacyDeleteConnectorResponse parses an HTTP response from a LegacyDeleteConnectorWithResponse call
func ParseLegacyDeleteConnectorResponse(rsp *http.Response) (*LegacyDeleteConnectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LegacyDeleteConnectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthorizationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseLegacyGetConnectorResponse parses an HTTP response from a LegacyGetConnectorWithResponse call
func ParseLegacyGetConnectorResponse(rsp *http.Response) (*LegacyGetConnectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LegacyGetConnectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest N200Actions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthorizationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseLegacyUpdateConnectorResponse parses an HTTP response from a LegacyUpdateConnectorWithResponse call
func ParseLegacyUpdateConnectorResponse(rsp *http.Response) (*LegacyUpdateConnectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LegacyUpdateConnectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest N200Actions
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ObjectNotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseLegacyRunConnectorResponse parses an HTTP response from a LegacyRunConnectorWithResponse call
func ParseLegacyRunConnectorResponse(rsp *http.Response) (*LegacyRunConnectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LegacyRunConnectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LegacyRunConnectorGeneralResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthorizationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateConnectorResponse parses an HTTP response from a CreateConnectorWithResponse call
func ParseCreateConnectorResponse(rsp *http.Response) (*CreateConnectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateConnectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConnectorResponseProperties
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthorizationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseDeleteConnectorResponse parses an HTTP response from a DeleteConnectorWithResponse call
func ParseDeleteConnectorResponse(rsp *http.Response) (*DeleteConnectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteConnectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthorizationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error      *string `json:"error,omitempty"`
			Message    *string `json:"message,omitempty"`
			StatusCode *int    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetConnectorResponse parses an HTTP response from a GetConnectorWithResponse call
func ParseGetConnectorResponse(rsp *http.Response) (*GetConnectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConnectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConnectorResponseProperties
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthorizationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error      *string `json:"error,omitempty"`
			Message    *string `json:"message,omitempty"`
			StatusCode *int    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateConnectorResponse parses an HTTP response from a UpdateConnectorWithResponse call
func ParseUpdateConnectorResponse(rsp *http.Response) (*UpdateConnectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateConnectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConnectorResponseProperties
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequestError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthorizationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ObjectNotFoundError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseRunConnectorResponse parses an HTTP response from a RunConnectorWithResponse call
func ParseRunConnectorResponse(rsp *http.Response) (*RunConnectorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RunConnectorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RunConnectorGeneralResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthorizationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetConnectorTypesResponse parses an HTTP response from a GetConnectorTypesWithResponse call
func ParseGetConnectorTypesResponse(rsp *http.Response) (*GetConnectorTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConnectorTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Enabled Indicates whether the connector type is enabled in Kibana.
			Enabled *bool `json:"enabled,omitempty"`

			// EnabledInConfig Indicates whether the connector type is enabled in the Kibana `.yml` file.
			EnabledInConfig *bool `json:"enabled_in_config,omitempty"`

			// EnabledInLicense Indicates whether the connector is enabled in the license.
			EnabledInLicense *bool `json:"enabled_in_license,omitempty"`

			// Id The type of connector. For example, `.email`, `.index`, `.jira`, `.opsgenie`, or `.server-log`.
			Id *ConnectorTypes `json:"id,omitempty"`

			// MinimumLicenseRequired The license that is required to use the connector type.
			MinimumLicenseRequired *string `json:"minimum_license_required,omitempty"`

			// Name The name of the connector type.
			Name *string `json:"name,omitempty"`

			// SupportedFeatureIds The Kibana features that are supported by the connector type.
			SupportedFeatureIds *[]Features `json:"supported_feature_ids,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthorizationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetConnectorsResponse parses an HTTP response from a GetConnectorsWithResponse call
func ParseGetConnectorsResponse(rsp *http.Response) (*GetConnectorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConnectorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Config The configuration for the connector. Configuration properties vary depending on the connector type.
			Config *map[string]interface{} `json:"config"`

			// ConnectorTypeId The type of connector. For example, `.email`, `.index`, `.jira`, `.opsgenie`, or `.server-log`.
			ConnectorTypeId ConnectorTypes `json:"connector_type_id"`

			// Id The identifier for the connector.
			Id string `json:"id"`

			// IsDeprecated Indicates whether the connector type is deprecated.
			IsDeprecated *IsDeprecated `json:"is_deprecated,omitempty"`

			// IsMissingSecrets Indicates whether secrets are missing for the connector. Secrets configuration properties vary depending on the connector type.
			IsMissingSecrets *IsMissingSecrets `json:"is_missing_secrets,omitempty"`

			// IsPreconfigured Indicates whether it is a preconfigured connector. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
			IsPreconfigured IsPreconfigured `json:"is_preconfigured"`

			// Name The display name for the connector.
			Name string `json:"name"`

			// ReferencedByCount Indicates the number of saved objects that reference the connector. If `is_preconfigured` is true, this value is not calculated.
			ReferencedByCount int `json:"referenced_by_count"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthorizationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseLegacyGetConnectorTypesResponse parses an HTTP response from a LegacyGetConnectorTypesWithResponse call
func ParseLegacyGetConnectorTypesResponse(rsp *http.Response) (*LegacyGetConnectorTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LegacyGetConnectorTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// Enabled Indicates whether the connector type is enabled in Kibana.
			Enabled *bool `json:"enabled,omitempty"`

			// EnabledInConfig Indicates whether the connector type is enabled in the Kibana `.yml` file.
			EnabledInConfig *bool `json:"enabledInConfig,omitempty"`

			// EnabledInLicense Indicates whether the connector is enabled in the license.
			EnabledInLicense *bool `json:"enabledInLicense,omitempty"`

			// Id The unique identifier for the connector type.
			Id *string `json:"id,omitempty"`

			// MinimumLicenseRequired The license that is required to use the connector type.
			MinimumLicenseRequired *string `json:"minimumLicenseRequired,omitempty"`

			// Name The name of the connector type.
			Name *string `json:"name,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest AuthorizationError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}
