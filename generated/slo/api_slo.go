/*
SLOs

OpenAPI schema for SLOs endpoints

API version: 1.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package slo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

type SloAPI interface {

	/*
		BulkDeleteOp Bulk delete SLO definitions and their associated summary and rollup data.

		Bulk delete SLO definitions and their associated summary and rollup data.  This endpoint initiates a bulk deletion operation for SLOs, which may take some time to complete.  The status of the operation can be checked using the `GET /api/slo/_bulk_delete/{taskId}` endpoint.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiBulkDeleteOpRequest
	*/
	BulkDeleteOp(ctx context.Context, spaceId string) ApiBulkDeleteOpRequest

	// BulkDeleteOpExecute executes the request
	//  @return BulkDeleteResponse
	BulkDeleteOpExecute(r ApiBulkDeleteOpRequest) (*BulkDeleteResponse, *http.Response, error)

	/*
		BulkDeleteStatusOp Retrieve the status of the bulk deletion

		Retrieve the status of the bulk deletion operation for SLOs.  This endpoint returns the status of the bulk deletion operation, including whether it is completed and the results of the operation.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@param taskId The task id of the bulk delete operation
		@return ApiBulkDeleteStatusOpRequest
	*/
	BulkDeleteStatusOp(ctx context.Context, spaceId string, taskId string) ApiBulkDeleteStatusOpRequest

	// BulkDeleteStatusOpExecute executes the request
	//  @return BulkDeleteStatusResponse
	BulkDeleteStatusOpExecute(r ApiBulkDeleteStatusOpRequest) (*BulkDeleteStatusResponse, *http.Response, error)

	/*
		CreateSloOp Create an SLO

		You must have `all` privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiCreateSloOpRequest
	*/
	CreateSloOp(ctx context.Context, spaceId string) ApiCreateSloOpRequest

	// CreateSloOpExecute executes the request
	//  @return CreateSloResponse
	CreateSloOpExecute(r ApiCreateSloOpRequest) (*CreateSloResponse, *http.Response, error)

	/*
		DeleteRollupDataOp Batch delete rollup and summary data

		The deletion occurs for the specified list of `sloId`. You must have `all` privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiDeleteRollupDataOpRequest
	*/
	DeleteRollupDataOp(ctx context.Context, spaceId string) ApiDeleteRollupDataOpRequest

	// DeleteRollupDataOpExecute executes the request
	//  @return BulkPurgeRollupResponse
	DeleteRollupDataOpExecute(r ApiDeleteRollupDataOpRequest) (*BulkPurgeRollupResponse, *http.Response, error)

	/*
		DeleteSloInstancesOp Batch delete rollup and summary data

		The deletion occurs for the specified list of `sloId` and `instanceId`. You must have `all` privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiDeleteSloInstancesOpRequest
	*/
	DeleteSloInstancesOp(ctx context.Context, spaceId string) ApiDeleteSloInstancesOpRequest

	// DeleteSloInstancesOpExecute executes the request
	DeleteSloInstancesOpExecute(r ApiDeleteSloInstancesOpRequest) (*http.Response, error)

	/*
		DeleteSloOp Delete an SLO

		You must have the `write` privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@param sloId An identifier for the slo.
		@return ApiDeleteSloOpRequest
	*/
	DeleteSloOp(ctx context.Context, spaceId string, sloId string) ApiDeleteSloOpRequest

	// DeleteSloOpExecute executes the request
	DeleteSloOpExecute(r ApiDeleteSloOpRequest) (*http.Response, error)

	/*
		DisableSloOp Disable an SLO

		You must have the `write` privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@param sloId An identifier for the slo.
		@return ApiDisableSloOpRequest
	*/
	DisableSloOp(ctx context.Context, spaceId string, sloId string) ApiDisableSloOpRequest

	// DisableSloOpExecute executes the request
	DisableSloOpExecute(r ApiDisableSloOpRequest) (*http.Response, error)

	/*
		EnableSloOp Enable an SLO

		You must have the `write` privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@param sloId An identifier for the slo.
		@return ApiEnableSloOpRequest
	*/
	EnableSloOp(ctx context.Context, spaceId string, sloId string) ApiEnableSloOpRequest

	// EnableSloOpExecute executes the request
	EnableSloOpExecute(r ApiEnableSloOpRequest) (*http.Response, error)

	/*
		FindSlosOp Get a paginated list of SLOs

		You must have the `read` privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiFindSlosOpRequest
	*/
	FindSlosOp(ctx context.Context, spaceId string) ApiFindSlosOpRequest

	// FindSlosOpExecute executes the request
	//  @return FindSloResponse
	FindSlosOpExecute(r ApiFindSlosOpRequest) (*FindSloResponse, *http.Response, error)

	/*
		GetDefinitionsOp Get the SLO definitions

		You must have the `read` privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiGetDefinitionsOpRequest
	*/
	GetDefinitionsOp(ctx context.Context, spaceId string) ApiGetDefinitionsOpRequest

	// GetDefinitionsOpExecute executes the request
	//  @return FindSloDefinitionsResponse
	GetDefinitionsOpExecute(r ApiGetDefinitionsOpRequest) (*FindSloDefinitionsResponse, *http.Response, error)

	/*
		GetSloOp Get an SLO

		You must have the `read` privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@param sloId An identifier for the slo.
		@return ApiGetSloOpRequest
	*/
	GetSloOp(ctx context.Context, spaceId string, sloId string) ApiGetSloOpRequest

	// GetSloOpExecute executes the request
	//  @return SloWithSummaryResponse
	GetSloOpExecute(r ApiGetSloOpRequest) (*SloWithSummaryResponse, *http.Response, error)

	/*
		ResetSloOp Reset an SLO

		You must have the `write` privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@param sloId An identifier for the slo.
		@return ApiResetSloOpRequest
	*/
	ResetSloOp(ctx context.Context, spaceId string, sloId string) ApiResetSloOpRequest

	// ResetSloOpExecute executes the request
	//  @return SloDefinitionResponse
	ResetSloOpExecute(r ApiResetSloOpRequest) (*SloDefinitionResponse, *http.Response, error)

	/*
		UpdateSloOp Update an SLO

		You must have the `write` privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@param sloId An identifier for the slo.
		@return ApiUpdateSloOpRequest
	*/
	UpdateSloOp(ctx context.Context, spaceId string, sloId string) ApiUpdateSloOpRequest

	// UpdateSloOpExecute executes the request
	//  @return SloDefinitionResponse
	UpdateSloOpExecute(r ApiUpdateSloOpRequest) (*SloDefinitionResponse, *http.Response, error)
}

// SloAPIService SloAPI service
type SloAPIService service

type ApiBulkDeleteOpRequest struct {
	ctx               context.Context
	ApiService        SloAPI
	kbnXsrf           *string
	spaceId           string
	bulkDeleteRequest *BulkDeleteRequest
}

// Cross-site request forgery protection
func (r ApiBulkDeleteOpRequest) KbnXsrf(kbnXsrf string) ApiBulkDeleteOpRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiBulkDeleteOpRequest) BulkDeleteRequest(bulkDeleteRequest BulkDeleteRequest) ApiBulkDeleteOpRequest {
	r.bulkDeleteRequest = &bulkDeleteRequest
	return r
}

func (r ApiBulkDeleteOpRequest) Execute() (*BulkDeleteResponse, *http.Response, error) {
	return r.ApiService.BulkDeleteOpExecute(r)
}

/*
BulkDeleteOp Bulk delete SLO definitions and their associated summary and rollup data.

Bulk delete SLO definitions and their associated summary and rollup data.  This endpoint initiates a bulk deletion operation for SLOs, which may take some time to complete.  The status of the operation can be checked using the `GET /api/slo/_bulk_delete/{taskId}` endpoint.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiBulkDeleteOpRequest
*/
func (a *SloAPIService) BulkDeleteOp(ctx context.Context, spaceId string) ApiBulkDeleteOpRequest {
	return ApiBulkDeleteOpRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return BulkDeleteResponse
func (a *SloAPIService) BulkDeleteOpExecute(r ApiBulkDeleteOpRequest) (*BulkDeleteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkDeleteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SloAPIService.BulkDeleteOp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/observability/slos/_bulk_delete"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return localVarReturnValue, nil, reportError("kbnXsrf is required and must be specified")
	}
	if r.bulkDeleteRequest == nil {
		return localVarReturnValue, nil, reportError("bulkDeleteRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	// body params
	localVarPostBody = r.bulkDeleteRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Model400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Model403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkDeleteStatusOpRequest struct {
	ctx        context.Context
	ApiService SloAPI
	kbnXsrf    *string
	spaceId    string
	taskId     string
}

// Cross-site request forgery protection
func (r ApiBulkDeleteStatusOpRequest) KbnXsrf(kbnXsrf string) ApiBulkDeleteStatusOpRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiBulkDeleteStatusOpRequest) Execute() (*BulkDeleteStatusResponse, *http.Response, error) {
	return r.ApiService.BulkDeleteStatusOpExecute(r)
}

/*
BulkDeleteStatusOp Retrieve the status of the bulk deletion

Retrieve the status of the bulk deletion operation for SLOs.  This endpoint returns the status of the bulk deletion operation, including whether it is completed and the results of the operation.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@param taskId The task id of the bulk delete operation
	@return ApiBulkDeleteStatusOpRequest
*/
func (a *SloAPIService) BulkDeleteStatusOp(ctx context.Context, spaceId string, taskId string) ApiBulkDeleteStatusOpRequest {
	return ApiBulkDeleteStatusOpRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
		taskId:     taskId,
	}
}

// Execute executes the request
//
//	@return BulkDeleteStatusResponse
func (a *SloAPIService) BulkDeleteStatusOpExecute(r ApiBulkDeleteStatusOpRequest) (*BulkDeleteStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkDeleteStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SloAPIService.BulkDeleteStatusOp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/observability/slos/_bulk_delete/{taskId}"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"taskId"+"}", url.PathEscape(parameterValueToString(r.taskId, "taskId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return localVarReturnValue, nil, reportError("kbnXsrf is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Model400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Model403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSloOpRequest struct {
	ctx              context.Context
	ApiService       SloAPI
	kbnXsrf          *string
	spaceId          string
	createSloRequest *CreateSloRequest
}

// Cross-site request forgery protection
func (r ApiCreateSloOpRequest) KbnXsrf(kbnXsrf string) ApiCreateSloOpRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiCreateSloOpRequest) CreateSloRequest(createSloRequest CreateSloRequest) ApiCreateSloOpRequest {
	r.createSloRequest = &createSloRequest
	return r
}

func (r ApiCreateSloOpRequest) Execute() (*CreateSloResponse, *http.Response, error) {
	return r.ApiService.CreateSloOpExecute(r)
}

/*
CreateSloOp Create an SLO

You must have `all` privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiCreateSloOpRequest
*/
func (a *SloAPIService) CreateSloOp(ctx context.Context, spaceId string) ApiCreateSloOpRequest {
	return ApiCreateSloOpRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return CreateSloResponse
func (a *SloAPIService) CreateSloOpExecute(r ApiCreateSloOpRequest) (*CreateSloResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateSloResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SloAPIService.CreateSloOp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/observability/slos"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return localVarReturnValue, nil, reportError("kbnXsrf is required and must be specified")
	}
	if r.createSloRequest == nil {
		return localVarReturnValue, nil, reportError("createSloRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	// body params
	localVarPostBody = r.createSloRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Model400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Model403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v Model409Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRollupDataOpRequest struct {
	ctx                    context.Context
	ApiService             SloAPI
	kbnXsrf                *string
	spaceId                string
	bulkPurgeRollupRequest *BulkPurgeRollupRequest
}

// Cross-site request forgery protection
func (r ApiDeleteRollupDataOpRequest) KbnXsrf(kbnXsrf string) ApiDeleteRollupDataOpRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiDeleteRollupDataOpRequest) BulkPurgeRollupRequest(bulkPurgeRollupRequest BulkPurgeRollupRequest) ApiDeleteRollupDataOpRequest {
	r.bulkPurgeRollupRequest = &bulkPurgeRollupRequest
	return r
}

func (r ApiDeleteRollupDataOpRequest) Execute() (*BulkPurgeRollupResponse, *http.Response, error) {
	return r.ApiService.DeleteRollupDataOpExecute(r)
}

/*
DeleteRollupDataOp Batch delete rollup and summary data

The deletion occurs for the specified list of `sloId`. You must have `all` privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiDeleteRollupDataOpRequest
*/
func (a *SloAPIService) DeleteRollupDataOp(ctx context.Context, spaceId string) ApiDeleteRollupDataOpRequest {
	return ApiDeleteRollupDataOpRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return BulkPurgeRollupResponse
func (a *SloAPIService) DeleteRollupDataOpExecute(r ApiDeleteRollupDataOpRequest) (*BulkPurgeRollupResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *BulkPurgeRollupResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SloAPIService.DeleteRollupDataOp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/observability/slos/_bulk_purge_rollup"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return localVarReturnValue, nil, reportError("kbnXsrf is required and must be specified")
	}
	if r.bulkPurgeRollupRequest == nil {
		return localVarReturnValue, nil, reportError("bulkPurgeRollupRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	// body params
	localVarPostBody = r.bulkPurgeRollupRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Model400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Model403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSloInstancesOpRequest struct {
	ctx                       context.Context
	ApiService                SloAPI
	kbnXsrf                   *string
	spaceId                   string
	deleteSloInstancesRequest *DeleteSloInstancesRequest
}

// Cross-site request forgery protection
func (r ApiDeleteSloInstancesOpRequest) KbnXsrf(kbnXsrf string) ApiDeleteSloInstancesOpRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiDeleteSloInstancesOpRequest) DeleteSloInstancesRequest(deleteSloInstancesRequest DeleteSloInstancesRequest) ApiDeleteSloInstancesOpRequest {
	r.deleteSloInstancesRequest = &deleteSloInstancesRequest
	return r
}

func (r ApiDeleteSloInstancesOpRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSloInstancesOpExecute(r)
}

/*
DeleteSloInstancesOp Batch delete rollup and summary data

The deletion occurs for the specified list of `sloId` and `instanceId`. You must have `all` privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiDeleteSloInstancesOpRequest
*/
func (a *SloAPIService) DeleteSloInstancesOp(ctx context.Context, spaceId string) ApiDeleteSloInstancesOpRequest {
	return ApiDeleteSloInstancesOpRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
func (a *SloAPIService) DeleteSloInstancesOpExecute(r ApiDeleteSloInstancesOpRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SloAPIService.DeleteSloInstancesOp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/observability/slos/_delete_instances"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return nil, reportError("kbnXsrf is required and must be specified")
	}
	if r.deleteSloInstancesRequest == nil {
		return nil, reportError("deleteSloInstancesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	// body params
	localVarPostBody = r.deleteSloInstancesRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Model400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Model403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSloOpRequest struct {
	ctx        context.Context
	ApiService SloAPI
	kbnXsrf    *string
	spaceId    string
	sloId      string
}

// Cross-site request forgery protection
func (r ApiDeleteSloOpRequest) KbnXsrf(kbnXsrf string) ApiDeleteSloOpRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiDeleteSloOpRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSloOpExecute(r)
}

/*
DeleteSloOp Delete an SLO

You must have the `write` privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@param sloId An identifier for the slo.
	@return ApiDeleteSloOpRequest
*/
func (a *SloAPIService) DeleteSloOp(ctx context.Context, spaceId string, sloId string) ApiDeleteSloOpRequest {
	return ApiDeleteSloOpRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
		sloId:      sloId,
	}
}

// Execute executes the request
func (a *SloAPIService) DeleteSloOpExecute(r ApiDeleteSloOpRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SloAPIService.DeleteSloOp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/observability/slos/{sloId}"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sloId"+"}", url.PathEscape(parameterValueToString(r.sloId, "sloId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return nil, reportError("kbnXsrf is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Model400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Model403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Model404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDisableSloOpRequest struct {
	ctx        context.Context
	ApiService SloAPI
	kbnXsrf    *string
	spaceId    string
	sloId      string
}

// Cross-site request forgery protection
func (r ApiDisableSloOpRequest) KbnXsrf(kbnXsrf string) ApiDisableSloOpRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiDisableSloOpRequest) Execute() (*http.Response, error) {
	return r.ApiService.DisableSloOpExecute(r)
}

/*
DisableSloOp Disable an SLO

You must have the `write` privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@param sloId An identifier for the slo.
	@return ApiDisableSloOpRequest
*/
func (a *SloAPIService) DisableSloOp(ctx context.Context, spaceId string, sloId string) ApiDisableSloOpRequest {
	return ApiDisableSloOpRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
		sloId:      sloId,
	}
}

// Execute executes the request
func (a *SloAPIService) DisableSloOpExecute(r ApiDisableSloOpRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SloAPIService.DisableSloOp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/observability/slos/{sloId}/disable"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sloId"+"}", url.PathEscape(parameterValueToString(r.sloId, "sloId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return nil, reportError("kbnXsrf is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Model400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Model403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Model404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnableSloOpRequest struct {
	ctx        context.Context
	ApiService SloAPI
	kbnXsrf    *string
	spaceId    string
	sloId      string
}

// Cross-site request forgery protection
func (r ApiEnableSloOpRequest) KbnXsrf(kbnXsrf string) ApiEnableSloOpRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiEnableSloOpRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnableSloOpExecute(r)
}

/*
EnableSloOp Enable an SLO

You must have the `write` privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@param sloId An identifier for the slo.
	@return ApiEnableSloOpRequest
*/
func (a *SloAPIService) EnableSloOp(ctx context.Context, spaceId string, sloId string) ApiEnableSloOpRequest {
	return ApiEnableSloOpRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
		sloId:      sloId,
	}
}

// Execute executes the request
func (a *SloAPIService) EnableSloOpExecute(r ApiEnableSloOpRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SloAPIService.EnableSloOp")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/observability/slos/{sloId}/enable"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sloId"+"}", url.PathEscape(parameterValueToString(r.sloId, "sloId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return nil, reportError("kbnXsrf is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Model400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Model403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Model404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFindSlosOpRequest struct {
	ctx           context.Context
	ApiService    SloAPI
	kbnXsrf       *string
	spaceId       string
	kqlQuery      *string
	size          *int32
	searchAfter   *[]string
	page          *int32
	perPage       *int32
	sortBy        *string
	sortDirection *string
	hideStale     *bool
}

// Cross-site request forgery protection
func (r ApiFindSlosOpRequest) KbnXsrf(kbnXsrf string) ApiFindSlosOpRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

// A valid kql query to filter the SLO with
func (r ApiFindSlosOpRequest) KqlQuery(kqlQuery string) ApiFindSlosOpRequest {
	r.kqlQuery = &kqlQuery
	return r
}

// The page size to use for cursor-based pagination, must be greater or equal than 1
func (r ApiFindSlosOpRequest) Size(size int32) ApiFindSlosOpRequest {
	r.size = &size
	return r
}

// The cursor to use for fetching the results from, when using a cursor-base pagination.
func (r ApiFindSlosOpRequest) SearchAfter(searchAfter []string) ApiFindSlosOpRequest {
	r.searchAfter = &searchAfter
	return r
}

// The page to use for pagination, must be greater or equal than 1
func (r ApiFindSlosOpRequest) Page(page int32) ApiFindSlosOpRequest {
	r.page = &page
	return r
}

// Number of SLOs returned by page
func (r ApiFindSlosOpRequest) PerPage(perPage int32) ApiFindSlosOpRequest {
	r.perPage = &perPage
	return r
}

// Sort by field
func (r ApiFindSlosOpRequest) SortBy(sortBy string) ApiFindSlosOpRequest {
	r.sortBy = &sortBy
	return r
}

// Sort order
func (r ApiFindSlosOpRequest) SortDirection(sortDirection string) ApiFindSlosOpRequest {
	r.sortDirection = &sortDirection
	return r
}

// Hide stale SLOs from the list as defined by stale SLO threshold in SLO settings
func (r ApiFindSlosOpRequest) HideStale(hideStale bool) ApiFindSlosOpRequest {
	r.hideStale = &hideStale
	return r
}

func (r ApiFindSlosOpRequest) Execute() (*FindSloResponse, *http.Response, error) {
	return r.ApiService.FindSlosOpExecute(r)
}

/*
FindSlosOp Get a paginated list of SLOs

You must have the `read` privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiFindSlosOpRequest
*/
func (a *SloAPIService) FindSlosOp(ctx context.Context, spaceId string) ApiFindSlosOpRequest {
	return ApiFindSlosOpRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return FindSloResponse
func (a *SloAPIService) FindSlosOpExecute(r ApiFindSlosOpRequest) (*FindSloResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FindSloResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SloAPIService.FindSlosOp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/observability/slos"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return localVarReturnValue, nil, reportError("kbnXsrf is required and must be specified")
	}

	if r.kqlQuery != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "kqlQuery", r.kqlQuery, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	} else {
		var defaultValue int32 = 1
		r.size = &defaultValue
	}
	if r.searchAfter != nil {
		t := *r.searchAfter
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "searchAfter", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "searchAfter", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "perPage", r.perPage, "")
	} else {
		var defaultValue int32 = 25
		r.perPage = &defaultValue
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "")
	} else {
		var defaultValue string = "status"
		r.sortBy = &defaultValue
	}
	if r.sortDirection != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortDirection", r.sortDirection, "")
	} else {
		var defaultValue string = "asc"
		r.sortDirection = &defaultValue
	}
	if r.hideStale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hideStale", r.hideStale, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Model400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Model403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Model404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDefinitionsOpRequest struct {
	ctx                 context.Context
	ApiService          SloAPI
	kbnXsrf             *string
	spaceId             string
	includeOutdatedOnly *bool
	tags                *string
	search              *string
	page                *float64
	perPage             *int32
}

// Cross-site request forgery protection
func (r ApiGetDefinitionsOpRequest) KbnXsrf(kbnXsrf string) ApiGetDefinitionsOpRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

// Indicates if the API returns only outdated SLO or all SLO definitions
func (r ApiGetDefinitionsOpRequest) IncludeOutdatedOnly(includeOutdatedOnly bool) ApiGetDefinitionsOpRequest {
	r.includeOutdatedOnly = &includeOutdatedOnly
	return r
}

// Filters the SLOs by tag
func (r ApiGetDefinitionsOpRequest) Tags(tags string) ApiGetDefinitionsOpRequest {
	r.tags = &tags
	return r
}

// Filters the SLOs by name
func (r ApiGetDefinitionsOpRequest) Search(search string) ApiGetDefinitionsOpRequest {
	r.search = &search
	return r
}

// The page to use for pagination, must be greater or equal than 1
func (r ApiGetDefinitionsOpRequest) Page(page float64) ApiGetDefinitionsOpRequest {
	r.page = &page
	return r
}

// Number of SLOs returned by page
func (r ApiGetDefinitionsOpRequest) PerPage(perPage int32) ApiGetDefinitionsOpRequest {
	r.perPage = &perPage
	return r
}

func (r ApiGetDefinitionsOpRequest) Execute() (*FindSloDefinitionsResponse, *http.Response, error) {
	return r.ApiService.GetDefinitionsOpExecute(r)
}

/*
GetDefinitionsOp Get the SLO definitions

You must have the `read` privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiGetDefinitionsOpRequest
*/
func (a *SloAPIService) GetDefinitionsOp(ctx context.Context, spaceId string) ApiGetDefinitionsOpRequest {
	return ApiGetDefinitionsOpRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return FindSloDefinitionsResponse
func (a *SloAPIService) GetDefinitionsOpExecute(r ApiGetDefinitionsOpRequest) (*FindSloDefinitionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FindSloDefinitionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SloAPIService.GetDefinitionsOp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/internal/observability/slos/_definitions"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return localVarReturnValue, nil, reportError("kbnXsrf is required and must be specified")
	}

	if r.includeOutdatedOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeOutdatedOnly", r.includeOutdatedOnly, "")
	}
	if r.tags != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tags", r.tags, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "perPage", r.perPage, "")
	} else {
		var defaultValue int32 = 100
		r.perPage = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Model400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Model403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSloOpRequest struct {
	ctx        context.Context
	ApiService SloAPI
	kbnXsrf    *string
	spaceId    string
	sloId      string
	instanceId *string
}

// Cross-site request forgery protection
func (r ApiGetSloOpRequest) KbnXsrf(kbnXsrf string) ApiGetSloOpRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

// the specific instanceId used by the summary calculation
func (r ApiGetSloOpRequest) InstanceId(instanceId string) ApiGetSloOpRequest {
	r.instanceId = &instanceId
	return r
}

func (r ApiGetSloOpRequest) Execute() (*SloWithSummaryResponse, *http.Response, error) {
	return r.ApiService.GetSloOpExecute(r)
}

/*
GetSloOp Get an SLO

You must have the `read` privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@param sloId An identifier for the slo.
	@return ApiGetSloOpRequest
*/
func (a *SloAPIService) GetSloOp(ctx context.Context, spaceId string, sloId string) ApiGetSloOpRequest {
	return ApiGetSloOpRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
		sloId:      sloId,
	}
}

// Execute executes the request
//
//	@return SloWithSummaryResponse
func (a *SloAPIService) GetSloOpExecute(r ApiGetSloOpRequest) (*SloWithSummaryResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SloWithSummaryResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SloAPIService.GetSloOp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/observability/slos/{sloId}"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sloId"+"}", url.PathEscape(parameterValueToString(r.sloId, "sloId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return localVarReturnValue, nil, reportError("kbnXsrf is required and must be specified")
	}

	if r.instanceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "instanceId", r.instanceId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Model400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Model403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Model404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetSloOpRequest struct {
	ctx        context.Context
	ApiService SloAPI
	kbnXsrf    *string
	spaceId    string
	sloId      string
}

// Cross-site request forgery protection
func (r ApiResetSloOpRequest) KbnXsrf(kbnXsrf string) ApiResetSloOpRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiResetSloOpRequest) Execute() (*SloDefinitionResponse, *http.Response, error) {
	return r.ApiService.ResetSloOpExecute(r)
}

/*
ResetSloOp Reset an SLO

You must have the `write` privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@param sloId An identifier for the slo.
	@return ApiResetSloOpRequest
*/
func (a *SloAPIService) ResetSloOp(ctx context.Context, spaceId string, sloId string) ApiResetSloOpRequest {
	return ApiResetSloOpRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
		sloId:      sloId,
	}
}

// Execute executes the request
//
//	@return SloDefinitionResponse
func (a *SloAPIService) ResetSloOpExecute(r ApiResetSloOpRequest) (*SloDefinitionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SloDefinitionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SloAPIService.ResetSloOp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/observability/slos/{sloId}/_reset"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sloId"+"}", url.PathEscape(parameterValueToString(r.sloId, "sloId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return localVarReturnValue, nil, reportError("kbnXsrf is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Model400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Model403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Model404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSloOpRequest struct {
	ctx              context.Context
	ApiService       SloAPI
	kbnXsrf          *string
	spaceId          string
	sloId            string
	updateSloRequest *UpdateSloRequest
}

// Cross-site request forgery protection
func (r ApiUpdateSloOpRequest) KbnXsrf(kbnXsrf string) ApiUpdateSloOpRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiUpdateSloOpRequest) UpdateSloRequest(updateSloRequest UpdateSloRequest) ApiUpdateSloOpRequest {
	r.updateSloRequest = &updateSloRequest
	return r
}

func (r ApiUpdateSloOpRequest) Execute() (*SloDefinitionResponse, *http.Response, error) {
	return r.ApiService.UpdateSloOpExecute(r)
}

/*
UpdateSloOp Update an SLO

You must have the `write` privileges for the **SLOs** feature in the **Observability** section of the Kibana feature privileges.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@param sloId An identifier for the slo.
	@return ApiUpdateSloOpRequest
*/
func (a *SloAPIService) UpdateSloOp(ctx context.Context, spaceId string, sloId string) ApiUpdateSloOpRequest {
	return ApiUpdateSloOpRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
		sloId:      sloId,
	}
}

// Execute executes the request
//
//	@return SloDefinitionResponse
func (a *SloAPIService) UpdateSloOpExecute(r ApiUpdateSloOpRequest) (*SloDefinitionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SloDefinitionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SloAPIService.UpdateSloOp")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/observability/slos/{sloId}"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"sloId"+"}", url.PathEscape(parameterValueToString(r.sloId, "sloId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return localVarReturnValue, nil, reportError("kbnXsrf is required and must be specified")
	}
	if r.updateSloRequest == nil {
		return localVarReturnValue, nil, reportError("updateSloRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	// body params
	localVarPostBody = r.updateSloRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Model400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Model403Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Model404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
