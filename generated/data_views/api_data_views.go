/*
Data views

OpenAPI schema for data view endpoints

API version: 0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package data_views

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type DataViewsAPI interface {

	/*
		CreateDataView Creates a data view.

		This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiCreateDataViewRequest
	*/
	CreateDataView(ctx context.Context, spaceId string) ApiCreateDataViewRequest

	// CreateDataViewExecute executes the request
	//  @return DataViewResponseObject
	CreateDataViewExecute(r ApiCreateDataViewRequest) (*DataViewResponseObject, *http.Response, error)

	/*
		CreateRuntimeField Creates a runtime field.

		This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param viewId An identifier for the data view.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiCreateRuntimeFieldRequest
	*/
	CreateRuntimeField(ctx context.Context, viewId string, spaceId string) ApiCreateRuntimeFieldRequest

	// CreateRuntimeFieldExecute executes the request
	CreateRuntimeFieldExecute(r ApiCreateRuntimeFieldRequest) (*http.Response, error)

	/*
		CreateUpdateRuntimeField Create or update an existing runtime field.

		This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@param viewId The ID of the data view fields you want to update.
		@return ApiCreateUpdateRuntimeFieldRequest
	*/
	CreateUpdateRuntimeField(ctx context.Context, spaceId string, viewId string) ApiCreateUpdateRuntimeFieldRequest

	// CreateUpdateRuntimeFieldExecute executes the request
	//  @return CreateUpdateRuntimeField200Response
	CreateUpdateRuntimeFieldExecute(r ApiCreateUpdateRuntimeFieldRequest) (*CreateUpdateRuntimeField200Response, *http.Response, error)

	/*
		DeleteDataView Deletes a data view.

		WARNING: When you delete a data view, it cannot be recovered. This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param viewId An identifier for the data view.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiDeleteDataViewRequest
	*/
	DeleteDataView(ctx context.Context, viewId string, spaceId string) ApiDeleteDataViewRequest

	// DeleteDataViewExecute executes the request
	DeleteDataViewExecute(r ApiDeleteDataViewRequest) (*http.Response, error)

	/*
		DeleteRuntimeField Delete a runtime field from a data view.

		This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param fieldName The name of the runtime field.
		@param viewId An identifier for the data view.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiDeleteRuntimeFieldRequest
	*/
	DeleteRuntimeField(ctx context.Context, fieldName string, viewId string, spaceId string) ApiDeleteRuntimeFieldRequest

	// DeleteRuntimeFieldExecute executes the request
	DeleteRuntimeFieldExecute(r ApiDeleteRuntimeFieldRequest) (*http.Response, error)

	/*
		GetAllDataViews Retrieves a list of all data views.

		This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiGetAllDataViewsRequest
	*/
	GetAllDataViews(ctx context.Context, spaceId string) ApiGetAllDataViewsRequest

	// GetAllDataViewsExecute executes the request
	//  @return GetAllDataViews200Response
	GetAllDataViewsExecute(r ApiGetAllDataViewsRequest) (*GetAllDataViews200Response, *http.Response, error)

	/*
		GetDataView Retrieves a single data view by identifier.

		This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param viewId An identifier for the data view.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiGetDataViewRequest
	*/
	GetDataView(ctx context.Context, viewId string, spaceId string) ApiGetDataViewRequest

	// GetDataViewExecute executes the request
	//  @return DataViewResponseObject
	GetDataViewExecute(r ApiGetDataViewRequest) (*DataViewResponseObject, *http.Response, error)

	/*
		GetDefaultDataView Retrieves the default data view identifier.

		This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiGetDefaultDataViewRequest
	*/
	GetDefaultDataView(ctx context.Context, spaceId string) ApiGetDefaultDataViewRequest

	// GetDefaultDataViewExecute executes the request
	//  @return GetDefaultDataView200Response
	GetDefaultDataViewExecute(r ApiGetDefaultDataViewRequest) (*GetDefaultDataView200Response, *http.Response, error)

	/*
		GetRuntimeField Retrieves a runtime field.

		This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param fieldName The name of the runtime field.
		@param viewId An identifier for the data view.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiGetRuntimeFieldRequest
	*/
	GetRuntimeField(ctx context.Context, fieldName string, viewId string, spaceId string) ApiGetRuntimeFieldRequest

	// GetRuntimeFieldExecute executes the request
	//  @return CreateUpdateRuntimeField200Response
	GetRuntimeFieldExecute(r ApiGetRuntimeFieldRequest) (*CreateUpdateRuntimeField200Response, *http.Response, error)

	/*
		SetDefaultDatailView Sets the default data view identifier.

		This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiSetDefaultDatailViewRequest
	*/
	SetDefaultDatailView(ctx context.Context, spaceId string) ApiSetDefaultDatailViewRequest

	// SetDefaultDatailViewExecute executes the request
	//  @return SetDefaultDatailView200Response
	SetDefaultDatailViewExecute(r ApiSetDefaultDatailViewRequest) (*SetDefaultDatailView200Response, *http.Response, error)

	/*
		UpdateDataView Updates a data view.

		This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param viewId An identifier for the data view.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiUpdateDataViewRequest
	*/
	UpdateDataView(ctx context.Context, viewId string, spaceId string) ApiUpdateDataViewRequest

	// UpdateDataViewExecute executes the request
	//  @return DataViewResponseObject
	UpdateDataViewExecute(r ApiUpdateDataViewRequest) (*DataViewResponseObject, *http.Response, error)

	/*
		UpdateFieldsMetadata Update fields presentation metadata such as count, customLabel and format.

		This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features. You can update multiple fields in one request. Updates are merged with persisted metadata. To remove existing metadata, specify null as the value.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param viewId An identifier for the data view.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiUpdateFieldsMetadataRequest
	*/
	UpdateFieldsMetadata(ctx context.Context, viewId string, spaceId string) ApiUpdateFieldsMetadataRequest

	// UpdateFieldsMetadataExecute executes the request
	//  @return SetDefaultDatailView200Response
	UpdateFieldsMetadataExecute(r ApiUpdateFieldsMetadataRequest) (*SetDefaultDatailView200Response, *http.Response, error)

	/*
		UpdateRuntimeField Update an existing runtime field.

		This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param fieldName The name of the runtime field.
		@param viewId An identifier for the data view.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiUpdateRuntimeFieldRequest
	*/
	UpdateRuntimeField(ctx context.Context, fieldName string, viewId string, spaceId string) ApiUpdateRuntimeFieldRequest

	// UpdateRuntimeFieldExecute executes the request
	UpdateRuntimeFieldExecute(r ApiUpdateRuntimeFieldRequest) (*http.Response, error)
}

// DataViewsAPIService DataViewsAPI service
type DataViewsAPIService service

type ApiCreateDataViewRequest struct {
	ctx                         context.Context
	ApiService                  DataViewsAPI
	kbnXsrf                     *string
	spaceId                     string
	createDataViewRequestObject *CreateDataViewRequestObject
}

// Cross-site request forgery protection
func (r ApiCreateDataViewRequest) KbnXsrf(kbnXsrf string) ApiCreateDataViewRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiCreateDataViewRequest) CreateDataViewRequestObject(createDataViewRequestObject CreateDataViewRequestObject) ApiCreateDataViewRequest {
	r.createDataViewRequestObject = &createDataViewRequestObject
	return r
}

func (r ApiCreateDataViewRequest) Execute() (*DataViewResponseObject, *http.Response, error) {
	return r.ApiService.CreateDataViewExecute(r)
}

/*
CreateDataView Creates a data view.

This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiCreateDataViewRequest
*/
func (a *DataViewsAPIService) CreateDataView(ctx context.Context, spaceId string) ApiCreateDataViewRequest {
	return ApiCreateDataViewRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return DataViewResponseObject
func (a *DataViewsAPIService) CreateDataViewExecute(r ApiCreateDataViewRequest) (*DataViewResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataViewResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewsAPIService.CreateDataView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/data_views/data_view"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return localVarReturnValue, nil, reportError("kbnXsrf is required and must be specified")
	}
	if r.createDataViewRequestObject == nil {
		return localVarReturnValue, nil, reportError("createDataViewRequestObject is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	// body params
	localVarPostBody = r.createDataViewRequestObject
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Model400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateRuntimeFieldRequest struct {
	ctx                             context.Context
	ApiService                      DataViewsAPI
	kbnXsrf                         *string
	viewId                          string
	spaceId                         string
	createUpdateRuntimeFieldRequest *CreateUpdateRuntimeFieldRequest
}

// Cross-site request forgery protection
func (r ApiCreateRuntimeFieldRequest) KbnXsrf(kbnXsrf string) ApiCreateRuntimeFieldRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiCreateRuntimeFieldRequest) CreateUpdateRuntimeFieldRequest(createUpdateRuntimeFieldRequest CreateUpdateRuntimeFieldRequest) ApiCreateRuntimeFieldRequest {
	r.createUpdateRuntimeFieldRequest = &createUpdateRuntimeFieldRequest
	return r
}

func (r ApiCreateRuntimeFieldRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateRuntimeFieldExecute(r)
}

/*
CreateRuntimeField Creates a runtime field.

This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param viewId An identifier for the data view.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiCreateRuntimeFieldRequest
*/
func (a *DataViewsAPIService) CreateRuntimeField(ctx context.Context, viewId string, spaceId string) ApiCreateRuntimeFieldRequest {
	return ApiCreateRuntimeFieldRequest{
		ApiService: a,
		ctx:        ctx,
		viewId:     viewId,
		spaceId:    spaceId,
	}
}

// Execute executes the request
func (a *DataViewsAPIService) CreateRuntimeFieldExecute(r ApiCreateRuntimeFieldRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewsAPIService.CreateRuntimeField")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/data_views/data_view/{viewId}/runtime_field"
	localVarPath = strings.Replace(localVarPath, "{"+"viewId"+"}", url.PathEscape(parameterValueToString(r.viewId, "viewId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return nil, reportError("kbnXsrf is required and must be specified")
	}
	if r.createUpdateRuntimeFieldRequest == nil {
		return nil, reportError("createUpdateRuntimeFieldRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	// body params
	localVarPostBody = r.createUpdateRuntimeFieldRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateUpdateRuntimeFieldRequest struct {
	ctx                             context.Context
	ApiService                      DataViewsAPI
	kbnXsrf                         *string
	spaceId                         string
	viewId                          string
	createUpdateRuntimeFieldRequest *CreateUpdateRuntimeFieldRequest
}

// Cross-site request forgery protection
func (r ApiCreateUpdateRuntimeFieldRequest) KbnXsrf(kbnXsrf string) ApiCreateUpdateRuntimeFieldRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiCreateUpdateRuntimeFieldRequest) CreateUpdateRuntimeFieldRequest(createUpdateRuntimeFieldRequest CreateUpdateRuntimeFieldRequest) ApiCreateUpdateRuntimeFieldRequest {
	r.createUpdateRuntimeFieldRequest = &createUpdateRuntimeFieldRequest
	return r
}

func (r ApiCreateUpdateRuntimeFieldRequest) Execute() (*CreateUpdateRuntimeField200Response, *http.Response, error) {
	return r.ApiService.CreateUpdateRuntimeFieldExecute(r)
}

/*
CreateUpdateRuntimeField Create or update an existing runtime field.

This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@param viewId The ID of the data view fields you want to update.
	@return ApiCreateUpdateRuntimeFieldRequest
*/
func (a *DataViewsAPIService) CreateUpdateRuntimeField(ctx context.Context, spaceId string, viewId string) ApiCreateUpdateRuntimeFieldRequest {
	return ApiCreateUpdateRuntimeFieldRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
		viewId:     viewId,
	}
}

// Execute executes the request
//
//	@return CreateUpdateRuntimeField200Response
func (a *DataViewsAPIService) CreateUpdateRuntimeFieldExecute(r ApiCreateUpdateRuntimeFieldRequest) (*CreateUpdateRuntimeField200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateUpdateRuntimeField200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewsAPIService.CreateUpdateRuntimeField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/data_views/data_view/{viewId}/runtime_field"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"viewId"+"}", url.PathEscape(parameterValueToString(r.viewId, "viewId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return localVarReturnValue, nil, reportError("kbnXsrf is required and must be specified")
	}
	if r.createUpdateRuntimeFieldRequest == nil {
		return localVarReturnValue, nil, reportError("createUpdateRuntimeFieldRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	// body params
	localVarPostBody = r.createUpdateRuntimeFieldRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Model400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDataViewRequest struct {
	ctx        context.Context
	ApiService DataViewsAPI
	kbnXsrf    *string
	viewId     string
	spaceId    string
}

// Cross-site request forgery protection
func (r ApiDeleteDataViewRequest) KbnXsrf(kbnXsrf string) ApiDeleteDataViewRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiDeleteDataViewRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDataViewExecute(r)
}

/*
DeleteDataView Deletes a data view.

WARNING: When you delete a data view, it cannot be recovered. This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param viewId An identifier for the data view.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiDeleteDataViewRequest
*/
func (a *DataViewsAPIService) DeleteDataView(ctx context.Context, viewId string, spaceId string) ApiDeleteDataViewRequest {
	return ApiDeleteDataViewRequest{
		ApiService: a,
		ctx:        ctx,
		viewId:     viewId,
		spaceId:    spaceId,
	}
}

// Execute executes the request
func (a *DataViewsAPIService) DeleteDataViewExecute(r ApiDeleteDataViewRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewsAPIService.DeleteDataView")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/data_views/data_view/{viewId}"
	localVarPath = strings.Replace(localVarPath, "{"+"viewId"+"}", url.PathEscape(parameterValueToString(r.viewId, "viewId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return nil, reportError("kbnXsrf is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Model404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteRuntimeFieldRequest struct {
	ctx        context.Context
	ApiService DataViewsAPI
	fieldName  string
	viewId     string
	spaceId    string
}

func (r ApiDeleteRuntimeFieldRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRuntimeFieldExecute(r)
}

/*
DeleteRuntimeField Delete a runtime field from a data view.

This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fieldName The name of the runtime field.
	@param viewId An identifier for the data view.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiDeleteRuntimeFieldRequest
*/
func (a *DataViewsAPIService) DeleteRuntimeField(ctx context.Context, fieldName string, viewId string, spaceId string) ApiDeleteRuntimeFieldRequest {
	return ApiDeleteRuntimeFieldRequest{
		ApiService: a,
		ctx:        ctx,
		fieldName:  fieldName,
		viewId:     viewId,
		spaceId:    spaceId,
	}
}

// Execute executes the request
func (a *DataViewsAPIService) DeleteRuntimeFieldExecute(r ApiDeleteRuntimeFieldRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewsAPIService.DeleteRuntimeField")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/data_views/data_view/{viewId}/runtime_field/{fieldName}"
	localVarPath = strings.Replace(localVarPath, "{"+"fieldName"+"}", url.PathEscape(parameterValueToString(r.fieldName, "fieldName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"viewId"+"}", url.PathEscape(parameterValueToString(r.viewId, "viewId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Model404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllDataViewsRequest struct {
	ctx        context.Context
	ApiService DataViewsAPI
	spaceId    string
}

func (r ApiGetAllDataViewsRequest) Execute() (*GetAllDataViews200Response, *http.Response, error) {
	return r.ApiService.GetAllDataViewsExecute(r)
}

/*
GetAllDataViews Retrieves a list of all data views.

This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiGetAllDataViewsRequest
*/
func (a *DataViewsAPIService) GetAllDataViews(ctx context.Context, spaceId string) ApiGetAllDataViewsRequest {
	return ApiGetAllDataViewsRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return GetAllDataViews200Response
func (a *DataViewsAPIService) GetAllDataViewsExecute(r ApiGetAllDataViewsRequest) (*GetAllDataViews200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetAllDataViews200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewsAPIService.GetAllDataViews")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/data_views"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Model400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDataViewRequest struct {
	ctx        context.Context
	ApiService DataViewsAPI
	viewId     string
	spaceId    string
}

func (r ApiGetDataViewRequest) Execute() (*DataViewResponseObject, *http.Response, error) {
	return r.ApiService.GetDataViewExecute(r)
}

/*
GetDataView Retrieves a single data view by identifier.

This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param viewId An identifier for the data view.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiGetDataViewRequest
*/
func (a *DataViewsAPIService) GetDataView(ctx context.Context, viewId string, spaceId string) ApiGetDataViewRequest {
	return ApiGetDataViewRequest{
		ApiService: a,
		ctx:        ctx,
		viewId:     viewId,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return DataViewResponseObject
func (a *DataViewsAPIService) GetDataViewExecute(r ApiGetDataViewRequest) (*DataViewResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataViewResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewsAPIService.GetDataView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/data_views/data_view/{viewId}"
	localVarPath = strings.Replace(localVarPath, "{"+"viewId"+"}", url.PathEscape(parameterValueToString(r.viewId, "viewId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Model404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDefaultDataViewRequest struct {
	ctx        context.Context
	ApiService DataViewsAPI
	spaceId    string
}

func (r ApiGetDefaultDataViewRequest) Execute() (*GetDefaultDataView200Response, *http.Response, error) {
	return r.ApiService.GetDefaultDataViewExecute(r)
}

/*
GetDefaultDataView Retrieves the default data view identifier.

This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiGetDefaultDataViewRequest
*/
func (a *DataViewsAPIService) GetDefaultDataView(ctx context.Context, spaceId string) ApiGetDefaultDataViewRequest {
	return ApiGetDefaultDataViewRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return GetDefaultDataView200Response
func (a *DataViewsAPIService) GetDefaultDataViewExecute(r ApiGetDefaultDataViewRequest) (*GetDefaultDataView200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetDefaultDataView200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewsAPIService.GetDefaultDataView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/data_views/default"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Model400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRuntimeFieldRequest struct {
	ctx        context.Context
	ApiService DataViewsAPI
	fieldName  string
	viewId     string
	spaceId    string
}

func (r ApiGetRuntimeFieldRequest) Execute() (*CreateUpdateRuntimeField200Response, *http.Response, error) {
	return r.ApiService.GetRuntimeFieldExecute(r)
}

/*
GetRuntimeField Retrieves a runtime field.

This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fieldName The name of the runtime field.
	@param viewId An identifier for the data view.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiGetRuntimeFieldRequest
*/
func (a *DataViewsAPIService) GetRuntimeField(ctx context.Context, fieldName string, viewId string, spaceId string) ApiGetRuntimeFieldRequest {
	return ApiGetRuntimeFieldRequest{
		ApiService: a,
		ctx:        ctx,
		fieldName:  fieldName,
		viewId:     viewId,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return CreateUpdateRuntimeField200Response
func (a *DataViewsAPIService) GetRuntimeFieldExecute(r ApiGetRuntimeFieldRequest) (*CreateUpdateRuntimeField200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *CreateUpdateRuntimeField200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewsAPIService.GetRuntimeField")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/data_views/data_view/{viewId}/runtime_field/{fieldName}"
	localVarPath = strings.Replace(localVarPath, "{"+"fieldName"+"}", url.PathEscape(parameterValueToString(r.fieldName, "fieldName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"viewId"+"}", url.PathEscape(parameterValueToString(r.viewId, "viewId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Model404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetDefaultDatailViewRequest struct {
	ctx                         context.Context
	ApiService                  DataViewsAPI
	kbnXsrf                     *string
	spaceId                     string
	setDefaultDatailViewRequest *SetDefaultDatailViewRequest
}

// Cross-site request forgery protection
func (r ApiSetDefaultDatailViewRequest) KbnXsrf(kbnXsrf string) ApiSetDefaultDatailViewRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiSetDefaultDatailViewRequest) SetDefaultDatailViewRequest(setDefaultDatailViewRequest SetDefaultDatailViewRequest) ApiSetDefaultDatailViewRequest {
	r.setDefaultDatailViewRequest = &setDefaultDatailViewRequest
	return r
}

func (r ApiSetDefaultDatailViewRequest) Execute() (*SetDefaultDatailView200Response, *http.Response, error) {
	return r.ApiService.SetDefaultDatailViewExecute(r)
}

/*
SetDefaultDatailView Sets the default data view identifier.

This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiSetDefaultDatailViewRequest
*/
func (a *DataViewsAPIService) SetDefaultDatailView(ctx context.Context, spaceId string) ApiSetDefaultDatailViewRequest {
	return ApiSetDefaultDatailViewRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return SetDefaultDatailView200Response
func (a *DataViewsAPIService) SetDefaultDatailViewExecute(r ApiSetDefaultDatailViewRequest) (*SetDefaultDatailView200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SetDefaultDatailView200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewsAPIService.SetDefaultDatailView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/data_views/default"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return localVarReturnValue, nil, reportError("kbnXsrf is required and must be specified")
	}
	if r.setDefaultDatailViewRequest == nil {
		return localVarReturnValue, nil, reportError("setDefaultDatailViewRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	// body params
	localVarPostBody = r.setDefaultDatailViewRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Model400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateDataViewRequest struct {
	ctx                         context.Context
	ApiService                  DataViewsAPI
	kbnXsrf                     *string
	viewId                      string
	spaceId                     string
	updateDataViewRequestObject *UpdateDataViewRequestObject
}

// Cross-site request forgery protection
func (r ApiUpdateDataViewRequest) KbnXsrf(kbnXsrf string) ApiUpdateDataViewRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiUpdateDataViewRequest) UpdateDataViewRequestObject(updateDataViewRequestObject UpdateDataViewRequestObject) ApiUpdateDataViewRequest {
	r.updateDataViewRequestObject = &updateDataViewRequestObject
	return r
}

func (r ApiUpdateDataViewRequest) Execute() (*DataViewResponseObject, *http.Response, error) {
	return r.ApiService.UpdateDataViewExecute(r)
}

/*
UpdateDataView Updates a data view.

This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param viewId An identifier for the data view.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiUpdateDataViewRequest
*/
func (a *DataViewsAPIService) UpdateDataView(ctx context.Context, viewId string, spaceId string) ApiUpdateDataViewRequest {
	return ApiUpdateDataViewRequest{
		ApiService: a,
		ctx:        ctx,
		viewId:     viewId,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return DataViewResponseObject
func (a *DataViewsAPIService) UpdateDataViewExecute(r ApiUpdateDataViewRequest) (*DataViewResponseObject, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *DataViewResponseObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewsAPIService.UpdateDataView")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/data_views/data_view/{viewId}"
	localVarPath = strings.Replace(localVarPath, "{"+"viewId"+"}", url.PathEscape(parameterValueToString(r.viewId, "viewId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return localVarReturnValue, nil, reportError("kbnXsrf is required and must be specified")
	}
	if r.updateDataViewRequestObject == nil {
		return localVarReturnValue, nil, reportError("updateDataViewRequestObject is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	// body params
	localVarPostBody = r.updateDataViewRequestObject
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Model400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateFieldsMetadataRequest struct {
	ctx                         context.Context
	ApiService                  DataViewsAPI
	kbnXsrf                     *string
	viewId                      string
	spaceId                     string
	updateFieldsMetadataRequest *UpdateFieldsMetadataRequest
}

// Cross-site request forgery protection
func (r ApiUpdateFieldsMetadataRequest) KbnXsrf(kbnXsrf string) ApiUpdateFieldsMetadataRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiUpdateFieldsMetadataRequest) UpdateFieldsMetadataRequest(updateFieldsMetadataRequest UpdateFieldsMetadataRequest) ApiUpdateFieldsMetadataRequest {
	r.updateFieldsMetadataRequest = &updateFieldsMetadataRequest
	return r
}

func (r ApiUpdateFieldsMetadataRequest) Execute() (*SetDefaultDatailView200Response, *http.Response, error) {
	return r.ApiService.UpdateFieldsMetadataExecute(r)
}

/*
UpdateFieldsMetadata Update fields presentation metadata such as count, customLabel and format.

This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features. You can update multiple fields in one request. Updates are merged with persisted metadata. To remove existing metadata, specify null as the value.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param viewId An identifier for the data view.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiUpdateFieldsMetadataRequest
*/
func (a *DataViewsAPIService) UpdateFieldsMetadata(ctx context.Context, viewId string, spaceId string) ApiUpdateFieldsMetadataRequest {
	return ApiUpdateFieldsMetadataRequest{
		ApiService: a,
		ctx:        ctx,
		viewId:     viewId,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return SetDefaultDatailView200Response
func (a *DataViewsAPIService) UpdateFieldsMetadataExecute(r ApiUpdateFieldsMetadataRequest) (*SetDefaultDatailView200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SetDefaultDatailView200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewsAPIService.UpdateFieldsMetadata")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/data_views/data_view/{viewId}/fields"
	localVarPath = strings.Replace(localVarPath, "{"+"viewId"+"}", url.PathEscape(parameterValueToString(r.viewId, "viewId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return localVarReturnValue, nil, reportError("kbnXsrf is required and must be specified")
	}
	if r.updateFieldsMetadataRequest == nil {
		return localVarReturnValue, nil, reportError("updateFieldsMetadataRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	// body params
	localVarPostBody = r.updateFieldsMetadataRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Model400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateRuntimeFieldRequest struct {
	ctx                       context.Context
	ApiService                DataViewsAPI
	fieldName                 string
	viewId                    string
	spaceId                   string
	updateRuntimeFieldRequest *UpdateRuntimeFieldRequest
}

func (r ApiUpdateRuntimeFieldRequest) UpdateRuntimeFieldRequest(updateRuntimeFieldRequest UpdateRuntimeFieldRequest) ApiUpdateRuntimeFieldRequest {
	r.updateRuntimeFieldRequest = &updateRuntimeFieldRequest
	return r
}

func (r ApiUpdateRuntimeFieldRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateRuntimeFieldExecute(r)
}

/*
UpdateRuntimeField Update an existing runtime field.

This functionality is in technical preview and may be changed or removed in a future release. Elastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param fieldName The name of the runtime field.
	@param viewId An identifier for the data view.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiUpdateRuntimeFieldRequest
*/
func (a *DataViewsAPIService) UpdateRuntimeField(ctx context.Context, fieldName string, viewId string, spaceId string) ApiUpdateRuntimeFieldRequest {
	return ApiUpdateRuntimeFieldRequest{
		ApiService: a,
		ctx:        ctx,
		fieldName:  fieldName,
		viewId:     viewId,
		spaceId:    spaceId,
	}
}

// Execute executes the request
func (a *DataViewsAPIService) UpdateRuntimeFieldExecute(r ApiUpdateRuntimeFieldRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DataViewsAPIService.UpdateRuntimeField")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/data_views/data_view/{viewId}/runtime_field/{fieldName}"
	localVarPath = strings.Replace(localVarPath, "{"+"fieldName"+"}", url.PathEscape(parameterValueToString(r.fieldName, "fieldName")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"viewId"+"}", url.PathEscape(parameterValueToString(r.viewId, "viewId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateRuntimeFieldRequest == nil {
		return nil, reportError("updateRuntimeFieldRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateRuntimeFieldRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Model400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
