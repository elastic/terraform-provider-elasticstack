// Package fleetapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package fleetapi

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyAuthScopes = "apiKeyAuth.Scopes"
	BasicAuthScopes  = "basicAuth.Scopes"
)

// Defines values for AgentPolicyMonitoringEnabled.
const (
	AgentPolicyMonitoringEnabledLogs    AgentPolicyMonitoringEnabled = "logs"
	AgentPolicyMonitoringEnabledMetrics AgentPolicyMonitoringEnabled = "metrics"
	AgentPolicyMonitoringEnabledTraces  AgentPolicyMonitoringEnabled = "traces"
)

// Defines values for AgentPolicyPackagePolicies1InputsStreamsRelease.
const (
	AgentPolicyPackagePolicies1InputsStreamsReleaseBeta         AgentPolicyPackagePolicies1InputsStreamsRelease = "beta"
	AgentPolicyPackagePolicies1InputsStreamsReleaseExperimental AgentPolicyPackagePolicies1InputsStreamsRelease = "experimental"
	AgentPolicyPackagePolicies1InputsStreamsReleaseGa           AgentPolicyPackagePolicies1InputsStreamsRelease = "ga"
)

// Defines values for AgentPolicyStatus.
const (
	Active   AgentPolicyStatus = "active"
	Inactive AgentPolicyStatus = "inactive"
)

// Defines values for NewOutputElasticsearchPreset.
const (
	NewOutputElasticsearchPresetBalanced   NewOutputElasticsearchPreset = "balanced"
	NewOutputElasticsearchPresetCustom     NewOutputElasticsearchPreset = "custom"
	NewOutputElasticsearchPresetLatency    NewOutputElasticsearchPreset = "latency"
	NewOutputElasticsearchPresetScale      NewOutputElasticsearchPreset = "scale"
	NewOutputElasticsearchPresetThroughput NewOutputElasticsearchPreset = "throughput"
)

// Defines values for NewOutputElasticsearchType.
const (
	NewOutputElasticsearchTypeElasticsearch NewOutputElasticsearchType = "elasticsearch"
)

// Defines values for NewOutputKafkaAuthType.
const (
	NewOutputKafkaAuthTypeKerberos NewOutputKafkaAuthType = "kerberos"
	NewOutputKafkaAuthTypeNone     NewOutputKafkaAuthType = "none"
	NewOutputKafkaAuthTypeSsl      NewOutputKafkaAuthType = "ssl"
	NewOutputKafkaAuthTypeUserPass NewOutputKafkaAuthType = "user_pass"
)

// Defines values for NewOutputKafkaCompression.
const (
	NewOutputKafkaCompressionGzip   NewOutputKafkaCompression = "gzip"
	NewOutputKafkaCompressionLz4    NewOutputKafkaCompression = "lz4"
	NewOutputKafkaCompressionNone   NewOutputKafkaCompression = "none"
	NewOutputKafkaCompressionSnappy NewOutputKafkaCompression = "snappy"
)

// Defines values for NewOutputKafkaPartition.
const (
	NewOutputKafkaPartitionHash       NewOutputKafkaPartition = "hash"
	NewOutputKafkaPartitionRandom     NewOutputKafkaPartition = "random"
	NewOutputKafkaPartitionRoundRobin NewOutputKafkaPartition = "round_robin"
)

// Defines values for NewOutputKafkaRequiredAcks.
const (
	NewOutputKafkaRequiredAcksMinus1 NewOutputKafkaRequiredAcks = -1
	NewOutputKafkaRequiredAcksN0     NewOutputKafkaRequiredAcks = 0
	NewOutputKafkaRequiredAcksN1     NewOutputKafkaRequiredAcks = 1
)

// Defines values for NewOutputKafkaSaslMechanism.
const (
	NewOutputKafkaSaslMechanismPLAIN       NewOutputKafkaSaslMechanism = "PLAIN"
	NewOutputKafkaSaslMechanismSCRAMSHA256 NewOutputKafkaSaslMechanism = "SCRAM-SHA-256"
	NewOutputKafkaSaslMechanismSCRAMSHA512 NewOutputKafkaSaslMechanism = "SCRAM-SHA-512"
)

// Defines values for NewOutputKafkaTopicsWhenType.
const (
	NewOutputKafkaTopicsWhenTypeContains NewOutputKafkaTopicsWhenType = "contains"
	NewOutputKafkaTopicsWhenTypeEquals   NewOutputKafkaTopicsWhenType = "equals"
	NewOutputKafkaTopicsWhenTypeRegexp   NewOutputKafkaTopicsWhenType = "regexp"
)

// Defines values for NewOutputKafkaType.
const (
	NewOutputKafkaTypeKafka NewOutputKafkaType = "kafka"
)

// Defines values for NewOutputLogstashType.
const (
	NewOutputLogstashTypeLogstash NewOutputLogstashType = "logstash"
)

// Defines values for NewOutputRemoteElasticsearchPreset.
const (
	NewOutputRemoteElasticsearchPresetBalanced   NewOutputRemoteElasticsearchPreset = "balanced"
	NewOutputRemoteElasticsearchPresetCustom     NewOutputRemoteElasticsearchPreset = "custom"
	NewOutputRemoteElasticsearchPresetLatency    NewOutputRemoteElasticsearchPreset = "latency"
	NewOutputRemoteElasticsearchPresetScale      NewOutputRemoteElasticsearchPreset = "scale"
	NewOutputRemoteElasticsearchPresetThroughput NewOutputRemoteElasticsearchPreset = "throughput"
)

// Defines values for NewOutputRemoteElasticsearchType.
const (
	NewOutputRemoteElasticsearchTypeRemoteElasticsearch NewOutputRemoteElasticsearchType = "remote_elasticsearch"
)

// Defines values for NewOutputSslVerificationMode.
const (
	NewOutputSslVerificationModeCertificate NewOutputSslVerificationMode = "certificate"
	NewOutputSslVerificationModeFull        NewOutputSslVerificationMode = "full"
	NewOutputSslVerificationModeNone        NewOutputSslVerificationMode = "none"
	NewOutputSslVerificationModeStrict      NewOutputSslVerificationMode = "strict"
)

// Defines values for OutputElasticsearchPreset.
const (
	OutputElasticsearchPresetBalanced   OutputElasticsearchPreset = "balanced"
	OutputElasticsearchPresetCustom     OutputElasticsearchPreset = "custom"
	OutputElasticsearchPresetLatency    OutputElasticsearchPreset = "latency"
	OutputElasticsearchPresetScale      OutputElasticsearchPreset = "scale"
	OutputElasticsearchPresetThroughput OutputElasticsearchPreset = "throughput"
)

// Defines values for OutputElasticsearchType.
const (
	OutputElasticsearchTypeElasticsearch OutputElasticsearchType = "elasticsearch"
)

// Defines values for OutputKafkaAuthType.
const (
	OutputKafkaAuthTypeKerberos OutputKafkaAuthType = "kerberos"
	OutputKafkaAuthTypeNone     OutputKafkaAuthType = "none"
	OutputKafkaAuthTypeSsl      OutputKafkaAuthType = "ssl"
	OutputKafkaAuthTypeUserPass OutputKafkaAuthType = "user_pass"
)

// Defines values for OutputKafkaCompression.
const (
	OutputKafkaCompressionGzip   OutputKafkaCompression = "gzip"
	OutputKafkaCompressionLz4    OutputKafkaCompression = "lz4"
	OutputKafkaCompressionNone   OutputKafkaCompression = "none"
	OutputKafkaCompressionSnappy OutputKafkaCompression = "snappy"
)

// Defines values for OutputKafkaPartition.
const (
	OutputKafkaPartitionHash       OutputKafkaPartition = "hash"
	OutputKafkaPartitionRandom     OutputKafkaPartition = "random"
	OutputKafkaPartitionRoundRobin OutputKafkaPartition = "round_robin"
)

// Defines values for OutputKafkaRequiredAcks.
const (
	OutputKafkaRequiredAcksMinus1 OutputKafkaRequiredAcks = -1
	OutputKafkaRequiredAcksN0     OutputKafkaRequiredAcks = 0
	OutputKafkaRequiredAcksN1     OutputKafkaRequiredAcks = 1
)

// Defines values for OutputKafkaSaslMechanism.
const (
	OutputKafkaSaslMechanismPLAIN       OutputKafkaSaslMechanism = "PLAIN"
	OutputKafkaSaslMechanismSCRAMSHA256 OutputKafkaSaslMechanism = "SCRAM-SHA-256"
	OutputKafkaSaslMechanismSCRAMSHA512 OutputKafkaSaslMechanism = "SCRAM-SHA-512"
)

// Defines values for OutputKafkaTopicsWhenType.
const (
	OutputKafkaTopicsWhenTypeContains OutputKafkaTopicsWhenType = "contains"
	OutputKafkaTopicsWhenTypeEquals   OutputKafkaTopicsWhenType = "equals"
	OutputKafkaTopicsWhenTypeRegexp   OutputKafkaTopicsWhenType = "regexp"
)

// Defines values for OutputKafkaType.
const (
	OutputKafkaTypeKafka OutputKafkaType = "kafka"
)

// Defines values for OutputLogstashType.
const (
	OutputLogstashTypeLogstash OutputLogstashType = "logstash"
)

// Defines values for OutputRemoteElasticsearchPreset.
const (
	OutputRemoteElasticsearchPresetBalanced   OutputRemoteElasticsearchPreset = "balanced"
	OutputRemoteElasticsearchPresetCustom     OutputRemoteElasticsearchPreset = "custom"
	OutputRemoteElasticsearchPresetLatency    OutputRemoteElasticsearchPreset = "latency"
	OutputRemoteElasticsearchPresetScale      OutputRemoteElasticsearchPreset = "scale"
	OutputRemoteElasticsearchPresetThroughput OutputRemoteElasticsearchPreset = "throughput"
)

// Defines values for OutputRemoteElasticsearchType.
const (
	OutputRemoteElasticsearchTypeRemoteElasticsearch OutputRemoteElasticsearchType = "remote_elasticsearch"
)

// Defines values for OutputSslVerificationMode.
const (
	OutputSslVerificationModeCertificate OutputSslVerificationMode = "certificate"
	OutputSslVerificationModeFull        OutputSslVerificationMode = "full"
	OutputSslVerificationModeNone        OutputSslVerificationMode = "none"
	OutputSslVerificationModeStrict      OutputSslVerificationMode = "strict"
)

// Defines values for PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType.
const (
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaTypeCspRuleTemplate   PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType = "csp-rule-template"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaTypeDashboard         PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType = "dashboard"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaTypeIndexPattern      PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType = "index-pattern"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaTypeLens              PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType = "lens"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaTypeMap               PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType = "map"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaTypeMlModule          PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType = "ml-module"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaTypeOsqueryPackAsset  PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType = "osquery-pack-asset"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaTypeOsquerySavedQuery PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType = "osquery-saved-query"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaTypeSearch            PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType = "search"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaTypeSecurityRule      PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType = "security-rule"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaTypeTag               PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType = "tag"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaTypeVisualization     PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType = "visualization"
)

// Defines values for PackageInfoInstallationInfoInstallSource.
const (
	PackageInfoInstallationInfoInstallSourceBundled  PackageInfoInstallationInfoInstallSource = "bundled"
	PackageInfoInstallationInfoInstallSourceCustom   PackageInfoInstallationInfoInstallSource = "custom"
	PackageInfoInstallationInfoInstallSourceRegistry PackageInfoInstallationInfoInstallSource = "registry"
	PackageInfoInstallationInfoInstallSourceUpload   PackageInfoInstallationInfoInstallSource = "upload"
)

// Defines values for PackageInfoInstallationInfoInstallStatus.
const (
	PackageInfoInstallationInfoInstallStatusInstallFailed PackageInfoInstallationInfoInstallStatus = "install_failed"
	PackageInfoInstallationInfoInstallStatusInstalled     PackageInfoInstallationInfoInstallStatus = "installed"
	PackageInfoInstallationInfoInstallStatusInstalling    PackageInfoInstallationInfoInstallStatus = "installing"
)

// Defines values for PackageInfoInstallationInfoInstalledEsType.
const (
	PackageInfoInstallationInfoInstalledEsTypeComponentTemplate   PackageInfoInstallationInfoInstalledEsType = "component_template"
	PackageInfoInstallationInfoInstalledEsTypeDataStreamIlmPolicy PackageInfoInstallationInfoInstalledEsType = "data_stream_ilm_policy"
	PackageInfoInstallationInfoInstalledEsTypeIlmPolicy           PackageInfoInstallationInfoInstalledEsType = "ilm_policy"
	PackageInfoInstallationInfoInstalledEsTypeIndex               PackageInfoInstallationInfoInstalledEsType = "index"
	PackageInfoInstallationInfoInstalledEsTypeIndexTemplate       PackageInfoInstallationInfoInstalledEsType = "index_template"
	PackageInfoInstallationInfoInstalledEsTypeIngestPipeline      PackageInfoInstallationInfoInstalledEsType = "ingest_pipeline"
	PackageInfoInstallationInfoInstalledEsTypeMlModel             PackageInfoInstallationInfoInstalledEsType = "ml_model"
	PackageInfoInstallationInfoInstalledEsTypeTransform           PackageInfoInstallationInfoInstalledEsType = "transform"
)

// Defines values for PackageInfoInstallationInfoInstalledKibanaType.
const (
	PackageInfoInstallationInfoInstalledKibanaTypeCspRuleTemplate   PackageInfoInstallationInfoInstalledKibanaType = "csp-rule-template"
	PackageInfoInstallationInfoInstalledKibanaTypeDashboard         PackageInfoInstallationInfoInstalledKibanaType = "dashboard"
	PackageInfoInstallationInfoInstalledKibanaTypeIndexPattern      PackageInfoInstallationInfoInstalledKibanaType = "index-pattern"
	PackageInfoInstallationInfoInstalledKibanaTypeLens              PackageInfoInstallationInfoInstalledKibanaType = "lens"
	PackageInfoInstallationInfoInstalledKibanaTypeMap               PackageInfoInstallationInfoInstalledKibanaType = "map"
	PackageInfoInstallationInfoInstalledKibanaTypeMlModule          PackageInfoInstallationInfoInstalledKibanaType = "ml-module"
	PackageInfoInstallationInfoInstalledKibanaTypeOsqueryPackAsset  PackageInfoInstallationInfoInstalledKibanaType = "osquery-pack-asset"
	PackageInfoInstallationInfoInstalledKibanaTypeOsquerySavedQuery PackageInfoInstallationInfoInstalledKibanaType = "osquery-saved-query"
	PackageInfoInstallationInfoInstalledKibanaTypeSearch            PackageInfoInstallationInfoInstalledKibanaType = "search"
	PackageInfoInstallationInfoInstalledKibanaTypeSecurityRule      PackageInfoInstallationInfoInstalledKibanaType = "security-rule"
	PackageInfoInstallationInfoInstalledKibanaTypeTag               PackageInfoInstallationInfoInstalledKibanaType = "tag"
	PackageInfoInstallationInfoInstalledKibanaTypeVisualization     PackageInfoInstallationInfoInstalledKibanaType = "visualization"
)

// Defines values for PackageInfoInstallationInfoVerificationStatus.
const (
	PackageInfoInstallationInfoVerificationStatusUnknown    PackageInfoInstallationInfoVerificationStatus = "unknown"
	PackageInfoInstallationInfoVerificationStatusUnverified PackageInfoInstallationInfoVerificationStatus = "unverified"
	PackageInfoInstallationInfoVerificationStatusVerified   PackageInfoInstallationInfoVerificationStatus = "verified"
)

// Defines values for PackageInfoOwnerType.
const (
	PackageInfoOwnerTypeCommunity PackageInfoOwnerType = "community"
	PackageInfoOwnerTypeElastic   PackageInfoOwnerType = "elastic"
	PackageInfoOwnerTypePartner   PackageInfoOwnerType = "partner"
)

// Defines values for PackageInfoRelease.
const (
	PackageInfoReleaseBeta         PackageInfoRelease = "beta"
	PackageInfoReleaseExperimental PackageInfoRelease = "experimental"
	PackageInfoReleaseGa           PackageInfoRelease = "ga"
)

// Defines values for PackageInfoType.
const (
	PackageInfoTypeContent     PackageInfoType = "content"
	PackageInfoTypeInput       PackageInfoType = "input"
	PackageInfoTypeIntegration PackageInfoType = "integration"
)

// Defines values for PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType.
const (
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaTypeCspRuleTemplate   PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType = "csp-rule-template"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaTypeDashboard         PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType = "dashboard"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaTypeIndexPattern      PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType = "index-pattern"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaTypeLens              PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType = "lens"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaTypeMap               PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType = "map"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaTypeMlModule          PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType = "ml-module"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaTypeOsqueryPackAsset  PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType = "osquery-pack-asset"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaTypeOsquerySavedQuery PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType = "osquery-saved-query"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaTypeSearch            PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType = "search"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaTypeSecurityRule      PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType = "security-rule"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaTypeTag               PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType = "tag"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaTypeVisualization     PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType = "visualization"
)

// Defines values for PackageListItemInstallationInfoInstallSource.
const (
	PackageListItemInstallationInfoInstallSourceBundled  PackageListItemInstallationInfoInstallSource = "bundled"
	PackageListItemInstallationInfoInstallSourceCustom   PackageListItemInstallationInfoInstallSource = "custom"
	PackageListItemInstallationInfoInstallSourceRegistry PackageListItemInstallationInfoInstallSource = "registry"
	PackageListItemInstallationInfoInstallSourceUpload   PackageListItemInstallationInfoInstallSource = "upload"
)

// Defines values for PackageListItemInstallationInfoInstallStatus.
const (
	PackageListItemInstallationInfoInstallStatusInstallFailed PackageListItemInstallationInfoInstallStatus = "install_failed"
	PackageListItemInstallationInfoInstallStatusInstalled     PackageListItemInstallationInfoInstallStatus = "installed"
	PackageListItemInstallationInfoInstallStatusInstalling    PackageListItemInstallationInfoInstallStatus = "installing"
)

// Defines values for PackageListItemInstallationInfoInstalledEsType.
const (
	PackageListItemInstallationInfoInstalledEsTypeComponentTemplate   PackageListItemInstallationInfoInstalledEsType = "component_template"
	PackageListItemInstallationInfoInstalledEsTypeDataStreamIlmPolicy PackageListItemInstallationInfoInstalledEsType = "data_stream_ilm_policy"
	PackageListItemInstallationInfoInstalledEsTypeIlmPolicy           PackageListItemInstallationInfoInstalledEsType = "ilm_policy"
	PackageListItemInstallationInfoInstalledEsTypeIndex               PackageListItemInstallationInfoInstalledEsType = "index"
	PackageListItemInstallationInfoInstalledEsTypeIndexTemplate       PackageListItemInstallationInfoInstalledEsType = "index_template"
	PackageListItemInstallationInfoInstalledEsTypeIngestPipeline      PackageListItemInstallationInfoInstalledEsType = "ingest_pipeline"
	PackageListItemInstallationInfoInstalledEsTypeMlModel             PackageListItemInstallationInfoInstalledEsType = "ml_model"
	PackageListItemInstallationInfoInstalledEsTypeTransform           PackageListItemInstallationInfoInstalledEsType = "transform"
)

// Defines values for PackageListItemInstallationInfoInstalledKibanaType.
const (
	PackageListItemInstallationInfoInstalledKibanaTypeCspRuleTemplate   PackageListItemInstallationInfoInstalledKibanaType = "csp-rule-template"
	PackageListItemInstallationInfoInstalledKibanaTypeDashboard         PackageListItemInstallationInfoInstalledKibanaType = "dashboard"
	PackageListItemInstallationInfoInstalledKibanaTypeIndexPattern      PackageListItemInstallationInfoInstalledKibanaType = "index-pattern"
	PackageListItemInstallationInfoInstalledKibanaTypeLens              PackageListItemInstallationInfoInstalledKibanaType = "lens"
	PackageListItemInstallationInfoInstalledKibanaTypeMap               PackageListItemInstallationInfoInstalledKibanaType = "map"
	PackageListItemInstallationInfoInstalledKibanaTypeMlModule          PackageListItemInstallationInfoInstalledKibanaType = "ml-module"
	PackageListItemInstallationInfoInstalledKibanaTypeOsqueryPackAsset  PackageListItemInstallationInfoInstalledKibanaType = "osquery-pack-asset"
	PackageListItemInstallationInfoInstalledKibanaTypeOsquerySavedQuery PackageListItemInstallationInfoInstalledKibanaType = "osquery-saved-query"
	PackageListItemInstallationInfoInstalledKibanaTypeSearch            PackageListItemInstallationInfoInstalledKibanaType = "search"
	PackageListItemInstallationInfoInstalledKibanaTypeSecurityRule      PackageListItemInstallationInfoInstalledKibanaType = "security-rule"
	PackageListItemInstallationInfoInstalledKibanaTypeTag               PackageListItemInstallationInfoInstalledKibanaType = "tag"
	PackageListItemInstallationInfoInstalledKibanaTypeVisualization     PackageListItemInstallationInfoInstalledKibanaType = "visualization"
)

// Defines values for PackageListItemInstallationInfoVerificationStatus.
const (
	PackageListItemInstallationInfoVerificationStatusUnknown    PackageListItemInstallationInfoVerificationStatus = "unknown"
	PackageListItemInstallationInfoVerificationStatusUnverified PackageListItemInstallationInfoVerificationStatus = "unverified"
	PackageListItemInstallationInfoVerificationStatusVerified   PackageListItemInstallationInfoVerificationStatus = "verified"
)

// Defines values for PackageListItemOwnerType.
const (
	PackageListItemOwnerTypeCommunity PackageListItemOwnerType = "community"
	PackageListItemOwnerTypeElastic   PackageListItemOwnerType = "elastic"
	PackageListItemOwnerTypePartner   PackageListItemOwnerType = "partner"
)

// Defines values for PackageListItemRelease.
const (
	Beta         PackageListItemRelease = "beta"
	Experimental PackageListItemRelease = "experimental"
	Ga           PackageListItemRelease = "ga"
)

// Defines values for PackageListItemType.
const (
	PackageListItemTypeContent     PackageListItemType = "content"
	PackageListItemTypeInput       PackageListItemType = "input"
	PackageListItemTypeIntegration PackageListItemType = "integration"
)

// Defines values for UpdateOutputElasticsearchPreset.
const (
	UpdateOutputElasticsearchPresetBalanced   UpdateOutputElasticsearchPreset = "balanced"
	UpdateOutputElasticsearchPresetCustom     UpdateOutputElasticsearchPreset = "custom"
	UpdateOutputElasticsearchPresetLatency    UpdateOutputElasticsearchPreset = "latency"
	UpdateOutputElasticsearchPresetScale      UpdateOutputElasticsearchPreset = "scale"
	UpdateOutputElasticsearchPresetThroughput UpdateOutputElasticsearchPreset = "throughput"
)

// Defines values for UpdateOutputElasticsearchType.
const (
	Elasticsearch UpdateOutputElasticsearchType = "elasticsearch"
)

// Defines values for UpdateOutputKafkaAuthType.
const (
	UpdateOutputKafkaAuthTypeKerberos UpdateOutputKafkaAuthType = "kerberos"
	UpdateOutputKafkaAuthTypeNone     UpdateOutputKafkaAuthType = "none"
	UpdateOutputKafkaAuthTypeSsl      UpdateOutputKafkaAuthType = "ssl"
	UpdateOutputKafkaAuthTypeUserPass UpdateOutputKafkaAuthType = "user_pass"
)

// Defines values for UpdateOutputKafkaCompression.
const (
	UpdateOutputKafkaCompressionGzip   UpdateOutputKafkaCompression = "gzip"
	UpdateOutputKafkaCompressionLz4    UpdateOutputKafkaCompression = "lz4"
	UpdateOutputKafkaCompressionNone   UpdateOutputKafkaCompression = "none"
	UpdateOutputKafkaCompressionSnappy UpdateOutputKafkaCompression = "snappy"
)

// Defines values for UpdateOutputKafkaPartition.
const (
	Hash       UpdateOutputKafkaPartition = "hash"
	Random     UpdateOutputKafkaPartition = "random"
	RoundRobin UpdateOutputKafkaPartition = "round_robin"
)

// Defines values for UpdateOutputKafkaRequiredAcks.
const (
	Minus1 UpdateOutputKafkaRequiredAcks = -1
	N0     UpdateOutputKafkaRequiredAcks = 0
	N1     UpdateOutputKafkaRequiredAcks = 1
)

// Defines values for UpdateOutputKafkaSaslMechanism.
const (
	PLAIN       UpdateOutputKafkaSaslMechanism = "PLAIN"
	SCRAMSHA256 UpdateOutputKafkaSaslMechanism = "SCRAM-SHA-256"
	SCRAMSHA512 UpdateOutputKafkaSaslMechanism = "SCRAM-SHA-512"
)

// Defines values for UpdateOutputKafkaTopicsWhenType.
const (
	Contains UpdateOutputKafkaTopicsWhenType = "contains"
	Equals   UpdateOutputKafkaTopicsWhenType = "equals"
	Regexp   UpdateOutputKafkaTopicsWhenType = "regexp"
)

// Defines values for UpdateOutputKafkaType.
const (
	Kafka UpdateOutputKafkaType = "kafka"
)

// Defines values for UpdateOutputLogstashType.
const (
	Logstash UpdateOutputLogstashType = "logstash"
)

// Defines values for UpdateOutputRemoteElasticsearchPreset.
const (
	UpdateOutputRemoteElasticsearchPresetBalanced   UpdateOutputRemoteElasticsearchPreset = "balanced"
	UpdateOutputRemoteElasticsearchPresetCustom     UpdateOutputRemoteElasticsearchPreset = "custom"
	UpdateOutputRemoteElasticsearchPresetLatency    UpdateOutputRemoteElasticsearchPreset = "latency"
	UpdateOutputRemoteElasticsearchPresetScale      UpdateOutputRemoteElasticsearchPreset = "scale"
	UpdateOutputRemoteElasticsearchPresetThroughput UpdateOutputRemoteElasticsearchPreset = "throughput"
)

// Defines values for UpdateOutputRemoteElasticsearchType.
const (
	RemoteElasticsearch UpdateOutputRemoteElasticsearchType = "remote_elasticsearch"
)

// Defines values for UpdateOutputSslVerificationMode.
const (
	Certificate UpdateOutputSslVerificationMode = "certificate"
	Full        UpdateOutputSslVerificationMode = "full"
	None        UpdateOutputSslVerificationMode = "none"
	Strict      UpdateOutputSslVerificationMode = "strict"
)

// Defines values for GetAgentPoliciesParamsSortOrder.
const (
	GetAgentPoliciesParamsSortOrderAsc  GetAgentPoliciesParamsSortOrder = "asc"
	GetAgentPoliciesParamsSortOrderDesc GetAgentPoliciesParamsSortOrder = "desc"
)

// Defines values for GetAgentPoliciesParamsFormat.
const (
	GetAgentPoliciesParamsFormatLegacy     GetAgentPoliciesParamsFormat = "legacy"
	GetAgentPoliciesParamsFormatSimplified GetAgentPoliciesParamsFormat = "simplified"
)

// Defines values for CreateAgentPolicyJSONBodyMonitoringEnabled.
const (
	CreateAgentPolicyJSONBodyMonitoringEnabledLogs    CreateAgentPolicyJSONBodyMonitoringEnabled = "logs"
	CreateAgentPolicyJSONBodyMonitoringEnabledMetrics CreateAgentPolicyJSONBodyMonitoringEnabled = "metrics"
	CreateAgentPolicyJSONBodyMonitoringEnabledTraces  CreateAgentPolicyJSONBodyMonitoringEnabled = "traces"
)

// Defines values for GetAgentPolicyParamsFormat.
const (
	GetAgentPolicyParamsFormatLegacy     GetAgentPolicyParamsFormat = "legacy"
	GetAgentPolicyParamsFormatSimplified GetAgentPolicyParamsFormat = "simplified"
)

// Defines values for UpdateAgentPolicyParamsFormat.
const (
	UpdateAgentPolicyParamsFormatLegacy     UpdateAgentPolicyParamsFormat = "legacy"
	UpdateAgentPolicyParamsFormatSimplified UpdateAgentPolicyParamsFormat = "simplified"
)

// Defines values for UpdateAgentPolicyJSONBodyMonitoringEnabled.
const (
	Logs    UpdateAgentPolicyJSONBodyMonitoringEnabled = "logs"
	Metrics UpdateAgentPolicyJSONBodyMonitoringEnabled = "metrics"
	Traces  UpdateAgentPolicyJSONBodyMonitoringEnabled = "traces"
)

// Defines values for GetPackagePoliciesParamsSortOrder.
const (
	GetPackagePoliciesParamsSortOrderAsc  GetPackagePoliciesParamsSortOrder = "asc"
	GetPackagePoliciesParamsSortOrderDesc GetPackagePoliciesParamsSortOrder = "desc"
)

// Defines values for GetPackagePoliciesParamsFormat.
const (
	GetPackagePoliciesParamsFormatLegacy     GetPackagePoliciesParamsFormat = "legacy"
	GetPackagePoliciesParamsFormatSimplified GetPackagePoliciesParamsFormat = "simplified"
)

// Defines values for CreatePackagePolicyParamsFormat.
const (
	CreatePackagePolicyParamsFormatLegacy     CreatePackagePolicyParamsFormat = "legacy"
	CreatePackagePolicyParamsFormatSimplified CreatePackagePolicyParamsFormat = "simplified"
)

// Defines values for GetPackagePolicyParamsFormat.
const (
	GetPackagePolicyParamsFormatLegacy     GetPackagePolicyParamsFormat = "legacy"
	GetPackagePolicyParamsFormatSimplified GetPackagePolicyParamsFormat = "simplified"
)

// Defines values for UpdatePackagePolicyParamsFormat.
const (
	Legacy     UpdatePackagePolicyParamsFormat = "legacy"
	Simplified UpdatePackagePolicyParamsFormat = "simplified"
)

// AgentPolicy defines model for agent_policy.
type AgentPolicy struct {
	AdvancedSettings *struct {
		AgentDownloadTargetDirectory *interface{} `json:"agent_download_target_directory"`
		AgentDownloadTimeout         *interface{} `json:"agent_download_timeout"`
		AgentLimitsGoMaxProcs        *interface{} `json:"agent_limits_go_max_procs"`
		AgentLoggingLevel            *interface{} `json:"agent_logging_level"`
		AgentLoggingMetricsPeriod    *interface{} `json:"agent_logging_metrics_period"`
	} `json:"advanced_settings,omitempty"`
	AgentFeatures *[]struct {
		Enabled bool   `json:"enabled"`
		Name    string `json:"name"`
	} `json:"agent_features,omitempty"`
	Agents            *float32 `json:"agents,omitempty"`
	DataOutputId      *string  `json:"data_output_id"`
	Description       *string  `json:"description,omitempty"`
	DownloadSourceId  *string  `json:"download_source_id"`
	FleetServerHostId *string  `json:"fleet_server_host_id"`

	// GlobalDataTags User defined data tags that are added to all of the inputs. The values can be strings or numbers.
	GlobalDataTags *[]struct {
		Name  string                           `json:"name"`
		Value AgentPolicy_GlobalDataTags_Value `json:"value"`
	} `json:"global_data_tags,omitempty"`
	HasFleetServer       *bool    `json:"has_fleet_server,omitempty"`
	Id                   string   `json:"id"`
	InactivityTimeout    *float32 `json:"inactivity_timeout,omitempty"`
	IsDefault            *bool    `json:"is_default,omitempty"`
	IsDefaultFleetServer *bool    `json:"is_default_fleet_server,omitempty"`
	IsManaged            bool     `json:"is_managed"`
	IsPreconfigured      *bool    `json:"is_preconfigured,omitempty"`

	// IsProtected Indicates whether the agent policy has tamper protection enabled. Default false.
	IsProtected bool `json:"is_protected"`

	// KeepMonitoringAlive When set to true, monitoring will be enabled but logs/metrics collection will be disabled
	KeepMonitoringAlive   *bool `json:"keep_monitoring_alive"`
	MonitoringDiagnostics *struct {
		Limit *struct {
			Burst    *float32 `json:"burst,omitempty"`
			Interval *string  `json:"interval,omitempty"`
		} `json:"limit,omitempty"`
		Uploader *struct {
			InitDur    *string  `json:"init_dur,omitempty"`
			MaxDur     *string  `json:"max_dur,omitempty"`
			MaxRetries *float32 `json:"max_retries,omitempty"`
		} `json:"uploader,omitempty"`
	} `json:"monitoring_diagnostics,omitempty"`
	MonitoringEnabled *[]AgentPolicyMonitoringEnabled `json:"monitoring_enabled,omitempty"`
	MonitoringHttp    *struct {
		Buffer *struct {
			Enabled *bool `json:"enabled,omitempty"`
		} `json:"buffer,omitempty"`
		Enabled bool     `json:"enabled"`
		Host    *string  `json:"host,omitempty"`
		Port    *float32 `json:"port,omitempty"`
	} `json:"monitoring_http,omitempty"`
	MonitoringOutputId     *string `json:"monitoring_output_id"`
	MonitoringPprofEnabled *bool   `json:"monitoring_pprof_enabled,omitempty"`
	Name                   string  `json:"name"`
	Namespace              string  `json:"namespace"`

	// Overrides Override settings that are defined in the agent policy. Input settings cannot be overridden. The override option should be used only in unusual circumstances and not as a routine procedure.
	Overrides       *map[string]interface{}      `json:"overrides"`
	PackagePolicies *AgentPolicy_PackagePolicies `json:"package_policies,omitempty"`
	Revision        float32                      `json:"revision"`
	SchemaVersion   *string                      `json:"schema_version,omitempty"`
	SpaceIds        *[]string                    `json:"space_ids,omitempty"`
	Status          AgentPolicyStatus            `json:"status"`

	// SupportsAgentless Indicates whether the agent policy supports agentless integrations.
	SupportsAgentless  *bool    `json:"supports_agentless"`
	UnenrollTimeout    *float32 `json:"unenroll_timeout,omitempty"`
	UnprivilegedAgents *float32 `json:"unprivileged_agents,omitempty"`
	UpdatedAt          string   `json:"updated_at"`
	UpdatedBy          string   `json:"updated_by"`
	Version            *string  `json:"version,omitempty"`
}

// AgentPolicyGlobalDataTagsValue0 defines model for .
type AgentPolicyGlobalDataTagsValue0 = string

// AgentPolicyGlobalDataTagsValue1 defines model for .
type AgentPolicyGlobalDataTagsValue1 = float32

// AgentPolicy_GlobalDataTags_Value defines model for AgentPolicy.GlobalDataTags.Value.
type AgentPolicy_GlobalDataTags_Value struct {
	union json.RawMessage
}

// AgentPolicyMonitoringEnabled defines model for AgentPolicy.MonitoringEnabled.
type AgentPolicyMonitoringEnabled string

// AgentPolicyPackagePolicies0 defines model for .
type AgentPolicyPackagePolicies0 = []string

// AgentPolicyPackagePolicies1 This field is present only when retrieving a single agent policy, or when retrieving a list of agent policies with the ?full=true parameter
type AgentPolicyPackagePolicies1 = []struct {
	CreatedAt string `json:"created_at"`
	CreatedBy string `json:"created_by"`

	// Description Package policy description
	Description   *string                                      `json:"description,omitempty"`
	Elasticsearch *AgentPolicy_PackagePolicies_1_Elasticsearch `json:"elasticsearch,omitempty"`
	Enabled       bool                                         `json:"enabled"`
	Id            string                                       `json:"id"`
	Inputs        []struct {
		CompiledInput interface{} `json:"compiled_input"`

		// Config Package variable (see integration documentation for more information)
		Config *map[string]struct {
			Frozen *bool       `json:"frozen,omitempty"`
			Type   *string     `json:"type,omitempty"`
			Value  interface{} `json:"value"`
		} `json:"config,omitempty"`
		Enabled        bool    `json:"enabled"`
		Id             *string `json:"id,omitempty"`
		KeepEnabled    *bool   `json:"keep_enabled,omitempty"`
		PolicyTemplate *string `json:"policy_template,omitempty"`
		Streams        []struct {
			CompiledStream interface{} `json:"compiled_stream"`

			// Config Package variable (see integration documentation for more information)
			Config *map[string]struct {
				Frozen *bool       `json:"frozen,omitempty"`
				Type   *string     `json:"type,omitempty"`
				Value  interface{} `json:"value"`
			} `json:"config,omitempty"`
			DataStream struct {
				Dataset       string `json:"dataset"`
				Elasticsearch *struct {
					DynamicDataset   *bool `json:"dynamic_dataset,omitempty"`
					DynamicNamespace *bool `json:"dynamic_namespace,omitempty"`
					Privileges       *struct {
						Indices *[]string `json:"indices,omitempty"`
					} `json:"privileges,omitempty"`
				} `json:"elasticsearch,omitempty"`
				Type string `json:"type"`
			} `json:"data_stream"`
			Enabled     bool                                             `json:"enabled"`
			Id          *string                                          `json:"id,omitempty"`
			KeepEnabled *bool                                            `json:"keep_enabled,omitempty"`
			Release     *AgentPolicyPackagePolicies1InputsStreamsRelease `json:"release,omitempty"`

			// Vars Package variable (see integration documentation for more information)
			Vars *map[string]struct {
				Frozen *bool       `json:"frozen,omitempty"`
				Type   *string     `json:"type,omitempty"`
				Value  interface{} `json:"value"`
			} `json:"vars,omitempty"`
		} `json:"streams"`
		Type string `json:"type"`

		// Vars Package variable (see integration documentation for more information)
		Vars *map[string]struct {
			Frozen *bool       `json:"frozen,omitempty"`
			Type   *string     `json:"type,omitempty"`
			Value  interface{} `json:"value"`
		} `json:"vars,omitempty"`
	} `json:"inputs"`
	IsManaged *bool `json:"is_managed,omitempty"`

	// Name Package policy name (should be unique)
	Name string `json:"name"`

	// Namespace The package policy namespace. Leave blank to inherit the agent policy's namespace.
	Namespace *string `json:"namespace,omitempty"`
	OutputId  *string `json:"output_id"`

	// Overrides Override settings that are defined in the package policy. The override option should be used only in unusual circumstances and not as a routine procedure.
	Overrides *struct {
		Inputs *map[string]interface{} `json:"inputs,omitempty"`
	} `json:"overrides"`
	Package *struct {
		ExperimentalDataStreamFeatures *[]struct {
			DataStream string `json:"data_stream"`
			Features   struct {
				DocValueOnlyNumeric *bool `json:"doc_value_only_numeric,omitempty"`
				DocValueOnlyOther   *bool `json:"doc_value_only_other,omitempty"`
				SyntheticSource     *bool `json:"synthetic_source,omitempty"`
				Tsdb                *bool `json:"tsdb,omitempty"`
			} `json:"features"`
		} `json:"experimental_data_stream_features,omitempty"`

		// Name Package name
		Name         string  `json:"name"`
		RequiresRoot *bool   `json:"requires_root,omitempty"`
		Title        *string `json:"title,omitempty"`

		// Version Package version
		Version string `json:"version"`
	} `json:"package,omitempty"`

	// PolicyId Agent policy ID where that package policy will be added
	// Deprecated:
	PolicyId         *string   `json:"policy_id"`
	PolicyIds        *[]string `json:"policy_ids,omitempty"`
	Revision         float32   `json:"revision"`
	SecretReferences *[]struct {
		Id string `json:"id"`
	} `json:"secret_references,omitempty"`
	UpdatedAt string `json:"updated_at"`
	UpdatedBy string `json:"updated_by"`

	// Vars Package variable (see integration documentation for more information)
	Vars *map[string]struct {
		Frozen *bool       `json:"frozen,omitempty"`
		Type   *string     `json:"type,omitempty"`
		Value  interface{} `json:"value"`
	} `json:"vars,omitempty"`
	Version *string `json:"version,omitempty"`
}

// AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges defines model for AgentPolicy.PackagePolicies.1.Elasticsearch.Privileges.
type AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges struct {
	Cluster              *[]string              `json:"cluster,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// AgentPolicy_PackagePolicies_1_Elasticsearch defines model for AgentPolicy.PackagePolicies.1.Elasticsearch.
type AgentPolicy_PackagePolicies_1_Elasticsearch struct {
	Privileges           *AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges `json:"privileges,omitempty"`
	AdditionalProperties map[string]interface{}                                  `json:"-"`
}

// AgentPolicyPackagePolicies1InputsStreamsRelease defines model for AgentPolicy.PackagePolicies.1.Inputs.Streams.Release.
type AgentPolicyPackagePolicies1InputsStreamsRelease string

// AgentPolicy_PackagePolicies defines model for AgentPolicy.PackagePolicies.
type AgentPolicy_PackagePolicies struct {
	union json.RawMessage
}

// AgentPolicyStatus defines model for AgentPolicy.Status.
type AgentPolicyStatus string

// EnrollmentApiKey defines model for enrollment_api_key.
type EnrollmentApiKey struct {
	// Active When false, the enrollment API key is revoked and cannot be used for enrolling Elastic Agents.
	Active bool `json:"active"`

	// ApiKey The enrollment API key (token) used for enrolling Elastic Agents.
	ApiKey string `json:"api_key"`

	// ApiKeyId The ID of the API key in the Security API.
	ApiKeyId  string `json:"api_key_id"`
	CreatedAt string `json:"created_at"`
	Id        string `json:"id"`

	// Name The name of the enrollment API key.
	Name *string `json:"name,omitempty"`

	// PolicyId The ID of the agent policy the Elastic Agent will be enrolled in.
	PolicyId *string `json:"policy_id,omitempty"`
}

// NewOutputElasticsearch defines model for new_output_elasticsearch.
type NewOutputElasticsearch struct {
	AllowEdit            *[]string                     `json:"allow_edit,omitempty"`
	CaSha256             *string                       `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                       `json:"ca_trusted_fingerprint,omitempty"`
	ConfigYaml           *string                       `json:"config_yaml"`
	Hosts                []string                      `json:"hosts"`
	Id                   *string                       `json:"id,omitempty"`
	IsDefault            *bool                         `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                         `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                         `json:"is_internal,omitempty"`
	IsPreconfigured      *bool                         `json:"is_preconfigured,omitempty"`
	Name                 string                        `json:"name"`
	Preset               *NewOutputElasticsearchPreset `json:"preset,omitempty"`
	ProxyId              *string                       `json:"proxy_id,omitempty"`
	Shipper              *NewOutputShipper             `json:"shipper,omitempty"`
	Ssl                  *NewOutputSsl                 `json:"ssl,omitempty"`
	Type                 NewOutputElasticsearchType    `json:"type"`
}

// NewOutputElasticsearchPreset defines model for NewOutputElasticsearch.Preset.
type NewOutputElasticsearchPreset string

// NewOutputElasticsearchType defines model for NewOutputElasticsearch.Type.
type NewOutputElasticsearchType string

// NewOutputKafka defines model for new_output_kafka.
type NewOutputKafka struct {
	AllowEdit            *[]string                  `json:"allow_edit,omitempty"`
	AuthType             NewOutputKafkaAuthType     `json:"auth_type"`
	BrokerTimeout        *float32                   `json:"broker_timeout,omitempty"`
	CaSha256             *string                    `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                    `json:"ca_trusted_fingerprint,omitempty"`
	ClientId             *string                    `json:"client_id,omitempty"`
	Compression          *NewOutputKafkaCompression `json:"compression,omitempty"`
	CompressionLevel     interface{}                `json:"compression_level"`
	ConfigYaml           *string                    `json:"config_yaml"`
	ConnectionType       interface{}                `json:"connection_type"`
	Hash                 *struct {
		Hash   *string `json:"hash,omitempty"`
		Random *bool   `json:"random,omitempty"`
	} `json:"hash,omitempty"`
	Headers *[]struct {
		Key   string `json:"key"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Hosts               []string                 `json:"hosts"`
	Id                  *string                  `json:"id,omitempty"`
	IsDefault           *bool                    `json:"is_default,omitempty"`
	IsDefaultMonitoring *bool                    `json:"is_default_monitoring,omitempty"`
	IsInternal          *bool                    `json:"is_internal,omitempty"`
	IsPreconfigured     *bool                    `json:"is_preconfigured,omitempty"`
	Key                 *string                  `json:"key,omitempty"`
	Name                string                   `json:"name"`
	Partition           *NewOutputKafkaPartition `json:"partition,omitempty"`
	Password            interface{}              `json:"password"`
	ProxyId             *string                  `json:"proxy_id,omitempty"`
	Random              *struct {
		GroupEvents *float32 `json:"group_events,omitempty"`
	} `json:"random,omitempty"`
	RequiredAcks *NewOutputKafkaRequiredAcks `json:"required_acks,omitempty"`
	RoundRobin   *struct {
		GroupEvents *float32 `json:"group_events,omitempty"`
	} `json:"round_robin,omitempty"`
	Sasl *struct {
		Mechanism *NewOutputKafkaSaslMechanism `json:"mechanism,omitempty"`
	} `json:"sasl"`
	Secrets *struct {
		Password *NewOutputKafka_Secrets_Password `json:"password,omitempty"`
		Ssl      *struct {
			Key NewOutputKafka_Secrets_Ssl_Key `json:"key"`
		} `json:"ssl,omitempty"`
	} `json:"secrets,omitempty"`
	Shipper *NewOutputShipper `json:"shipper,omitempty"`
	Ssl     *NewOutputSsl     `json:"ssl,omitempty"`
	Timeout *float32          `json:"timeout,omitempty"`
	Topic   *string           `json:"topic,omitempty"`
	Topics  *[]struct {
		Topic string `json:"topic"`
		When  *struct {
			Condition *string                       `json:"condition,omitempty"`
			Type      *NewOutputKafkaTopicsWhenType `json:"type,omitempty"`
		} `json:"when,omitempty"`
	} `json:"topics,omitempty"`
	Type     NewOutputKafkaType `json:"type"`
	Username interface{}        `json:"username"`
	Version  *string            `json:"version,omitempty"`
}

// NewOutputKafkaAuthType defines model for NewOutputKafka.AuthType.
type NewOutputKafkaAuthType string

// NewOutputKafkaCompression defines model for NewOutputKafka.Compression.
type NewOutputKafkaCompression string

// NewOutputKafkaPartition defines model for NewOutputKafka.Partition.
type NewOutputKafkaPartition string

// NewOutputKafkaRequiredAcks defines model for NewOutputKafka.RequiredAcks.
type NewOutputKafkaRequiredAcks int

// NewOutputKafkaSaslMechanism defines model for NewOutputKafka.Sasl.Mechanism.
type NewOutputKafkaSaslMechanism string

// NewOutputKafkaSecretsPassword0 defines model for .
type NewOutputKafkaSecretsPassword0 struct {
	Id string `json:"id"`
}

// NewOutputKafkaSecretsPassword1 defines model for .
type NewOutputKafkaSecretsPassword1 = string

// NewOutputKafka_Secrets_Password defines model for NewOutputKafka.Secrets.Password.
type NewOutputKafka_Secrets_Password struct {
	union json.RawMessage
}

// NewOutputKafkaSecretsSslKey0 defines model for .
type NewOutputKafkaSecretsSslKey0 struct {
	Id string `json:"id"`
}

// NewOutputKafkaSecretsSslKey1 defines model for .
type NewOutputKafkaSecretsSslKey1 = string

// NewOutputKafka_Secrets_Ssl_Key defines model for NewOutputKafka.Secrets.Ssl.Key.
type NewOutputKafka_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// NewOutputKafkaTopicsWhenType defines model for NewOutputKafka.Topics.When.Type.
type NewOutputKafkaTopicsWhenType string

// NewOutputKafkaType defines model for NewOutputKafka.Type.
type NewOutputKafkaType string

// NewOutputLogstash defines model for new_output_logstash.
type NewOutputLogstash struct {
	AllowEdit            *[]string `json:"allow_edit,omitempty"`
	CaSha256             *string   `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string   `json:"ca_trusted_fingerprint,omitempty"`
	ConfigYaml           *string   `json:"config_yaml"`
	Hosts                []string  `json:"hosts"`
	Id                   *string   `json:"id,omitempty"`
	IsDefault            *bool     `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool     `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool     `json:"is_internal,omitempty"`
	IsPreconfigured      *bool     `json:"is_preconfigured,omitempty"`
	Name                 string    `json:"name"`
	ProxyId              *string   `json:"proxy_id,omitempty"`
	Secrets              *struct {
		Ssl *struct {
			Key *NewOutputLogstash_Secrets_Ssl_Key `json:"key,omitempty"`
		} `json:"ssl,omitempty"`
	} `json:"secrets,omitempty"`
	Shipper *NewOutputShipper     `json:"shipper,omitempty"`
	Ssl     *NewOutputSsl         `json:"ssl,omitempty"`
	Type    NewOutputLogstashType `json:"type"`
}

// NewOutputLogstashSecretsSslKey0 defines model for .
type NewOutputLogstashSecretsSslKey0 struct {
	Id string `json:"id"`
}

// NewOutputLogstashSecretsSslKey1 defines model for .
type NewOutputLogstashSecretsSslKey1 = string

// NewOutputLogstash_Secrets_Ssl_Key defines model for NewOutputLogstash.Secrets.Ssl.Key.
type NewOutputLogstash_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// NewOutputLogstashType defines model for NewOutputLogstash.Type.
type NewOutputLogstashType string

// NewOutputRemoteElasticsearch defines model for new_output_remote_elasticsearch.
type NewOutputRemoteElasticsearch struct {
	AllowEdit            *[]string                           `json:"allow_edit,omitempty"`
	CaSha256             *string                             `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                             `json:"ca_trusted_fingerprint,omitempty"`
	ConfigYaml           *string                             `json:"config_yaml"`
	Hosts                []string                            `json:"hosts"`
	Id                   *string                             `json:"id,omitempty"`
	IsDefault            *bool                               `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                               `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                               `json:"is_internal,omitempty"`
	IsPreconfigured      *bool                               `json:"is_preconfigured,omitempty"`
	Name                 string                              `json:"name"`
	Preset               *NewOutputRemoteElasticsearchPreset `json:"preset,omitempty"`
	ProxyId              *string                             `json:"proxy_id,omitempty"`
	Secrets              *struct {
		ServiceToken *NewOutputRemoteElasticsearch_Secrets_ServiceToken `json:"service_token,omitempty"`
	} `json:"secrets,omitempty"`
	ServiceToken *string                          `json:"service_token"`
	Shipper      *NewOutputShipper                `json:"shipper,omitempty"`
	Ssl          *NewOutputSsl                    `json:"ssl,omitempty"`
	Type         NewOutputRemoteElasticsearchType `json:"type"`
}

// NewOutputRemoteElasticsearchPreset defines model for NewOutputRemoteElasticsearch.Preset.
type NewOutputRemoteElasticsearchPreset string

// NewOutputRemoteElasticsearchSecretsServiceToken0 defines model for .
type NewOutputRemoteElasticsearchSecretsServiceToken0 struct {
	Id string `json:"id"`
}

// NewOutputRemoteElasticsearchSecretsServiceToken1 defines model for .
type NewOutputRemoteElasticsearchSecretsServiceToken1 = string

// NewOutputRemoteElasticsearch_Secrets_ServiceToken defines model for NewOutputRemoteElasticsearch.Secrets.ServiceToken.
type NewOutputRemoteElasticsearch_Secrets_ServiceToken struct {
	union json.RawMessage
}

// NewOutputRemoteElasticsearchType defines model for NewOutputRemoteElasticsearch.Type.
type NewOutputRemoteElasticsearchType string

// NewOutputShipper defines model for new_output_shipper.
type NewOutputShipper struct {
	CompressionLevel            *float32 `json:"compression_level"`
	DiskQueueCompressionEnabled *bool    `json:"disk_queue_compression_enabled"`
	DiskQueueEnabled            *bool    `json:"disk_queue_enabled"`
	DiskQueueEncryptionEnabled  *bool    `json:"disk_queue_encryption_enabled"`
	DiskQueueMaxSize            *float32 `json:"disk_queue_max_size"`
	DiskQueuePath               *string  `json:"disk_queue_path"`
	Loadbalance                 *bool    `json:"loadbalance"`
	MaxBatchBytes               *float32 `json:"max_batch_bytes"`
	MemQueueEvents              *float32 `json:"mem_queue_events"`
	QueueFlushTimeout           *float32 `json:"queue_flush_timeout"`
}

// NewOutputSsl defines model for new_output_ssl.
type NewOutputSsl struct {
	Certificate            *string                       `json:"certificate,omitempty"`
	CertificateAuthorities *[]string                     `json:"certificate_authorities,omitempty"`
	Key                    *string                       `json:"key,omitempty"`
	VerificationMode       *NewOutputSslVerificationMode `json:"verification_mode,omitempty"`
}

// NewOutputSslVerificationMode defines model for NewOutputSsl.VerificationMode.
type NewOutputSslVerificationMode string

// NewOutputUnion defines model for new_output_union.
type NewOutputUnion struct {
	union json.RawMessage
}

// OutputElasticsearch defines model for output_elasticsearch.
type OutputElasticsearch struct {
	AllowEdit            *[]string                  `json:"allow_edit,omitempty"`
	CaSha256             *string                    `json:"ca_sha256"`
	CaTrustedFingerprint *string                    `json:"ca_trusted_fingerprint"`
	ConfigYaml           *string                    `json:"config_yaml"`
	Hosts                []string                   `json:"hosts"`
	Id                   *string                    `json:"id,omitempty"`
	IsDefault            *bool                      `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                      `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                      `json:"is_internal,omitempty"`
	IsPreconfigured      *bool                      `json:"is_preconfigured,omitempty"`
	Name                 string                     `json:"name"`
	Preset               *OutputElasticsearchPreset `json:"preset,omitempty"`
	ProxyId              *string                    `json:"proxy_id"`
	Shipper              *OutputShipper             `json:"shipper"`
	Ssl                  *OutputSsl                 `json:"ssl"`
	Type                 OutputElasticsearchType    `json:"type"`
	AdditionalProperties map[string]interface{}     `json:"-"`
}

// OutputElasticsearchPreset defines model for OutputElasticsearch.Preset.
type OutputElasticsearchPreset string

// OutputElasticsearchType defines model for OutputElasticsearch.Type.
type OutputElasticsearchType string

// OutputKafka defines model for output_kafka.
type OutputKafka struct {
	AllowEdit            *[]string                   `json:"allow_edit,omitempty"`
	AuthType             OutputKafkaAuthType         `json:"auth_type"`
	BrokerTimeout        *float32                    `json:"broker_timeout,omitempty"`
	CaSha256             *string                     `json:"ca_sha256"`
	CaTrustedFingerprint *string                     `json:"ca_trusted_fingerprint"`
	ClientId             *string                     `json:"client_id,omitempty"`
	Compression          *OutputKafkaCompression     `json:"compression,omitempty"`
	CompressionLevel     interface{}                 `json:"compression_level"`
	ConfigYaml           *string                     `json:"config_yaml"`
	ConnectionType       interface{}                 `json:"connection_type"`
	Hash                 *OutputKafka_Hash           `json:"hash,omitempty"`
	Headers              *[]OutputKafka_Headers_Item `json:"headers,omitempty"`
	Hosts                []string                    `json:"hosts"`
	Id                   *string                     `json:"id,omitempty"`
	IsDefault            *bool                       `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                       `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                       `json:"is_internal,omitempty"`
	IsPreconfigured      *bool                       `json:"is_preconfigured,omitempty"`
	Key                  *string                     `json:"key,omitempty"`
	Name                 string                      `json:"name"`
	Partition            *OutputKafkaPartition       `json:"partition,omitempty"`
	Password             interface{}                 `json:"password"`
	ProxyId              *string                     `json:"proxy_id"`
	Random               *OutputKafka_Random         `json:"random,omitempty"`
	RequiredAcks         *OutputKafkaRequiredAcks    `json:"required_acks,omitempty"`
	RoundRobin           *OutputKafka_RoundRobin     `json:"round_robin,omitempty"`
	Sasl                 *OutputKafka_Sasl           `json:"sasl"`
	Secrets              *OutputKafka_Secrets        `json:"secrets,omitempty"`
	Shipper              *OutputShipper              `json:"shipper"`
	Ssl                  *OutputSsl                  `json:"ssl"`
	Timeout              *float32                    `json:"timeout,omitempty"`
	Topic                *string                     `json:"topic,omitempty"`
	Topics               *[]OutputKafka_Topics_Item  `json:"topics,omitempty"`
	Type                 OutputKafkaType             `json:"type"`
	Username             interface{}                 `json:"username"`
	Version              *string                     `json:"version,omitempty"`
	AdditionalProperties map[string]interface{}      `json:"-"`
}

// OutputKafkaAuthType defines model for OutputKafka.AuthType.
type OutputKafkaAuthType string

// OutputKafkaCompression defines model for OutputKafka.Compression.
type OutputKafkaCompression string

// OutputKafka_Hash defines model for OutputKafka.Hash.
type OutputKafka_Hash struct {
	Hash                 *string                `json:"hash,omitempty"`
	Random               *bool                  `json:"random,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputKafka_Headers_Item defines model for output_kafka.headers.Item.
type OutputKafka_Headers_Item struct {
	Key                  string                 `json:"key"`
	Value                string                 `json:"value"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputKafkaPartition defines model for OutputKafka.Partition.
type OutputKafkaPartition string

// OutputKafka_Random defines model for OutputKafka.Random.
type OutputKafka_Random struct {
	GroupEvents          *float32               `json:"group_events,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputKafkaRequiredAcks defines model for OutputKafka.RequiredAcks.
type OutputKafkaRequiredAcks int

// OutputKafka_RoundRobin defines model for OutputKafka.RoundRobin.
type OutputKafka_RoundRobin struct {
	GroupEvents          *float32               `json:"group_events,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputKafkaSaslMechanism defines model for OutputKafka.Sasl.Mechanism.
type OutputKafkaSaslMechanism string

// OutputKafka_Sasl defines model for OutputKafka.Sasl.
type OutputKafka_Sasl struct {
	Mechanism            *OutputKafkaSaslMechanism `json:"mechanism,omitempty"`
	AdditionalProperties map[string]interface{}    `json:"-"`
}

// OutputKafkaSecretsPassword0 defines model for .
type OutputKafkaSecretsPassword0 struct {
	Id                   string                 `json:"id"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputKafkaSecretsPassword1 defines model for .
type OutputKafkaSecretsPassword1 = string

// OutputKafka_Secrets_Password defines model for OutputKafka.Secrets.Password.
type OutputKafka_Secrets_Password struct {
	union json.RawMessage
}

// OutputKafkaSecretsSslKey0 defines model for .
type OutputKafkaSecretsSslKey0 struct {
	Id                   string                 `json:"id"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputKafkaSecretsSslKey1 defines model for .
type OutputKafkaSecretsSslKey1 = string

// OutputKafka_Secrets_Ssl_Key defines model for OutputKafka.Secrets.Ssl.Key.
type OutputKafka_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// OutputKafka_Secrets_Ssl defines model for OutputKafka.Secrets.Ssl.
type OutputKafka_Secrets_Ssl struct {
	Key                  OutputKafka_Secrets_Ssl_Key `json:"key"`
	AdditionalProperties map[string]interface{}      `json:"-"`
}

// OutputKafka_Secrets defines model for OutputKafka.Secrets.
type OutputKafka_Secrets struct {
	Password             *OutputKafka_Secrets_Password `json:"password,omitempty"`
	Ssl                  *OutputKafka_Secrets_Ssl      `json:"ssl,omitempty"`
	AdditionalProperties map[string]interface{}        `json:"-"`
}

// OutputKafkaTopicsWhenType defines model for OutputKafka.Topics.When.Type.
type OutputKafkaTopicsWhenType string

// OutputKafka_Topics_When defines model for OutputKafka.Topics.When.
type OutputKafka_Topics_When struct {
	Condition            *string                    `json:"condition,omitempty"`
	Type                 *OutputKafkaTopicsWhenType `json:"type,omitempty"`
	AdditionalProperties map[string]interface{}     `json:"-"`
}

// OutputKafka_Topics_Item defines model for output_kafka.topics.Item.
type OutputKafka_Topics_Item struct {
	Topic                string                   `json:"topic"`
	When                 *OutputKafka_Topics_When `json:"when,omitempty"`
	AdditionalProperties map[string]interface{}   `json:"-"`
}

// OutputKafkaType defines model for OutputKafka.Type.
type OutputKafkaType string

// OutputLogstash defines model for output_logstash.
type OutputLogstash struct {
	AllowEdit            *[]string               `json:"allow_edit,omitempty"`
	CaSha256             *string                 `json:"ca_sha256"`
	CaTrustedFingerprint *string                 `json:"ca_trusted_fingerprint"`
	ConfigYaml           *string                 `json:"config_yaml"`
	Hosts                []string                `json:"hosts"`
	Id                   *string                 `json:"id,omitempty"`
	IsDefault            *bool                   `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                   `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                   `json:"is_internal,omitempty"`
	IsPreconfigured      *bool                   `json:"is_preconfigured,omitempty"`
	Name                 string                  `json:"name"`
	ProxyId              *string                 `json:"proxy_id"`
	Secrets              *OutputLogstash_Secrets `json:"secrets,omitempty"`
	Shipper              *OutputShipper          `json:"shipper"`
	Ssl                  *OutputSsl              `json:"ssl"`
	Type                 OutputLogstashType      `json:"type"`
	AdditionalProperties map[string]interface{}  `json:"-"`
}

// OutputLogstashSecretsSslKey0 defines model for .
type OutputLogstashSecretsSslKey0 struct {
	Id                   string                 `json:"id"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputLogstashSecretsSslKey1 defines model for .
type OutputLogstashSecretsSslKey1 = string

// OutputLogstash_Secrets_Ssl_Key defines model for OutputLogstash.Secrets.Ssl.Key.
type OutputLogstash_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// OutputLogstash_Secrets_Ssl defines model for OutputLogstash.Secrets.Ssl.
type OutputLogstash_Secrets_Ssl struct {
	Key                  *OutputLogstash_Secrets_Ssl_Key `json:"key,omitempty"`
	AdditionalProperties map[string]interface{}          `json:"-"`
}

// OutputLogstash_Secrets defines model for OutputLogstash.Secrets.
type OutputLogstash_Secrets struct {
	Ssl                  *OutputLogstash_Secrets_Ssl `json:"ssl,omitempty"`
	AdditionalProperties map[string]interface{}      `json:"-"`
}

// OutputLogstashType defines model for OutputLogstash.Type.
type OutputLogstashType string

// OutputRemoteElasticsearch defines model for output_remote_elasticsearch.
type OutputRemoteElasticsearch struct {
	AllowEdit            *[]string                          `json:"allow_edit,omitempty"`
	CaSha256             *string                            `json:"ca_sha256"`
	CaTrustedFingerprint *string                            `json:"ca_trusted_fingerprint"`
	ConfigYaml           *string                            `json:"config_yaml"`
	Hosts                []string                           `json:"hosts"`
	Id                   *string                            `json:"id,omitempty"`
	IsDefault            *bool                              `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                              `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                              `json:"is_internal,omitempty"`
	IsPreconfigured      *bool                              `json:"is_preconfigured,omitempty"`
	Name                 string                             `json:"name"`
	Preset               *OutputRemoteElasticsearchPreset   `json:"preset,omitempty"`
	ProxyId              *string                            `json:"proxy_id"`
	Secrets              *OutputRemoteElasticsearch_Secrets `json:"secrets,omitempty"`
	ServiceToken         *string                            `json:"service_token"`
	Shipper              *OutputShipper                     `json:"shipper"`
	Ssl                  *OutputSsl                         `json:"ssl"`
	Type                 OutputRemoteElasticsearchType      `json:"type"`
	AdditionalProperties map[string]interface{}             `json:"-"`
}

// OutputRemoteElasticsearchPreset defines model for OutputRemoteElasticsearch.Preset.
type OutputRemoteElasticsearchPreset string

// OutputRemoteElasticsearchSecretsServiceToken0 defines model for .
type OutputRemoteElasticsearchSecretsServiceToken0 struct {
	Id                   string                 `json:"id"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputRemoteElasticsearchSecretsServiceToken1 defines model for .
type OutputRemoteElasticsearchSecretsServiceToken1 = string

// OutputRemoteElasticsearch_Secrets_ServiceToken defines model for OutputRemoteElasticsearch.Secrets.ServiceToken.
type OutputRemoteElasticsearch_Secrets_ServiceToken struct {
	union json.RawMessage
}

// OutputRemoteElasticsearch_Secrets defines model for OutputRemoteElasticsearch.Secrets.
type OutputRemoteElasticsearch_Secrets struct {
	ServiceToken         *OutputRemoteElasticsearch_Secrets_ServiceToken `json:"service_token,omitempty"`
	AdditionalProperties map[string]interface{}                          `json:"-"`
}

// OutputRemoteElasticsearchType defines model for OutputRemoteElasticsearch.Type.
type OutputRemoteElasticsearchType string

// OutputShipper defines model for output_shipper.
type OutputShipper struct {
	CompressionLevel            *float32               `json:"compression_level"`
	DiskQueueCompressionEnabled *bool                  `json:"disk_queue_compression_enabled"`
	DiskQueueEnabled            *bool                  `json:"disk_queue_enabled"`
	DiskQueueEncryptionEnabled  *bool                  `json:"disk_queue_encryption_enabled"`
	DiskQueueMaxSize            *float32               `json:"disk_queue_max_size"`
	DiskQueuePath               *string                `json:"disk_queue_path"`
	Loadbalance                 *bool                  `json:"loadbalance"`
	MaxBatchBytes               *float32               `json:"max_batch_bytes"`
	MemQueueEvents              *float32               `json:"mem_queue_events"`
	QueueFlushTimeout           *float32               `json:"queue_flush_timeout"`
	AdditionalProperties        map[string]interface{} `json:"-"`
}

// OutputSsl defines model for output_ssl.
type OutputSsl struct {
	Certificate            *string                    `json:"certificate,omitempty"`
	CertificateAuthorities *[]string                  `json:"certificate_authorities,omitempty"`
	Key                    *string                    `json:"key,omitempty"`
	VerificationMode       *OutputSslVerificationMode `json:"verification_mode,omitempty"`
	AdditionalProperties   map[string]interface{}     `json:"-"`
}

// OutputSslVerificationMode defines model for OutputSsl.VerificationMode.
type OutputSslVerificationMode string

// OutputUnion defines model for output_union.
type OutputUnion struct {
	union json.RawMessage
}

// PackageInfo defines model for package_info.
type PackageInfo struct {
	Agent *struct {
		Privileges *struct {
			Root *bool `json:"root,omitempty"`
		} `json:"privileges,omitempty"`
	} `json:"agent,omitempty"`
	AssetTags *[]struct {
		AssetIds   *[]string `json:"asset_ids,omitempty"`
		AssetTypes *[]string `json:"asset_types,omitempty"`
		Text       string    `json:"text"`
	} `json:"asset_tags,omitempty"`
	Assets               map[string]interface{}        `json:"assets"`
	Categories           *[]string                     `json:"categories,omitempty"`
	Conditions           *PackageInfo_Conditions       `json:"conditions,omitempty"`
	DataStreams          *[]map[string]interface{}     `json:"data_streams,omitempty"`
	Description          *string                       `json:"description,omitempty"`
	Discovery            *PackageInfo_Discovery        `json:"discovery,omitempty"`
	Download             *string                       `json:"download,omitempty"`
	Elasticsearch        *map[string]interface{}       `json:"elasticsearch,omitempty"`
	FormatVersion        *string                       `json:"format_version,omitempty"`
	Icons                *[]PackageInfo_Icons_Item     `json:"icons,omitempty"`
	InstallationInfo     *PackageInfo_InstallationInfo `json:"installationInfo,omitempty"`
	Internal             *bool                         `json:"internal,omitempty"`
	KeepPoliciesUpToDate *bool                         `json:"keepPoliciesUpToDate,omitempty"`
	LatestVersion        *string                       `json:"latestVersion,omitempty"`
	License              *string                       `json:"license,omitempty"`
	LicensePath          *string                       `json:"licensePath,omitempty"`
	Name                 string                        `json:"name"`
	Notice               *string                       `json:"notice,omitempty"`
	Owner                *PackageInfo_Owner            `json:"owner,omitempty"`
	Path                 *string                       `json:"path,omitempty"`
	PolicyTemplates      *[]map[string]interface{}     `json:"policy_templates,omitempty"`
	Readme               *string                       `json:"readme,omitempty"`
	Release              *PackageInfoRelease           `json:"release,omitempty"`
	SavedObject          interface{}                   `json:"savedObject"`
	Screenshots          *[]struct {
		DarkMode *bool   `json:"dark_mode,omitempty"`
		Path     *string `json:"path,omitempty"`
		Size     *string `json:"size,omitempty"`
		Src      string  `json:"src"`
		Title    *string `json:"title,omitempty"`
		Type     *string `json:"type,omitempty"`
	} `json:"screenshots,omitempty"`
	SignaturePath        *string                   `json:"signature_path,omitempty"`
	Source               *PackageInfo_Source       `json:"source,omitempty"`
	Status               *string                   `json:"status,omitempty"`
	Title                string                    `json:"title"`
	Type                 *PackageInfoType          `json:"type,omitempty"`
	Vars                 *[]map[string]interface{} `json:"vars,omitempty"`
	Version              string                    `json:"version"`
	AdditionalProperties map[string]interface{}    `json:"-"`
}

// PackageInfo_Conditions_Elastic defines model for PackageInfo.Conditions.Elastic.
type PackageInfo_Conditions_Elastic struct {
	Capabilities         *[]string              `json:"capabilities,omitempty"`
	Subscription         *string                `json:"subscription,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfo_Conditions_Kibana defines model for PackageInfo.Conditions.Kibana.
type PackageInfo_Conditions_Kibana struct {
	Version              *string                `json:"version,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfo_Conditions defines model for PackageInfo.Conditions.
type PackageInfo_Conditions struct {
	Elastic              *PackageInfo_Conditions_Elastic `json:"elastic,omitempty"`
	Kibana               *PackageInfo_Conditions_Kibana  `json:"kibana,omitempty"`
	AdditionalProperties map[string]interface{}          `json:"-"`
}

// PackageInfo_Discovery_Fields_Item defines model for PackageInfo.Discovery.Fields.Item.
type PackageInfo_Discovery_Fields_Item struct {
	Name                 string                 `json:"name"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfo_Discovery defines model for PackageInfo.Discovery.
type PackageInfo_Discovery struct {
	Fields               *[]PackageInfo_Discovery_Fields_Item `json:"fields,omitempty"`
	AdditionalProperties map[string]interface{}               `json:"-"`
}

// PackageInfo_Icons_Item defines model for package_info.icons.Item.
type PackageInfo_Icons_Item struct {
	DarkMode             *bool                  `json:"dark_mode,omitempty"`
	Path                 *string                `json:"path,omitempty"`
	Size                 *string                `json:"size,omitempty"`
	Src                  string                 `json:"src"`
	Title                *string                `json:"title,omitempty"`
	Type                 *string                `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType defines model for PackageInfo.InstallationInfo.AdditionalSpacesInstalledKibana.Type.
type PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType string

// PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item defines model for PackageInfo.InstallationInfo.AdditionalSpacesInstalledKibana.Item.
type PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item struct {
	Id                   string                                                         `json:"id"`
	OriginId             *string                                                        `json:"originId,omitempty"`
	Type                 PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType `json:"type"`
	AdditionalProperties map[string]interface{}                                         `json:"-"`
}

// PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features defines model for PackageInfo.InstallationInfo.ExperimentalDataStreamFeatures.Features.
type PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features struct {
	DocValueOnlyNumeric  *bool                  `json:"doc_value_only_numeric,omitempty"`
	DocValueOnlyOther    *bool                  `json:"doc_value_only_other,omitempty"`
	SyntheticSource      *bool                  `json:"synthetic_source,omitempty"`
	Tsdb                 *bool                  `json:"tsdb,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item defines model for PackageInfo.InstallationInfo.ExperimentalDataStreamFeatures.Item.
type PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item struct {
	DataStream           string                                                               `json:"data_stream"`
	Features             PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features `json:"features"`
	AdditionalProperties map[string]interface{}                                               `json:"-"`
}

// PackageInfoInstallationInfoInstallSource defines model for PackageInfo.InstallationInfo.InstallSource.
type PackageInfoInstallationInfoInstallSource string

// PackageInfoInstallationInfoInstallStatus defines model for PackageInfo.InstallationInfo.InstallStatus.
type PackageInfoInstallationInfoInstallStatus string

// PackageInfoInstallationInfoInstalledEsType defines model for PackageInfo.InstallationInfo.InstalledEs.Type.
type PackageInfoInstallationInfoInstalledEsType string

// PackageInfo_InstallationInfo_InstalledEs_Item defines model for PackageInfo.InstallationInfo.InstalledEs.Item.
type PackageInfo_InstallationInfo_InstalledEs_Item struct {
	Deferred             *bool                                      `json:"deferred,omitempty"`
	Id                   string                                     `json:"id"`
	Type                 PackageInfoInstallationInfoInstalledEsType `json:"type"`
	Version              *string                                    `json:"version,omitempty"`
	AdditionalProperties map[string]interface{}                     `json:"-"`
}

// PackageInfoInstallationInfoInstalledKibanaType defines model for PackageInfo.InstallationInfo.InstalledKibana.Type.
type PackageInfoInstallationInfoInstalledKibanaType string

// PackageInfo_InstallationInfo_InstalledKibana_Item defines model for PackageInfo.InstallationInfo.InstalledKibana.Item.
type PackageInfo_InstallationInfo_InstalledKibana_Item struct {
	Id                   string                                         `json:"id"`
	OriginId             *string                                        `json:"originId,omitempty"`
	Type                 PackageInfoInstallationInfoInstalledKibanaType `json:"type"`
	AdditionalProperties map[string]interface{}                         `json:"-"`
}

// PackageInfo_InstallationInfo_LatestExecutedState defines model for PackageInfo.InstallationInfo.LatestExecutedState.
type PackageInfo_InstallationInfo_LatestExecutedState struct {
	Error                *string                `json:"error,omitempty"`
	Name                 string                 `json:"name"`
	StartedAt            string                 `json:"started_at"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error defines model for PackageInfo.InstallationInfo.LatestInstallFailedAttempts.Error.
type PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error struct {
	Message              string                 `json:"message"`
	Name                 string                 `json:"name"`
	Stack                *string                `json:"stack,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item defines model for PackageInfo.InstallationInfo.LatestInstallFailedAttempts.Item.
type PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item struct {
	CreatedAt            string                                                         `json:"created_at"`
	Error                PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error `json:"error"`
	TargetVersion        string                                                         `json:"target_version"`
	AdditionalProperties map[string]interface{}                                         `json:"-"`
}

// PackageInfoInstallationInfoVerificationStatus defines model for PackageInfo.InstallationInfo.VerificationStatus.
type PackageInfoInstallationInfoVerificationStatus string

// PackageInfo_InstallationInfo defines model for PackageInfo.InstallationInfo.
type PackageInfo_InstallationInfo struct {
	AdditionalSpacesInstalledKibana *map[string][]PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item `json:"additional_spaces_installed_kibana,omitempty"`
	CreatedAt                       *string                                                                         `json:"created_at,omitempty"`
	ExperimentalDataStreamFeatures  *[]PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item             `json:"experimental_data_stream_features,omitempty"`
	InstallFormatSchemaVersion      *string                                                                         `json:"install_format_schema_version,omitempty"`
	InstallSource                   PackageInfoInstallationInfoInstallSource                                        `json:"install_source"`
	InstallStatus                   PackageInfoInstallationInfoInstallStatus                                        `json:"install_status"`
	InstalledEs                     []PackageInfo_InstallationInfo_InstalledEs_Item                                 `json:"installed_es"`
	InstalledKibana                 []PackageInfo_InstallationInfo_InstalledKibana_Item                             `json:"installed_kibana"`
	InstalledKibanaSpaceId          *string                                                                         `json:"installed_kibana_space_id,omitempty"`
	LatestExecutedState             *PackageInfo_InstallationInfo_LatestExecutedState                               `json:"latest_executed_state,omitempty"`
	LatestInstallFailedAttempts     *[]PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item                `json:"latest_install_failed_attempts,omitempty"`
	Name                            string                                                                          `json:"name"`
	Namespaces                      *[]string                                                                       `json:"namespaces,omitempty"`
	Type                            string                                                                          `json:"type"`
	UpdatedAt                       *string                                                                         `json:"updated_at,omitempty"`
	VerificationKeyId               *string                                                                         `json:"verification_key_id"`
	VerificationStatus              PackageInfoInstallationInfoVerificationStatus                                   `json:"verification_status"`
	Version                         string                                                                          `json:"version"`
	AdditionalProperties            map[string]interface{}                                                          `json:"-"`
}

// PackageInfoOwnerType defines model for PackageInfo.Owner.Type.
type PackageInfoOwnerType string

// PackageInfo_Owner defines model for PackageInfo.Owner.
type PackageInfo_Owner struct {
	Github               *string                `json:"github,omitempty"`
	Type                 *PackageInfoOwnerType  `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfoRelease defines model for PackageInfo.Release.
type PackageInfoRelease string

// PackageInfo_Source defines model for PackageInfo.Source.
type PackageInfo_Source struct {
	License              string                 `json:"license"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfoType defines model for PackageInfo.Type.
type PackageInfoType string

// PackageListItem defines model for package_list_item.
type PackageListItem struct {
	Categories           *[]string                         `json:"categories,omitempty"`
	Conditions           *PackageListItem_Conditions       `json:"conditions,omitempty"`
	DataStreams          *[]map[string]interface{}         `json:"data_streams,omitempty"`
	Description          *string                           `json:"description,omitempty"`
	Discovery            *PackageListItem_Discovery        `json:"discovery,omitempty"`
	Download             *string                           `json:"download,omitempty"`
	FormatVersion        *string                           `json:"format_version,omitempty"`
	Icons                *[]PackageListItem_Icons_Item     `json:"icons,omitempty"`
	Id                   string                            `json:"id"`
	InstallationInfo     *PackageListItem_InstallationInfo `json:"installationInfo,omitempty"`
	Integration          *string                           `json:"integration,omitempty"`
	Internal             *bool                             `json:"internal,omitempty"`
	LatestVersion        *string                           `json:"latestVersion,omitempty"`
	Name                 string                            `json:"name"`
	Owner                *PackageListItem_Owner            `json:"owner,omitempty"`
	Path                 *string                           `json:"path,omitempty"`
	PolicyTemplates      *[]map[string]interface{}         `json:"policy_templates,omitempty"`
	Readme               *string                           `json:"readme,omitempty"`
	Release              *PackageListItemRelease           `json:"release,omitempty"`
	SavedObject          interface{}                       `json:"savedObject"`
	SignaturePath        *string                           `json:"signature_path,omitempty"`
	Source               *PackageListItem_Source           `json:"source,omitempty"`
	Status               *string                           `json:"status,omitempty"`
	Title                string                            `json:"title"`
	Type                 *PackageListItemType              `json:"type,omitempty"`
	Vars                 *[]map[string]interface{}         `json:"vars,omitempty"`
	Version              string                            `json:"version"`
	AdditionalProperties map[string]interface{}            `json:"-"`
}

// PackageListItem_Conditions_Elastic defines model for PackageListItem.Conditions.Elastic.
type PackageListItem_Conditions_Elastic struct {
	Capabilities         *[]string              `json:"capabilities,omitempty"`
	Subscription         *string                `json:"subscription,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageListItem_Conditions_Kibana defines model for PackageListItem.Conditions.Kibana.
type PackageListItem_Conditions_Kibana struct {
	Version              *string                `json:"version,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageListItem_Conditions defines model for PackageListItem.Conditions.
type PackageListItem_Conditions struct {
	Elastic              *PackageListItem_Conditions_Elastic `json:"elastic,omitempty"`
	Kibana               *PackageListItem_Conditions_Kibana  `json:"kibana,omitempty"`
	AdditionalProperties map[string]interface{}              `json:"-"`
}

// PackageListItem_Discovery_Fields_Item defines model for PackageListItem.Discovery.Fields.Item.
type PackageListItem_Discovery_Fields_Item struct {
	Name                 string                 `json:"name"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageListItem_Discovery defines model for PackageListItem.Discovery.
type PackageListItem_Discovery struct {
	Fields               *[]PackageListItem_Discovery_Fields_Item `json:"fields,omitempty"`
	AdditionalProperties map[string]interface{}                   `json:"-"`
}

// PackageListItem_Icons_Item defines model for package_list_item.icons.Item.
type PackageListItem_Icons_Item struct {
	DarkMode             *bool                  `json:"dark_mode,omitempty"`
	Path                 *string                `json:"path,omitempty"`
	Size                 *string                `json:"size,omitempty"`
	Src                  string                 `json:"src"`
	Title                *string                `json:"title,omitempty"`
	Type                 *string                `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType defines model for PackageListItem.InstallationInfo.AdditionalSpacesInstalledKibana.Type.
type PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType string

// PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item defines model for PackageListItem.InstallationInfo.AdditionalSpacesInstalledKibana.Item.
type PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item struct {
	Id                   string                                                             `json:"id"`
	OriginId             *string                                                            `json:"originId,omitempty"`
	Type                 PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType `json:"type"`
	AdditionalProperties map[string]interface{}                                             `json:"-"`
}

// PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features defines model for PackageListItem.InstallationInfo.ExperimentalDataStreamFeatures.Features.
type PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features struct {
	DocValueOnlyNumeric  *bool                  `json:"doc_value_only_numeric,omitempty"`
	DocValueOnlyOther    *bool                  `json:"doc_value_only_other,omitempty"`
	SyntheticSource      *bool                  `json:"synthetic_source,omitempty"`
	Tsdb                 *bool                  `json:"tsdb,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item defines model for PackageListItem.InstallationInfo.ExperimentalDataStreamFeatures.Item.
type PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item struct {
	DataStream           string                                                                   `json:"data_stream"`
	Features             PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features `json:"features"`
	AdditionalProperties map[string]interface{}                                                   `json:"-"`
}

// PackageListItemInstallationInfoInstallSource defines model for PackageListItem.InstallationInfo.InstallSource.
type PackageListItemInstallationInfoInstallSource string

// PackageListItemInstallationInfoInstallStatus defines model for PackageListItem.InstallationInfo.InstallStatus.
type PackageListItemInstallationInfoInstallStatus string

// PackageListItemInstallationInfoInstalledEsType defines model for PackageListItem.InstallationInfo.InstalledEs.Type.
type PackageListItemInstallationInfoInstalledEsType string

// PackageListItem_InstallationInfo_InstalledEs_Item defines model for PackageListItem.InstallationInfo.InstalledEs.Item.
type PackageListItem_InstallationInfo_InstalledEs_Item struct {
	Deferred             *bool                                          `json:"deferred,omitempty"`
	Id                   string                                         `json:"id"`
	Type                 PackageListItemInstallationInfoInstalledEsType `json:"type"`
	Version              *string                                        `json:"version,omitempty"`
	AdditionalProperties map[string]interface{}                         `json:"-"`
}

// PackageListItemInstallationInfoInstalledKibanaType defines model for PackageListItem.InstallationInfo.InstalledKibana.Type.
type PackageListItemInstallationInfoInstalledKibanaType string

// PackageListItem_InstallationInfo_InstalledKibana_Item defines model for PackageListItem.InstallationInfo.InstalledKibana.Item.
type PackageListItem_InstallationInfo_InstalledKibana_Item struct {
	Id                   string                                             `json:"id"`
	OriginId             *string                                            `json:"originId,omitempty"`
	Type                 PackageListItemInstallationInfoInstalledKibanaType `json:"type"`
	AdditionalProperties map[string]interface{}                             `json:"-"`
}

// PackageListItem_InstallationInfo_LatestExecutedState defines model for PackageListItem.InstallationInfo.LatestExecutedState.
type PackageListItem_InstallationInfo_LatestExecutedState struct {
	Error                *string                `json:"error,omitempty"`
	Name                 string                 `json:"name"`
	StartedAt            string                 `json:"started_at"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error defines model for PackageListItem.InstallationInfo.LatestInstallFailedAttempts.Error.
type PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error struct {
	Message              string                 `json:"message"`
	Name                 string                 `json:"name"`
	Stack                *string                `json:"stack,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item defines model for PackageListItem.InstallationInfo.LatestInstallFailedAttempts.Item.
type PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item struct {
	CreatedAt            string                                                             `json:"created_at"`
	Error                PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error `json:"error"`
	TargetVersion        string                                                             `json:"target_version"`
	AdditionalProperties map[string]interface{}                                             `json:"-"`
}

// PackageListItemInstallationInfoVerificationStatus defines model for PackageListItem.InstallationInfo.VerificationStatus.
type PackageListItemInstallationInfoVerificationStatus string

// PackageListItem_InstallationInfo defines model for PackageListItem.InstallationInfo.
type PackageListItem_InstallationInfo struct {
	AdditionalSpacesInstalledKibana *map[string][]PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item `json:"additional_spaces_installed_kibana,omitempty"`
	CreatedAt                       *string                                                                             `json:"created_at,omitempty"`
	ExperimentalDataStreamFeatures  *[]PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item             `json:"experimental_data_stream_features,omitempty"`
	InstallFormatSchemaVersion      *string                                                                             `json:"install_format_schema_version,omitempty"`
	InstallSource                   PackageListItemInstallationInfoInstallSource                                        `json:"install_source"`
	InstallStatus                   PackageListItemInstallationInfoInstallStatus                                        `json:"install_status"`
	InstalledEs                     []PackageListItem_InstallationInfo_InstalledEs_Item                                 `json:"installed_es"`
	InstalledKibana                 []PackageListItem_InstallationInfo_InstalledKibana_Item                             `json:"installed_kibana"`
	InstalledKibanaSpaceId          *string                                                                             `json:"installed_kibana_space_id,omitempty"`
	LatestExecutedState             *PackageListItem_InstallationInfo_LatestExecutedState                               `json:"latest_executed_state,omitempty"`
	LatestInstallFailedAttempts     *[]PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item                `json:"latest_install_failed_attempts,omitempty"`
	Name                            string                                                                              `json:"name"`
	Namespaces                      *[]string                                                                           `json:"namespaces,omitempty"`
	Type                            string                                                                              `json:"type"`
	UpdatedAt                       *string                                                                             `json:"updated_at,omitempty"`
	VerificationKeyId               *string                                                                             `json:"verification_key_id"`
	VerificationStatus              PackageListItemInstallationInfoVerificationStatus                                   `json:"verification_status"`
	Version                         string                                                                              `json:"version"`
	AdditionalProperties            map[string]interface{}                                                              `json:"-"`
}

// PackageListItemOwnerType defines model for PackageListItem.Owner.Type.
type PackageListItemOwnerType string

// PackageListItem_Owner defines model for PackageListItem.Owner.
type PackageListItem_Owner struct {
	Github               *string                   `json:"github,omitempty"`
	Type                 *PackageListItemOwnerType `json:"type,omitempty"`
	AdditionalProperties map[string]interface{}    `json:"-"`
}

// PackageListItemRelease defines model for PackageListItem.Release.
type PackageListItemRelease string

// PackageListItem_Source defines model for PackageListItem.Source.
type PackageListItem_Source struct {
	License              string                 `json:"license"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageListItemType defines model for PackageListItem.Type.
type PackageListItemType string

// PackagePolicy defines model for package_policy.
type PackagePolicy struct {
	Agents    *float32 `json:"agents,omitempty"`
	CreatedAt string   `json:"created_at"`
	CreatedBy string   `json:"created_by"`

	// Description Package policy description
	Description   *string                      `json:"description,omitempty"`
	Elasticsearch *PackagePolicy_Elasticsearch `json:"elasticsearch,omitempty"`
	Enabled       bool                         `json:"enabled"`
	Id            string                       `json:"id"`

	// Inputs Package policy inputs (see integration documentation to know what inputs are available)
	Inputs    map[string]PackagePolicyInput `json:"inputs"`
	IsManaged *bool                         `json:"is_managed,omitempty"`

	// Name Package policy name (should be unique)
	Name string `json:"name"`

	// Namespace The package policy namespace. Leave blank to inherit the agent policy's namespace.
	Namespace *string `json:"namespace,omitempty"`
	OutputId  *string `json:"output_id"`

	// Overrides Override settings that are defined in the package policy. The override option should be used only in unusual circumstances and not as a routine procedure.
	Overrides *struct {
		Inputs *map[string]interface{} `json:"inputs,omitempty"`
	} `json:"overrides"`
	Package *struct {
		ExperimentalDataStreamFeatures *[]struct {
			DataStream string `json:"data_stream"`
			Features   struct {
				DocValueOnlyNumeric *bool `json:"doc_value_only_numeric,omitempty"`
				DocValueOnlyOther   *bool `json:"doc_value_only_other,omitempty"`
				SyntheticSource     *bool `json:"synthetic_source,omitempty"`
				Tsdb                *bool `json:"tsdb,omitempty"`
			} `json:"features"`
		} `json:"experimental_data_stream_features,omitempty"`

		// Name Package name
		Name         string  `json:"name"`
		RequiresRoot *bool   `json:"requires_root,omitempty"`
		Title        *string `json:"title,omitempty"`

		// Version Package version
		Version string `json:"version"`
	} `json:"package,omitempty"`

	// PolicyId Agent policy ID where that package policy will be added
	// Deprecated:
	PolicyId         *string                   `json:"policy_id"`
	PolicyIds        *[]string                 `json:"policy_ids,omitempty"`
	Revision         float32                   `json:"revision"`
	SecretReferences *[]PackagePolicySecretRef `json:"secret_references,omitempty"`
	SpaceIds         *[]string                 `json:"spaceIds,omitempty"`
	UpdatedAt        string                    `json:"updated_at"`
	UpdatedBy        string                    `json:"updated_by"`
	Vars             *map[string]interface{}   `json:"vars,omitempty"`
	Version          *string                   `json:"version,omitempty"`
}

// PackagePolicy_Elasticsearch_Privileges defines model for PackagePolicy.Elasticsearch.Privileges.
type PackagePolicy_Elasticsearch_Privileges struct {
	Cluster              *[]string              `json:"cluster,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackagePolicy_Elasticsearch defines model for PackagePolicy.Elasticsearch.
type PackagePolicy_Elasticsearch struct {
	Privileges           *PackagePolicy_Elasticsearch_Privileges `json:"privileges,omitempty"`
	AdditionalProperties map[string]interface{}                  `json:"-"`
}

// PackagePolicyInput defines model for package_policy_input.
type PackagePolicyInput struct {
	// Enabled enable or disable that input, (default to true)
	Enabled *bool `json:"enabled,omitempty"`

	// Streams Input streams (see integration documentation to know what streams are available)
	Streams *map[string]PackagePolicyInputStream `json:"streams,omitempty"`
	Vars    *map[string]interface{}              `json:"vars,omitempty"`
}

// PackagePolicyInputStream defines model for package_policy_input_stream.
type PackagePolicyInputStream struct {
	// Enabled enable or disable that stream, (default to true)
	Enabled *bool                   `json:"enabled,omitempty"`
	Vars    *map[string]interface{} `json:"vars,omitempty"`
}

// PackagePolicyRequest defines model for package_policy_request.
type PackagePolicyRequest struct {
	Description *string `json:"description,omitempty"`
	Force       *bool   `json:"force,omitempty"`
	Id          *string `json:"id,omitempty"`

	// Inputs Package policy inputs (see integration documentation to know what inputs are available)
	Inputs    *map[string]PackagePolicyRequestInput `json:"inputs,omitempty"`
	Name      string                                `json:"name"`
	Namespace *string                               `json:"namespace,omitempty"`
	OutputId  *string                               `json:"output_id,omitempty"`
	Package   PackagePolicyRequestPackage           `json:"package"`
	PolicyId  *string                               `json:"policy_id"`
	PolicyIds *[]string                             `json:"policy_ids,omitempty"`
	Vars      *map[string]interface{}               `json:"vars,omitempty"`
}

// PackagePolicyRequestInput defines model for package_policy_request_input.
type PackagePolicyRequestInput struct {
	// Enabled enable or disable that input, (default to true)
	Enabled *bool `json:"enabled,omitempty"`

	// Streams Input streams (see integration documentation to know what streams are available)
	Streams *map[string]PackagePolicyRequestInputStream `json:"streams,omitempty"`
	Vars    *map[string]interface{}                     `json:"vars,omitempty"`
}

// PackagePolicyRequestInputStream defines model for package_policy_request_input_stream.
type PackagePolicyRequestInputStream struct {
	// Enabled enable or disable that stream, (default to true)
	Enabled *bool                   `json:"enabled,omitempty"`
	Vars    *map[string]interface{} `json:"vars,omitempty"`
}

// PackagePolicyRequestPackage defines model for package_policy_request_package.
type PackagePolicyRequestPackage struct {
	ExperimentalDataStreamFeatures *[]struct {
		DataStream string `json:"data_stream"`
		Features   struct {
			DocValueOnlyNumeric *bool `json:"doc_value_only_numeric,omitempty"`
			DocValueOnlyOther   *bool `json:"doc_value_only_other,omitempty"`
			SyntheticSource     *bool `json:"synthetic_source,omitempty"`
			Tsdb                *bool `json:"tsdb,omitempty"`
		} `json:"features"`
	} `json:"experimental_data_stream_features,omitempty"`

	// Name Package name
	Name         string  `json:"name"`
	RequiresRoot *bool   `json:"requires_root,omitempty"`
	Title        *string `json:"title,omitempty"`

	// Version Package version
	Version string `json:"version"`
}

// PackagePolicySecretRef defines model for package_policy_secret_ref.
type PackagePolicySecretRef struct {
	Id string `json:"id"`
}

// ServerHost defines model for server_host.
type ServerHost struct {
	HostUrls        []string `json:"host_urls"`
	Id              string   `json:"id"`
	IsDefault       *bool    `json:"is_default,omitempty"`
	IsInternal      *bool    `json:"is_internal,omitempty"`
	IsPreconfigured *bool    `json:"is_preconfigured,omitempty"`
	Name            string   `json:"name"`
	ProxyId         *string  `json:"proxy_id"`
}

// UpdateOutputElasticsearch defines model for update_output_elasticsearch.
type UpdateOutputElasticsearch struct {
	AllowEdit            *[]string                        `json:"allow_edit,omitempty"`
	CaSha256             *string                          `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                          `json:"ca_trusted_fingerprint,omitempty"`
	ConfigYaml           *string                          `json:"config_yaml"`
	Hosts                *[]string                        `json:"hosts,omitempty"`
	IsDefault            *bool                            `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                            `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                            `json:"is_internal,omitempty"`
	IsPreconfigured      *bool                            `json:"is_preconfigured,omitempty"`
	Name                 *string                          `json:"name,omitempty"`
	Preset               *UpdateOutputElasticsearchPreset `json:"preset,omitempty"`
	ProxyId              *string                          `json:"proxy_id,omitempty"`
	Shipper              *UpdateOutputShipper             `json:"shipper,omitempty"`
	Ssl                  *UpdateOutputSsl                 `json:"ssl,omitempty"`
	Type                 *UpdateOutputElasticsearchType   `json:"type,omitempty"`
}

// UpdateOutputElasticsearchPreset defines model for UpdateOutputElasticsearch.Preset.
type UpdateOutputElasticsearchPreset string

// UpdateOutputElasticsearchType defines model for UpdateOutputElasticsearch.Type.
type UpdateOutputElasticsearchType string

// UpdateOutputKafka defines model for update_output_kafka.
type UpdateOutputKafka struct {
	AllowEdit            *[]string                     `json:"allow_edit,omitempty"`
	AuthType             *UpdateOutputKafkaAuthType    `json:"auth_type,omitempty"`
	BrokerTimeout        *float32                      `json:"broker_timeout,omitempty"`
	CaSha256             *string                       `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                       `json:"ca_trusted_fingerprint,omitempty"`
	ClientId             *string                       `json:"client_id,omitempty"`
	Compression          *UpdateOutputKafkaCompression `json:"compression,omitempty"`
	CompressionLevel     interface{}                   `json:"compression_level"`
	ConfigYaml           *string                       `json:"config_yaml"`
	ConnectionType       interface{}                   `json:"connection_type"`
	Hash                 *struct {
		Hash   *string `json:"hash,omitempty"`
		Random *bool   `json:"random,omitempty"`
	} `json:"hash,omitempty"`
	Headers *[]struct {
		Key   string `json:"key"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Hosts               *[]string                   `json:"hosts,omitempty"`
	IsDefault           *bool                       `json:"is_default,omitempty"`
	IsDefaultMonitoring *bool                       `json:"is_default_monitoring,omitempty"`
	IsInternal          *bool                       `json:"is_internal,omitempty"`
	IsPreconfigured     *bool                       `json:"is_preconfigured,omitempty"`
	Key                 *string                     `json:"key,omitempty"`
	Name                string                      `json:"name"`
	Partition           *UpdateOutputKafkaPartition `json:"partition,omitempty"`
	Password            interface{}                 `json:"password"`
	ProxyId             *string                     `json:"proxy_id,omitempty"`
	Random              *struct {
		GroupEvents *float32 `json:"group_events,omitempty"`
	} `json:"random,omitempty"`
	RequiredAcks *UpdateOutputKafkaRequiredAcks `json:"required_acks,omitempty"`
	RoundRobin   *struct {
		GroupEvents *float32 `json:"group_events,omitempty"`
	} `json:"round_robin,omitempty"`
	Sasl *struct {
		Mechanism *UpdateOutputKafkaSaslMechanism `json:"mechanism,omitempty"`
	} `json:"sasl"`
	Secrets *struct {
		Password *UpdateOutputKafka_Secrets_Password `json:"password,omitempty"`
		Ssl      *struct {
			Key UpdateOutputKafka_Secrets_Ssl_Key `json:"key"`
		} `json:"ssl,omitempty"`
	} `json:"secrets,omitempty"`
	Shipper *UpdateOutputShipper `json:"shipper,omitempty"`
	Ssl     *UpdateOutputSsl     `json:"ssl,omitempty"`
	Timeout *float32             `json:"timeout,omitempty"`
	Topic   *string              `json:"topic,omitempty"`
	Topics  *[]struct {
		Topic string `json:"topic"`
		When  *struct {
			Condition *string                          `json:"condition,omitempty"`
			Type      *UpdateOutputKafkaTopicsWhenType `json:"type,omitempty"`
		} `json:"when,omitempty"`
	} `json:"topics,omitempty"`
	Type     *UpdateOutputKafkaType `json:"type,omitempty"`
	Username interface{}            `json:"username"`
	Version  *string                `json:"version,omitempty"`
}

// UpdateOutputKafkaAuthType defines model for UpdateOutputKafka.AuthType.
type UpdateOutputKafkaAuthType string

// UpdateOutputKafkaCompression defines model for UpdateOutputKafka.Compression.
type UpdateOutputKafkaCompression string

// UpdateOutputKafkaPartition defines model for UpdateOutputKafka.Partition.
type UpdateOutputKafkaPartition string

// UpdateOutputKafkaRequiredAcks defines model for UpdateOutputKafka.RequiredAcks.
type UpdateOutputKafkaRequiredAcks int

// UpdateOutputKafkaSaslMechanism defines model for UpdateOutputKafka.Sasl.Mechanism.
type UpdateOutputKafkaSaslMechanism string

// UpdateOutputKafkaSecretsPassword0 defines model for .
type UpdateOutputKafkaSecretsPassword0 struct {
	Id string `json:"id"`
}

// UpdateOutputKafkaSecretsPassword1 defines model for .
type UpdateOutputKafkaSecretsPassword1 = string

// UpdateOutputKafka_Secrets_Password defines model for UpdateOutputKafka.Secrets.Password.
type UpdateOutputKafka_Secrets_Password struct {
	union json.RawMessage
}

// UpdateOutputKafkaSecretsSslKey0 defines model for .
type UpdateOutputKafkaSecretsSslKey0 struct {
	Id string `json:"id"`
}

// UpdateOutputKafkaSecretsSslKey1 defines model for .
type UpdateOutputKafkaSecretsSslKey1 = string

// UpdateOutputKafka_Secrets_Ssl_Key defines model for UpdateOutputKafka.Secrets.Ssl.Key.
type UpdateOutputKafka_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// UpdateOutputKafkaTopicsWhenType defines model for UpdateOutputKafka.Topics.When.Type.
type UpdateOutputKafkaTopicsWhenType string

// UpdateOutputKafkaType defines model for UpdateOutputKafka.Type.
type UpdateOutputKafkaType string

// UpdateOutputLogstash defines model for update_output_logstash.
type UpdateOutputLogstash struct {
	AllowEdit            *[]string `json:"allow_edit,omitempty"`
	CaSha256             *string   `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string   `json:"ca_trusted_fingerprint,omitempty"`
	ConfigYaml           *string   `json:"config_yaml"`
	Hosts                *[]string `json:"hosts,omitempty"`
	IsDefault            *bool     `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool     `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool     `json:"is_internal,omitempty"`
	IsPreconfigured      *bool     `json:"is_preconfigured,omitempty"`
	Name                 *string   `json:"name,omitempty"`
	ProxyId              *string   `json:"proxy_id,omitempty"`
	Secrets              *struct {
		Ssl *struct {
			Key *UpdateOutputLogstash_Secrets_Ssl_Key `json:"key,omitempty"`
		} `json:"ssl,omitempty"`
	} `json:"secrets,omitempty"`
	Shipper *UpdateOutputShipper      `json:"shipper,omitempty"`
	Ssl     *UpdateOutputSsl          `json:"ssl,omitempty"`
	Type    *UpdateOutputLogstashType `json:"type,omitempty"`
}

// UpdateOutputLogstashSecretsSslKey0 defines model for .
type UpdateOutputLogstashSecretsSslKey0 struct {
	Id string `json:"id"`
}

// UpdateOutputLogstashSecretsSslKey1 defines model for .
type UpdateOutputLogstashSecretsSslKey1 = string

// UpdateOutputLogstash_Secrets_Ssl_Key defines model for UpdateOutputLogstash.Secrets.Ssl.Key.
type UpdateOutputLogstash_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// UpdateOutputLogstashType defines model for UpdateOutputLogstash.Type.
type UpdateOutputLogstashType string

// UpdateOutputRemoteElasticsearch defines model for update_output_remote_elasticsearch.
type UpdateOutputRemoteElasticsearch struct {
	AllowEdit            *[]string                              `json:"allow_edit,omitempty"`
	CaSha256             *string                                `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                                `json:"ca_trusted_fingerprint,omitempty"`
	ConfigYaml           *string                                `json:"config_yaml"`
	Hosts                *[]string                              `json:"hosts,omitempty"`
	IsDefault            *bool                                  `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                                  `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                                  `json:"is_internal,omitempty"`
	IsPreconfigured      *bool                                  `json:"is_preconfigured,omitempty"`
	Name                 *string                                `json:"name,omitempty"`
	Preset               *UpdateOutputRemoteElasticsearchPreset `json:"preset,omitempty"`
	ProxyId              *string                                `json:"proxy_id,omitempty"`
	Secrets              *struct {
		ServiceToken *UpdateOutputRemoteElasticsearch_Secrets_ServiceToken `json:"service_token,omitempty"`
	} `json:"secrets,omitempty"`
	ServiceToken *string                              `json:"service_token"`
	Shipper      *UpdateOutputShipper                 `json:"shipper,omitempty"`
	Ssl          *UpdateOutputSsl                     `json:"ssl,omitempty"`
	Type         *UpdateOutputRemoteElasticsearchType `json:"type,omitempty"`
}

// UpdateOutputRemoteElasticsearchPreset defines model for UpdateOutputRemoteElasticsearch.Preset.
type UpdateOutputRemoteElasticsearchPreset string

// UpdateOutputRemoteElasticsearchSecretsServiceToken0 defines model for .
type UpdateOutputRemoteElasticsearchSecretsServiceToken0 struct {
	Id string `json:"id"`
}

// UpdateOutputRemoteElasticsearchSecretsServiceToken1 defines model for .
type UpdateOutputRemoteElasticsearchSecretsServiceToken1 = string

// UpdateOutputRemoteElasticsearch_Secrets_ServiceToken defines model for UpdateOutputRemoteElasticsearch.Secrets.ServiceToken.
type UpdateOutputRemoteElasticsearch_Secrets_ServiceToken struct {
	union json.RawMessage
}

// UpdateOutputRemoteElasticsearchType defines model for UpdateOutputRemoteElasticsearch.Type.
type UpdateOutputRemoteElasticsearchType string

// UpdateOutputShipper defines model for update_output_shipper.
type UpdateOutputShipper struct {
	CompressionLevel            *float32 `json:"compression_level"`
	DiskQueueCompressionEnabled *bool    `json:"disk_queue_compression_enabled"`
	DiskQueueEnabled            *bool    `json:"disk_queue_enabled"`
	DiskQueueEncryptionEnabled  *bool    `json:"disk_queue_encryption_enabled"`
	DiskQueueMaxSize            *float32 `json:"disk_queue_max_size"`
	DiskQueuePath               *string  `json:"disk_queue_path"`
	Loadbalance                 *bool    `json:"loadbalance"`
	MaxBatchBytes               *float32 `json:"max_batch_bytes"`
	MemQueueEvents              *float32 `json:"mem_queue_events"`
	QueueFlushTimeout           *float32 `json:"queue_flush_timeout"`
}

// UpdateOutputSsl defines model for update_output_ssl.
type UpdateOutputSsl struct {
	Certificate            *string                          `json:"certificate,omitempty"`
	CertificateAuthorities *[]string                        `json:"certificate_authorities,omitempty"`
	Key                    *string                          `json:"key,omitempty"`
	VerificationMode       *UpdateOutputSslVerificationMode `json:"verification_mode,omitempty"`
}

// UpdateOutputSslVerificationMode defines model for UpdateOutputSsl.VerificationMode.
type UpdateOutputSslVerificationMode string

// UpdateOutputUnion defines model for update_output_union.
type UpdateOutputUnion struct {
	union json.RawMessage
}

// GetAgentPoliciesParams defines parameters for GetAgentPolicies.
type GetAgentPoliciesParams struct {
	Page            *float32                         `form:"page,omitempty" json:"page,omitempty"`
	PerPage         *float32                         `form:"perPage,omitempty" json:"perPage,omitempty"`
	SortField       *string                          `form:"sortField,omitempty" json:"sortField,omitempty"`
	SortOrder       *GetAgentPoliciesParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`
	ShowUpgradeable *bool                            `form:"showUpgradeable,omitempty" json:"showUpgradeable,omitempty"`
	Kuery           *string                          `form:"kuery,omitempty" json:"kuery,omitempty"`

	// NoAgentCount use withAgentCount instead
	NoAgentCount *bool `form:"noAgentCount,omitempty" json:"noAgentCount,omitempty"`

	// WithAgentCount get policies with agent count
	WithAgentCount *bool `form:"withAgentCount,omitempty" json:"withAgentCount,omitempty"`

	// Full get full policies with package policies populated
	Full   *bool                         `form:"full,omitempty" json:"full,omitempty"`
	Format *GetAgentPoliciesParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GetAgentPoliciesParamsSortOrder defines parameters for GetAgentPolicies.
type GetAgentPoliciesParamsSortOrder string

// GetAgentPoliciesParamsFormat defines parameters for GetAgentPolicies.
type GetAgentPoliciesParamsFormat string

// CreateAgentPolicyJSONBody defines parameters for CreateAgentPolicy.
type CreateAgentPolicyJSONBody struct {
	AdvancedSettings *struct {
		AgentDownloadTargetDirectory *interface{} `json:"agent_download_target_directory"`
		AgentDownloadTimeout         *interface{} `json:"agent_download_timeout"`
		AgentLimitsGoMaxProcs        *interface{} `json:"agent_limits_go_max_procs"`
		AgentLoggingLevel            *interface{} `json:"agent_logging_level"`
		AgentLoggingMetricsPeriod    *interface{} `json:"agent_logging_metrics_period"`
	} `json:"advanced_settings,omitempty"`
	AgentFeatures *[]struct {
		Enabled bool   `json:"enabled"`
		Name    string `json:"name"`
	} `json:"agent_features,omitempty"`
	DataOutputId      *string `json:"data_output_id"`
	Description       *string `json:"description,omitempty"`
	DownloadSourceId  *string `json:"download_source_id"`
	FleetServerHostId *string `json:"fleet_server_host_id"`
	Force             *bool   `json:"force,omitempty"`

	// GlobalDataTags User defined data tags that are added to all of the inputs. The values can be strings or numbers.
	GlobalDataTags *[]struct {
		Name  string                                         `json:"name"`
		Value CreateAgentPolicyJSONBody_GlobalDataTags_Value `json:"value"`
	} `json:"global_data_tags,omitempty"`
	HasFleetServer       *bool    `json:"has_fleet_server,omitempty"`
	Id                   *string  `json:"id,omitempty"`
	InactivityTimeout    *float32 `json:"inactivity_timeout,omitempty"`
	IsDefault            *bool    `json:"is_default,omitempty"`
	IsDefaultFleetServer *bool    `json:"is_default_fleet_server,omitempty"`
	IsManaged            *bool    `json:"is_managed,omitempty"`
	IsProtected          *bool    `json:"is_protected,omitempty"`

	// KeepMonitoringAlive When set to true, monitoring will be enabled but logs/metrics collection will be disabled
	KeepMonitoringAlive   *bool `json:"keep_monitoring_alive,omitempty"`
	MonitoringDiagnostics *struct {
		Limit *struct {
			Burst    *float32 `json:"burst,omitempty"`
			Interval *string  `json:"interval,omitempty"`
		} `json:"limit,omitempty"`
		Uploader *struct {
			InitDur    *string  `json:"init_dur,omitempty"`
			MaxDur     *string  `json:"max_dur,omitempty"`
			MaxRetries *float32 `json:"max_retries,omitempty"`
		} `json:"uploader,omitempty"`
	} `json:"monitoring_diagnostics,omitempty"`
	MonitoringEnabled *[]CreateAgentPolicyJSONBodyMonitoringEnabled `json:"monitoring_enabled,omitempty"`
	MonitoringHttp    *struct {
		Buffer *struct {
			Enabled *bool `json:"enabled,omitempty"`
		} `json:"buffer,omitempty"`
		Enabled bool     `json:"enabled"`
		Host    *string  `json:"host,omitempty"`
		Port    *float32 `json:"port,omitempty"`
	} `json:"monitoring_http,omitempty"`
	MonitoringOutputId     *string `json:"monitoring_output_id"`
	MonitoringPprofEnabled *bool   `json:"monitoring_pprof_enabled,omitempty"`
	Name                   string  `json:"name"`
	Namespace              string  `json:"namespace"`

	// Overrides Override settings that are defined in the agent policy. Input settings cannot be overridden. The override option should be used only in unusual circumstances and not as a routine procedure.
	Overrides *map[string]interface{} `json:"overrides,omitempty"`
	SpaceIds  *[]string               `json:"space_ids,omitempty"`

	// SupportsAgentless Indicates whether the agent policy supports agentless integrations.
	SupportsAgentless *bool    `json:"supports_agentless,omitempty"`
	UnenrollTimeout   *float32 `json:"unenroll_timeout,omitempty"`
}

// CreateAgentPolicyParams defines parameters for CreateAgentPolicy.
type CreateAgentPolicyParams struct {
	SysMonitoring *bool `form:"sys_monitoring,omitempty" json:"sys_monitoring,omitempty"`
}

// CreateAgentPolicyJSONBodyGlobalDataTagsValue0 defines parameters for CreateAgentPolicy.
type CreateAgentPolicyJSONBodyGlobalDataTagsValue0 = string

// CreateAgentPolicyJSONBodyGlobalDataTagsValue1 defines parameters for CreateAgentPolicy.
type CreateAgentPolicyJSONBodyGlobalDataTagsValue1 = float32

// CreateAgentPolicyJSONBody_GlobalDataTags_Value defines parameters for CreateAgentPolicy.
type CreateAgentPolicyJSONBody_GlobalDataTags_Value struct {
	union json.RawMessage
}

// CreateAgentPolicyJSONBodyMonitoringEnabled defines parameters for CreateAgentPolicy.
type CreateAgentPolicyJSONBodyMonitoringEnabled string

// DeleteAgentPolicyJSONBody defines parameters for DeleteAgentPolicy.
type DeleteAgentPolicyJSONBody struct {
	AgentPolicyId string `json:"agentPolicyId"`

	// Force bypass validation checks that can prevent agent policy deletion
	Force *bool `json:"force,omitempty"`
}

// GetAgentPolicyParams defines parameters for GetAgentPolicy.
type GetAgentPolicyParams struct {
	Format *GetAgentPolicyParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GetAgentPolicyParamsFormat defines parameters for GetAgentPolicy.
type GetAgentPolicyParamsFormat string

// UpdateAgentPolicyJSONBody defines parameters for UpdateAgentPolicy.
type UpdateAgentPolicyJSONBody struct {
	AdvancedSettings *struct {
		AgentDownloadTargetDirectory *interface{} `json:"agent_download_target_directory"`
		AgentDownloadTimeout         *interface{} `json:"agent_download_timeout"`
		AgentLimitsGoMaxProcs        *interface{} `json:"agent_limits_go_max_procs"`
		AgentLoggingLevel            *interface{} `json:"agent_logging_level"`
		AgentLoggingMetricsPeriod    *interface{} `json:"agent_logging_metrics_period"`
	} `json:"advanced_settings,omitempty"`
	AgentFeatures *[]struct {
		Enabled bool   `json:"enabled"`
		Name    string `json:"name"`
	} `json:"agent_features,omitempty"`
	DataOutputId      *string `json:"data_output_id"`
	Description       *string `json:"description,omitempty"`
	DownloadSourceId  *string `json:"download_source_id"`
	FleetServerHostId *string `json:"fleet_server_host_id"`
	Force             *bool   `json:"force,omitempty"`

	// GlobalDataTags User defined data tags that are added to all of the inputs. The values can be strings or numbers.
	GlobalDataTags *[]struct {
		Name  string                                         `json:"name"`
		Value UpdateAgentPolicyJSONBody_GlobalDataTags_Value `json:"value"`
	} `json:"global_data_tags,omitempty"`
	HasFleetServer       *bool    `json:"has_fleet_server,omitempty"`
	Id                   *string  `json:"id,omitempty"`
	InactivityTimeout    *float32 `json:"inactivity_timeout,omitempty"`
	IsDefault            *bool    `json:"is_default,omitempty"`
	IsDefaultFleetServer *bool    `json:"is_default_fleet_server,omitempty"`
	IsManaged            *bool    `json:"is_managed,omitempty"`
	IsProtected          *bool    `json:"is_protected,omitempty"`

	// KeepMonitoringAlive When set to true, monitoring will be enabled but logs/metrics collection will be disabled
	KeepMonitoringAlive   *bool `json:"keep_monitoring_alive,omitempty"`
	MonitoringDiagnostics *struct {
		Limit *struct {
			Burst    *float32 `json:"burst,omitempty"`
			Interval *string  `json:"interval,omitempty"`
		} `json:"limit,omitempty"`
		Uploader *struct {
			InitDur    *string  `json:"init_dur,omitempty"`
			MaxDur     *string  `json:"max_dur,omitempty"`
			MaxRetries *float32 `json:"max_retries,omitempty"`
		} `json:"uploader,omitempty"`
	} `json:"monitoring_diagnostics,omitempty"`
	MonitoringEnabled *[]UpdateAgentPolicyJSONBodyMonitoringEnabled `json:"monitoring_enabled,omitempty"`
	MonitoringHttp    *struct {
		Buffer *struct {
			Enabled *bool `json:"enabled,omitempty"`
		} `json:"buffer,omitempty"`
		Enabled bool     `json:"enabled"`
		Host    *string  `json:"host,omitempty"`
		Port    *float32 `json:"port,omitempty"`
	} `json:"monitoring_http,omitempty"`
	MonitoringOutputId     *string `json:"monitoring_output_id"`
	MonitoringPprofEnabled *bool   `json:"monitoring_pprof_enabled,omitempty"`
	Name                   string  `json:"name"`
	Namespace              string  `json:"namespace"`

	// Overrides Override settings that are defined in the agent policy. Input settings cannot be overridden. The override option should be used only in unusual circumstances and not as a routine procedure.
	Overrides *map[string]interface{} `json:"overrides,omitempty"`
	SpaceIds  *[]string               `json:"space_ids,omitempty"`

	// SupportsAgentless Indicates whether the agent policy supports agentless integrations.
	SupportsAgentless *bool    `json:"supports_agentless,omitempty"`
	UnenrollTimeout   *float32 `json:"unenroll_timeout,omitempty"`
}

// UpdateAgentPolicyParams defines parameters for UpdateAgentPolicy.
type UpdateAgentPolicyParams struct {
	Format *UpdateAgentPolicyParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// UpdateAgentPolicyParamsFormat defines parameters for UpdateAgentPolicy.
type UpdateAgentPolicyParamsFormat string

// UpdateAgentPolicyJSONBodyGlobalDataTagsValue0 defines parameters for UpdateAgentPolicy.
type UpdateAgentPolicyJSONBodyGlobalDataTagsValue0 = string

// UpdateAgentPolicyJSONBodyGlobalDataTagsValue1 defines parameters for UpdateAgentPolicy.
type UpdateAgentPolicyJSONBodyGlobalDataTagsValue1 = float32

// UpdateAgentPolicyJSONBody_GlobalDataTags_Value defines parameters for UpdateAgentPolicy.
type UpdateAgentPolicyJSONBody_GlobalDataTags_Value struct {
	union json.RawMessage
}

// UpdateAgentPolicyJSONBodyMonitoringEnabled defines parameters for UpdateAgentPolicy.
type UpdateAgentPolicyJSONBodyMonitoringEnabled string

// GetEnrollmentApiKeysParams defines parameters for GetEnrollmentApiKeys.
type GetEnrollmentApiKeysParams struct {
	Page    *float32 `form:"page,omitempty" json:"page,omitempty"`
	PerPage *float32 `form:"perPage,omitempty" json:"perPage,omitempty"`
	Kuery   *string  `form:"kuery,omitempty" json:"kuery,omitempty"`
}

// ListPackagesParams defines parameters for ListPackages.
type ListPackagesParams struct {
	Category             *string `form:"category,omitempty" json:"category,omitempty"`
	Prerelease           *bool   `form:"prerelease,omitempty" json:"prerelease,omitempty"`
	Experimental         *bool   `form:"experimental,omitempty" json:"experimental,omitempty"`
	ExcludeInstallStatus *bool   `form:"excludeInstallStatus,omitempty" json:"excludeInstallStatus,omitempty"`
}

// InstallPackageByUploadParams defines parameters for InstallPackageByUpload.
type InstallPackageByUploadParams struct {
	IgnoreMappingUpdateErrors *bool `form:"ignoreMappingUpdateErrors,omitempty" json:"ignoreMappingUpdateErrors,omitempty"`
	SkipDataStreamRollover    *bool `form:"skipDataStreamRollover,omitempty" json:"skipDataStreamRollover,omitempty"`
}

// DeletePackageJSONBody defines parameters for DeletePackage.
type DeletePackageJSONBody struct {
	Force bool `json:"force"`
}

// DeletePackageParams defines parameters for DeletePackage.
type DeletePackageParams struct {
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// GetPackageParams defines parameters for GetPackage.
type GetPackageParams struct {
	IgnoreUnverified *bool `form:"ignoreUnverified,omitempty" json:"ignoreUnverified,omitempty"`
	Prerelease       *bool `form:"prerelease,omitempty" json:"prerelease,omitempty"`
	Full             *bool `form:"full,omitempty" json:"full,omitempty"`
	WithMetadata     *bool `form:"withMetadata,omitempty" json:"withMetadata,omitempty"`
}

// InstallPackageJSONBody defines parameters for InstallPackage.
type InstallPackageJSONBody struct {
	Force             *bool `json:"force,omitempty"`
	IgnoreConstraints *bool `json:"ignore_constraints,omitempty"`
}

// InstallPackageParams defines parameters for InstallPackage.
type InstallPackageParams struct {
	Prerelease                *bool `form:"prerelease,omitempty" json:"prerelease,omitempty"`
	IgnoreMappingUpdateErrors *bool `form:"ignoreMappingUpdateErrors,omitempty" json:"ignoreMappingUpdateErrors,omitempty"`
	SkipDataStreamRollover    *bool `form:"skipDataStreamRollover,omitempty" json:"skipDataStreamRollover,omitempty"`
}

// CreateFleetServerHostJSONBody defines parameters for CreateFleetServerHost.
type CreateFleetServerHostJSONBody struct {
	HostUrls        []string `json:"host_urls"`
	Id              *string  `json:"id,omitempty"`
	IsDefault       *bool    `json:"is_default,omitempty"`
	IsInternal      *bool    `json:"is_internal,omitempty"`
	IsPreconfigured *bool    `json:"is_preconfigured,omitempty"`
	Name            string   `json:"name"`
	ProxyId         *string  `json:"proxy_id,omitempty"`
}

// UpdateFleetServerHostJSONBody defines parameters for UpdateFleetServerHost.
type UpdateFleetServerHostJSONBody struct {
	HostUrls   *[]string `json:"host_urls,omitempty"`
	IsDefault  *bool     `json:"is_default,omitempty"`
	IsInternal *bool     `json:"is_internal,omitempty"`
	Name       *string   `json:"name,omitempty"`
	ProxyId    *string   `json:"proxy_id,omitempty"`
}

// GetPackagePoliciesParams defines parameters for GetPackagePolicies.
type GetPackagePoliciesParams struct {
	Page            *float32                           `form:"page,omitempty" json:"page,omitempty"`
	PerPage         *float32                           `form:"perPage,omitempty" json:"perPage,omitempty"`
	SortField       *string                            `form:"sortField,omitempty" json:"sortField,omitempty"`
	SortOrder       *GetPackagePoliciesParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`
	ShowUpgradeable *bool                              `form:"showUpgradeable,omitempty" json:"showUpgradeable,omitempty"`
	Kuery           *string                            `form:"kuery,omitempty" json:"kuery,omitempty"`
	Format          *GetPackagePoliciesParamsFormat    `form:"format,omitempty" json:"format,omitempty"`
	WithAgentCount  *bool                              `form:"withAgentCount,omitempty" json:"withAgentCount,omitempty"`
}

// GetPackagePoliciesParamsSortOrder defines parameters for GetPackagePolicies.
type GetPackagePoliciesParamsSortOrder string

// GetPackagePoliciesParamsFormat defines parameters for GetPackagePolicies.
type GetPackagePoliciesParamsFormat string

// CreatePackagePolicyParams defines parameters for CreatePackagePolicy.
type CreatePackagePolicyParams struct {
	Format *CreatePackagePolicyParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// CreatePackagePolicyParamsFormat defines parameters for CreatePackagePolicy.
type CreatePackagePolicyParamsFormat string

// DeletePackagePolicyParams defines parameters for DeletePackagePolicy.
type DeletePackagePolicyParams struct {
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// GetPackagePolicyParams defines parameters for GetPackagePolicy.
type GetPackagePolicyParams struct {
	Format *GetPackagePolicyParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GetPackagePolicyParamsFormat defines parameters for GetPackagePolicy.
type GetPackagePolicyParamsFormat string

// UpdatePackagePolicyParams defines parameters for UpdatePackagePolicy.
type UpdatePackagePolicyParams struct {
	Format *UpdatePackagePolicyParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// UpdatePackagePolicyParamsFormat defines parameters for UpdatePackagePolicy.
type UpdatePackagePolicyParamsFormat string

// CreateAgentPolicyJSONRequestBody defines body for CreateAgentPolicy for application/json ContentType.
type CreateAgentPolicyJSONRequestBody CreateAgentPolicyJSONBody

// DeleteAgentPolicyJSONRequestBody defines body for DeleteAgentPolicy for application/json ContentType.
type DeleteAgentPolicyJSONRequestBody DeleteAgentPolicyJSONBody

// UpdateAgentPolicyJSONRequestBody defines body for UpdateAgentPolicy for application/json ContentType.
type UpdateAgentPolicyJSONRequestBody UpdateAgentPolicyJSONBody

// DeletePackageJSONRequestBody defines body for DeletePackage for application/json ContentType.
type DeletePackageJSONRequestBody DeletePackageJSONBody

// InstallPackageJSONRequestBody defines body for InstallPackage for application/json ContentType.
type InstallPackageJSONRequestBody InstallPackageJSONBody

// CreateFleetServerHostJSONRequestBody defines body for CreateFleetServerHost for application/json ContentType.
type CreateFleetServerHostJSONRequestBody CreateFleetServerHostJSONBody

// UpdateFleetServerHostJSONRequestBody defines body for UpdateFleetServerHost for application/json ContentType.
type UpdateFleetServerHostJSONRequestBody UpdateFleetServerHostJSONBody

// CreateOutputJSONRequestBody defines body for CreateOutput for application/json ContentType.
type CreateOutputJSONRequestBody = NewOutputUnion

// UpdateOutputJSONRequestBody defines body for UpdateOutput for application/json ContentType.
type UpdateOutputJSONRequestBody = UpdateOutputUnion

// CreatePackagePolicyJSONRequestBody defines body for CreatePackagePolicy for application/json ContentType.
type CreatePackagePolicyJSONRequestBody = PackagePolicyRequest

// UpdatePackagePolicyJSONRequestBody defines body for UpdatePackagePolicy for application/json ContentType.
type UpdatePackagePolicyJSONRequestBody = PackagePolicyRequest

// Getter for additional properties for AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges. Returns the specified
// element and whether it was found
func (a AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges
func (a *AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges to handle AdditionalProperties
func (a *AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["cluster"]; found {
		err = json.Unmarshal(raw, &a.Cluster)
		if err != nil {
			return fmt.Errorf("error reading 'cluster': %w", err)
		}
		delete(object, "cluster")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges to handle AdditionalProperties
func (a AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Cluster != nil {
		object["cluster"], err = json.Marshal(a.Cluster)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'cluster': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AgentPolicy_PackagePolicies_1_Elasticsearch. Returns the specified
// element and whether it was found
func (a AgentPolicy_PackagePolicies_1_Elasticsearch) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AgentPolicy_PackagePolicies_1_Elasticsearch
func (a *AgentPolicy_PackagePolicies_1_Elasticsearch) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AgentPolicy_PackagePolicies_1_Elasticsearch to handle AdditionalProperties
func (a *AgentPolicy_PackagePolicies_1_Elasticsearch) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["privileges"]; found {
		err = json.Unmarshal(raw, &a.Privileges)
		if err != nil {
			return fmt.Errorf("error reading 'privileges': %w", err)
		}
		delete(object, "privileges")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AgentPolicy_PackagePolicies_1_Elasticsearch to handle AdditionalProperties
func (a AgentPolicy_PackagePolicies_1_Elasticsearch) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Privileges != nil {
		object["privileges"], err = json.Marshal(a.Privileges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'privileges': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputElasticsearch. Returns the specified
// element and whether it was found
func (a OutputElasticsearch) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputElasticsearch
func (a *OutputElasticsearch) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputElasticsearch to handle AdditionalProperties
func (a *OutputElasticsearch) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["allow_edit"]; found {
		err = json.Unmarshal(raw, &a.AllowEdit)
		if err != nil {
			return fmt.Errorf("error reading 'allow_edit': %w", err)
		}
		delete(object, "allow_edit")
	}

	if raw, found := object["ca_sha256"]; found {
		err = json.Unmarshal(raw, &a.CaSha256)
		if err != nil {
			return fmt.Errorf("error reading 'ca_sha256': %w", err)
		}
		delete(object, "ca_sha256")
	}

	if raw, found := object["ca_trusted_fingerprint"]; found {
		err = json.Unmarshal(raw, &a.CaTrustedFingerprint)
		if err != nil {
			return fmt.Errorf("error reading 'ca_trusted_fingerprint': %w", err)
		}
		delete(object, "ca_trusted_fingerprint")
	}

	if raw, found := object["config_yaml"]; found {
		err = json.Unmarshal(raw, &a.ConfigYaml)
		if err != nil {
			return fmt.Errorf("error reading 'config_yaml': %w", err)
		}
		delete(object, "config_yaml")
	}

	if raw, found := object["hosts"]; found {
		err = json.Unmarshal(raw, &a.Hosts)
		if err != nil {
			return fmt.Errorf("error reading 'hosts': %w", err)
		}
		delete(object, "hosts")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["is_default"]; found {
		err = json.Unmarshal(raw, &a.IsDefault)
		if err != nil {
			return fmt.Errorf("error reading 'is_default': %w", err)
		}
		delete(object, "is_default")
	}

	if raw, found := object["is_default_monitoring"]; found {
		err = json.Unmarshal(raw, &a.IsDefaultMonitoring)
		if err != nil {
			return fmt.Errorf("error reading 'is_default_monitoring': %w", err)
		}
		delete(object, "is_default_monitoring")
	}

	if raw, found := object["is_internal"]; found {
		err = json.Unmarshal(raw, &a.IsInternal)
		if err != nil {
			return fmt.Errorf("error reading 'is_internal': %w", err)
		}
		delete(object, "is_internal")
	}

	if raw, found := object["is_preconfigured"]; found {
		err = json.Unmarshal(raw, &a.IsPreconfigured)
		if err != nil {
			return fmt.Errorf("error reading 'is_preconfigured': %w", err)
		}
		delete(object, "is_preconfigured")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["preset"]; found {
		err = json.Unmarshal(raw, &a.Preset)
		if err != nil {
			return fmt.Errorf("error reading 'preset': %w", err)
		}
		delete(object, "preset")
	}

	if raw, found := object["proxy_id"]; found {
		err = json.Unmarshal(raw, &a.ProxyId)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_id': %w", err)
		}
		delete(object, "proxy_id")
	}

	if raw, found := object["shipper"]; found {
		err = json.Unmarshal(raw, &a.Shipper)
		if err != nil {
			return fmt.Errorf("error reading 'shipper': %w", err)
		}
		delete(object, "shipper")
	}

	if raw, found := object["ssl"]; found {
		err = json.Unmarshal(raw, &a.Ssl)
		if err != nil {
			return fmt.Errorf("error reading 'ssl': %w", err)
		}
		delete(object, "ssl")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputElasticsearch to handle AdditionalProperties
func (a OutputElasticsearch) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AllowEdit != nil {
		object["allow_edit"], err = json.Marshal(a.AllowEdit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allow_edit': %w", err)
		}
	}

	if a.CaSha256 != nil {
		object["ca_sha256"], err = json.Marshal(a.CaSha256)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ca_sha256': %w", err)
		}
	}

	if a.CaTrustedFingerprint != nil {
		object["ca_trusted_fingerprint"], err = json.Marshal(a.CaTrustedFingerprint)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ca_trusted_fingerprint': %w", err)
		}
	}

	if a.ConfigYaml != nil {
		object["config_yaml"], err = json.Marshal(a.ConfigYaml)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'config_yaml': %w", err)
		}
	}

	object["hosts"], err = json.Marshal(a.Hosts)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'hosts': %w", err)
	}

	if a.Id != nil {
		object["id"], err = json.Marshal(a.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if a.IsDefault != nil {
		object["is_default"], err = json.Marshal(a.IsDefault)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_default': %w", err)
		}
	}

	if a.IsDefaultMonitoring != nil {
		object["is_default_monitoring"], err = json.Marshal(a.IsDefaultMonitoring)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_default_monitoring': %w", err)
		}
	}

	if a.IsInternal != nil {
		object["is_internal"], err = json.Marshal(a.IsInternal)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_internal': %w", err)
		}
	}

	if a.IsPreconfigured != nil {
		object["is_preconfigured"], err = json.Marshal(a.IsPreconfigured)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_preconfigured': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Preset != nil {
		object["preset"], err = json.Marshal(a.Preset)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'preset': %w", err)
		}
	}

	if a.ProxyId != nil {
		object["proxy_id"], err = json.Marshal(a.ProxyId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_id': %w", err)
		}
	}

	if a.Shipper != nil {
		object["shipper"], err = json.Marshal(a.Shipper)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'shipper': %w", err)
		}
	}

	if a.Ssl != nil {
		object["ssl"], err = json.Marshal(a.Ssl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka. Returns the specified
// element and whether it was found
func (a OutputKafka) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka
func (a *OutputKafka) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka to handle AdditionalProperties
func (a *OutputKafka) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["allow_edit"]; found {
		err = json.Unmarshal(raw, &a.AllowEdit)
		if err != nil {
			return fmt.Errorf("error reading 'allow_edit': %w", err)
		}
		delete(object, "allow_edit")
	}

	if raw, found := object["auth_type"]; found {
		err = json.Unmarshal(raw, &a.AuthType)
		if err != nil {
			return fmt.Errorf("error reading 'auth_type': %w", err)
		}
		delete(object, "auth_type")
	}

	if raw, found := object["broker_timeout"]; found {
		err = json.Unmarshal(raw, &a.BrokerTimeout)
		if err != nil {
			return fmt.Errorf("error reading 'broker_timeout': %w", err)
		}
		delete(object, "broker_timeout")
	}

	if raw, found := object["ca_sha256"]; found {
		err = json.Unmarshal(raw, &a.CaSha256)
		if err != nil {
			return fmt.Errorf("error reading 'ca_sha256': %w", err)
		}
		delete(object, "ca_sha256")
	}

	if raw, found := object["ca_trusted_fingerprint"]; found {
		err = json.Unmarshal(raw, &a.CaTrustedFingerprint)
		if err != nil {
			return fmt.Errorf("error reading 'ca_trusted_fingerprint': %w", err)
		}
		delete(object, "ca_trusted_fingerprint")
	}

	if raw, found := object["client_id"]; found {
		err = json.Unmarshal(raw, &a.ClientId)
		if err != nil {
			return fmt.Errorf("error reading 'client_id': %w", err)
		}
		delete(object, "client_id")
	}

	if raw, found := object["compression"]; found {
		err = json.Unmarshal(raw, &a.Compression)
		if err != nil {
			return fmt.Errorf("error reading 'compression': %w", err)
		}
		delete(object, "compression")
	}

	if raw, found := object["compression_level"]; found {
		err = json.Unmarshal(raw, &a.CompressionLevel)
		if err != nil {
			return fmt.Errorf("error reading 'compression_level': %w", err)
		}
		delete(object, "compression_level")
	}

	if raw, found := object["config_yaml"]; found {
		err = json.Unmarshal(raw, &a.ConfigYaml)
		if err != nil {
			return fmt.Errorf("error reading 'config_yaml': %w", err)
		}
		delete(object, "config_yaml")
	}

	if raw, found := object["connection_type"]; found {
		err = json.Unmarshal(raw, &a.ConnectionType)
		if err != nil {
			return fmt.Errorf("error reading 'connection_type': %w", err)
		}
		delete(object, "connection_type")
	}

	if raw, found := object["hash"]; found {
		err = json.Unmarshal(raw, &a.Hash)
		if err != nil {
			return fmt.Errorf("error reading 'hash': %w", err)
		}
		delete(object, "hash")
	}

	if raw, found := object["headers"]; found {
		err = json.Unmarshal(raw, &a.Headers)
		if err != nil {
			return fmt.Errorf("error reading 'headers': %w", err)
		}
		delete(object, "headers")
	}

	if raw, found := object["hosts"]; found {
		err = json.Unmarshal(raw, &a.Hosts)
		if err != nil {
			return fmt.Errorf("error reading 'hosts': %w", err)
		}
		delete(object, "hosts")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["is_default"]; found {
		err = json.Unmarshal(raw, &a.IsDefault)
		if err != nil {
			return fmt.Errorf("error reading 'is_default': %w", err)
		}
		delete(object, "is_default")
	}

	if raw, found := object["is_default_monitoring"]; found {
		err = json.Unmarshal(raw, &a.IsDefaultMonitoring)
		if err != nil {
			return fmt.Errorf("error reading 'is_default_monitoring': %w", err)
		}
		delete(object, "is_default_monitoring")
	}

	if raw, found := object["is_internal"]; found {
		err = json.Unmarshal(raw, &a.IsInternal)
		if err != nil {
			return fmt.Errorf("error reading 'is_internal': %w", err)
		}
		delete(object, "is_internal")
	}

	if raw, found := object["is_preconfigured"]; found {
		err = json.Unmarshal(raw, &a.IsPreconfigured)
		if err != nil {
			return fmt.Errorf("error reading 'is_preconfigured': %w", err)
		}
		delete(object, "is_preconfigured")
	}

	if raw, found := object["key"]; found {
		err = json.Unmarshal(raw, &a.Key)
		if err != nil {
			return fmt.Errorf("error reading 'key': %w", err)
		}
		delete(object, "key")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["partition"]; found {
		err = json.Unmarshal(raw, &a.Partition)
		if err != nil {
			return fmt.Errorf("error reading 'partition': %w", err)
		}
		delete(object, "partition")
	}

	if raw, found := object["password"]; found {
		err = json.Unmarshal(raw, &a.Password)
		if err != nil {
			return fmt.Errorf("error reading 'password': %w", err)
		}
		delete(object, "password")
	}

	if raw, found := object["proxy_id"]; found {
		err = json.Unmarshal(raw, &a.ProxyId)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_id': %w", err)
		}
		delete(object, "proxy_id")
	}

	if raw, found := object["random"]; found {
		err = json.Unmarshal(raw, &a.Random)
		if err != nil {
			return fmt.Errorf("error reading 'random': %w", err)
		}
		delete(object, "random")
	}

	if raw, found := object["required_acks"]; found {
		err = json.Unmarshal(raw, &a.RequiredAcks)
		if err != nil {
			return fmt.Errorf("error reading 'required_acks': %w", err)
		}
		delete(object, "required_acks")
	}

	if raw, found := object["round_robin"]; found {
		err = json.Unmarshal(raw, &a.RoundRobin)
		if err != nil {
			return fmt.Errorf("error reading 'round_robin': %w", err)
		}
		delete(object, "round_robin")
	}

	if raw, found := object["sasl"]; found {
		err = json.Unmarshal(raw, &a.Sasl)
		if err != nil {
			return fmt.Errorf("error reading 'sasl': %w", err)
		}
		delete(object, "sasl")
	}

	if raw, found := object["secrets"]; found {
		err = json.Unmarshal(raw, &a.Secrets)
		if err != nil {
			return fmt.Errorf("error reading 'secrets': %w", err)
		}
		delete(object, "secrets")
	}

	if raw, found := object["shipper"]; found {
		err = json.Unmarshal(raw, &a.Shipper)
		if err != nil {
			return fmt.Errorf("error reading 'shipper': %w", err)
		}
		delete(object, "shipper")
	}

	if raw, found := object["ssl"]; found {
		err = json.Unmarshal(raw, &a.Ssl)
		if err != nil {
			return fmt.Errorf("error reading 'ssl': %w", err)
		}
		delete(object, "ssl")
	}

	if raw, found := object["timeout"]; found {
		err = json.Unmarshal(raw, &a.Timeout)
		if err != nil {
			return fmt.Errorf("error reading 'timeout': %w", err)
		}
		delete(object, "timeout")
	}

	if raw, found := object["topic"]; found {
		err = json.Unmarshal(raw, &a.Topic)
		if err != nil {
			return fmt.Errorf("error reading 'topic': %w", err)
		}
		delete(object, "topic")
	}

	if raw, found := object["topics"]; found {
		err = json.Unmarshal(raw, &a.Topics)
		if err != nil {
			return fmt.Errorf("error reading 'topics': %w", err)
		}
		delete(object, "topics")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["username"]; found {
		err = json.Unmarshal(raw, &a.Username)
		if err != nil {
			return fmt.Errorf("error reading 'username': %w", err)
		}
		delete(object, "username")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka to handle AdditionalProperties
func (a OutputKafka) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AllowEdit != nil {
		object["allow_edit"], err = json.Marshal(a.AllowEdit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allow_edit': %w", err)
		}
	}

	object["auth_type"], err = json.Marshal(a.AuthType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'auth_type': %w", err)
	}

	if a.BrokerTimeout != nil {
		object["broker_timeout"], err = json.Marshal(a.BrokerTimeout)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'broker_timeout': %w", err)
		}
	}

	if a.CaSha256 != nil {
		object["ca_sha256"], err = json.Marshal(a.CaSha256)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ca_sha256': %w", err)
		}
	}

	if a.CaTrustedFingerprint != nil {
		object["ca_trusted_fingerprint"], err = json.Marshal(a.CaTrustedFingerprint)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ca_trusted_fingerprint': %w", err)
		}
	}

	if a.ClientId != nil {
		object["client_id"], err = json.Marshal(a.ClientId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'client_id': %w", err)
		}
	}

	if a.Compression != nil {
		object["compression"], err = json.Marshal(a.Compression)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'compression': %w", err)
		}
	}

	object["compression_level"], err = json.Marshal(a.CompressionLevel)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'compression_level': %w", err)
	}

	if a.ConfigYaml != nil {
		object["config_yaml"], err = json.Marshal(a.ConfigYaml)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'config_yaml': %w", err)
		}
	}

	object["connection_type"], err = json.Marshal(a.ConnectionType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'connection_type': %w", err)
	}

	if a.Hash != nil {
		object["hash"], err = json.Marshal(a.Hash)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'hash': %w", err)
		}
	}

	if a.Headers != nil {
		object["headers"], err = json.Marshal(a.Headers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'headers': %w", err)
		}
	}

	object["hosts"], err = json.Marshal(a.Hosts)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'hosts': %w", err)
	}

	if a.Id != nil {
		object["id"], err = json.Marshal(a.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if a.IsDefault != nil {
		object["is_default"], err = json.Marshal(a.IsDefault)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_default': %w", err)
		}
	}

	if a.IsDefaultMonitoring != nil {
		object["is_default_monitoring"], err = json.Marshal(a.IsDefaultMonitoring)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_default_monitoring': %w", err)
		}
	}

	if a.IsInternal != nil {
		object["is_internal"], err = json.Marshal(a.IsInternal)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_internal': %w", err)
		}
	}

	if a.IsPreconfigured != nil {
		object["is_preconfigured"], err = json.Marshal(a.IsPreconfigured)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_preconfigured': %w", err)
		}
	}

	if a.Key != nil {
		object["key"], err = json.Marshal(a.Key)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'key': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Partition != nil {
		object["partition"], err = json.Marshal(a.Partition)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'partition': %w", err)
		}
	}

	object["password"], err = json.Marshal(a.Password)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'password': %w", err)
	}

	if a.ProxyId != nil {
		object["proxy_id"], err = json.Marshal(a.ProxyId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_id': %w", err)
		}
	}

	if a.Random != nil {
		object["random"], err = json.Marshal(a.Random)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'random': %w", err)
		}
	}

	if a.RequiredAcks != nil {
		object["required_acks"], err = json.Marshal(a.RequiredAcks)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'required_acks': %w", err)
		}
	}

	if a.RoundRobin != nil {
		object["round_robin"], err = json.Marshal(a.RoundRobin)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'round_robin': %w", err)
		}
	}

	if a.Sasl != nil {
		object["sasl"], err = json.Marshal(a.Sasl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sasl': %w", err)
		}
	}

	if a.Secrets != nil {
		object["secrets"], err = json.Marshal(a.Secrets)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secrets': %w", err)
		}
	}

	if a.Shipper != nil {
		object["shipper"], err = json.Marshal(a.Shipper)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'shipper': %w", err)
		}
	}

	if a.Ssl != nil {
		object["ssl"], err = json.Marshal(a.Ssl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl': %w", err)
		}
	}

	if a.Timeout != nil {
		object["timeout"], err = json.Marshal(a.Timeout)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'timeout': %w", err)
		}
	}

	if a.Topic != nil {
		object["topic"], err = json.Marshal(a.Topic)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'topic': %w", err)
		}
	}

	if a.Topics != nil {
		object["topics"], err = json.Marshal(a.Topics)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'topics': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	object["username"], err = json.Marshal(a.Username)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'username': %w", err)
	}

	if a.Version != nil {
		object["version"], err = json.Marshal(a.Version)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'version': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka_Hash. Returns the specified
// element and whether it was found
func (a OutputKafka_Hash) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka_Hash
func (a *OutputKafka_Hash) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka_Hash to handle AdditionalProperties
func (a *OutputKafka_Hash) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["hash"]; found {
		err = json.Unmarshal(raw, &a.Hash)
		if err != nil {
			return fmt.Errorf("error reading 'hash': %w", err)
		}
		delete(object, "hash")
	}

	if raw, found := object["random"]; found {
		err = json.Unmarshal(raw, &a.Random)
		if err != nil {
			return fmt.Errorf("error reading 'random': %w", err)
		}
		delete(object, "random")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka_Hash to handle AdditionalProperties
func (a OutputKafka_Hash) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Hash != nil {
		object["hash"], err = json.Marshal(a.Hash)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'hash': %w", err)
		}
	}

	if a.Random != nil {
		object["random"], err = json.Marshal(a.Random)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'random': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka_Headers_Item. Returns the specified
// element and whether it was found
func (a OutputKafka_Headers_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka_Headers_Item
func (a *OutputKafka_Headers_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka_Headers_Item to handle AdditionalProperties
func (a *OutputKafka_Headers_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["key"]; found {
		err = json.Unmarshal(raw, &a.Key)
		if err != nil {
			return fmt.Errorf("error reading 'key': %w", err)
		}
		delete(object, "key")
	}

	if raw, found := object["value"]; found {
		err = json.Unmarshal(raw, &a.Value)
		if err != nil {
			return fmt.Errorf("error reading 'value': %w", err)
		}
		delete(object, "value")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka_Headers_Item to handle AdditionalProperties
func (a OutputKafka_Headers_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["key"], err = json.Marshal(a.Key)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'key': %w", err)
	}

	object["value"], err = json.Marshal(a.Value)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'value': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka_Random. Returns the specified
// element and whether it was found
func (a OutputKafka_Random) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka_Random
func (a *OutputKafka_Random) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka_Random to handle AdditionalProperties
func (a *OutputKafka_Random) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["group_events"]; found {
		err = json.Unmarshal(raw, &a.GroupEvents)
		if err != nil {
			return fmt.Errorf("error reading 'group_events': %w", err)
		}
		delete(object, "group_events")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka_Random to handle AdditionalProperties
func (a OutputKafka_Random) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.GroupEvents != nil {
		object["group_events"], err = json.Marshal(a.GroupEvents)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'group_events': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka_RoundRobin. Returns the specified
// element and whether it was found
func (a OutputKafka_RoundRobin) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka_RoundRobin
func (a *OutputKafka_RoundRobin) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka_RoundRobin to handle AdditionalProperties
func (a *OutputKafka_RoundRobin) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["group_events"]; found {
		err = json.Unmarshal(raw, &a.GroupEvents)
		if err != nil {
			return fmt.Errorf("error reading 'group_events': %w", err)
		}
		delete(object, "group_events")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka_RoundRobin to handle AdditionalProperties
func (a OutputKafka_RoundRobin) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.GroupEvents != nil {
		object["group_events"], err = json.Marshal(a.GroupEvents)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'group_events': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka_Sasl. Returns the specified
// element and whether it was found
func (a OutputKafka_Sasl) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka_Sasl
func (a *OutputKafka_Sasl) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka_Sasl to handle AdditionalProperties
func (a *OutputKafka_Sasl) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["mechanism"]; found {
		err = json.Unmarshal(raw, &a.Mechanism)
		if err != nil {
			return fmt.Errorf("error reading 'mechanism': %w", err)
		}
		delete(object, "mechanism")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka_Sasl to handle AdditionalProperties
func (a OutputKafka_Sasl) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Mechanism != nil {
		object["mechanism"], err = json.Marshal(a.Mechanism)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mechanism': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafkaSecretsPassword0. Returns the specified
// element and whether it was found
func (a OutputKafkaSecretsPassword0) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafkaSecretsPassword0
func (a *OutputKafkaSecretsPassword0) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafkaSecretsPassword0 to handle AdditionalProperties
func (a *OutputKafkaSecretsPassword0) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafkaSecretsPassword0 to handle AdditionalProperties
func (a OutputKafkaSecretsPassword0) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafkaSecretsSslKey0. Returns the specified
// element and whether it was found
func (a OutputKafkaSecretsSslKey0) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafkaSecretsSslKey0
func (a *OutputKafkaSecretsSslKey0) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafkaSecretsSslKey0 to handle AdditionalProperties
func (a *OutputKafkaSecretsSslKey0) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafkaSecretsSslKey0 to handle AdditionalProperties
func (a OutputKafkaSecretsSslKey0) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka_Secrets_Ssl. Returns the specified
// element and whether it was found
func (a OutputKafka_Secrets_Ssl) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka_Secrets_Ssl
func (a *OutputKafka_Secrets_Ssl) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka_Secrets_Ssl to handle AdditionalProperties
func (a *OutputKafka_Secrets_Ssl) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["key"]; found {
		err = json.Unmarshal(raw, &a.Key)
		if err != nil {
			return fmt.Errorf("error reading 'key': %w", err)
		}
		delete(object, "key")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka_Secrets_Ssl to handle AdditionalProperties
func (a OutputKafka_Secrets_Ssl) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["key"], err = json.Marshal(a.Key)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'key': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka_Secrets. Returns the specified
// element and whether it was found
func (a OutputKafka_Secrets) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka_Secrets
func (a *OutputKafka_Secrets) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka_Secrets to handle AdditionalProperties
func (a *OutputKafka_Secrets) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["password"]; found {
		err = json.Unmarshal(raw, &a.Password)
		if err != nil {
			return fmt.Errorf("error reading 'password': %w", err)
		}
		delete(object, "password")
	}

	if raw, found := object["ssl"]; found {
		err = json.Unmarshal(raw, &a.Ssl)
		if err != nil {
			return fmt.Errorf("error reading 'ssl': %w", err)
		}
		delete(object, "ssl")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka_Secrets to handle AdditionalProperties
func (a OutputKafka_Secrets) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Password != nil {
		object["password"], err = json.Marshal(a.Password)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'password': %w", err)
		}
	}

	if a.Ssl != nil {
		object["ssl"], err = json.Marshal(a.Ssl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka_Topics_When. Returns the specified
// element and whether it was found
func (a OutputKafka_Topics_When) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka_Topics_When
func (a *OutputKafka_Topics_When) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka_Topics_When to handle AdditionalProperties
func (a *OutputKafka_Topics_When) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["condition"]; found {
		err = json.Unmarshal(raw, &a.Condition)
		if err != nil {
			return fmt.Errorf("error reading 'condition': %w", err)
		}
		delete(object, "condition")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka_Topics_When to handle AdditionalProperties
func (a OutputKafka_Topics_When) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Condition != nil {
		object["condition"], err = json.Marshal(a.Condition)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'condition': %w", err)
		}
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka_Topics_Item. Returns the specified
// element and whether it was found
func (a OutputKafka_Topics_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka_Topics_Item
func (a *OutputKafka_Topics_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka_Topics_Item to handle AdditionalProperties
func (a *OutputKafka_Topics_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["topic"]; found {
		err = json.Unmarshal(raw, &a.Topic)
		if err != nil {
			return fmt.Errorf("error reading 'topic': %w", err)
		}
		delete(object, "topic")
	}

	if raw, found := object["when"]; found {
		err = json.Unmarshal(raw, &a.When)
		if err != nil {
			return fmt.Errorf("error reading 'when': %w", err)
		}
		delete(object, "when")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka_Topics_Item to handle AdditionalProperties
func (a OutputKafka_Topics_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["topic"], err = json.Marshal(a.Topic)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'topic': %w", err)
	}

	if a.When != nil {
		object["when"], err = json.Marshal(a.When)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'when': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputLogstash. Returns the specified
// element and whether it was found
func (a OutputLogstash) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputLogstash
func (a *OutputLogstash) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputLogstash to handle AdditionalProperties
func (a *OutputLogstash) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["allow_edit"]; found {
		err = json.Unmarshal(raw, &a.AllowEdit)
		if err != nil {
			return fmt.Errorf("error reading 'allow_edit': %w", err)
		}
		delete(object, "allow_edit")
	}

	if raw, found := object["ca_sha256"]; found {
		err = json.Unmarshal(raw, &a.CaSha256)
		if err != nil {
			return fmt.Errorf("error reading 'ca_sha256': %w", err)
		}
		delete(object, "ca_sha256")
	}

	if raw, found := object["ca_trusted_fingerprint"]; found {
		err = json.Unmarshal(raw, &a.CaTrustedFingerprint)
		if err != nil {
			return fmt.Errorf("error reading 'ca_trusted_fingerprint': %w", err)
		}
		delete(object, "ca_trusted_fingerprint")
	}

	if raw, found := object["config_yaml"]; found {
		err = json.Unmarshal(raw, &a.ConfigYaml)
		if err != nil {
			return fmt.Errorf("error reading 'config_yaml': %w", err)
		}
		delete(object, "config_yaml")
	}

	if raw, found := object["hosts"]; found {
		err = json.Unmarshal(raw, &a.Hosts)
		if err != nil {
			return fmt.Errorf("error reading 'hosts': %w", err)
		}
		delete(object, "hosts")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["is_default"]; found {
		err = json.Unmarshal(raw, &a.IsDefault)
		if err != nil {
			return fmt.Errorf("error reading 'is_default': %w", err)
		}
		delete(object, "is_default")
	}

	if raw, found := object["is_default_monitoring"]; found {
		err = json.Unmarshal(raw, &a.IsDefaultMonitoring)
		if err != nil {
			return fmt.Errorf("error reading 'is_default_monitoring': %w", err)
		}
		delete(object, "is_default_monitoring")
	}

	if raw, found := object["is_internal"]; found {
		err = json.Unmarshal(raw, &a.IsInternal)
		if err != nil {
			return fmt.Errorf("error reading 'is_internal': %w", err)
		}
		delete(object, "is_internal")
	}

	if raw, found := object["is_preconfigured"]; found {
		err = json.Unmarshal(raw, &a.IsPreconfigured)
		if err != nil {
			return fmt.Errorf("error reading 'is_preconfigured': %w", err)
		}
		delete(object, "is_preconfigured")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["proxy_id"]; found {
		err = json.Unmarshal(raw, &a.ProxyId)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_id': %w", err)
		}
		delete(object, "proxy_id")
	}

	if raw, found := object["secrets"]; found {
		err = json.Unmarshal(raw, &a.Secrets)
		if err != nil {
			return fmt.Errorf("error reading 'secrets': %w", err)
		}
		delete(object, "secrets")
	}

	if raw, found := object["shipper"]; found {
		err = json.Unmarshal(raw, &a.Shipper)
		if err != nil {
			return fmt.Errorf("error reading 'shipper': %w", err)
		}
		delete(object, "shipper")
	}

	if raw, found := object["ssl"]; found {
		err = json.Unmarshal(raw, &a.Ssl)
		if err != nil {
			return fmt.Errorf("error reading 'ssl': %w", err)
		}
		delete(object, "ssl")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputLogstash to handle AdditionalProperties
func (a OutputLogstash) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AllowEdit != nil {
		object["allow_edit"], err = json.Marshal(a.AllowEdit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allow_edit': %w", err)
		}
	}

	if a.CaSha256 != nil {
		object["ca_sha256"], err = json.Marshal(a.CaSha256)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ca_sha256': %w", err)
		}
	}

	if a.CaTrustedFingerprint != nil {
		object["ca_trusted_fingerprint"], err = json.Marshal(a.CaTrustedFingerprint)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ca_trusted_fingerprint': %w", err)
		}
	}

	if a.ConfigYaml != nil {
		object["config_yaml"], err = json.Marshal(a.ConfigYaml)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'config_yaml': %w", err)
		}
	}

	object["hosts"], err = json.Marshal(a.Hosts)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'hosts': %w", err)
	}

	if a.Id != nil {
		object["id"], err = json.Marshal(a.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if a.IsDefault != nil {
		object["is_default"], err = json.Marshal(a.IsDefault)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_default': %w", err)
		}
	}

	if a.IsDefaultMonitoring != nil {
		object["is_default_monitoring"], err = json.Marshal(a.IsDefaultMonitoring)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_default_monitoring': %w", err)
		}
	}

	if a.IsInternal != nil {
		object["is_internal"], err = json.Marshal(a.IsInternal)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_internal': %w", err)
		}
	}

	if a.IsPreconfigured != nil {
		object["is_preconfigured"], err = json.Marshal(a.IsPreconfigured)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_preconfigured': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.ProxyId != nil {
		object["proxy_id"], err = json.Marshal(a.ProxyId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_id': %w", err)
		}
	}

	if a.Secrets != nil {
		object["secrets"], err = json.Marshal(a.Secrets)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secrets': %w", err)
		}
	}

	if a.Shipper != nil {
		object["shipper"], err = json.Marshal(a.Shipper)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'shipper': %w", err)
		}
	}

	if a.Ssl != nil {
		object["ssl"], err = json.Marshal(a.Ssl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputLogstashSecretsSslKey0. Returns the specified
// element and whether it was found
func (a OutputLogstashSecretsSslKey0) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputLogstashSecretsSslKey0
func (a *OutputLogstashSecretsSslKey0) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputLogstashSecretsSslKey0 to handle AdditionalProperties
func (a *OutputLogstashSecretsSslKey0) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputLogstashSecretsSslKey0 to handle AdditionalProperties
func (a OutputLogstashSecretsSslKey0) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputLogstash_Secrets_Ssl. Returns the specified
// element and whether it was found
func (a OutputLogstash_Secrets_Ssl) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputLogstash_Secrets_Ssl
func (a *OutputLogstash_Secrets_Ssl) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputLogstash_Secrets_Ssl to handle AdditionalProperties
func (a *OutputLogstash_Secrets_Ssl) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["key"]; found {
		err = json.Unmarshal(raw, &a.Key)
		if err != nil {
			return fmt.Errorf("error reading 'key': %w", err)
		}
		delete(object, "key")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputLogstash_Secrets_Ssl to handle AdditionalProperties
func (a OutputLogstash_Secrets_Ssl) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Key != nil {
		object["key"], err = json.Marshal(a.Key)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'key': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputLogstash_Secrets. Returns the specified
// element and whether it was found
func (a OutputLogstash_Secrets) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputLogstash_Secrets
func (a *OutputLogstash_Secrets) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputLogstash_Secrets to handle AdditionalProperties
func (a *OutputLogstash_Secrets) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["ssl"]; found {
		err = json.Unmarshal(raw, &a.Ssl)
		if err != nil {
			return fmt.Errorf("error reading 'ssl': %w", err)
		}
		delete(object, "ssl")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputLogstash_Secrets to handle AdditionalProperties
func (a OutputLogstash_Secrets) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Ssl != nil {
		object["ssl"], err = json.Marshal(a.Ssl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputRemoteElasticsearch. Returns the specified
// element and whether it was found
func (a OutputRemoteElasticsearch) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputRemoteElasticsearch
func (a *OutputRemoteElasticsearch) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputRemoteElasticsearch to handle AdditionalProperties
func (a *OutputRemoteElasticsearch) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["allow_edit"]; found {
		err = json.Unmarshal(raw, &a.AllowEdit)
		if err != nil {
			return fmt.Errorf("error reading 'allow_edit': %w", err)
		}
		delete(object, "allow_edit")
	}

	if raw, found := object["ca_sha256"]; found {
		err = json.Unmarshal(raw, &a.CaSha256)
		if err != nil {
			return fmt.Errorf("error reading 'ca_sha256': %w", err)
		}
		delete(object, "ca_sha256")
	}

	if raw, found := object["ca_trusted_fingerprint"]; found {
		err = json.Unmarshal(raw, &a.CaTrustedFingerprint)
		if err != nil {
			return fmt.Errorf("error reading 'ca_trusted_fingerprint': %w", err)
		}
		delete(object, "ca_trusted_fingerprint")
	}

	if raw, found := object["config_yaml"]; found {
		err = json.Unmarshal(raw, &a.ConfigYaml)
		if err != nil {
			return fmt.Errorf("error reading 'config_yaml': %w", err)
		}
		delete(object, "config_yaml")
	}

	if raw, found := object["hosts"]; found {
		err = json.Unmarshal(raw, &a.Hosts)
		if err != nil {
			return fmt.Errorf("error reading 'hosts': %w", err)
		}
		delete(object, "hosts")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["is_default"]; found {
		err = json.Unmarshal(raw, &a.IsDefault)
		if err != nil {
			return fmt.Errorf("error reading 'is_default': %w", err)
		}
		delete(object, "is_default")
	}

	if raw, found := object["is_default_monitoring"]; found {
		err = json.Unmarshal(raw, &a.IsDefaultMonitoring)
		if err != nil {
			return fmt.Errorf("error reading 'is_default_monitoring': %w", err)
		}
		delete(object, "is_default_monitoring")
	}

	if raw, found := object["is_internal"]; found {
		err = json.Unmarshal(raw, &a.IsInternal)
		if err != nil {
			return fmt.Errorf("error reading 'is_internal': %w", err)
		}
		delete(object, "is_internal")
	}

	if raw, found := object["is_preconfigured"]; found {
		err = json.Unmarshal(raw, &a.IsPreconfigured)
		if err != nil {
			return fmt.Errorf("error reading 'is_preconfigured': %w", err)
		}
		delete(object, "is_preconfigured")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["preset"]; found {
		err = json.Unmarshal(raw, &a.Preset)
		if err != nil {
			return fmt.Errorf("error reading 'preset': %w", err)
		}
		delete(object, "preset")
	}

	if raw, found := object["proxy_id"]; found {
		err = json.Unmarshal(raw, &a.ProxyId)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_id': %w", err)
		}
		delete(object, "proxy_id")
	}

	if raw, found := object["secrets"]; found {
		err = json.Unmarshal(raw, &a.Secrets)
		if err != nil {
			return fmt.Errorf("error reading 'secrets': %w", err)
		}
		delete(object, "secrets")
	}

	if raw, found := object["service_token"]; found {
		err = json.Unmarshal(raw, &a.ServiceToken)
		if err != nil {
			return fmt.Errorf("error reading 'service_token': %w", err)
		}
		delete(object, "service_token")
	}

	if raw, found := object["shipper"]; found {
		err = json.Unmarshal(raw, &a.Shipper)
		if err != nil {
			return fmt.Errorf("error reading 'shipper': %w", err)
		}
		delete(object, "shipper")
	}

	if raw, found := object["ssl"]; found {
		err = json.Unmarshal(raw, &a.Ssl)
		if err != nil {
			return fmt.Errorf("error reading 'ssl': %w", err)
		}
		delete(object, "ssl")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputRemoteElasticsearch to handle AdditionalProperties
func (a OutputRemoteElasticsearch) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AllowEdit != nil {
		object["allow_edit"], err = json.Marshal(a.AllowEdit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allow_edit': %w", err)
		}
	}

	if a.CaSha256 != nil {
		object["ca_sha256"], err = json.Marshal(a.CaSha256)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ca_sha256': %w", err)
		}
	}

	if a.CaTrustedFingerprint != nil {
		object["ca_trusted_fingerprint"], err = json.Marshal(a.CaTrustedFingerprint)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ca_trusted_fingerprint': %w", err)
		}
	}

	if a.ConfigYaml != nil {
		object["config_yaml"], err = json.Marshal(a.ConfigYaml)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'config_yaml': %w", err)
		}
	}

	object["hosts"], err = json.Marshal(a.Hosts)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'hosts': %w", err)
	}

	if a.Id != nil {
		object["id"], err = json.Marshal(a.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if a.IsDefault != nil {
		object["is_default"], err = json.Marshal(a.IsDefault)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_default': %w", err)
		}
	}

	if a.IsDefaultMonitoring != nil {
		object["is_default_monitoring"], err = json.Marshal(a.IsDefaultMonitoring)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_default_monitoring': %w", err)
		}
	}

	if a.IsInternal != nil {
		object["is_internal"], err = json.Marshal(a.IsInternal)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_internal': %w", err)
		}
	}

	if a.IsPreconfigured != nil {
		object["is_preconfigured"], err = json.Marshal(a.IsPreconfigured)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_preconfigured': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Preset != nil {
		object["preset"], err = json.Marshal(a.Preset)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'preset': %w", err)
		}
	}

	if a.ProxyId != nil {
		object["proxy_id"], err = json.Marshal(a.ProxyId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_id': %w", err)
		}
	}

	if a.Secrets != nil {
		object["secrets"], err = json.Marshal(a.Secrets)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secrets': %w", err)
		}
	}

	if a.ServiceToken != nil {
		object["service_token"], err = json.Marshal(a.ServiceToken)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'service_token': %w", err)
		}
	}

	if a.Shipper != nil {
		object["shipper"], err = json.Marshal(a.Shipper)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'shipper': %w", err)
		}
	}

	if a.Ssl != nil {
		object["ssl"], err = json.Marshal(a.Ssl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputRemoteElasticsearchSecretsServiceToken0. Returns the specified
// element and whether it was found
func (a OutputRemoteElasticsearchSecretsServiceToken0) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputRemoteElasticsearchSecretsServiceToken0
func (a *OutputRemoteElasticsearchSecretsServiceToken0) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputRemoteElasticsearchSecretsServiceToken0 to handle AdditionalProperties
func (a *OutputRemoteElasticsearchSecretsServiceToken0) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputRemoteElasticsearchSecretsServiceToken0 to handle AdditionalProperties
func (a OutputRemoteElasticsearchSecretsServiceToken0) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputRemoteElasticsearch_Secrets. Returns the specified
// element and whether it was found
func (a OutputRemoteElasticsearch_Secrets) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputRemoteElasticsearch_Secrets
func (a *OutputRemoteElasticsearch_Secrets) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputRemoteElasticsearch_Secrets to handle AdditionalProperties
func (a *OutputRemoteElasticsearch_Secrets) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["service_token"]; found {
		err = json.Unmarshal(raw, &a.ServiceToken)
		if err != nil {
			return fmt.Errorf("error reading 'service_token': %w", err)
		}
		delete(object, "service_token")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputRemoteElasticsearch_Secrets to handle AdditionalProperties
func (a OutputRemoteElasticsearch_Secrets) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.ServiceToken != nil {
		object["service_token"], err = json.Marshal(a.ServiceToken)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'service_token': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputShipper. Returns the specified
// element and whether it was found
func (a OutputShipper) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputShipper
func (a *OutputShipper) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputShipper to handle AdditionalProperties
func (a *OutputShipper) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["compression_level"]; found {
		err = json.Unmarshal(raw, &a.CompressionLevel)
		if err != nil {
			return fmt.Errorf("error reading 'compression_level': %w", err)
		}
		delete(object, "compression_level")
	}

	if raw, found := object["disk_queue_compression_enabled"]; found {
		err = json.Unmarshal(raw, &a.DiskQueueCompressionEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'disk_queue_compression_enabled': %w", err)
		}
		delete(object, "disk_queue_compression_enabled")
	}

	if raw, found := object["disk_queue_enabled"]; found {
		err = json.Unmarshal(raw, &a.DiskQueueEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'disk_queue_enabled': %w", err)
		}
		delete(object, "disk_queue_enabled")
	}

	if raw, found := object["disk_queue_encryption_enabled"]; found {
		err = json.Unmarshal(raw, &a.DiskQueueEncryptionEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'disk_queue_encryption_enabled': %w", err)
		}
		delete(object, "disk_queue_encryption_enabled")
	}

	if raw, found := object["disk_queue_max_size"]; found {
		err = json.Unmarshal(raw, &a.DiskQueueMaxSize)
		if err != nil {
			return fmt.Errorf("error reading 'disk_queue_max_size': %w", err)
		}
		delete(object, "disk_queue_max_size")
	}

	if raw, found := object["disk_queue_path"]; found {
		err = json.Unmarshal(raw, &a.DiskQueuePath)
		if err != nil {
			return fmt.Errorf("error reading 'disk_queue_path': %w", err)
		}
		delete(object, "disk_queue_path")
	}

	if raw, found := object["loadbalance"]; found {
		err = json.Unmarshal(raw, &a.Loadbalance)
		if err != nil {
			return fmt.Errorf("error reading 'loadbalance': %w", err)
		}
		delete(object, "loadbalance")
	}

	if raw, found := object["max_batch_bytes"]; found {
		err = json.Unmarshal(raw, &a.MaxBatchBytes)
		if err != nil {
			return fmt.Errorf("error reading 'max_batch_bytes': %w", err)
		}
		delete(object, "max_batch_bytes")
	}

	if raw, found := object["mem_queue_events"]; found {
		err = json.Unmarshal(raw, &a.MemQueueEvents)
		if err != nil {
			return fmt.Errorf("error reading 'mem_queue_events': %w", err)
		}
		delete(object, "mem_queue_events")
	}

	if raw, found := object["queue_flush_timeout"]; found {
		err = json.Unmarshal(raw, &a.QueueFlushTimeout)
		if err != nil {
			return fmt.Errorf("error reading 'queue_flush_timeout': %w", err)
		}
		delete(object, "queue_flush_timeout")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputShipper to handle AdditionalProperties
func (a OutputShipper) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["compression_level"], err = json.Marshal(a.CompressionLevel)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'compression_level': %w", err)
	}

	object["disk_queue_compression_enabled"], err = json.Marshal(a.DiskQueueCompressionEnabled)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'disk_queue_compression_enabled': %w", err)
	}

	if a.DiskQueueEnabled != nil {
		object["disk_queue_enabled"], err = json.Marshal(a.DiskQueueEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'disk_queue_enabled': %w", err)
		}
	}

	object["disk_queue_encryption_enabled"], err = json.Marshal(a.DiskQueueEncryptionEnabled)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'disk_queue_encryption_enabled': %w", err)
	}

	object["disk_queue_max_size"], err = json.Marshal(a.DiskQueueMaxSize)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'disk_queue_max_size': %w", err)
	}

	object["disk_queue_path"], err = json.Marshal(a.DiskQueuePath)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'disk_queue_path': %w", err)
	}

	object["loadbalance"], err = json.Marshal(a.Loadbalance)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'loadbalance': %w", err)
	}

	object["max_batch_bytes"], err = json.Marshal(a.MaxBatchBytes)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'max_batch_bytes': %w", err)
	}

	object["mem_queue_events"], err = json.Marshal(a.MemQueueEvents)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'mem_queue_events': %w", err)
	}

	object["queue_flush_timeout"], err = json.Marshal(a.QueueFlushTimeout)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'queue_flush_timeout': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputSsl. Returns the specified
// element and whether it was found
func (a OutputSsl) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputSsl
func (a *OutputSsl) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputSsl to handle AdditionalProperties
func (a *OutputSsl) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["certificate"]; found {
		err = json.Unmarshal(raw, &a.Certificate)
		if err != nil {
			return fmt.Errorf("error reading 'certificate': %w", err)
		}
		delete(object, "certificate")
	}

	if raw, found := object["certificate_authorities"]; found {
		err = json.Unmarshal(raw, &a.CertificateAuthorities)
		if err != nil {
			return fmt.Errorf("error reading 'certificate_authorities': %w", err)
		}
		delete(object, "certificate_authorities")
	}

	if raw, found := object["key"]; found {
		err = json.Unmarshal(raw, &a.Key)
		if err != nil {
			return fmt.Errorf("error reading 'key': %w", err)
		}
		delete(object, "key")
	}

	if raw, found := object["verification_mode"]; found {
		err = json.Unmarshal(raw, &a.VerificationMode)
		if err != nil {
			return fmt.Errorf("error reading 'verification_mode': %w", err)
		}
		delete(object, "verification_mode")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputSsl to handle AdditionalProperties
func (a OutputSsl) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Certificate != nil {
		object["certificate"], err = json.Marshal(a.Certificate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'certificate': %w", err)
		}
	}

	if a.CertificateAuthorities != nil {
		object["certificate_authorities"], err = json.Marshal(a.CertificateAuthorities)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'certificate_authorities': %w", err)
		}
	}

	if a.Key != nil {
		object["key"], err = json.Marshal(a.Key)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'key': %w", err)
		}
	}

	if a.VerificationMode != nil {
		object["verification_mode"], err = json.Marshal(a.VerificationMode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'verification_mode': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo. Returns the specified
// element and whether it was found
func (a PackageInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo
func (a *PackageInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo to handle AdditionalProperties
func (a *PackageInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["agent"]; found {
		err = json.Unmarshal(raw, &a.Agent)
		if err != nil {
			return fmt.Errorf("error reading 'agent': %w", err)
		}
		delete(object, "agent")
	}

	if raw, found := object["asset_tags"]; found {
		err = json.Unmarshal(raw, &a.AssetTags)
		if err != nil {
			return fmt.Errorf("error reading 'asset_tags': %w", err)
		}
		delete(object, "asset_tags")
	}

	if raw, found := object["assets"]; found {
		err = json.Unmarshal(raw, &a.Assets)
		if err != nil {
			return fmt.Errorf("error reading 'assets': %w", err)
		}
		delete(object, "assets")
	}

	if raw, found := object["categories"]; found {
		err = json.Unmarshal(raw, &a.Categories)
		if err != nil {
			return fmt.Errorf("error reading 'categories': %w", err)
		}
		delete(object, "categories")
	}

	if raw, found := object["conditions"]; found {
		err = json.Unmarshal(raw, &a.Conditions)
		if err != nil {
			return fmt.Errorf("error reading 'conditions': %w", err)
		}
		delete(object, "conditions")
	}

	if raw, found := object["data_streams"]; found {
		err = json.Unmarshal(raw, &a.DataStreams)
		if err != nil {
			return fmt.Errorf("error reading 'data_streams': %w", err)
		}
		delete(object, "data_streams")
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["discovery"]; found {
		err = json.Unmarshal(raw, &a.Discovery)
		if err != nil {
			return fmt.Errorf("error reading 'discovery': %w", err)
		}
		delete(object, "discovery")
	}

	if raw, found := object["download"]; found {
		err = json.Unmarshal(raw, &a.Download)
		if err != nil {
			return fmt.Errorf("error reading 'download': %w", err)
		}
		delete(object, "download")
	}

	if raw, found := object["elasticsearch"]; found {
		err = json.Unmarshal(raw, &a.Elasticsearch)
		if err != nil {
			return fmt.Errorf("error reading 'elasticsearch': %w", err)
		}
		delete(object, "elasticsearch")
	}

	if raw, found := object["format_version"]; found {
		err = json.Unmarshal(raw, &a.FormatVersion)
		if err != nil {
			return fmt.Errorf("error reading 'format_version': %w", err)
		}
		delete(object, "format_version")
	}

	if raw, found := object["icons"]; found {
		err = json.Unmarshal(raw, &a.Icons)
		if err != nil {
			return fmt.Errorf("error reading 'icons': %w", err)
		}
		delete(object, "icons")
	}

	if raw, found := object["installationInfo"]; found {
		err = json.Unmarshal(raw, &a.InstallationInfo)
		if err != nil {
			return fmt.Errorf("error reading 'installationInfo': %w", err)
		}
		delete(object, "installationInfo")
	}

	if raw, found := object["internal"]; found {
		err = json.Unmarshal(raw, &a.Internal)
		if err != nil {
			return fmt.Errorf("error reading 'internal': %w", err)
		}
		delete(object, "internal")
	}

	if raw, found := object["keepPoliciesUpToDate"]; found {
		err = json.Unmarshal(raw, &a.KeepPoliciesUpToDate)
		if err != nil {
			return fmt.Errorf("error reading 'keepPoliciesUpToDate': %w", err)
		}
		delete(object, "keepPoliciesUpToDate")
	}

	if raw, found := object["latestVersion"]; found {
		err = json.Unmarshal(raw, &a.LatestVersion)
		if err != nil {
			return fmt.Errorf("error reading 'latestVersion': %w", err)
		}
		delete(object, "latestVersion")
	}

	if raw, found := object["license"]; found {
		err = json.Unmarshal(raw, &a.License)
		if err != nil {
			return fmt.Errorf("error reading 'license': %w", err)
		}
		delete(object, "license")
	}

	if raw, found := object["licensePath"]; found {
		err = json.Unmarshal(raw, &a.LicensePath)
		if err != nil {
			return fmt.Errorf("error reading 'licensePath': %w", err)
		}
		delete(object, "licensePath")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["notice"]; found {
		err = json.Unmarshal(raw, &a.Notice)
		if err != nil {
			return fmt.Errorf("error reading 'notice': %w", err)
		}
		delete(object, "notice")
	}

	if raw, found := object["owner"]; found {
		err = json.Unmarshal(raw, &a.Owner)
		if err != nil {
			return fmt.Errorf("error reading 'owner': %w", err)
		}
		delete(object, "owner")
	}

	if raw, found := object["path"]; found {
		err = json.Unmarshal(raw, &a.Path)
		if err != nil {
			return fmt.Errorf("error reading 'path': %w", err)
		}
		delete(object, "path")
	}

	if raw, found := object["policy_templates"]; found {
		err = json.Unmarshal(raw, &a.PolicyTemplates)
		if err != nil {
			return fmt.Errorf("error reading 'policy_templates': %w", err)
		}
		delete(object, "policy_templates")
	}

	if raw, found := object["readme"]; found {
		err = json.Unmarshal(raw, &a.Readme)
		if err != nil {
			return fmt.Errorf("error reading 'readme': %w", err)
		}
		delete(object, "readme")
	}

	if raw, found := object["release"]; found {
		err = json.Unmarshal(raw, &a.Release)
		if err != nil {
			return fmt.Errorf("error reading 'release': %w", err)
		}
		delete(object, "release")
	}

	if raw, found := object["savedObject"]; found {
		err = json.Unmarshal(raw, &a.SavedObject)
		if err != nil {
			return fmt.Errorf("error reading 'savedObject': %w", err)
		}
		delete(object, "savedObject")
	}

	if raw, found := object["screenshots"]; found {
		err = json.Unmarshal(raw, &a.Screenshots)
		if err != nil {
			return fmt.Errorf("error reading 'screenshots': %w", err)
		}
		delete(object, "screenshots")
	}

	if raw, found := object["signature_path"]; found {
		err = json.Unmarshal(raw, &a.SignaturePath)
		if err != nil {
			return fmt.Errorf("error reading 'signature_path': %w", err)
		}
		delete(object, "signature_path")
	}

	if raw, found := object["source"]; found {
		err = json.Unmarshal(raw, &a.Source)
		if err != nil {
			return fmt.Errorf("error reading 'source': %w", err)
		}
		delete(object, "source")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
		delete(object, "title")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["vars"]; found {
		err = json.Unmarshal(raw, &a.Vars)
		if err != nil {
			return fmt.Errorf("error reading 'vars': %w", err)
		}
		delete(object, "vars")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo to handle AdditionalProperties
func (a PackageInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Agent != nil {
		object["agent"], err = json.Marshal(a.Agent)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'agent': %w", err)
		}
	}

	if a.AssetTags != nil {
		object["asset_tags"], err = json.Marshal(a.AssetTags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'asset_tags': %w", err)
		}
	}

	object["assets"], err = json.Marshal(a.Assets)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'assets': %w", err)
	}

	if a.Categories != nil {
		object["categories"], err = json.Marshal(a.Categories)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'categories': %w", err)
		}
	}

	if a.Conditions != nil {
		object["conditions"], err = json.Marshal(a.Conditions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'conditions': %w", err)
		}
	}

	if a.DataStreams != nil {
		object["data_streams"], err = json.Marshal(a.DataStreams)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'data_streams': %w", err)
		}
	}

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.Discovery != nil {
		object["discovery"], err = json.Marshal(a.Discovery)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'discovery': %w", err)
		}
	}

	if a.Download != nil {
		object["download"], err = json.Marshal(a.Download)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'download': %w", err)
		}
	}

	if a.Elasticsearch != nil {
		object["elasticsearch"], err = json.Marshal(a.Elasticsearch)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'elasticsearch': %w", err)
		}
	}

	if a.FormatVersion != nil {
		object["format_version"], err = json.Marshal(a.FormatVersion)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'format_version': %w", err)
		}
	}

	if a.Icons != nil {
		object["icons"], err = json.Marshal(a.Icons)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'icons': %w", err)
		}
	}

	if a.InstallationInfo != nil {
		object["installationInfo"], err = json.Marshal(a.InstallationInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'installationInfo': %w", err)
		}
	}

	if a.Internal != nil {
		object["internal"], err = json.Marshal(a.Internal)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'internal': %w", err)
		}
	}

	if a.KeepPoliciesUpToDate != nil {
		object["keepPoliciesUpToDate"], err = json.Marshal(a.KeepPoliciesUpToDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'keepPoliciesUpToDate': %w", err)
		}
	}

	if a.LatestVersion != nil {
		object["latestVersion"], err = json.Marshal(a.LatestVersion)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'latestVersion': %w", err)
		}
	}

	if a.License != nil {
		object["license"], err = json.Marshal(a.License)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'license': %w", err)
		}
	}

	if a.LicensePath != nil {
		object["licensePath"], err = json.Marshal(a.LicensePath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'licensePath': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Notice != nil {
		object["notice"], err = json.Marshal(a.Notice)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'notice': %w", err)
		}
	}

	if a.Owner != nil {
		object["owner"], err = json.Marshal(a.Owner)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'owner': %w", err)
		}
	}

	if a.Path != nil {
		object["path"], err = json.Marshal(a.Path)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'path': %w", err)
		}
	}

	if a.PolicyTemplates != nil {
		object["policy_templates"], err = json.Marshal(a.PolicyTemplates)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'policy_templates': %w", err)
		}
	}

	if a.Readme != nil {
		object["readme"], err = json.Marshal(a.Readme)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'readme': %w", err)
		}
	}

	if a.Release != nil {
		object["release"], err = json.Marshal(a.Release)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'release': %w", err)
		}
	}

	object["savedObject"], err = json.Marshal(a.SavedObject)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'savedObject': %w", err)
	}

	if a.Screenshots != nil {
		object["screenshots"], err = json.Marshal(a.Screenshots)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'screenshots': %w", err)
		}
	}

	if a.SignaturePath != nil {
		object["signature_path"], err = json.Marshal(a.SignaturePath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'signature_path': %w", err)
		}
	}

	if a.Source != nil {
		object["source"], err = json.Marshal(a.Source)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'source': %w", err)
		}
	}

	if a.Status != nil {
		object["status"], err = json.Marshal(a.Status)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status': %w", err)
		}
	}

	object["title"], err = json.Marshal(a.Title)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'title': %w", err)
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	if a.Vars != nil {
		object["vars"], err = json.Marshal(a.Vars)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'vars': %w", err)
		}
	}

	object["version"], err = json.Marshal(a.Version)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'version': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_Conditions_Elastic. Returns the specified
// element and whether it was found
func (a PackageInfo_Conditions_Elastic) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_Conditions_Elastic
func (a *PackageInfo_Conditions_Elastic) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_Conditions_Elastic to handle AdditionalProperties
func (a *PackageInfo_Conditions_Elastic) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["capabilities"]; found {
		err = json.Unmarshal(raw, &a.Capabilities)
		if err != nil {
			return fmt.Errorf("error reading 'capabilities': %w", err)
		}
		delete(object, "capabilities")
	}

	if raw, found := object["subscription"]; found {
		err = json.Unmarshal(raw, &a.Subscription)
		if err != nil {
			return fmt.Errorf("error reading 'subscription': %w", err)
		}
		delete(object, "subscription")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_Conditions_Elastic to handle AdditionalProperties
func (a PackageInfo_Conditions_Elastic) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Capabilities != nil {
		object["capabilities"], err = json.Marshal(a.Capabilities)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'capabilities': %w", err)
		}
	}

	if a.Subscription != nil {
		object["subscription"], err = json.Marshal(a.Subscription)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subscription': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_Conditions_Kibana. Returns the specified
// element and whether it was found
func (a PackageInfo_Conditions_Kibana) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_Conditions_Kibana
func (a *PackageInfo_Conditions_Kibana) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_Conditions_Kibana to handle AdditionalProperties
func (a *PackageInfo_Conditions_Kibana) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_Conditions_Kibana to handle AdditionalProperties
func (a PackageInfo_Conditions_Kibana) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Version != nil {
		object["version"], err = json.Marshal(a.Version)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'version': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_Conditions. Returns the specified
// element and whether it was found
func (a PackageInfo_Conditions) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_Conditions
func (a *PackageInfo_Conditions) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_Conditions to handle AdditionalProperties
func (a *PackageInfo_Conditions) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["elastic"]; found {
		err = json.Unmarshal(raw, &a.Elastic)
		if err != nil {
			return fmt.Errorf("error reading 'elastic': %w", err)
		}
		delete(object, "elastic")
	}

	if raw, found := object["kibana"]; found {
		err = json.Unmarshal(raw, &a.Kibana)
		if err != nil {
			return fmt.Errorf("error reading 'kibana': %w", err)
		}
		delete(object, "kibana")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_Conditions to handle AdditionalProperties
func (a PackageInfo_Conditions) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Elastic != nil {
		object["elastic"], err = json.Marshal(a.Elastic)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'elastic': %w", err)
		}
	}

	if a.Kibana != nil {
		object["kibana"], err = json.Marshal(a.Kibana)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'kibana': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_Discovery_Fields_Item. Returns the specified
// element and whether it was found
func (a PackageInfo_Discovery_Fields_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_Discovery_Fields_Item
func (a *PackageInfo_Discovery_Fields_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_Discovery_Fields_Item to handle AdditionalProperties
func (a *PackageInfo_Discovery_Fields_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_Discovery_Fields_Item to handle AdditionalProperties
func (a PackageInfo_Discovery_Fields_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_Discovery. Returns the specified
// element and whether it was found
func (a PackageInfo_Discovery) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_Discovery
func (a *PackageInfo_Discovery) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_Discovery to handle AdditionalProperties
func (a *PackageInfo_Discovery) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["fields"]; found {
		err = json.Unmarshal(raw, &a.Fields)
		if err != nil {
			return fmt.Errorf("error reading 'fields': %w", err)
		}
		delete(object, "fields")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_Discovery to handle AdditionalProperties
func (a PackageInfo_Discovery) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Fields != nil {
		object["fields"], err = json.Marshal(a.Fields)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fields': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_Icons_Item. Returns the specified
// element and whether it was found
func (a PackageInfo_Icons_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_Icons_Item
func (a *PackageInfo_Icons_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_Icons_Item to handle AdditionalProperties
func (a *PackageInfo_Icons_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["dark_mode"]; found {
		err = json.Unmarshal(raw, &a.DarkMode)
		if err != nil {
			return fmt.Errorf("error reading 'dark_mode': %w", err)
		}
		delete(object, "dark_mode")
	}

	if raw, found := object["path"]; found {
		err = json.Unmarshal(raw, &a.Path)
		if err != nil {
			return fmt.Errorf("error reading 'path': %w", err)
		}
		delete(object, "path")
	}

	if raw, found := object["size"]; found {
		err = json.Unmarshal(raw, &a.Size)
		if err != nil {
			return fmt.Errorf("error reading 'size': %w", err)
		}
		delete(object, "size")
	}

	if raw, found := object["src"]; found {
		err = json.Unmarshal(raw, &a.Src)
		if err != nil {
			return fmt.Errorf("error reading 'src': %w", err)
		}
		delete(object, "src")
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
		delete(object, "title")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_Icons_Item to handle AdditionalProperties
func (a PackageInfo_Icons_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.DarkMode != nil {
		object["dark_mode"], err = json.Marshal(a.DarkMode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dark_mode': %w", err)
		}
	}

	if a.Path != nil {
		object["path"], err = json.Marshal(a.Path)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'path': %w", err)
		}
	}

	if a.Size != nil {
		object["size"], err = json.Marshal(a.Size)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'size': %w", err)
		}
	}

	object["src"], err = json.Marshal(a.Src)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'src': %w", err)
	}

	if a.Title != nil {
		object["title"], err = json.Marshal(a.Title)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'title': %w", err)
		}
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item
func (a *PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["originId"]; found {
		err = json.Unmarshal(raw, &a.OriginId)
		if err != nil {
			return fmt.Errorf("error reading 'originId': %w", err)
		}
		delete(object, "originId")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item to handle AdditionalProperties
func (a PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if a.OriginId != nil {
		object["originId"], err = json.Marshal(a.OriginId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'originId': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features
func (a *PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["doc_value_only_numeric"]; found {
		err = json.Unmarshal(raw, &a.DocValueOnlyNumeric)
		if err != nil {
			return fmt.Errorf("error reading 'doc_value_only_numeric': %w", err)
		}
		delete(object, "doc_value_only_numeric")
	}

	if raw, found := object["doc_value_only_other"]; found {
		err = json.Unmarshal(raw, &a.DocValueOnlyOther)
		if err != nil {
			return fmt.Errorf("error reading 'doc_value_only_other': %w", err)
		}
		delete(object, "doc_value_only_other")
	}

	if raw, found := object["synthetic_source"]; found {
		err = json.Unmarshal(raw, &a.SyntheticSource)
		if err != nil {
			return fmt.Errorf("error reading 'synthetic_source': %w", err)
		}
		delete(object, "synthetic_source")
	}

	if raw, found := object["tsdb"]; found {
		err = json.Unmarshal(raw, &a.Tsdb)
		if err != nil {
			return fmt.Errorf("error reading 'tsdb': %w", err)
		}
		delete(object, "tsdb")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features to handle AdditionalProperties
func (a PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.DocValueOnlyNumeric != nil {
		object["doc_value_only_numeric"], err = json.Marshal(a.DocValueOnlyNumeric)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'doc_value_only_numeric': %w", err)
		}
	}

	if a.DocValueOnlyOther != nil {
		object["doc_value_only_other"], err = json.Marshal(a.DocValueOnlyOther)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'doc_value_only_other': %w", err)
		}
	}

	if a.SyntheticSource != nil {
		object["synthetic_source"], err = json.Marshal(a.SyntheticSource)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'synthetic_source': %w", err)
		}
	}

	if a.Tsdb != nil {
		object["tsdb"], err = json.Marshal(a.Tsdb)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tsdb': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item
func (a *PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["data_stream"]; found {
		err = json.Unmarshal(raw, &a.DataStream)
		if err != nil {
			return fmt.Errorf("error reading 'data_stream': %w", err)
		}
		delete(object, "data_stream")
	}

	if raw, found := object["features"]; found {
		err = json.Unmarshal(raw, &a.Features)
		if err != nil {
			return fmt.Errorf("error reading 'features': %w", err)
		}
		delete(object, "features")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item to handle AdditionalProperties
func (a PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["data_stream"], err = json.Marshal(a.DataStream)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'data_stream': %w", err)
	}

	object["features"], err = json.Marshal(a.Features)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'features': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo_InstalledEs_Item. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo_InstalledEs_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo_InstalledEs_Item
func (a *PackageInfo_InstallationInfo_InstalledEs_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo_InstalledEs_Item to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo_InstalledEs_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["deferred"]; found {
		err = json.Unmarshal(raw, &a.Deferred)
		if err != nil {
			return fmt.Errorf("error reading 'deferred': %w", err)
		}
		delete(object, "deferred")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo_InstalledEs_Item to handle AdditionalProperties
func (a PackageInfo_InstallationInfo_InstalledEs_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Deferred != nil {
		object["deferred"], err = json.Marshal(a.Deferred)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'deferred': %w", err)
		}
	}

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	if a.Version != nil {
		object["version"], err = json.Marshal(a.Version)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'version': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo_InstalledKibana_Item. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo_InstalledKibana_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo_InstalledKibana_Item
func (a *PackageInfo_InstallationInfo_InstalledKibana_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo_InstalledKibana_Item to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo_InstalledKibana_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["originId"]; found {
		err = json.Unmarshal(raw, &a.OriginId)
		if err != nil {
			return fmt.Errorf("error reading 'originId': %w", err)
		}
		delete(object, "originId")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo_InstalledKibana_Item to handle AdditionalProperties
func (a PackageInfo_InstallationInfo_InstalledKibana_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if a.OriginId != nil {
		object["originId"], err = json.Marshal(a.OriginId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'originId': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo_LatestExecutedState. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo_LatestExecutedState) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo_LatestExecutedState
func (a *PackageInfo_InstallationInfo_LatestExecutedState) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo_LatestExecutedState to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo_LatestExecutedState) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["error"]; found {
		err = json.Unmarshal(raw, &a.Error)
		if err != nil {
			return fmt.Errorf("error reading 'error': %w", err)
		}
		delete(object, "error")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["started_at"]; found {
		err = json.Unmarshal(raw, &a.StartedAt)
		if err != nil {
			return fmt.Errorf("error reading 'started_at': %w", err)
		}
		delete(object, "started_at")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo_LatestExecutedState to handle AdditionalProperties
func (a PackageInfo_InstallationInfo_LatestExecutedState) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Error != nil {
		object["error"], err = json.Marshal(a.Error)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'error': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	object["started_at"], err = json.Marshal(a.StartedAt)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'started_at': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error
func (a *PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &a.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
		delete(object, "message")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["stack"]; found {
		err = json.Unmarshal(raw, &a.Stack)
		if err != nil {
			return fmt.Errorf("error reading 'stack': %w", err)
		}
		delete(object, "stack")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error to handle AdditionalProperties
func (a PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["message"], err = json.Marshal(a.Message)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'message': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Stack != nil {
		object["stack"], err = json.Marshal(a.Stack)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stack': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item
func (a *PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["created_at"]; found {
		err = json.Unmarshal(raw, &a.CreatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'created_at': %w", err)
		}
		delete(object, "created_at")
	}

	if raw, found := object["error"]; found {
		err = json.Unmarshal(raw, &a.Error)
		if err != nil {
			return fmt.Errorf("error reading 'error': %w", err)
		}
		delete(object, "error")
	}

	if raw, found := object["target_version"]; found {
		err = json.Unmarshal(raw, &a.TargetVersion)
		if err != nil {
			return fmt.Errorf("error reading 'target_version': %w", err)
		}
		delete(object, "target_version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item to handle AdditionalProperties
func (a PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["created_at"], err = json.Marshal(a.CreatedAt)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'created_at': %w", err)
	}

	object["error"], err = json.Marshal(a.Error)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'error': %w", err)
	}

	object["target_version"], err = json.Marshal(a.TargetVersion)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'target_version': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo
func (a *PackageInfo_InstallationInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["additional_spaces_installed_kibana"]; found {
		err = json.Unmarshal(raw, &a.AdditionalSpacesInstalledKibana)
		if err != nil {
			return fmt.Errorf("error reading 'additional_spaces_installed_kibana': %w", err)
		}
		delete(object, "additional_spaces_installed_kibana")
	}

	if raw, found := object["created_at"]; found {
		err = json.Unmarshal(raw, &a.CreatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'created_at': %w", err)
		}
		delete(object, "created_at")
	}

	if raw, found := object["experimental_data_stream_features"]; found {
		err = json.Unmarshal(raw, &a.ExperimentalDataStreamFeatures)
		if err != nil {
			return fmt.Errorf("error reading 'experimental_data_stream_features': %w", err)
		}
		delete(object, "experimental_data_stream_features")
	}

	if raw, found := object["install_format_schema_version"]; found {
		err = json.Unmarshal(raw, &a.InstallFormatSchemaVersion)
		if err != nil {
			return fmt.Errorf("error reading 'install_format_schema_version': %w", err)
		}
		delete(object, "install_format_schema_version")
	}

	if raw, found := object["install_source"]; found {
		err = json.Unmarshal(raw, &a.InstallSource)
		if err != nil {
			return fmt.Errorf("error reading 'install_source': %w", err)
		}
		delete(object, "install_source")
	}

	if raw, found := object["install_status"]; found {
		err = json.Unmarshal(raw, &a.InstallStatus)
		if err != nil {
			return fmt.Errorf("error reading 'install_status': %w", err)
		}
		delete(object, "install_status")
	}

	if raw, found := object["installed_es"]; found {
		err = json.Unmarshal(raw, &a.InstalledEs)
		if err != nil {
			return fmt.Errorf("error reading 'installed_es': %w", err)
		}
		delete(object, "installed_es")
	}

	if raw, found := object["installed_kibana"]; found {
		err = json.Unmarshal(raw, &a.InstalledKibana)
		if err != nil {
			return fmt.Errorf("error reading 'installed_kibana': %w", err)
		}
		delete(object, "installed_kibana")
	}

	if raw, found := object["installed_kibana_space_id"]; found {
		err = json.Unmarshal(raw, &a.InstalledKibanaSpaceId)
		if err != nil {
			return fmt.Errorf("error reading 'installed_kibana_space_id': %w", err)
		}
		delete(object, "installed_kibana_space_id")
	}

	if raw, found := object["latest_executed_state"]; found {
		err = json.Unmarshal(raw, &a.LatestExecutedState)
		if err != nil {
			return fmt.Errorf("error reading 'latest_executed_state': %w", err)
		}
		delete(object, "latest_executed_state")
	}

	if raw, found := object["latest_install_failed_attempts"]; found {
		err = json.Unmarshal(raw, &a.LatestInstallFailedAttempts)
		if err != nil {
			return fmt.Errorf("error reading 'latest_install_failed_attempts': %w", err)
		}
		delete(object, "latest_install_failed_attempts")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["namespaces"]; found {
		err = json.Unmarshal(raw, &a.Namespaces)
		if err != nil {
			return fmt.Errorf("error reading 'namespaces': %w", err)
		}
		delete(object, "namespaces")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["updated_at"]; found {
		err = json.Unmarshal(raw, &a.UpdatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'updated_at': %w", err)
		}
		delete(object, "updated_at")
	}

	if raw, found := object["verification_key_id"]; found {
		err = json.Unmarshal(raw, &a.VerificationKeyId)
		if err != nil {
			return fmt.Errorf("error reading 'verification_key_id': %w", err)
		}
		delete(object, "verification_key_id")
	}

	if raw, found := object["verification_status"]; found {
		err = json.Unmarshal(raw, &a.VerificationStatus)
		if err != nil {
			return fmt.Errorf("error reading 'verification_status': %w", err)
		}
		delete(object, "verification_status")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo to handle AdditionalProperties
func (a PackageInfo_InstallationInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AdditionalSpacesInstalledKibana != nil {
		object["additional_spaces_installed_kibana"], err = json.Marshal(a.AdditionalSpacesInstalledKibana)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'additional_spaces_installed_kibana': %w", err)
		}
	}

	if a.CreatedAt != nil {
		object["created_at"], err = json.Marshal(a.CreatedAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'created_at': %w", err)
		}
	}

	if a.ExperimentalDataStreamFeatures != nil {
		object["experimental_data_stream_features"], err = json.Marshal(a.ExperimentalDataStreamFeatures)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'experimental_data_stream_features': %w", err)
		}
	}

	if a.InstallFormatSchemaVersion != nil {
		object["install_format_schema_version"], err = json.Marshal(a.InstallFormatSchemaVersion)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'install_format_schema_version': %w", err)
		}
	}

	object["install_source"], err = json.Marshal(a.InstallSource)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'install_source': %w", err)
	}

	object["install_status"], err = json.Marshal(a.InstallStatus)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'install_status': %w", err)
	}

	object["installed_es"], err = json.Marshal(a.InstalledEs)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'installed_es': %w", err)
	}

	object["installed_kibana"], err = json.Marshal(a.InstalledKibana)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'installed_kibana': %w", err)
	}

	if a.InstalledKibanaSpaceId != nil {
		object["installed_kibana_space_id"], err = json.Marshal(a.InstalledKibanaSpaceId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'installed_kibana_space_id': %w", err)
		}
	}

	if a.LatestExecutedState != nil {
		object["latest_executed_state"], err = json.Marshal(a.LatestExecutedState)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'latest_executed_state': %w", err)
		}
	}

	if a.LatestInstallFailedAttempts != nil {
		object["latest_install_failed_attempts"], err = json.Marshal(a.LatestInstallFailedAttempts)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'latest_install_failed_attempts': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Namespaces != nil {
		object["namespaces"], err = json.Marshal(a.Namespaces)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'namespaces': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	if a.UpdatedAt != nil {
		object["updated_at"], err = json.Marshal(a.UpdatedAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'updated_at': %w", err)
		}
	}

	if a.VerificationKeyId != nil {
		object["verification_key_id"], err = json.Marshal(a.VerificationKeyId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'verification_key_id': %w", err)
		}
	}

	object["verification_status"], err = json.Marshal(a.VerificationStatus)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'verification_status': %w", err)
	}

	object["version"], err = json.Marshal(a.Version)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'version': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_Owner. Returns the specified
// element and whether it was found
func (a PackageInfo_Owner) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_Owner
func (a *PackageInfo_Owner) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_Owner to handle AdditionalProperties
func (a *PackageInfo_Owner) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["github"]; found {
		err = json.Unmarshal(raw, &a.Github)
		if err != nil {
			return fmt.Errorf("error reading 'github': %w", err)
		}
		delete(object, "github")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_Owner to handle AdditionalProperties
func (a PackageInfo_Owner) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Github != nil {
		object["github"], err = json.Marshal(a.Github)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'github': %w", err)
		}
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_Source. Returns the specified
// element and whether it was found
func (a PackageInfo_Source) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_Source
func (a *PackageInfo_Source) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_Source to handle AdditionalProperties
func (a *PackageInfo_Source) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["license"]; found {
		err = json.Unmarshal(raw, &a.License)
		if err != nil {
			return fmt.Errorf("error reading 'license': %w", err)
		}
		delete(object, "license")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_Source to handle AdditionalProperties
func (a PackageInfo_Source) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["license"], err = json.Marshal(a.License)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'license': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem. Returns the specified
// element and whether it was found
func (a PackageListItem) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem
func (a *PackageListItem) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem to handle AdditionalProperties
func (a *PackageListItem) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["categories"]; found {
		err = json.Unmarshal(raw, &a.Categories)
		if err != nil {
			return fmt.Errorf("error reading 'categories': %w", err)
		}
		delete(object, "categories")
	}

	if raw, found := object["conditions"]; found {
		err = json.Unmarshal(raw, &a.Conditions)
		if err != nil {
			return fmt.Errorf("error reading 'conditions': %w", err)
		}
		delete(object, "conditions")
	}

	if raw, found := object["data_streams"]; found {
		err = json.Unmarshal(raw, &a.DataStreams)
		if err != nil {
			return fmt.Errorf("error reading 'data_streams': %w", err)
		}
		delete(object, "data_streams")
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["discovery"]; found {
		err = json.Unmarshal(raw, &a.Discovery)
		if err != nil {
			return fmt.Errorf("error reading 'discovery': %w", err)
		}
		delete(object, "discovery")
	}

	if raw, found := object["download"]; found {
		err = json.Unmarshal(raw, &a.Download)
		if err != nil {
			return fmt.Errorf("error reading 'download': %w", err)
		}
		delete(object, "download")
	}

	if raw, found := object["format_version"]; found {
		err = json.Unmarshal(raw, &a.FormatVersion)
		if err != nil {
			return fmt.Errorf("error reading 'format_version': %w", err)
		}
		delete(object, "format_version")
	}

	if raw, found := object["icons"]; found {
		err = json.Unmarshal(raw, &a.Icons)
		if err != nil {
			return fmt.Errorf("error reading 'icons': %w", err)
		}
		delete(object, "icons")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["installationInfo"]; found {
		err = json.Unmarshal(raw, &a.InstallationInfo)
		if err != nil {
			return fmt.Errorf("error reading 'installationInfo': %w", err)
		}
		delete(object, "installationInfo")
	}

	if raw, found := object["integration"]; found {
		err = json.Unmarshal(raw, &a.Integration)
		if err != nil {
			return fmt.Errorf("error reading 'integration': %w", err)
		}
		delete(object, "integration")
	}

	if raw, found := object["internal"]; found {
		err = json.Unmarshal(raw, &a.Internal)
		if err != nil {
			return fmt.Errorf("error reading 'internal': %w", err)
		}
		delete(object, "internal")
	}

	if raw, found := object["latestVersion"]; found {
		err = json.Unmarshal(raw, &a.LatestVersion)
		if err != nil {
			return fmt.Errorf("error reading 'latestVersion': %w", err)
		}
		delete(object, "latestVersion")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["owner"]; found {
		err = json.Unmarshal(raw, &a.Owner)
		if err != nil {
			return fmt.Errorf("error reading 'owner': %w", err)
		}
		delete(object, "owner")
	}

	if raw, found := object["path"]; found {
		err = json.Unmarshal(raw, &a.Path)
		if err != nil {
			return fmt.Errorf("error reading 'path': %w", err)
		}
		delete(object, "path")
	}

	if raw, found := object["policy_templates"]; found {
		err = json.Unmarshal(raw, &a.PolicyTemplates)
		if err != nil {
			return fmt.Errorf("error reading 'policy_templates': %w", err)
		}
		delete(object, "policy_templates")
	}

	if raw, found := object["readme"]; found {
		err = json.Unmarshal(raw, &a.Readme)
		if err != nil {
			return fmt.Errorf("error reading 'readme': %w", err)
		}
		delete(object, "readme")
	}

	if raw, found := object["release"]; found {
		err = json.Unmarshal(raw, &a.Release)
		if err != nil {
			return fmt.Errorf("error reading 'release': %w", err)
		}
		delete(object, "release")
	}

	if raw, found := object["savedObject"]; found {
		err = json.Unmarshal(raw, &a.SavedObject)
		if err != nil {
			return fmt.Errorf("error reading 'savedObject': %w", err)
		}
		delete(object, "savedObject")
	}

	if raw, found := object["signature_path"]; found {
		err = json.Unmarshal(raw, &a.SignaturePath)
		if err != nil {
			return fmt.Errorf("error reading 'signature_path': %w", err)
		}
		delete(object, "signature_path")
	}

	if raw, found := object["source"]; found {
		err = json.Unmarshal(raw, &a.Source)
		if err != nil {
			return fmt.Errorf("error reading 'source': %w", err)
		}
		delete(object, "source")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
		delete(object, "title")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["vars"]; found {
		err = json.Unmarshal(raw, &a.Vars)
		if err != nil {
			return fmt.Errorf("error reading 'vars': %w", err)
		}
		delete(object, "vars")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem to handle AdditionalProperties
func (a PackageListItem) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Categories != nil {
		object["categories"], err = json.Marshal(a.Categories)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'categories': %w", err)
		}
	}

	if a.Conditions != nil {
		object["conditions"], err = json.Marshal(a.Conditions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'conditions': %w", err)
		}
	}

	if a.DataStreams != nil {
		object["data_streams"], err = json.Marshal(a.DataStreams)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'data_streams': %w", err)
		}
	}

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.Discovery != nil {
		object["discovery"], err = json.Marshal(a.Discovery)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'discovery': %w", err)
		}
	}

	if a.Download != nil {
		object["download"], err = json.Marshal(a.Download)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'download': %w", err)
		}
	}

	if a.FormatVersion != nil {
		object["format_version"], err = json.Marshal(a.FormatVersion)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'format_version': %w", err)
		}
	}

	if a.Icons != nil {
		object["icons"], err = json.Marshal(a.Icons)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'icons': %w", err)
		}
	}

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if a.InstallationInfo != nil {
		object["installationInfo"], err = json.Marshal(a.InstallationInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'installationInfo': %w", err)
		}
	}

	if a.Integration != nil {
		object["integration"], err = json.Marshal(a.Integration)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'integration': %w", err)
		}
	}

	if a.Internal != nil {
		object["internal"], err = json.Marshal(a.Internal)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'internal': %w", err)
		}
	}

	if a.LatestVersion != nil {
		object["latestVersion"], err = json.Marshal(a.LatestVersion)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'latestVersion': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Owner != nil {
		object["owner"], err = json.Marshal(a.Owner)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'owner': %w", err)
		}
	}

	if a.Path != nil {
		object["path"], err = json.Marshal(a.Path)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'path': %w", err)
		}
	}

	if a.PolicyTemplates != nil {
		object["policy_templates"], err = json.Marshal(a.PolicyTemplates)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'policy_templates': %w", err)
		}
	}

	if a.Readme != nil {
		object["readme"], err = json.Marshal(a.Readme)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'readme': %w", err)
		}
	}

	if a.Release != nil {
		object["release"], err = json.Marshal(a.Release)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'release': %w", err)
		}
	}

	object["savedObject"], err = json.Marshal(a.SavedObject)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'savedObject': %w", err)
	}

	if a.SignaturePath != nil {
		object["signature_path"], err = json.Marshal(a.SignaturePath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'signature_path': %w", err)
		}
	}

	if a.Source != nil {
		object["source"], err = json.Marshal(a.Source)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'source': %w", err)
		}
	}

	if a.Status != nil {
		object["status"], err = json.Marshal(a.Status)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status': %w", err)
		}
	}

	object["title"], err = json.Marshal(a.Title)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'title': %w", err)
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	if a.Vars != nil {
		object["vars"], err = json.Marshal(a.Vars)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'vars': %w", err)
		}
	}

	object["version"], err = json.Marshal(a.Version)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'version': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_Conditions_Elastic. Returns the specified
// element and whether it was found
func (a PackageListItem_Conditions_Elastic) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_Conditions_Elastic
func (a *PackageListItem_Conditions_Elastic) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_Conditions_Elastic to handle AdditionalProperties
func (a *PackageListItem_Conditions_Elastic) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["capabilities"]; found {
		err = json.Unmarshal(raw, &a.Capabilities)
		if err != nil {
			return fmt.Errorf("error reading 'capabilities': %w", err)
		}
		delete(object, "capabilities")
	}

	if raw, found := object["subscription"]; found {
		err = json.Unmarshal(raw, &a.Subscription)
		if err != nil {
			return fmt.Errorf("error reading 'subscription': %w", err)
		}
		delete(object, "subscription")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_Conditions_Elastic to handle AdditionalProperties
func (a PackageListItem_Conditions_Elastic) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Capabilities != nil {
		object["capabilities"], err = json.Marshal(a.Capabilities)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'capabilities': %w", err)
		}
	}

	if a.Subscription != nil {
		object["subscription"], err = json.Marshal(a.Subscription)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subscription': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_Conditions_Kibana. Returns the specified
// element and whether it was found
func (a PackageListItem_Conditions_Kibana) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_Conditions_Kibana
func (a *PackageListItem_Conditions_Kibana) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_Conditions_Kibana to handle AdditionalProperties
func (a *PackageListItem_Conditions_Kibana) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_Conditions_Kibana to handle AdditionalProperties
func (a PackageListItem_Conditions_Kibana) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Version != nil {
		object["version"], err = json.Marshal(a.Version)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'version': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_Conditions. Returns the specified
// element and whether it was found
func (a PackageListItem_Conditions) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_Conditions
func (a *PackageListItem_Conditions) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_Conditions to handle AdditionalProperties
func (a *PackageListItem_Conditions) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["elastic"]; found {
		err = json.Unmarshal(raw, &a.Elastic)
		if err != nil {
			return fmt.Errorf("error reading 'elastic': %w", err)
		}
		delete(object, "elastic")
	}

	if raw, found := object["kibana"]; found {
		err = json.Unmarshal(raw, &a.Kibana)
		if err != nil {
			return fmt.Errorf("error reading 'kibana': %w", err)
		}
		delete(object, "kibana")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_Conditions to handle AdditionalProperties
func (a PackageListItem_Conditions) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Elastic != nil {
		object["elastic"], err = json.Marshal(a.Elastic)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'elastic': %w", err)
		}
	}

	if a.Kibana != nil {
		object["kibana"], err = json.Marshal(a.Kibana)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'kibana': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_Discovery_Fields_Item. Returns the specified
// element and whether it was found
func (a PackageListItem_Discovery_Fields_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_Discovery_Fields_Item
func (a *PackageListItem_Discovery_Fields_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_Discovery_Fields_Item to handle AdditionalProperties
func (a *PackageListItem_Discovery_Fields_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_Discovery_Fields_Item to handle AdditionalProperties
func (a PackageListItem_Discovery_Fields_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_Discovery. Returns the specified
// element and whether it was found
func (a PackageListItem_Discovery) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_Discovery
func (a *PackageListItem_Discovery) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_Discovery to handle AdditionalProperties
func (a *PackageListItem_Discovery) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["fields"]; found {
		err = json.Unmarshal(raw, &a.Fields)
		if err != nil {
			return fmt.Errorf("error reading 'fields': %w", err)
		}
		delete(object, "fields")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_Discovery to handle AdditionalProperties
func (a PackageListItem_Discovery) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Fields != nil {
		object["fields"], err = json.Marshal(a.Fields)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fields': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_Icons_Item. Returns the specified
// element and whether it was found
func (a PackageListItem_Icons_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_Icons_Item
func (a *PackageListItem_Icons_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_Icons_Item to handle AdditionalProperties
func (a *PackageListItem_Icons_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["dark_mode"]; found {
		err = json.Unmarshal(raw, &a.DarkMode)
		if err != nil {
			return fmt.Errorf("error reading 'dark_mode': %w", err)
		}
		delete(object, "dark_mode")
	}

	if raw, found := object["path"]; found {
		err = json.Unmarshal(raw, &a.Path)
		if err != nil {
			return fmt.Errorf("error reading 'path': %w", err)
		}
		delete(object, "path")
	}

	if raw, found := object["size"]; found {
		err = json.Unmarshal(raw, &a.Size)
		if err != nil {
			return fmt.Errorf("error reading 'size': %w", err)
		}
		delete(object, "size")
	}

	if raw, found := object["src"]; found {
		err = json.Unmarshal(raw, &a.Src)
		if err != nil {
			return fmt.Errorf("error reading 'src': %w", err)
		}
		delete(object, "src")
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
		delete(object, "title")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_Icons_Item to handle AdditionalProperties
func (a PackageListItem_Icons_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.DarkMode != nil {
		object["dark_mode"], err = json.Marshal(a.DarkMode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dark_mode': %w", err)
		}
	}

	if a.Path != nil {
		object["path"], err = json.Marshal(a.Path)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'path': %w", err)
		}
	}

	if a.Size != nil {
		object["size"], err = json.Marshal(a.Size)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'size': %w", err)
		}
	}

	object["src"], err = json.Marshal(a.Src)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'src': %w", err)
	}

	if a.Title != nil {
		object["title"], err = json.Marshal(a.Title)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'title': %w", err)
		}
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item
func (a *PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["originId"]; found {
		err = json.Unmarshal(raw, &a.OriginId)
		if err != nil {
			return fmt.Errorf("error reading 'originId': %w", err)
		}
		delete(object, "originId")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item to handle AdditionalProperties
func (a PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if a.OriginId != nil {
		object["originId"], err = json.Marshal(a.OriginId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'originId': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features
func (a *PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["doc_value_only_numeric"]; found {
		err = json.Unmarshal(raw, &a.DocValueOnlyNumeric)
		if err != nil {
			return fmt.Errorf("error reading 'doc_value_only_numeric': %w", err)
		}
		delete(object, "doc_value_only_numeric")
	}

	if raw, found := object["doc_value_only_other"]; found {
		err = json.Unmarshal(raw, &a.DocValueOnlyOther)
		if err != nil {
			return fmt.Errorf("error reading 'doc_value_only_other': %w", err)
		}
		delete(object, "doc_value_only_other")
	}

	if raw, found := object["synthetic_source"]; found {
		err = json.Unmarshal(raw, &a.SyntheticSource)
		if err != nil {
			return fmt.Errorf("error reading 'synthetic_source': %w", err)
		}
		delete(object, "synthetic_source")
	}

	if raw, found := object["tsdb"]; found {
		err = json.Unmarshal(raw, &a.Tsdb)
		if err != nil {
			return fmt.Errorf("error reading 'tsdb': %w", err)
		}
		delete(object, "tsdb")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features to handle AdditionalProperties
func (a PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.DocValueOnlyNumeric != nil {
		object["doc_value_only_numeric"], err = json.Marshal(a.DocValueOnlyNumeric)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'doc_value_only_numeric': %w", err)
		}
	}

	if a.DocValueOnlyOther != nil {
		object["doc_value_only_other"], err = json.Marshal(a.DocValueOnlyOther)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'doc_value_only_other': %w", err)
		}
	}

	if a.SyntheticSource != nil {
		object["synthetic_source"], err = json.Marshal(a.SyntheticSource)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'synthetic_source': %w", err)
		}
	}

	if a.Tsdb != nil {
		object["tsdb"], err = json.Marshal(a.Tsdb)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tsdb': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item
func (a *PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["data_stream"]; found {
		err = json.Unmarshal(raw, &a.DataStream)
		if err != nil {
			return fmt.Errorf("error reading 'data_stream': %w", err)
		}
		delete(object, "data_stream")
	}

	if raw, found := object["features"]; found {
		err = json.Unmarshal(raw, &a.Features)
		if err != nil {
			return fmt.Errorf("error reading 'features': %w", err)
		}
		delete(object, "features")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item to handle AdditionalProperties
func (a PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["data_stream"], err = json.Marshal(a.DataStream)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'data_stream': %w", err)
	}

	object["features"], err = json.Marshal(a.Features)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'features': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo_InstalledEs_Item. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo_InstalledEs_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo_InstalledEs_Item
func (a *PackageListItem_InstallationInfo_InstalledEs_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo_InstalledEs_Item to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo_InstalledEs_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["deferred"]; found {
		err = json.Unmarshal(raw, &a.Deferred)
		if err != nil {
			return fmt.Errorf("error reading 'deferred': %w", err)
		}
		delete(object, "deferred")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo_InstalledEs_Item to handle AdditionalProperties
func (a PackageListItem_InstallationInfo_InstalledEs_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Deferred != nil {
		object["deferred"], err = json.Marshal(a.Deferred)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'deferred': %w", err)
		}
	}

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	if a.Version != nil {
		object["version"], err = json.Marshal(a.Version)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'version': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo_InstalledKibana_Item. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo_InstalledKibana_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo_InstalledKibana_Item
func (a *PackageListItem_InstallationInfo_InstalledKibana_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo_InstalledKibana_Item to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo_InstalledKibana_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["originId"]; found {
		err = json.Unmarshal(raw, &a.OriginId)
		if err != nil {
			return fmt.Errorf("error reading 'originId': %w", err)
		}
		delete(object, "originId")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo_InstalledKibana_Item to handle AdditionalProperties
func (a PackageListItem_InstallationInfo_InstalledKibana_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if a.OriginId != nil {
		object["originId"], err = json.Marshal(a.OriginId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'originId': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo_LatestExecutedState. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo_LatestExecutedState) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo_LatestExecutedState
func (a *PackageListItem_InstallationInfo_LatestExecutedState) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo_LatestExecutedState to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo_LatestExecutedState) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["error"]; found {
		err = json.Unmarshal(raw, &a.Error)
		if err != nil {
			return fmt.Errorf("error reading 'error': %w", err)
		}
		delete(object, "error")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["started_at"]; found {
		err = json.Unmarshal(raw, &a.StartedAt)
		if err != nil {
			return fmt.Errorf("error reading 'started_at': %w", err)
		}
		delete(object, "started_at")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo_LatestExecutedState to handle AdditionalProperties
func (a PackageListItem_InstallationInfo_LatestExecutedState) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Error != nil {
		object["error"], err = json.Marshal(a.Error)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'error': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	object["started_at"], err = json.Marshal(a.StartedAt)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'started_at': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error
func (a *PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &a.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
		delete(object, "message")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["stack"]; found {
		err = json.Unmarshal(raw, &a.Stack)
		if err != nil {
			return fmt.Errorf("error reading 'stack': %w", err)
		}
		delete(object, "stack")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error to handle AdditionalProperties
func (a PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["message"], err = json.Marshal(a.Message)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'message': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Stack != nil {
		object["stack"], err = json.Marshal(a.Stack)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stack': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item
func (a *PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["created_at"]; found {
		err = json.Unmarshal(raw, &a.CreatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'created_at': %w", err)
		}
		delete(object, "created_at")
	}

	if raw, found := object["error"]; found {
		err = json.Unmarshal(raw, &a.Error)
		if err != nil {
			return fmt.Errorf("error reading 'error': %w", err)
		}
		delete(object, "error")
	}

	if raw, found := object["target_version"]; found {
		err = json.Unmarshal(raw, &a.TargetVersion)
		if err != nil {
			return fmt.Errorf("error reading 'target_version': %w", err)
		}
		delete(object, "target_version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item to handle AdditionalProperties
func (a PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["created_at"], err = json.Marshal(a.CreatedAt)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'created_at': %w", err)
	}

	object["error"], err = json.Marshal(a.Error)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'error': %w", err)
	}

	object["target_version"], err = json.Marshal(a.TargetVersion)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'target_version': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo
func (a *PackageListItem_InstallationInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["additional_spaces_installed_kibana"]; found {
		err = json.Unmarshal(raw, &a.AdditionalSpacesInstalledKibana)
		if err != nil {
			return fmt.Errorf("error reading 'additional_spaces_installed_kibana': %w", err)
		}
		delete(object, "additional_spaces_installed_kibana")
	}

	if raw, found := object["created_at"]; found {
		err = json.Unmarshal(raw, &a.CreatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'created_at': %w", err)
		}
		delete(object, "created_at")
	}

	if raw, found := object["experimental_data_stream_features"]; found {
		err = json.Unmarshal(raw, &a.ExperimentalDataStreamFeatures)
		if err != nil {
			return fmt.Errorf("error reading 'experimental_data_stream_features': %w", err)
		}
		delete(object, "experimental_data_stream_features")
	}

	if raw, found := object["install_format_schema_version"]; found {
		err = json.Unmarshal(raw, &a.InstallFormatSchemaVersion)
		if err != nil {
			return fmt.Errorf("error reading 'install_format_schema_version': %w", err)
		}
		delete(object, "install_format_schema_version")
	}

	if raw, found := object["install_source"]; found {
		err = json.Unmarshal(raw, &a.InstallSource)
		if err != nil {
			return fmt.Errorf("error reading 'install_source': %w", err)
		}
		delete(object, "install_source")
	}

	if raw, found := object["install_status"]; found {
		err = json.Unmarshal(raw, &a.InstallStatus)
		if err != nil {
			return fmt.Errorf("error reading 'install_status': %w", err)
		}
		delete(object, "install_status")
	}

	if raw, found := object["installed_es"]; found {
		err = json.Unmarshal(raw, &a.InstalledEs)
		if err != nil {
			return fmt.Errorf("error reading 'installed_es': %w", err)
		}
		delete(object, "installed_es")
	}

	if raw, found := object["installed_kibana"]; found {
		err = json.Unmarshal(raw, &a.InstalledKibana)
		if err != nil {
			return fmt.Errorf("error reading 'installed_kibana': %w", err)
		}
		delete(object, "installed_kibana")
	}

	if raw, found := object["installed_kibana_space_id"]; found {
		err = json.Unmarshal(raw, &a.InstalledKibanaSpaceId)
		if err != nil {
			return fmt.Errorf("error reading 'installed_kibana_space_id': %w", err)
		}
		delete(object, "installed_kibana_space_id")
	}

	if raw, found := object["latest_executed_state"]; found {
		err = json.Unmarshal(raw, &a.LatestExecutedState)
		if err != nil {
			return fmt.Errorf("error reading 'latest_executed_state': %w", err)
		}
		delete(object, "latest_executed_state")
	}

	if raw, found := object["latest_install_failed_attempts"]; found {
		err = json.Unmarshal(raw, &a.LatestInstallFailedAttempts)
		if err != nil {
			return fmt.Errorf("error reading 'latest_install_failed_attempts': %w", err)
		}
		delete(object, "latest_install_failed_attempts")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["namespaces"]; found {
		err = json.Unmarshal(raw, &a.Namespaces)
		if err != nil {
			return fmt.Errorf("error reading 'namespaces': %w", err)
		}
		delete(object, "namespaces")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["updated_at"]; found {
		err = json.Unmarshal(raw, &a.UpdatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'updated_at': %w", err)
		}
		delete(object, "updated_at")
	}

	if raw, found := object["verification_key_id"]; found {
		err = json.Unmarshal(raw, &a.VerificationKeyId)
		if err != nil {
			return fmt.Errorf("error reading 'verification_key_id': %w", err)
		}
		delete(object, "verification_key_id")
	}

	if raw, found := object["verification_status"]; found {
		err = json.Unmarshal(raw, &a.VerificationStatus)
		if err != nil {
			return fmt.Errorf("error reading 'verification_status': %w", err)
		}
		delete(object, "verification_status")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo to handle AdditionalProperties
func (a PackageListItem_InstallationInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AdditionalSpacesInstalledKibana != nil {
		object["additional_spaces_installed_kibana"], err = json.Marshal(a.AdditionalSpacesInstalledKibana)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'additional_spaces_installed_kibana': %w", err)
		}
	}

	if a.CreatedAt != nil {
		object["created_at"], err = json.Marshal(a.CreatedAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'created_at': %w", err)
		}
	}

	if a.ExperimentalDataStreamFeatures != nil {
		object["experimental_data_stream_features"], err = json.Marshal(a.ExperimentalDataStreamFeatures)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'experimental_data_stream_features': %w", err)
		}
	}

	if a.InstallFormatSchemaVersion != nil {
		object["install_format_schema_version"], err = json.Marshal(a.InstallFormatSchemaVersion)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'install_format_schema_version': %w", err)
		}
	}

	object["install_source"], err = json.Marshal(a.InstallSource)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'install_source': %w", err)
	}

	object["install_status"], err = json.Marshal(a.InstallStatus)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'install_status': %w", err)
	}

	object["installed_es"], err = json.Marshal(a.InstalledEs)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'installed_es': %w", err)
	}

	object["installed_kibana"], err = json.Marshal(a.InstalledKibana)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'installed_kibana': %w", err)
	}

	if a.InstalledKibanaSpaceId != nil {
		object["installed_kibana_space_id"], err = json.Marshal(a.InstalledKibanaSpaceId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'installed_kibana_space_id': %w", err)
		}
	}

	if a.LatestExecutedState != nil {
		object["latest_executed_state"], err = json.Marshal(a.LatestExecutedState)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'latest_executed_state': %w", err)
		}
	}

	if a.LatestInstallFailedAttempts != nil {
		object["latest_install_failed_attempts"], err = json.Marshal(a.LatestInstallFailedAttempts)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'latest_install_failed_attempts': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Namespaces != nil {
		object["namespaces"], err = json.Marshal(a.Namespaces)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'namespaces': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	if a.UpdatedAt != nil {
		object["updated_at"], err = json.Marshal(a.UpdatedAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'updated_at': %w", err)
		}
	}

	if a.VerificationKeyId != nil {
		object["verification_key_id"], err = json.Marshal(a.VerificationKeyId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'verification_key_id': %w", err)
		}
	}

	object["verification_status"], err = json.Marshal(a.VerificationStatus)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'verification_status': %w", err)
	}

	object["version"], err = json.Marshal(a.Version)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'version': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_Owner. Returns the specified
// element and whether it was found
func (a PackageListItem_Owner) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_Owner
func (a *PackageListItem_Owner) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_Owner to handle AdditionalProperties
func (a *PackageListItem_Owner) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["github"]; found {
		err = json.Unmarshal(raw, &a.Github)
		if err != nil {
			return fmt.Errorf("error reading 'github': %w", err)
		}
		delete(object, "github")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_Owner to handle AdditionalProperties
func (a PackageListItem_Owner) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Github != nil {
		object["github"], err = json.Marshal(a.Github)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'github': %w", err)
		}
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_Source. Returns the specified
// element and whether it was found
func (a PackageListItem_Source) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_Source
func (a *PackageListItem_Source) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_Source to handle AdditionalProperties
func (a *PackageListItem_Source) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["license"]; found {
		err = json.Unmarshal(raw, &a.License)
		if err != nil {
			return fmt.Errorf("error reading 'license': %w", err)
		}
		delete(object, "license")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_Source to handle AdditionalProperties
func (a PackageListItem_Source) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["license"], err = json.Marshal(a.License)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'license': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackagePolicy_Elasticsearch_Privileges. Returns the specified
// element and whether it was found
func (a PackagePolicy_Elasticsearch_Privileges) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackagePolicy_Elasticsearch_Privileges
func (a *PackagePolicy_Elasticsearch_Privileges) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackagePolicy_Elasticsearch_Privileges to handle AdditionalProperties
func (a *PackagePolicy_Elasticsearch_Privileges) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["cluster"]; found {
		err = json.Unmarshal(raw, &a.Cluster)
		if err != nil {
			return fmt.Errorf("error reading 'cluster': %w", err)
		}
		delete(object, "cluster")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackagePolicy_Elasticsearch_Privileges to handle AdditionalProperties
func (a PackagePolicy_Elasticsearch_Privileges) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Cluster != nil {
		object["cluster"], err = json.Marshal(a.Cluster)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'cluster': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackagePolicy_Elasticsearch. Returns the specified
// element and whether it was found
func (a PackagePolicy_Elasticsearch) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackagePolicy_Elasticsearch
func (a *PackagePolicy_Elasticsearch) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackagePolicy_Elasticsearch to handle AdditionalProperties
func (a *PackagePolicy_Elasticsearch) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["privileges"]; found {
		err = json.Unmarshal(raw, &a.Privileges)
		if err != nil {
			return fmt.Errorf("error reading 'privileges': %w", err)
		}
		delete(object, "privileges")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackagePolicy_Elasticsearch to handle AdditionalProperties
func (a PackagePolicy_Elasticsearch) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Privileges != nil {
		object["privileges"], err = json.Marshal(a.Privileges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'privileges': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsAgentPolicyGlobalDataTagsValue0 returns the union data inside the AgentPolicy_GlobalDataTags_Value as a AgentPolicyGlobalDataTagsValue0
func (t AgentPolicy_GlobalDataTags_Value) AsAgentPolicyGlobalDataTagsValue0() (AgentPolicyGlobalDataTagsValue0, error) {
	var body AgentPolicyGlobalDataTagsValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyGlobalDataTagsValue0 overwrites any union data inside the AgentPolicy_GlobalDataTags_Value as the provided AgentPolicyGlobalDataTagsValue0
func (t *AgentPolicy_GlobalDataTags_Value) FromAgentPolicyGlobalDataTagsValue0(v AgentPolicyGlobalDataTagsValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyGlobalDataTagsValue0 performs a merge with any union data inside the AgentPolicy_GlobalDataTags_Value, using the provided AgentPolicyGlobalDataTagsValue0
func (t *AgentPolicy_GlobalDataTags_Value) MergeAgentPolicyGlobalDataTagsValue0(v AgentPolicyGlobalDataTagsValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyGlobalDataTagsValue1 returns the union data inside the AgentPolicy_GlobalDataTags_Value as a AgentPolicyGlobalDataTagsValue1
func (t AgentPolicy_GlobalDataTags_Value) AsAgentPolicyGlobalDataTagsValue1() (AgentPolicyGlobalDataTagsValue1, error) {
	var body AgentPolicyGlobalDataTagsValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyGlobalDataTagsValue1 overwrites any union data inside the AgentPolicy_GlobalDataTags_Value as the provided AgentPolicyGlobalDataTagsValue1
func (t *AgentPolicy_GlobalDataTags_Value) FromAgentPolicyGlobalDataTagsValue1(v AgentPolicyGlobalDataTagsValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyGlobalDataTagsValue1 performs a merge with any union data inside the AgentPolicy_GlobalDataTags_Value, using the provided AgentPolicyGlobalDataTagsValue1
func (t *AgentPolicy_GlobalDataTags_Value) MergeAgentPolicyGlobalDataTagsValue1(v AgentPolicyGlobalDataTagsValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AgentPolicy_GlobalDataTags_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AgentPolicy_GlobalDataTags_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAgentPolicyPackagePolicies0 returns the union data inside the AgentPolicy_PackagePolicies as a AgentPolicyPackagePolicies0
func (t AgentPolicy_PackagePolicies) AsAgentPolicyPackagePolicies0() (AgentPolicyPackagePolicies0, error) {
	var body AgentPolicyPackagePolicies0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies0 overwrites any union data inside the AgentPolicy_PackagePolicies as the provided AgentPolicyPackagePolicies0
func (t *AgentPolicy_PackagePolicies) FromAgentPolicyPackagePolicies0(v AgentPolicyPackagePolicies0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies0 performs a merge with any union data inside the AgentPolicy_PackagePolicies, using the provided AgentPolicyPackagePolicies0
func (t *AgentPolicy_PackagePolicies) MergeAgentPolicyPackagePolicies0(v AgentPolicyPackagePolicies0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyPackagePolicies1 returns the union data inside the AgentPolicy_PackagePolicies as a AgentPolicyPackagePolicies1
func (t AgentPolicy_PackagePolicies) AsAgentPolicyPackagePolicies1() (AgentPolicyPackagePolicies1, error) {
	var body AgentPolicyPackagePolicies1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies1 overwrites any union data inside the AgentPolicy_PackagePolicies as the provided AgentPolicyPackagePolicies1
func (t *AgentPolicy_PackagePolicies) FromAgentPolicyPackagePolicies1(v AgentPolicyPackagePolicies1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies1 performs a merge with any union data inside the AgentPolicy_PackagePolicies, using the provided AgentPolicyPackagePolicies1
func (t *AgentPolicy_PackagePolicies) MergeAgentPolicyPackagePolicies1(v AgentPolicyPackagePolicies1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AgentPolicy_PackagePolicies) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AgentPolicy_PackagePolicies) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNewOutputKafkaSecretsPassword0 returns the union data inside the NewOutputKafka_Secrets_Password as a NewOutputKafkaSecretsPassword0
func (t NewOutputKafka_Secrets_Password) AsNewOutputKafkaSecretsPassword0() (NewOutputKafkaSecretsPassword0, error) {
	var body NewOutputKafkaSecretsPassword0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputKafkaSecretsPassword0 overwrites any union data inside the NewOutputKafka_Secrets_Password as the provided NewOutputKafkaSecretsPassword0
func (t *NewOutputKafka_Secrets_Password) FromNewOutputKafkaSecretsPassword0(v NewOutputKafkaSecretsPassword0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputKafkaSecretsPassword0 performs a merge with any union data inside the NewOutputKafka_Secrets_Password, using the provided NewOutputKafkaSecretsPassword0
func (t *NewOutputKafka_Secrets_Password) MergeNewOutputKafkaSecretsPassword0(v NewOutputKafkaSecretsPassword0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNewOutputKafkaSecretsPassword1 returns the union data inside the NewOutputKafka_Secrets_Password as a NewOutputKafkaSecretsPassword1
func (t NewOutputKafka_Secrets_Password) AsNewOutputKafkaSecretsPassword1() (NewOutputKafkaSecretsPassword1, error) {
	var body NewOutputKafkaSecretsPassword1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputKafkaSecretsPassword1 overwrites any union data inside the NewOutputKafka_Secrets_Password as the provided NewOutputKafkaSecretsPassword1
func (t *NewOutputKafka_Secrets_Password) FromNewOutputKafkaSecretsPassword1(v NewOutputKafkaSecretsPassword1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputKafkaSecretsPassword1 performs a merge with any union data inside the NewOutputKafka_Secrets_Password, using the provided NewOutputKafkaSecretsPassword1
func (t *NewOutputKafka_Secrets_Password) MergeNewOutputKafkaSecretsPassword1(v NewOutputKafkaSecretsPassword1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NewOutputKafka_Secrets_Password) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NewOutputKafka_Secrets_Password) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNewOutputKafkaSecretsSslKey0 returns the union data inside the NewOutputKafka_Secrets_Ssl_Key as a NewOutputKafkaSecretsSslKey0
func (t NewOutputKafka_Secrets_Ssl_Key) AsNewOutputKafkaSecretsSslKey0() (NewOutputKafkaSecretsSslKey0, error) {
	var body NewOutputKafkaSecretsSslKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputKafkaSecretsSslKey0 overwrites any union data inside the NewOutputKafka_Secrets_Ssl_Key as the provided NewOutputKafkaSecretsSslKey0
func (t *NewOutputKafka_Secrets_Ssl_Key) FromNewOutputKafkaSecretsSslKey0(v NewOutputKafkaSecretsSslKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputKafkaSecretsSslKey0 performs a merge with any union data inside the NewOutputKafka_Secrets_Ssl_Key, using the provided NewOutputKafkaSecretsSslKey0
func (t *NewOutputKafka_Secrets_Ssl_Key) MergeNewOutputKafkaSecretsSslKey0(v NewOutputKafkaSecretsSslKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNewOutputKafkaSecretsSslKey1 returns the union data inside the NewOutputKafka_Secrets_Ssl_Key as a NewOutputKafkaSecretsSslKey1
func (t NewOutputKafka_Secrets_Ssl_Key) AsNewOutputKafkaSecretsSslKey1() (NewOutputKafkaSecretsSslKey1, error) {
	var body NewOutputKafkaSecretsSslKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputKafkaSecretsSslKey1 overwrites any union data inside the NewOutputKafka_Secrets_Ssl_Key as the provided NewOutputKafkaSecretsSslKey1
func (t *NewOutputKafka_Secrets_Ssl_Key) FromNewOutputKafkaSecretsSslKey1(v NewOutputKafkaSecretsSslKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputKafkaSecretsSslKey1 performs a merge with any union data inside the NewOutputKafka_Secrets_Ssl_Key, using the provided NewOutputKafkaSecretsSslKey1
func (t *NewOutputKafka_Secrets_Ssl_Key) MergeNewOutputKafkaSecretsSslKey1(v NewOutputKafkaSecretsSslKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NewOutputKafka_Secrets_Ssl_Key) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NewOutputKafka_Secrets_Ssl_Key) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNewOutputLogstashSecretsSslKey0 returns the union data inside the NewOutputLogstash_Secrets_Ssl_Key as a NewOutputLogstashSecretsSslKey0
func (t NewOutputLogstash_Secrets_Ssl_Key) AsNewOutputLogstashSecretsSslKey0() (NewOutputLogstashSecretsSslKey0, error) {
	var body NewOutputLogstashSecretsSslKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputLogstashSecretsSslKey0 overwrites any union data inside the NewOutputLogstash_Secrets_Ssl_Key as the provided NewOutputLogstashSecretsSslKey0
func (t *NewOutputLogstash_Secrets_Ssl_Key) FromNewOutputLogstashSecretsSslKey0(v NewOutputLogstashSecretsSslKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputLogstashSecretsSslKey0 performs a merge with any union data inside the NewOutputLogstash_Secrets_Ssl_Key, using the provided NewOutputLogstashSecretsSslKey0
func (t *NewOutputLogstash_Secrets_Ssl_Key) MergeNewOutputLogstashSecretsSslKey0(v NewOutputLogstashSecretsSslKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNewOutputLogstashSecretsSslKey1 returns the union data inside the NewOutputLogstash_Secrets_Ssl_Key as a NewOutputLogstashSecretsSslKey1
func (t NewOutputLogstash_Secrets_Ssl_Key) AsNewOutputLogstashSecretsSslKey1() (NewOutputLogstashSecretsSslKey1, error) {
	var body NewOutputLogstashSecretsSslKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputLogstashSecretsSslKey1 overwrites any union data inside the NewOutputLogstash_Secrets_Ssl_Key as the provided NewOutputLogstashSecretsSslKey1
func (t *NewOutputLogstash_Secrets_Ssl_Key) FromNewOutputLogstashSecretsSslKey1(v NewOutputLogstashSecretsSslKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputLogstashSecretsSslKey1 performs a merge with any union data inside the NewOutputLogstash_Secrets_Ssl_Key, using the provided NewOutputLogstashSecretsSslKey1
func (t *NewOutputLogstash_Secrets_Ssl_Key) MergeNewOutputLogstashSecretsSslKey1(v NewOutputLogstashSecretsSslKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NewOutputLogstash_Secrets_Ssl_Key) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NewOutputLogstash_Secrets_Ssl_Key) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNewOutputRemoteElasticsearchSecretsServiceToken0 returns the union data inside the NewOutputRemoteElasticsearch_Secrets_ServiceToken as a NewOutputRemoteElasticsearchSecretsServiceToken0
func (t NewOutputRemoteElasticsearch_Secrets_ServiceToken) AsNewOutputRemoteElasticsearchSecretsServiceToken0() (NewOutputRemoteElasticsearchSecretsServiceToken0, error) {
	var body NewOutputRemoteElasticsearchSecretsServiceToken0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputRemoteElasticsearchSecretsServiceToken0 overwrites any union data inside the NewOutputRemoteElasticsearch_Secrets_ServiceToken as the provided NewOutputRemoteElasticsearchSecretsServiceToken0
func (t *NewOutputRemoteElasticsearch_Secrets_ServiceToken) FromNewOutputRemoteElasticsearchSecretsServiceToken0(v NewOutputRemoteElasticsearchSecretsServiceToken0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputRemoteElasticsearchSecretsServiceToken0 performs a merge with any union data inside the NewOutputRemoteElasticsearch_Secrets_ServiceToken, using the provided NewOutputRemoteElasticsearchSecretsServiceToken0
func (t *NewOutputRemoteElasticsearch_Secrets_ServiceToken) MergeNewOutputRemoteElasticsearchSecretsServiceToken0(v NewOutputRemoteElasticsearchSecretsServiceToken0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNewOutputRemoteElasticsearchSecretsServiceToken1 returns the union data inside the NewOutputRemoteElasticsearch_Secrets_ServiceToken as a NewOutputRemoteElasticsearchSecretsServiceToken1
func (t NewOutputRemoteElasticsearch_Secrets_ServiceToken) AsNewOutputRemoteElasticsearchSecretsServiceToken1() (NewOutputRemoteElasticsearchSecretsServiceToken1, error) {
	var body NewOutputRemoteElasticsearchSecretsServiceToken1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputRemoteElasticsearchSecretsServiceToken1 overwrites any union data inside the NewOutputRemoteElasticsearch_Secrets_ServiceToken as the provided NewOutputRemoteElasticsearchSecretsServiceToken1
func (t *NewOutputRemoteElasticsearch_Secrets_ServiceToken) FromNewOutputRemoteElasticsearchSecretsServiceToken1(v NewOutputRemoteElasticsearchSecretsServiceToken1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputRemoteElasticsearchSecretsServiceToken1 performs a merge with any union data inside the NewOutputRemoteElasticsearch_Secrets_ServiceToken, using the provided NewOutputRemoteElasticsearchSecretsServiceToken1
func (t *NewOutputRemoteElasticsearch_Secrets_ServiceToken) MergeNewOutputRemoteElasticsearchSecretsServiceToken1(v NewOutputRemoteElasticsearchSecretsServiceToken1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NewOutputRemoteElasticsearch_Secrets_ServiceToken) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NewOutputRemoteElasticsearch_Secrets_ServiceToken) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNewOutputElasticsearch returns the union data inside the NewOutputUnion as a NewOutputElasticsearch
func (t NewOutputUnion) AsNewOutputElasticsearch() (NewOutputElasticsearch, error) {
	var body NewOutputElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputElasticsearch overwrites any union data inside the NewOutputUnion as the provided NewOutputElasticsearch
func (t *NewOutputUnion) FromNewOutputElasticsearch(v NewOutputElasticsearch) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputElasticsearch performs a merge with any union data inside the NewOutputUnion, using the provided NewOutputElasticsearch
func (t *NewOutputUnion) MergeNewOutputElasticsearch(v NewOutputElasticsearch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNewOutputRemoteElasticsearch returns the union data inside the NewOutputUnion as a NewOutputRemoteElasticsearch
func (t NewOutputUnion) AsNewOutputRemoteElasticsearch() (NewOutputRemoteElasticsearch, error) {
	var body NewOutputRemoteElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputRemoteElasticsearch overwrites any union data inside the NewOutputUnion as the provided NewOutputRemoteElasticsearch
func (t *NewOutputUnion) FromNewOutputRemoteElasticsearch(v NewOutputRemoteElasticsearch) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputRemoteElasticsearch performs a merge with any union data inside the NewOutputUnion, using the provided NewOutputRemoteElasticsearch
func (t *NewOutputUnion) MergeNewOutputRemoteElasticsearch(v NewOutputRemoteElasticsearch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNewOutputLogstash returns the union data inside the NewOutputUnion as a NewOutputLogstash
func (t NewOutputUnion) AsNewOutputLogstash() (NewOutputLogstash, error) {
	var body NewOutputLogstash
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputLogstash overwrites any union data inside the NewOutputUnion as the provided NewOutputLogstash
func (t *NewOutputUnion) FromNewOutputLogstash(v NewOutputLogstash) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputLogstash performs a merge with any union data inside the NewOutputUnion, using the provided NewOutputLogstash
func (t *NewOutputUnion) MergeNewOutputLogstash(v NewOutputLogstash) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNewOutputKafka returns the union data inside the NewOutputUnion as a NewOutputKafka
func (t NewOutputUnion) AsNewOutputKafka() (NewOutputKafka, error) {
	var body NewOutputKafka
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputKafka overwrites any union data inside the NewOutputUnion as the provided NewOutputKafka
func (t *NewOutputUnion) FromNewOutputKafka(v NewOutputKafka) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputKafka performs a merge with any union data inside the NewOutputUnion, using the provided NewOutputKafka
func (t *NewOutputUnion) MergeNewOutputKafka(v NewOutputKafka) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NewOutputUnion) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NewOutputUnion) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOutputKafkaSecretsPassword0 returns the union data inside the OutputKafka_Secrets_Password as a OutputKafkaSecretsPassword0
func (t OutputKafka_Secrets_Password) AsOutputKafkaSecretsPassword0() (OutputKafkaSecretsPassword0, error) {
	var body OutputKafkaSecretsPassword0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputKafkaSecretsPassword0 overwrites any union data inside the OutputKafka_Secrets_Password as the provided OutputKafkaSecretsPassword0
func (t *OutputKafka_Secrets_Password) FromOutputKafkaSecretsPassword0(v OutputKafkaSecretsPassword0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputKafkaSecretsPassword0 performs a merge with any union data inside the OutputKafka_Secrets_Password, using the provided OutputKafkaSecretsPassword0
func (t *OutputKafka_Secrets_Password) MergeOutputKafkaSecretsPassword0(v OutputKafkaSecretsPassword0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputKafkaSecretsPassword1 returns the union data inside the OutputKafka_Secrets_Password as a OutputKafkaSecretsPassword1
func (t OutputKafka_Secrets_Password) AsOutputKafkaSecretsPassword1() (OutputKafkaSecretsPassword1, error) {
	var body OutputKafkaSecretsPassword1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputKafkaSecretsPassword1 overwrites any union data inside the OutputKafka_Secrets_Password as the provided OutputKafkaSecretsPassword1
func (t *OutputKafka_Secrets_Password) FromOutputKafkaSecretsPassword1(v OutputKafkaSecretsPassword1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputKafkaSecretsPassword1 performs a merge with any union data inside the OutputKafka_Secrets_Password, using the provided OutputKafkaSecretsPassword1
func (t *OutputKafka_Secrets_Password) MergeOutputKafkaSecretsPassword1(v OutputKafkaSecretsPassword1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OutputKafka_Secrets_Password) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OutputKafka_Secrets_Password) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOutputKafkaSecretsSslKey0 returns the union data inside the OutputKafka_Secrets_Ssl_Key as a OutputKafkaSecretsSslKey0
func (t OutputKafka_Secrets_Ssl_Key) AsOutputKafkaSecretsSslKey0() (OutputKafkaSecretsSslKey0, error) {
	var body OutputKafkaSecretsSslKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputKafkaSecretsSslKey0 overwrites any union data inside the OutputKafka_Secrets_Ssl_Key as the provided OutputKafkaSecretsSslKey0
func (t *OutputKafka_Secrets_Ssl_Key) FromOutputKafkaSecretsSslKey0(v OutputKafkaSecretsSslKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputKafkaSecretsSslKey0 performs a merge with any union data inside the OutputKafka_Secrets_Ssl_Key, using the provided OutputKafkaSecretsSslKey0
func (t *OutputKafka_Secrets_Ssl_Key) MergeOutputKafkaSecretsSslKey0(v OutputKafkaSecretsSslKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputKafkaSecretsSslKey1 returns the union data inside the OutputKafka_Secrets_Ssl_Key as a OutputKafkaSecretsSslKey1
func (t OutputKafka_Secrets_Ssl_Key) AsOutputKafkaSecretsSslKey1() (OutputKafkaSecretsSslKey1, error) {
	var body OutputKafkaSecretsSslKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputKafkaSecretsSslKey1 overwrites any union data inside the OutputKafka_Secrets_Ssl_Key as the provided OutputKafkaSecretsSslKey1
func (t *OutputKafka_Secrets_Ssl_Key) FromOutputKafkaSecretsSslKey1(v OutputKafkaSecretsSslKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputKafkaSecretsSslKey1 performs a merge with any union data inside the OutputKafka_Secrets_Ssl_Key, using the provided OutputKafkaSecretsSslKey1
func (t *OutputKafka_Secrets_Ssl_Key) MergeOutputKafkaSecretsSslKey1(v OutputKafkaSecretsSslKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OutputKafka_Secrets_Ssl_Key) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OutputKafka_Secrets_Ssl_Key) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOutputLogstashSecretsSslKey0 returns the union data inside the OutputLogstash_Secrets_Ssl_Key as a OutputLogstashSecretsSslKey0
func (t OutputLogstash_Secrets_Ssl_Key) AsOutputLogstashSecretsSslKey0() (OutputLogstashSecretsSslKey0, error) {
	var body OutputLogstashSecretsSslKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputLogstashSecretsSslKey0 overwrites any union data inside the OutputLogstash_Secrets_Ssl_Key as the provided OutputLogstashSecretsSslKey0
func (t *OutputLogstash_Secrets_Ssl_Key) FromOutputLogstashSecretsSslKey0(v OutputLogstashSecretsSslKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputLogstashSecretsSslKey0 performs a merge with any union data inside the OutputLogstash_Secrets_Ssl_Key, using the provided OutputLogstashSecretsSslKey0
func (t *OutputLogstash_Secrets_Ssl_Key) MergeOutputLogstashSecretsSslKey0(v OutputLogstashSecretsSslKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputLogstashSecretsSslKey1 returns the union data inside the OutputLogstash_Secrets_Ssl_Key as a OutputLogstashSecretsSslKey1
func (t OutputLogstash_Secrets_Ssl_Key) AsOutputLogstashSecretsSslKey1() (OutputLogstashSecretsSslKey1, error) {
	var body OutputLogstashSecretsSslKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputLogstashSecretsSslKey1 overwrites any union data inside the OutputLogstash_Secrets_Ssl_Key as the provided OutputLogstashSecretsSslKey1
func (t *OutputLogstash_Secrets_Ssl_Key) FromOutputLogstashSecretsSslKey1(v OutputLogstashSecretsSslKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputLogstashSecretsSslKey1 performs a merge with any union data inside the OutputLogstash_Secrets_Ssl_Key, using the provided OutputLogstashSecretsSslKey1
func (t *OutputLogstash_Secrets_Ssl_Key) MergeOutputLogstashSecretsSslKey1(v OutputLogstashSecretsSslKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OutputLogstash_Secrets_Ssl_Key) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OutputLogstash_Secrets_Ssl_Key) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOutputRemoteElasticsearchSecretsServiceToken0 returns the union data inside the OutputRemoteElasticsearch_Secrets_ServiceToken as a OutputRemoteElasticsearchSecretsServiceToken0
func (t OutputRemoteElasticsearch_Secrets_ServiceToken) AsOutputRemoteElasticsearchSecretsServiceToken0() (OutputRemoteElasticsearchSecretsServiceToken0, error) {
	var body OutputRemoteElasticsearchSecretsServiceToken0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputRemoteElasticsearchSecretsServiceToken0 overwrites any union data inside the OutputRemoteElasticsearch_Secrets_ServiceToken as the provided OutputRemoteElasticsearchSecretsServiceToken0
func (t *OutputRemoteElasticsearch_Secrets_ServiceToken) FromOutputRemoteElasticsearchSecretsServiceToken0(v OutputRemoteElasticsearchSecretsServiceToken0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputRemoteElasticsearchSecretsServiceToken0 performs a merge with any union data inside the OutputRemoteElasticsearch_Secrets_ServiceToken, using the provided OutputRemoteElasticsearchSecretsServiceToken0
func (t *OutputRemoteElasticsearch_Secrets_ServiceToken) MergeOutputRemoteElasticsearchSecretsServiceToken0(v OutputRemoteElasticsearchSecretsServiceToken0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputRemoteElasticsearchSecretsServiceToken1 returns the union data inside the OutputRemoteElasticsearch_Secrets_ServiceToken as a OutputRemoteElasticsearchSecretsServiceToken1
func (t OutputRemoteElasticsearch_Secrets_ServiceToken) AsOutputRemoteElasticsearchSecretsServiceToken1() (OutputRemoteElasticsearchSecretsServiceToken1, error) {
	var body OutputRemoteElasticsearchSecretsServiceToken1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputRemoteElasticsearchSecretsServiceToken1 overwrites any union data inside the OutputRemoteElasticsearch_Secrets_ServiceToken as the provided OutputRemoteElasticsearchSecretsServiceToken1
func (t *OutputRemoteElasticsearch_Secrets_ServiceToken) FromOutputRemoteElasticsearchSecretsServiceToken1(v OutputRemoteElasticsearchSecretsServiceToken1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputRemoteElasticsearchSecretsServiceToken1 performs a merge with any union data inside the OutputRemoteElasticsearch_Secrets_ServiceToken, using the provided OutputRemoteElasticsearchSecretsServiceToken1
func (t *OutputRemoteElasticsearch_Secrets_ServiceToken) MergeOutputRemoteElasticsearchSecretsServiceToken1(v OutputRemoteElasticsearchSecretsServiceToken1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OutputRemoteElasticsearch_Secrets_ServiceToken) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OutputRemoteElasticsearch_Secrets_ServiceToken) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOutputElasticsearch returns the union data inside the OutputUnion as a OutputElasticsearch
func (t OutputUnion) AsOutputElasticsearch() (OutputElasticsearch, error) {
	var body OutputElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputElasticsearch overwrites any union data inside the OutputUnion as the provided OutputElasticsearch
func (t *OutputUnion) FromOutputElasticsearch(v OutputElasticsearch) error {
	v.Type = "elasticsearch"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputElasticsearch performs a merge with any union data inside the OutputUnion, using the provided OutputElasticsearch
func (t *OutputUnion) MergeOutputElasticsearch(v OutputElasticsearch) error {
	v.Type = "elasticsearch"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputRemoteElasticsearch returns the union data inside the OutputUnion as a OutputRemoteElasticsearch
func (t OutputUnion) AsOutputRemoteElasticsearch() (OutputRemoteElasticsearch, error) {
	var body OutputRemoteElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputRemoteElasticsearch overwrites any union data inside the OutputUnion as the provided OutputRemoteElasticsearch
func (t *OutputUnion) FromOutputRemoteElasticsearch(v OutputRemoteElasticsearch) error {
	v.Type = "remote_elasticsearch"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputRemoteElasticsearch performs a merge with any union data inside the OutputUnion, using the provided OutputRemoteElasticsearch
func (t *OutputUnion) MergeOutputRemoteElasticsearch(v OutputRemoteElasticsearch) error {
	v.Type = "remote_elasticsearch"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputLogstash returns the union data inside the OutputUnion as a OutputLogstash
func (t OutputUnion) AsOutputLogstash() (OutputLogstash, error) {
	var body OutputLogstash
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputLogstash overwrites any union data inside the OutputUnion as the provided OutputLogstash
func (t *OutputUnion) FromOutputLogstash(v OutputLogstash) error {
	v.Type = "logstash"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputLogstash performs a merge with any union data inside the OutputUnion, using the provided OutputLogstash
func (t *OutputUnion) MergeOutputLogstash(v OutputLogstash) error {
	v.Type = "logstash"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputKafka returns the union data inside the OutputUnion as a OutputKafka
func (t OutputUnion) AsOutputKafka() (OutputKafka, error) {
	var body OutputKafka
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputKafka overwrites any union data inside the OutputUnion as the provided OutputKafka
func (t *OutputUnion) FromOutputKafka(v OutputKafka) error {
	v.Type = "kafka"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputKafka performs a merge with any union data inside the OutputUnion, using the provided OutputKafka
func (t *OutputUnion) MergeOutputKafka(v OutputKafka) error {
	v.Type = "kafka"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OutputUnion) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t OutputUnion) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "elasticsearch":
		return t.AsOutputElasticsearch()
	case "kafka":
		return t.AsOutputKafka()
	case "logstash":
		return t.AsOutputLogstash()
	case "remote_elasticsearch":
		return t.AsOutputRemoteElasticsearch()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t OutputUnion) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OutputUnion) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateOutputKafkaSecretsPassword0 returns the union data inside the UpdateOutputKafka_Secrets_Password as a UpdateOutputKafkaSecretsPassword0
func (t UpdateOutputKafka_Secrets_Password) AsUpdateOutputKafkaSecretsPassword0() (UpdateOutputKafkaSecretsPassword0, error) {
	var body UpdateOutputKafkaSecretsPassword0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputKafkaSecretsPassword0 overwrites any union data inside the UpdateOutputKafka_Secrets_Password as the provided UpdateOutputKafkaSecretsPassword0
func (t *UpdateOutputKafka_Secrets_Password) FromUpdateOutputKafkaSecretsPassword0(v UpdateOutputKafkaSecretsPassword0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputKafkaSecretsPassword0 performs a merge with any union data inside the UpdateOutputKafka_Secrets_Password, using the provided UpdateOutputKafkaSecretsPassword0
func (t *UpdateOutputKafka_Secrets_Password) MergeUpdateOutputKafkaSecretsPassword0(v UpdateOutputKafkaSecretsPassword0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOutputKafkaSecretsPassword1 returns the union data inside the UpdateOutputKafka_Secrets_Password as a UpdateOutputKafkaSecretsPassword1
func (t UpdateOutputKafka_Secrets_Password) AsUpdateOutputKafkaSecretsPassword1() (UpdateOutputKafkaSecretsPassword1, error) {
	var body UpdateOutputKafkaSecretsPassword1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputKafkaSecretsPassword1 overwrites any union data inside the UpdateOutputKafka_Secrets_Password as the provided UpdateOutputKafkaSecretsPassword1
func (t *UpdateOutputKafka_Secrets_Password) FromUpdateOutputKafkaSecretsPassword1(v UpdateOutputKafkaSecretsPassword1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputKafkaSecretsPassword1 performs a merge with any union data inside the UpdateOutputKafka_Secrets_Password, using the provided UpdateOutputKafkaSecretsPassword1
func (t *UpdateOutputKafka_Secrets_Password) MergeUpdateOutputKafkaSecretsPassword1(v UpdateOutputKafkaSecretsPassword1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateOutputKafka_Secrets_Password) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateOutputKafka_Secrets_Password) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateOutputKafkaSecretsSslKey0 returns the union data inside the UpdateOutputKafka_Secrets_Ssl_Key as a UpdateOutputKafkaSecretsSslKey0
func (t UpdateOutputKafka_Secrets_Ssl_Key) AsUpdateOutputKafkaSecretsSslKey0() (UpdateOutputKafkaSecretsSslKey0, error) {
	var body UpdateOutputKafkaSecretsSslKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputKafkaSecretsSslKey0 overwrites any union data inside the UpdateOutputKafka_Secrets_Ssl_Key as the provided UpdateOutputKafkaSecretsSslKey0
func (t *UpdateOutputKafka_Secrets_Ssl_Key) FromUpdateOutputKafkaSecretsSslKey0(v UpdateOutputKafkaSecretsSslKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputKafkaSecretsSslKey0 performs a merge with any union data inside the UpdateOutputKafka_Secrets_Ssl_Key, using the provided UpdateOutputKafkaSecretsSslKey0
func (t *UpdateOutputKafka_Secrets_Ssl_Key) MergeUpdateOutputKafkaSecretsSslKey0(v UpdateOutputKafkaSecretsSslKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOutputKafkaSecretsSslKey1 returns the union data inside the UpdateOutputKafka_Secrets_Ssl_Key as a UpdateOutputKafkaSecretsSslKey1
func (t UpdateOutputKafka_Secrets_Ssl_Key) AsUpdateOutputKafkaSecretsSslKey1() (UpdateOutputKafkaSecretsSslKey1, error) {
	var body UpdateOutputKafkaSecretsSslKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputKafkaSecretsSslKey1 overwrites any union data inside the UpdateOutputKafka_Secrets_Ssl_Key as the provided UpdateOutputKafkaSecretsSslKey1
func (t *UpdateOutputKafka_Secrets_Ssl_Key) FromUpdateOutputKafkaSecretsSslKey1(v UpdateOutputKafkaSecretsSslKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputKafkaSecretsSslKey1 performs a merge with any union data inside the UpdateOutputKafka_Secrets_Ssl_Key, using the provided UpdateOutputKafkaSecretsSslKey1
func (t *UpdateOutputKafka_Secrets_Ssl_Key) MergeUpdateOutputKafkaSecretsSslKey1(v UpdateOutputKafkaSecretsSslKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateOutputKafka_Secrets_Ssl_Key) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateOutputKafka_Secrets_Ssl_Key) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateOutputLogstashSecretsSslKey0 returns the union data inside the UpdateOutputLogstash_Secrets_Ssl_Key as a UpdateOutputLogstashSecretsSslKey0
func (t UpdateOutputLogstash_Secrets_Ssl_Key) AsUpdateOutputLogstashSecretsSslKey0() (UpdateOutputLogstashSecretsSslKey0, error) {
	var body UpdateOutputLogstashSecretsSslKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputLogstashSecretsSslKey0 overwrites any union data inside the UpdateOutputLogstash_Secrets_Ssl_Key as the provided UpdateOutputLogstashSecretsSslKey0
func (t *UpdateOutputLogstash_Secrets_Ssl_Key) FromUpdateOutputLogstashSecretsSslKey0(v UpdateOutputLogstashSecretsSslKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputLogstashSecretsSslKey0 performs a merge with any union data inside the UpdateOutputLogstash_Secrets_Ssl_Key, using the provided UpdateOutputLogstashSecretsSslKey0
func (t *UpdateOutputLogstash_Secrets_Ssl_Key) MergeUpdateOutputLogstashSecretsSslKey0(v UpdateOutputLogstashSecretsSslKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOutputLogstashSecretsSslKey1 returns the union data inside the UpdateOutputLogstash_Secrets_Ssl_Key as a UpdateOutputLogstashSecretsSslKey1
func (t UpdateOutputLogstash_Secrets_Ssl_Key) AsUpdateOutputLogstashSecretsSslKey1() (UpdateOutputLogstashSecretsSslKey1, error) {
	var body UpdateOutputLogstashSecretsSslKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputLogstashSecretsSslKey1 overwrites any union data inside the UpdateOutputLogstash_Secrets_Ssl_Key as the provided UpdateOutputLogstashSecretsSslKey1
func (t *UpdateOutputLogstash_Secrets_Ssl_Key) FromUpdateOutputLogstashSecretsSslKey1(v UpdateOutputLogstashSecretsSslKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputLogstashSecretsSslKey1 performs a merge with any union data inside the UpdateOutputLogstash_Secrets_Ssl_Key, using the provided UpdateOutputLogstashSecretsSslKey1
func (t *UpdateOutputLogstash_Secrets_Ssl_Key) MergeUpdateOutputLogstashSecretsSslKey1(v UpdateOutputLogstashSecretsSslKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateOutputLogstash_Secrets_Ssl_Key) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateOutputLogstash_Secrets_Ssl_Key) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateOutputRemoteElasticsearchSecretsServiceToken0 returns the union data inside the UpdateOutputRemoteElasticsearch_Secrets_ServiceToken as a UpdateOutputRemoteElasticsearchSecretsServiceToken0
func (t UpdateOutputRemoteElasticsearch_Secrets_ServiceToken) AsUpdateOutputRemoteElasticsearchSecretsServiceToken0() (UpdateOutputRemoteElasticsearchSecretsServiceToken0, error) {
	var body UpdateOutputRemoteElasticsearchSecretsServiceToken0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputRemoteElasticsearchSecretsServiceToken0 overwrites any union data inside the UpdateOutputRemoteElasticsearch_Secrets_ServiceToken as the provided UpdateOutputRemoteElasticsearchSecretsServiceToken0
func (t *UpdateOutputRemoteElasticsearch_Secrets_ServiceToken) FromUpdateOutputRemoteElasticsearchSecretsServiceToken0(v UpdateOutputRemoteElasticsearchSecretsServiceToken0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputRemoteElasticsearchSecretsServiceToken0 performs a merge with any union data inside the UpdateOutputRemoteElasticsearch_Secrets_ServiceToken, using the provided UpdateOutputRemoteElasticsearchSecretsServiceToken0
func (t *UpdateOutputRemoteElasticsearch_Secrets_ServiceToken) MergeUpdateOutputRemoteElasticsearchSecretsServiceToken0(v UpdateOutputRemoteElasticsearchSecretsServiceToken0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOutputRemoteElasticsearchSecretsServiceToken1 returns the union data inside the UpdateOutputRemoteElasticsearch_Secrets_ServiceToken as a UpdateOutputRemoteElasticsearchSecretsServiceToken1
func (t UpdateOutputRemoteElasticsearch_Secrets_ServiceToken) AsUpdateOutputRemoteElasticsearchSecretsServiceToken1() (UpdateOutputRemoteElasticsearchSecretsServiceToken1, error) {
	var body UpdateOutputRemoteElasticsearchSecretsServiceToken1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputRemoteElasticsearchSecretsServiceToken1 overwrites any union data inside the UpdateOutputRemoteElasticsearch_Secrets_ServiceToken as the provided UpdateOutputRemoteElasticsearchSecretsServiceToken1
func (t *UpdateOutputRemoteElasticsearch_Secrets_ServiceToken) FromUpdateOutputRemoteElasticsearchSecretsServiceToken1(v UpdateOutputRemoteElasticsearchSecretsServiceToken1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputRemoteElasticsearchSecretsServiceToken1 performs a merge with any union data inside the UpdateOutputRemoteElasticsearch_Secrets_ServiceToken, using the provided UpdateOutputRemoteElasticsearchSecretsServiceToken1
func (t *UpdateOutputRemoteElasticsearch_Secrets_ServiceToken) MergeUpdateOutputRemoteElasticsearchSecretsServiceToken1(v UpdateOutputRemoteElasticsearchSecretsServiceToken1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateOutputRemoteElasticsearch_Secrets_ServiceToken) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateOutputRemoteElasticsearch_Secrets_ServiceToken) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateOutputElasticsearch returns the union data inside the UpdateOutputUnion as a UpdateOutputElasticsearch
func (t UpdateOutputUnion) AsUpdateOutputElasticsearch() (UpdateOutputElasticsearch, error) {
	var body UpdateOutputElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputElasticsearch overwrites any union data inside the UpdateOutputUnion as the provided UpdateOutputElasticsearch
func (t *UpdateOutputUnion) FromUpdateOutputElasticsearch(v UpdateOutputElasticsearch) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputElasticsearch performs a merge with any union data inside the UpdateOutputUnion, using the provided UpdateOutputElasticsearch
func (t *UpdateOutputUnion) MergeUpdateOutputElasticsearch(v UpdateOutputElasticsearch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOutputRemoteElasticsearch returns the union data inside the UpdateOutputUnion as a UpdateOutputRemoteElasticsearch
func (t UpdateOutputUnion) AsUpdateOutputRemoteElasticsearch() (UpdateOutputRemoteElasticsearch, error) {
	var body UpdateOutputRemoteElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputRemoteElasticsearch overwrites any union data inside the UpdateOutputUnion as the provided UpdateOutputRemoteElasticsearch
func (t *UpdateOutputUnion) FromUpdateOutputRemoteElasticsearch(v UpdateOutputRemoteElasticsearch) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputRemoteElasticsearch performs a merge with any union data inside the UpdateOutputUnion, using the provided UpdateOutputRemoteElasticsearch
func (t *UpdateOutputUnion) MergeUpdateOutputRemoteElasticsearch(v UpdateOutputRemoteElasticsearch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOutputLogstash returns the union data inside the UpdateOutputUnion as a UpdateOutputLogstash
func (t UpdateOutputUnion) AsUpdateOutputLogstash() (UpdateOutputLogstash, error) {
	var body UpdateOutputLogstash
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputLogstash overwrites any union data inside the UpdateOutputUnion as the provided UpdateOutputLogstash
func (t *UpdateOutputUnion) FromUpdateOutputLogstash(v UpdateOutputLogstash) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputLogstash performs a merge with any union data inside the UpdateOutputUnion, using the provided UpdateOutputLogstash
func (t *UpdateOutputUnion) MergeUpdateOutputLogstash(v UpdateOutputLogstash) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOutputKafka returns the union data inside the UpdateOutputUnion as a UpdateOutputKafka
func (t UpdateOutputUnion) AsUpdateOutputKafka() (UpdateOutputKafka, error) {
	var body UpdateOutputKafka
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputKafka overwrites any union data inside the UpdateOutputUnion as the provided UpdateOutputKafka
func (t *UpdateOutputUnion) FromUpdateOutputKafka(v UpdateOutputKafka) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputKafka performs a merge with any union data inside the UpdateOutputUnion, using the provided UpdateOutputKafka
func (t *UpdateOutputUnion) MergeUpdateOutputKafka(v UpdateOutputKafka) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateOutputUnion) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateOutputUnion) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAgentPolicies request
	GetAgentPolicies(ctx context.Context, params *GetAgentPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAgentPolicyWithBody request with any body
	CreateAgentPolicyWithBody(ctx context.Context, params *CreateAgentPolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAgentPolicy(ctx context.Context, params *CreateAgentPolicyParams, body CreateAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAgentPolicyWithBody request with any body
	DeleteAgentPolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteAgentPolicy(ctx context.Context, body DeleteAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAgentPolicy request
	GetAgentPolicy(ctx context.Context, agentPolicyId string, params *GetAgentPolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAgentPolicyWithBody request with any body
	UpdateAgentPolicyWithBody(ctx context.Context, agentPolicyId string, params *UpdateAgentPolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAgentPolicy(ctx context.Context, agentPolicyId string, params *UpdateAgentPolicyParams, body UpdateAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEnrollmentApiKeys request
	GetEnrollmentApiKeys(ctx context.Context, params *GetEnrollmentApiKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPackages request
	ListPackages(ctx context.Context, params *ListPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallPackageByUploadWithBody request with any body
	InstallPackageByUploadWithBody(ctx context.Context, params *InstallPackageByUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePackageWithBody request with any body
	DeletePackageWithBody(ctx context.Context, pkgName string, pkgVersion string, params *DeletePackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeletePackage(ctx context.Context, pkgName string, pkgVersion string, params *DeletePackageParams, body DeletePackageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPackage request
	GetPackage(ctx context.Context, pkgName string, pkgVersion string, params *GetPackageParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InstallPackageWithBody request with any body
	InstallPackageWithBody(ctx context.Context, pkgName string, pkgVersion string, params *InstallPackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InstallPackage(ctx context.Context, pkgName string, pkgVersion string, params *InstallPackageParams, body InstallPackageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFleetServerHosts request
	GetFleetServerHosts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFleetServerHostWithBody request with any body
	CreateFleetServerHostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFleetServerHost(ctx context.Context, body CreateFleetServerHostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFleetServerHost request
	DeleteFleetServerHost(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFleetServerHost request
	GetFleetServerHost(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFleetServerHostWithBody request with any body
	UpdateFleetServerHostWithBody(ctx context.Context, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFleetServerHost(ctx context.Context, itemId string, body UpdateFleetServerHostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOutputs request
	GetOutputs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOutputWithBody request with any body
	CreateOutputWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOutput(ctx context.Context, body CreateOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOutput request
	DeleteOutput(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOutput request
	GetOutput(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOutputWithBody request with any body
	UpdateOutputWithBody(ctx context.Context, outputId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOutput(ctx context.Context, outputId string, body UpdateOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPackagePolicies request
	GetPackagePolicies(ctx context.Context, params *GetPackagePoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreatePackagePolicyWithBody request with any body
	CreatePackagePolicyWithBody(ctx context.Context, params *CreatePackagePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreatePackagePolicy(ctx context.Context, params *CreatePackagePolicyParams, body CreatePackagePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePackagePolicy request
	DeletePackagePolicy(ctx context.Context, packagePolicyId string, params *DeletePackagePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPackagePolicy request
	GetPackagePolicy(ctx context.Context, packagePolicyId string, params *GetPackagePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePackagePolicyWithBody request with any body
	UpdatePackagePolicyWithBody(ctx context.Context, packagePolicyId string, params *UpdatePackagePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePackagePolicy(ctx context.Context, packagePolicyId string, params *UpdatePackagePolicyParams, body UpdatePackagePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAgentPolicies(ctx context.Context, params *GetAgentPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAgentPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAgentPolicyWithBody(ctx context.Context, params *CreateAgentPolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAgentPolicyRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAgentPolicy(ctx context.Context, params *CreateAgentPolicyParams, body CreateAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAgentPolicyRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAgentPolicyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAgentPolicyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAgentPolicy(ctx context.Context, body DeleteAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAgentPolicyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAgentPolicy(ctx context.Context, agentPolicyId string, params *GetAgentPolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAgentPolicyRequest(c.Server, agentPolicyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAgentPolicyWithBody(ctx context.Context, agentPolicyId string, params *UpdateAgentPolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAgentPolicyRequestWithBody(c.Server, agentPolicyId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAgentPolicy(ctx context.Context, agentPolicyId string, params *UpdateAgentPolicyParams, body UpdateAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAgentPolicyRequest(c.Server, agentPolicyId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEnrollmentApiKeys(ctx context.Context, params *GetEnrollmentApiKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEnrollmentApiKeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPackages(ctx context.Context, params *ListPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPackagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallPackageByUploadWithBody(ctx context.Context, params *InstallPackageByUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallPackageByUploadRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePackageWithBody(ctx context.Context, pkgName string, pkgVersion string, params *DeletePackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePackageRequestWithBody(c.Server, pkgName, pkgVersion, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePackage(ctx context.Context, pkgName string, pkgVersion string, params *DeletePackageParams, body DeletePackageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePackageRequest(c.Server, pkgName, pkgVersion, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPackage(ctx context.Context, pkgName string, pkgVersion string, params *GetPackageParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPackageRequest(c.Server, pkgName, pkgVersion, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallPackageWithBody(ctx context.Context, pkgName string, pkgVersion string, params *InstallPackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallPackageRequestWithBody(c.Server, pkgName, pkgVersion, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InstallPackage(ctx context.Context, pkgName string, pkgVersion string, params *InstallPackageParams, body InstallPackageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInstallPackageRequest(c.Server, pkgName, pkgVersion, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFleetServerHosts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetServerHostsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFleetServerHostWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFleetServerHostRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFleetServerHost(ctx context.Context, body CreateFleetServerHostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFleetServerHostRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFleetServerHost(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFleetServerHostRequest(c.Server, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFleetServerHost(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetServerHostRequest(c.Server, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFleetServerHostWithBody(ctx context.Context, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFleetServerHostRequestWithBody(c.Server, itemId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFleetServerHost(ctx context.Context, itemId string, body UpdateFleetServerHostJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFleetServerHostRequest(c.Server, itemId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOutputs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOutputsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOutputWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOutputRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOutput(ctx context.Context, body CreateOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOutputRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOutput(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOutputRequest(c.Server, outputId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOutput(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOutputRequest(c.Server, outputId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOutputWithBody(ctx context.Context, outputId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOutputRequestWithBody(c.Server, outputId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOutput(ctx context.Context, outputId string, body UpdateOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOutputRequest(c.Server, outputId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPackagePolicies(ctx context.Context, params *GetPackagePoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPackagePoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePackagePolicyWithBody(ctx context.Context, params *CreatePackagePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePackagePolicyRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreatePackagePolicy(ctx context.Context, params *CreatePackagePolicyParams, body CreatePackagePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreatePackagePolicyRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePackagePolicy(ctx context.Context, packagePolicyId string, params *DeletePackagePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePackagePolicyRequest(c.Server, packagePolicyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPackagePolicy(ctx context.Context, packagePolicyId string, params *GetPackagePolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPackagePolicyRequest(c.Server, packagePolicyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePackagePolicyWithBody(ctx context.Context, packagePolicyId string, params *UpdatePackagePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePackagePolicyRequestWithBody(c.Server, packagePolicyId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePackagePolicy(ctx context.Context, packagePolicyId string, params *UpdatePackagePolicyParams, body UpdatePackagePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePackagePolicyRequest(c.Server, packagePolicyId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAgentPoliciesRequest generates requests for GetAgentPolicies
func NewGetAgentPoliciesRequest(server string, params *GetAgentPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/agent_policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortField", runtime.ParamLocationQuery, *params.SortField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowUpgradeable != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "showUpgradeable", runtime.ParamLocationQuery, *params.ShowUpgradeable); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kuery != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kuery", runtime.ParamLocationQuery, *params.Kuery); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NoAgentCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "noAgentCount", runtime.ParamLocationQuery, *params.NoAgentCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithAgentCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withAgentCount", runtime.ParamLocationQuery, *params.WithAgentCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Full != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full", runtime.ParamLocationQuery, *params.Full); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAgentPolicyRequest calls the generic CreateAgentPolicy builder with application/json body
func NewCreateAgentPolicyRequest(server string, params *CreateAgentPolicyParams, body CreateAgentPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAgentPolicyRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateAgentPolicyRequestWithBody generates requests for CreateAgentPolicy with any type of body
func NewCreateAgentPolicyRequestWithBody(server string, params *CreateAgentPolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/agent_policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SysMonitoring != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sys_monitoring", runtime.ParamLocationQuery, *params.SysMonitoring); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAgentPolicyRequest calls the generic DeleteAgentPolicy builder with application/json body
func NewDeleteAgentPolicyRequest(server string, body DeleteAgentPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteAgentPolicyRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteAgentPolicyRequestWithBody generates requests for DeleteAgentPolicy with any type of body
func NewDeleteAgentPolicyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/agent_policies/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAgentPolicyRequest generates requests for GetAgentPolicy
func NewGetAgentPolicyRequest(server string, agentPolicyId string, params *GetAgentPolicyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agentPolicyId", runtime.ParamLocationPath, agentPolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/agent_policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAgentPolicyRequest calls the generic UpdateAgentPolicy builder with application/json body
func NewUpdateAgentPolicyRequest(server string, agentPolicyId string, params *UpdateAgentPolicyParams, body UpdateAgentPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAgentPolicyRequestWithBody(server, agentPolicyId, params, "application/json", bodyReader)
}

// NewUpdateAgentPolicyRequestWithBody generates requests for UpdateAgentPolicy with any type of body
func NewUpdateAgentPolicyRequestWithBody(server string, agentPolicyId string, params *UpdateAgentPolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agentPolicyId", runtime.ParamLocationPath, agentPolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/agent_policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEnrollmentApiKeysRequest generates requests for GetEnrollmentApiKeys
func NewGetEnrollmentApiKeysRequest(server string, params *GetEnrollmentApiKeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/enrollment_api_keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kuery != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kuery", runtime.ParamLocationQuery, *params.Kuery); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPackagesRequest generates requests for ListPackages
func NewListPackagesRequest(server string, params *ListPackagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/epm/packages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Category != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category", runtime.ParamLocationQuery, *params.Category); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Prerelease != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prerelease", runtime.ParamLocationQuery, *params.Prerelease); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Experimental != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "experimental", runtime.ParamLocationQuery, *params.Experimental); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeInstallStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeInstallStatus", runtime.ParamLocationQuery, *params.ExcludeInstallStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInstallPackageByUploadRequestWithBody generates requests for InstallPackageByUpload with any type of body
func NewInstallPackageByUploadRequestWithBody(server string, params *InstallPackageByUploadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/epm/packages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IgnoreMappingUpdateErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignoreMappingUpdateErrors", runtime.ParamLocationQuery, *params.IgnoreMappingUpdateErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipDataStreamRollover != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipDataStreamRollover", runtime.ParamLocationQuery, *params.SkipDataStreamRollover); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePackageRequest calls the generic DeletePackage builder with application/json body
func NewDeletePackageRequest(server string, pkgName string, pkgVersion string, params *DeletePackageParams, body DeletePackageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeletePackageRequestWithBody(server, pkgName, pkgVersion, params, "application/json", bodyReader)
}

// NewDeletePackageRequestWithBody generates requests for DeletePackage with any type of body
func NewDeletePackageRequestWithBody(server string, pkgName string, pkgVersion string, params *DeletePackageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pkgName", runtime.ParamLocationPath, pkgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pkgVersion", runtime.ParamLocationPath, pkgVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/epm/packages/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPackageRequest generates requests for GetPackage
func NewGetPackageRequest(server string, pkgName string, pkgVersion string, params *GetPackageParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pkgName", runtime.ParamLocationPath, pkgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pkgVersion", runtime.ParamLocationPath, pkgVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/epm/packages/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IgnoreUnverified != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignoreUnverified", runtime.ParamLocationQuery, *params.IgnoreUnverified); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Prerelease != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prerelease", runtime.ParamLocationQuery, *params.Prerelease); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Full != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full", runtime.ParamLocationQuery, *params.Full); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithMetadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withMetadata", runtime.ParamLocationQuery, *params.WithMetadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInstallPackageRequest calls the generic InstallPackage builder with application/json body
func NewInstallPackageRequest(server string, pkgName string, pkgVersion string, params *InstallPackageParams, body InstallPackageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInstallPackageRequestWithBody(server, pkgName, pkgVersion, params, "application/json", bodyReader)
}

// NewInstallPackageRequestWithBody generates requests for InstallPackage with any type of body
func NewInstallPackageRequestWithBody(server string, pkgName string, pkgVersion string, params *InstallPackageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pkgName", runtime.ParamLocationPath, pkgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pkgVersion", runtime.ParamLocationPath, pkgVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/epm/packages/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Prerelease != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prerelease", runtime.ParamLocationQuery, *params.Prerelease); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IgnoreMappingUpdateErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignoreMappingUpdateErrors", runtime.ParamLocationQuery, *params.IgnoreMappingUpdateErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipDataStreamRollover != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipDataStreamRollover", runtime.ParamLocationQuery, *params.SkipDataStreamRollover); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFleetServerHostsRequest generates requests for GetFleetServerHosts
func NewGetFleetServerHostsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/fleet_server_hosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFleetServerHostRequest calls the generic CreateFleetServerHost builder with application/json body
func NewCreateFleetServerHostRequest(server string, body CreateFleetServerHostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFleetServerHostRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateFleetServerHostRequestWithBody generates requests for CreateFleetServerHost with any type of body
func NewCreateFleetServerHostRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/fleet_server_hosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFleetServerHostRequest generates requests for DeleteFleetServerHost
func NewDeleteFleetServerHostRequest(server string, itemId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/fleet_server_hosts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFleetServerHostRequest generates requests for GetFleetServerHost
func NewGetFleetServerHostRequest(server string, itemId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/fleet_server_hosts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFleetServerHostRequest calls the generic UpdateFleetServerHost builder with application/json body
func NewUpdateFleetServerHostRequest(server string, itemId string, body UpdateFleetServerHostJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFleetServerHostRequestWithBody(server, itemId, "application/json", bodyReader)
}

// NewUpdateFleetServerHostRequestWithBody generates requests for UpdateFleetServerHost with any type of body
func NewUpdateFleetServerHostRequestWithBody(server string, itemId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/fleet_server_hosts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOutputsRequest generates requests for GetOutputs
func NewGetOutputsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/outputs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOutputRequest calls the generic CreateOutput builder with application/json body
func NewCreateOutputRequest(server string, body CreateOutputJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOutputRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateOutputRequestWithBody generates requests for CreateOutput with any type of body
func NewCreateOutputRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/outputs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOutputRequest generates requests for DeleteOutput
func NewDeleteOutputRequest(server string, outputId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "outputId", runtime.ParamLocationPath, outputId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/outputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOutputRequest generates requests for GetOutput
func NewGetOutputRequest(server string, outputId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "outputId", runtime.ParamLocationPath, outputId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/outputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOutputRequest calls the generic UpdateOutput builder with application/json body
func NewUpdateOutputRequest(server string, outputId string, body UpdateOutputJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOutputRequestWithBody(server, outputId, "application/json", bodyReader)
}

// NewUpdateOutputRequestWithBody generates requests for UpdateOutput with any type of body
func NewUpdateOutputRequestWithBody(server string, outputId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "outputId", runtime.ParamLocationPath, outputId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/outputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPackagePoliciesRequest generates requests for GetPackagePolicies
func NewGetPackagePoliciesRequest(server string, params *GetPackagePoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/package_policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortField", runtime.ParamLocationQuery, *params.SortField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowUpgradeable != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "showUpgradeable", runtime.ParamLocationQuery, *params.ShowUpgradeable); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kuery != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kuery", runtime.ParamLocationQuery, *params.Kuery); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithAgentCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withAgentCount", runtime.ParamLocationQuery, *params.WithAgentCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreatePackagePolicyRequest calls the generic CreatePackagePolicy builder with application/json body
func NewCreatePackagePolicyRequest(server string, params *CreatePackagePolicyParams, body CreatePackagePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreatePackagePolicyRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreatePackagePolicyRequestWithBody generates requests for CreatePackagePolicy with any type of body
func NewCreatePackagePolicyRequestWithBody(server string, params *CreatePackagePolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/package_policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePackagePolicyRequest generates requests for DeletePackagePolicy
func NewDeletePackagePolicyRequest(server string, packagePolicyId string, params *DeletePackagePolicyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "packagePolicyId", runtime.ParamLocationPath, packagePolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/package_policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPackagePolicyRequest generates requests for GetPackagePolicy
func NewGetPackagePolicyRequest(server string, packagePolicyId string, params *GetPackagePolicyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "packagePolicyId", runtime.ParamLocationPath, packagePolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/package_policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePackagePolicyRequest calls the generic UpdatePackagePolicy builder with application/json body
func NewUpdatePackagePolicyRequest(server string, packagePolicyId string, params *UpdatePackagePolicyParams, body UpdatePackagePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePackagePolicyRequestWithBody(server, packagePolicyId, params, "application/json", bodyReader)
}

// NewUpdatePackagePolicyRequestWithBody generates requests for UpdatePackagePolicy with any type of body
func NewUpdatePackagePolicyRequestWithBody(server string, packagePolicyId string, params *UpdatePackagePolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "packagePolicyId", runtime.ParamLocationPath, packagePolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/package_policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAgentPoliciesWithResponse request
	GetAgentPoliciesWithResponse(ctx context.Context, params *GetAgentPoliciesParams, reqEditors ...RequestEditorFn) (*GetAgentPoliciesResponse, error)

	// CreateAgentPolicyWithBodyWithResponse request with any body
	CreateAgentPolicyWithBodyWithResponse(ctx context.Context, params *CreateAgentPolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAgentPolicyResponse, error)

	CreateAgentPolicyWithResponse(ctx context.Context, params *CreateAgentPolicyParams, body CreateAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAgentPolicyResponse, error)

	// DeleteAgentPolicyWithBodyWithResponse request with any body
	DeleteAgentPolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteAgentPolicyResponse, error)

	DeleteAgentPolicyWithResponse(ctx context.Context, body DeleteAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteAgentPolicyResponse, error)

	// GetAgentPolicyWithResponse request
	GetAgentPolicyWithResponse(ctx context.Context, agentPolicyId string, params *GetAgentPolicyParams, reqEditors ...RequestEditorFn) (*GetAgentPolicyResponse, error)

	// UpdateAgentPolicyWithBodyWithResponse request with any body
	UpdateAgentPolicyWithBodyWithResponse(ctx context.Context, agentPolicyId string, params *UpdateAgentPolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAgentPolicyResponse, error)

	UpdateAgentPolicyWithResponse(ctx context.Context, agentPolicyId string, params *UpdateAgentPolicyParams, body UpdateAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAgentPolicyResponse, error)

	// GetEnrollmentApiKeysWithResponse request
	GetEnrollmentApiKeysWithResponse(ctx context.Context, params *GetEnrollmentApiKeysParams, reqEditors ...RequestEditorFn) (*GetEnrollmentApiKeysResponse, error)

	// ListPackagesWithResponse request
	ListPackagesWithResponse(ctx context.Context, params *ListPackagesParams, reqEditors ...RequestEditorFn) (*ListPackagesResponse, error)

	// InstallPackageByUploadWithBodyWithResponse request with any body
	InstallPackageByUploadWithBodyWithResponse(ctx context.Context, params *InstallPackageByUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallPackageByUploadResponse, error)

	// DeletePackageWithBodyWithResponse request with any body
	DeletePackageWithBodyWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *DeletePackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePackageResponse, error)

	DeletePackageWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *DeletePackageParams, body DeletePackageJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePackageResponse, error)

	// GetPackageWithResponse request
	GetPackageWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *GetPackageParams, reqEditors ...RequestEditorFn) (*GetPackageResponse, error)

	// InstallPackageWithBodyWithResponse request with any body
	InstallPackageWithBodyWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *InstallPackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallPackageResponse, error)

	InstallPackageWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *InstallPackageParams, body InstallPackageJSONRequestBody, reqEditors ...RequestEditorFn) (*InstallPackageResponse, error)

	// GetFleetServerHostsWithResponse request
	GetFleetServerHostsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFleetServerHostsResponse, error)

	// CreateFleetServerHostWithBodyWithResponse request with any body
	CreateFleetServerHostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFleetServerHostResponse, error)

	CreateFleetServerHostWithResponse(ctx context.Context, body CreateFleetServerHostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFleetServerHostResponse, error)

	// DeleteFleetServerHostWithResponse request
	DeleteFleetServerHostWithResponse(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*DeleteFleetServerHostResponse, error)

	// GetFleetServerHostWithResponse request
	GetFleetServerHostWithResponse(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*GetFleetServerHostResponse, error)

	// UpdateFleetServerHostWithBodyWithResponse request with any body
	UpdateFleetServerHostWithBodyWithResponse(ctx context.Context, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFleetServerHostResponse, error)

	UpdateFleetServerHostWithResponse(ctx context.Context, itemId string, body UpdateFleetServerHostJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFleetServerHostResponse, error)

	// GetOutputsWithResponse request
	GetOutputsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOutputsResponse, error)

	// CreateOutputWithBodyWithResponse request with any body
	CreateOutputWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOutputResponse, error)

	CreateOutputWithResponse(ctx context.Context, body CreateOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOutputResponse, error)

	// DeleteOutputWithResponse request
	DeleteOutputWithResponse(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*DeleteOutputResponse, error)

	// GetOutputWithResponse request
	GetOutputWithResponse(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*GetOutputResponse, error)

	// UpdateOutputWithBodyWithResponse request with any body
	UpdateOutputWithBodyWithResponse(ctx context.Context, outputId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOutputResponse, error)

	UpdateOutputWithResponse(ctx context.Context, outputId string, body UpdateOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOutputResponse, error)

	// GetPackagePoliciesWithResponse request
	GetPackagePoliciesWithResponse(ctx context.Context, params *GetPackagePoliciesParams, reqEditors ...RequestEditorFn) (*GetPackagePoliciesResponse, error)

	// CreatePackagePolicyWithBodyWithResponse request with any body
	CreatePackagePolicyWithBodyWithResponse(ctx context.Context, params *CreatePackagePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePackagePolicyResponse, error)

	CreatePackagePolicyWithResponse(ctx context.Context, params *CreatePackagePolicyParams, body CreatePackagePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePackagePolicyResponse, error)

	// DeletePackagePolicyWithResponse request
	DeletePackagePolicyWithResponse(ctx context.Context, packagePolicyId string, params *DeletePackagePolicyParams, reqEditors ...RequestEditorFn) (*DeletePackagePolicyResponse, error)

	// GetPackagePolicyWithResponse request
	GetPackagePolicyWithResponse(ctx context.Context, packagePolicyId string, params *GetPackagePolicyParams, reqEditors ...RequestEditorFn) (*GetPackagePolicyResponse, error)

	// UpdatePackagePolicyWithBodyWithResponse request with any body
	UpdatePackagePolicyWithBodyWithResponse(ctx context.Context, packagePolicyId string, params *UpdatePackagePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePackagePolicyResponse, error)

	UpdatePackagePolicyWithResponse(ctx context.Context, packagePolicyId string, params *UpdatePackagePolicyParams, body UpdatePackagePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePackagePolicyResponse, error)
}

type GetAgentPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items   []AgentPolicy `json:"items"`
		Page    float32       `json:"page"`
		PerPage float32       `json:"perPage"`
		Total   float32       `json:"total"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAgentPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAgentPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAgentPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item AgentPolicy `json:"item"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateAgentPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAgentPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAgentPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id   string `json:"id"`
		Name string `json:"name"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteAgentPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAgentPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAgentPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item AgentPolicy `json:"item"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAgentPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAgentPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAgentPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item AgentPolicy `json:"item"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateAgentPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAgentPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEnrollmentApiKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items []EnrollmentApiKey `json:"items"`
		// Deprecated:
		List []struct {
			// Active When false, the enrollment API key is revoked and cannot be used for enrolling Elastic Agents.
			Active bool `json:"active"`

			// ApiKey The enrollment API key (token) used for enrolling Elastic Agents.
			ApiKey string `json:"api_key"`

			// ApiKeyId The ID of the API key in the Security API.
			ApiKeyId  string `json:"api_key_id"`
			CreatedAt string `json:"created_at"`
			Id        string `json:"id"`

			// Name The name of the enrollment API key.
			Name *string `json:"name,omitempty"`

			// PolicyId The ID of the agent policy the Elastic Agent will be enrolled in.
			PolicyId *string `json:"policy_id,omitempty"`
		} `json:"list"`
		Page    float32 `json:"page"`
		PerPage float32 `json:"perPage"`
		Total   float32 `json:"total"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetEnrollmentApiKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEnrollmentApiKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPackagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items    []PackageListItem                 `json:"items"`
		Response *[]ListPackages_200_Response_Item `json:"response,omitempty"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}
type ListPackages_200_Response_Conditions_Elastic struct {
	Capabilities         *[]string              `json:"capabilities,omitempty"`
	Subscription         *string                `json:"subscription,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type ListPackages_200_Response_Conditions_Kibana struct {
	Version              *string                `json:"version,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type ListPackages_200_Response_Conditions struct {
	Elastic              *ListPackages_200_Response_Conditions_Elastic `json:"elastic,omitempty"`
	Kibana               *ListPackages_200_Response_Conditions_Kibana  `json:"kibana,omitempty"`
	AdditionalProperties map[string]interface{}                        `json:"-"`
}
type ListPackages_200_Response_Discovery_Fields_Item struct {
	Name                 string                 `json:"name"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type ListPackages_200_Response_Discovery struct {
	Fields               *[]ListPackages_200_Response_Discovery_Fields_Item `json:"fields,omitempty"`
	AdditionalProperties map[string]interface{}                             `json:"-"`
}
type ListPackages_200_Response_Icons_Item struct {
	DarkMode             *bool                  `json:"dark_mode,omitempty"`
	Path                 *string                `json:"path,omitempty"`
	Size                 *string                `json:"size,omitempty"`
	Src                  string                 `json:"src"`
	Title                *string                `json:"title,omitempty"`
	Type                 *string                `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type ListPackages200ResponseInstallationInfoAdditionalSpacesInstalledKibanaType string
type ListPackages_200_Response_InstallationInfo_AdditionalSpacesInstalledKibana_Item struct {
	Id                   string                                                                     `json:"id"`
	OriginId             *string                                                                    `json:"originId,omitempty"`
	Type                 ListPackages200ResponseInstallationInfoAdditionalSpacesInstalledKibanaType `json:"type"`
	AdditionalProperties map[string]interface{}                                                     `json:"-"`
}
type ListPackages_200_Response_InstallationInfo_ExperimentalDataStreamFeatures_Features struct {
	DocValueOnlyNumeric  *bool                  `json:"doc_value_only_numeric,omitempty"`
	DocValueOnlyOther    *bool                  `json:"doc_value_only_other,omitempty"`
	SyntheticSource      *bool                  `json:"synthetic_source,omitempty"`
	Tsdb                 *bool                  `json:"tsdb,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type ListPackages_200_Response_InstallationInfo_ExperimentalDataStreamFeatures_Item struct {
	DataStream           string                                                                             `json:"data_stream"`
	Features             ListPackages_200_Response_InstallationInfo_ExperimentalDataStreamFeatures_Features `json:"features"`
	AdditionalProperties map[string]interface{}                                                             `json:"-"`
}
type ListPackages200ResponseInstallationInfoInstallSource string
type ListPackages200ResponseInstallationInfoInstallStatus string
type ListPackages200ResponseInstallationInfoInstalledEsType string
type ListPackages_200_Response_InstallationInfo_InstalledEs_Item struct {
	Deferred             *bool                                                  `json:"deferred,omitempty"`
	Id                   string                                                 `json:"id"`
	Type                 ListPackages200ResponseInstallationInfoInstalledEsType `json:"type"`
	Version              *string                                                `json:"version,omitempty"`
	AdditionalProperties map[string]interface{}                                 `json:"-"`
}
type ListPackages200ResponseInstallationInfoInstalledKibanaType string
type ListPackages_200_Response_InstallationInfo_InstalledKibana_Item struct {
	Id                   string                                                     `json:"id"`
	OriginId             *string                                                    `json:"originId,omitempty"`
	Type                 ListPackages200ResponseInstallationInfoInstalledKibanaType `json:"type"`
	AdditionalProperties map[string]interface{}                                     `json:"-"`
}
type ListPackages_200_Response_InstallationInfo_LatestExecutedState struct {
	Error                *string                `json:"error,omitempty"`
	Name                 string                 `json:"name"`
	StartedAt            string                 `json:"started_at"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type ListPackages_200_Response_InstallationInfo_LatestInstallFailedAttempts_Error struct {
	Message              string                 `json:"message"`
	Name                 string                 `json:"name"`
	Stack                *string                `json:"stack,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type ListPackages_200_Response_InstallationInfo_LatestInstallFailedAttempts_Item struct {
	CreatedAt            string                                                                       `json:"created_at"`
	Error                ListPackages_200_Response_InstallationInfo_LatestInstallFailedAttempts_Error `json:"error"`
	TargetVersion        string                                                                       `json:"target_version"`
	AdditionalProperties map[string]interface{}                                                       `json:"-"`
}
type ListPackages200ResponseInstallationInfoVerificationStatus string
type ListPackages_200_Response_InstallationInfo struct {
	AdditionalSpacesInstalledKibana *map[string][]ListPackages_200_Response_InstallationInfo_AdditionalSpacesInstalledKibana_Item `json:"additional_spaces_installed_kibana,omitempty"`
	CreatedAt                       *string                                                                                       `json:"created_at,omitempty"`
	ExperimentalDataStreamFeatures  *[]ListPackages_200_Response_InstallationInfo_ExperimentalDataStreamFeatures_Item             `json:"experimental_data_stream_features,omitempty"`
	InstallFormatSchemaVersion      *string                                                                                       `json:"install_format_schema_version,omitempty"`
	InstallSource                   ListPackages200ResponseInstallationInfoInstallSource                                          `json:"install_source"`
	InstallStatus                   ListPackages200ResponseInstallationInfoInstallStatus                                          `json:"install_status"`
	InstalledEs                     []ListPackages_200_Response_InstallationInfo_InstalledEs_Item                                 `json:"installed_es"`
	InstalledKibana                 []ListPackages_200_Response_InstallationInfo_InstalledKibana_Item                             `json:"installed_kibana"`
	InstalledKibanaSpaceId          *string                                                                                       `json:"installed_kibana_space_id,omitempty"`
	LatestExecutedState             *ListPackages_200_Response_InstallationInfo_LatestExecutedState                               `json:"latest_executed_state,omitempty"`
	LatestInstallFailedAttempts     *[]ListPackages_200_Response_InstallationInfo_LatestInstallFailedAttempts_Item                `json:"latest_install_failed_attempts,omitempty"`
	Name                            string                                                                                        `json:"name"`
	Namespaces                      *[]string                                                                                     `json:"namespaces,omitempty"`
	Type                            string                                                                                        `json:"type"`
	UpdatedAt                       *string                                                                                       `json:"updated_at,omitempty"`
	VerificationKeyId               *string                                                                                       `json:"verification_key_id"`
	VerificationStatus              ListPackages200ResponseInstallationInfoVerificationStatus                                     `json:"verification_status"`
	Version                         string                                                                                        `json:"version"`
	AdditionalProperties            map[string]interface{}                                                                        `json:"-"`
}
type ListPackages200ResponseOwnerType string
type ListPackages_200_Response_Owner struct {
	Github               *string                           `json:"github,omitempty"`
	Type                 *ListPackages200ResponseOwnerType `json:"type,omitempty"`
	AdditionalProperties map[string]interface{}            `json:"-"`
}
type ListPackages200ResponseRelease string
type ListPackages_200_Response_Source struct {
	License              string                 `json:"license"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type ListPackages200ResponseType string
type ListPackages_200_Response_Item struct {
	Categories           *[]string                                   `json:"categories,omitempty"`
	Conditions           *ListPackages_200_Response_Conditions       `json:"conditions,omitempty"`
	DataStreams          *[]map[string]interface{}                   `json:"data_streams,omitempty"`
	Description          *string                                     `json:"description,omitempty"`
	Discovery            *ListPackages_200_Response_Discovery        `json:"discovery,omitempty"`
	Download             *string                                     `json:"download,omitempty"`
	FormatVersion        *string                                     `json:"format_version,omitempty"`
	Icons                *[]ListPackages_200_Response_Icons_Item     `json:"icons,omitempty"`
	Id                   string                                      `json:"id"`
	InstallationInfo     *ListPackages_200_Response_InstallationInfo `json:"installationInfo,omitempty"`
	Integration          *string                                     `json:"integration,omitempty"`
	Internal             *bool                                       `json:"internal,omitempty"`
	LatestVersion        *string                                     `json:"latestVersion,omitempty"`
	Name                 string                                      `json:"name"`
	Owner                *ListPackages_200_Response_Owner            `json:"owner,omitempty"`
	Path                 *string                                     `json:"path,omitempty"`
	PolicyTemplates      *[]map[string]interface{}                   `json:"policy_templates,omitempty"`
	Readme               *string                                     `json:"readme,omitempty"`
	Release              *ListPackages200ResponseRelease             `json:"release,omitempty"`
	SavedObject          interface{}                                 `json:"savedObject"`
	SignaturePath        *string                                     `json:"signature_path,omitempty"`
	Source               *ListPackages_200_Response_Source           `json:"source,omitempty"`
	Status               *string                                     `json:"status,omitempty"`
	Title                string                                      `json:"title"`
	Type                 *ListPackages200ResponseType                `json:"type,omitempty"`
	Vars                 *[]map[string]interface{}                   `json:"vars,omitempty"`
	Version              string                                      `json:"version"`
	AdditionalProperties map[string]interface{}                      `json:"-"`
}

// Status returns HTTPResponse.Status
func (r ListPackagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPackagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallPackageByUploadResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InstallPackageByUploadResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallPackageByUploadResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items []DeletePackage_200_Items_Item `json:"items"`
		// Deprecated:
		Response *[]DeletePackage_200_Response_Item `json:"response,omitempty"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}
type DeletePackage200Items0 struct {
	Id       string                     `json:"id"`
	OriginId *string                    `json:"originId,omitempty"`
	Type     DeletePackage200Items0Type `json:"type"`
}
type DeletePackage200Items0Type string
type DeletePackage200Items1 struct {
	Deferred *bool                      `json:"deferred,omitempty"`
	Id       string                     `json:"id"`
	Type     DeletePackage200Items1Type `json:"type"`
	Version  *string                    `json:"version,omitempty"`
}
type DeletePackage200Items1Type string
type DeletePackage_200_Items_Item struct {
	union json.RawMessage
}
type DeletePackage200Response0 struct {
	Id       string                        `json:"id"`
	OriginId *string                       `json:"originId,omitempty"`
	Type     DeletePackage200Response0Type `json:"type"`
}
type DeletePackage200Response0Type string
type DeletePackage200Response1 struct {
	Deferred *bool                         `json:"deferred,omitempty"`
	Id       string                        `json:"id"`
	Type     DeletePackage200Response1Type `json:"type"`
	Version  *string                       `json:"version,omitempty"`
}
type DeletePackage200Response1Type string
type DeletePackage_200_Response_Item struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeletePackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item     PackageInfo `json:"item"`
		Metadata *struct {
			HasPolicies bool `json:"has_policies"`
		} `json:"metadata,omitempty"`
		// Deprecated:
		Response *GetPackage_200_Response `json:"response,omitempty"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}
type GetPackage_200_Response_Conditions_Elastic struct {
	Capabilities         *[]string              `json:"capabilities,omitempty"`
	Subscription         *string                `json:"subscription,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetPackage_200_Response_Conditions_Kibana struct {
	Version              *string                `json:"version,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetPackage_200_Response_Conditions struct {
	Elastic              *GetPackage_200_Response_Conditions_Elastic `json:"elastic,omitempty"`
	Kibana               *GetPackage_200_Response_Conditions_Kibana  `json:"kibana,omitempty"`
	AdditionalProperties map[string]interface{}                      `json:"-"`
}
type GetPackage_200_Response_Discovery_Fields_Item struct {
	Name                 string                 `json:"name"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetPackage_200_Response_Discovery struct {
	Fields               *[]GetPackage_200_Response_Discovery_Fields_Item `json:"fields,omitempty"`
	AdditionalProperties map[string]interface{}                           `json:"-"`
}
type GetPackage_200_Response_Icons_Item struct {
	DarkMode             *bool                  `json:"dark_mode,omitempty"`
	Path                 *string                `json:"path,omitempty"`
	Size                 *string                `json:"size,omitempty"`
	Src                  string                 `json:"src"`
	Title                *string                `json:"title,omitempty"`
	Type                 *string                `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetPackage200ResponseInstallationInfoAdditionalSpacesInstalledKibanaType string
type GetPackage_200_Response_InstallationInfo_AdditionalSpacesInstalledKibana_Item struct {
	Id                   string                                                                   `json:"id"`
	OriginId             *string                                                                  `json:"originId,omitempty"`
	Type                 GetPackage200ResponseInstallationInfoAdditionalSpacesInstalledKibanaType `json:"type"`
	AdditionalProperties map[string]interface{}                                                   `json:"-"`
}
type GetPackage_200_Response_InstallationInfo_ExperimentalDataStreamFeatures_Features struct {
	DocValueOnlyNumeric  *bool                  `json:"doc_value_only_numeric,omitempty"`
	DocValueOnlyOther    *bool                  `json:"doc_value_only_other,omitempty"`
	SyntheticSource      *bool                  `json:"synthetic_source,omitempty"`
	Tsdb                 *bool                  `json:"tsdb,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetPackage_200_Response_InstallationInfo_ExperimentalDataStreamFeatures_Item struct {
	DataStream           string                                                                           `json:"data_stream"`
	Features             GetPackage_200_Response_InstallationInfo_ExperimentalDataStreamFeatures_Features `json:"features"`
	AdditionalProperties map[string]interface{}                                                           `json:"-"`
}
type GetPackage200ResponseInstallationInfoInstallSource string
type GetPackage200ResponseInstallationInfoInstallStatus string
type GetPackage200ResponseInstallationInfoInstalledEsType string
type GetPackage_200_Response_InstallationInfo_InstalledEs_Item struct {
	Deferred             *bool                                                `json:"deferred,omitempty"`
	Id                   string                                               `json:"id"`
	Type                 GetPackage200ResponseInstallationInfoInstalledEsType `json:"type"`
	Version              *string                                              `json:"version,omitempty"`
	AdditionalProperties map[string]interface{}                               `json:"-"`
}
type GetPackage200ResponseInstallationInfoInstalledKibanaType string
type GetPackage_200_Response_InstallationInfo_InstalledKibana_Item struct {
	Id                   string                                                   `json:"id"`
	OriginId             *string                                                  `json:"originId,omitempty"`
	Type                 GetPackage200ResponseInstallationInfoInstalledKibanaType `json:"type"`
	AdditionalProperties map[string]interface{}                                   `json:"-"`
}
type GetPackage_200_Response_InstallationInfo_LatestExecutedState struct {
	Error                *string                `json:"error,omitempty"`
	Name                 string                 `json:"name"`
	StartedAt            string                 `json:"started_at"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetPackage_200_Response_InstallationInfo_LatestInstallFailedAttempts_Error struct {
	Message              string                 `json:"message"`
	Name                 string                 `json:"name"`
	Stack                *string                `json:"stack,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetPackage_200_Response_InstallationInfo_LatestInstallFailedAttempts_Item struct {
	CreatedAt            string                                                                     `json:"created_at"`
	Error                GetPackage_200_Response_InstallationInfo_LatestInstallFailedAttempts_Error `json:"error"`
	TargetVersion        string                                                                     `json:"target_version"`
	AdditionalProperties map[string]interface{}                                                     `json:"-"`
}
type GetPackage200ResponseInstallationInfoVerificationStatus string
type GetPackage_200_Response_InstallationInfo struct {
	AdditionalSpacesInstalledKibana *map[string][]GetPackage_200_Response_InstallationInfo_AdditionalSpacesInstalledKibana_Item `json:"additional_spaces_installed_kibana,omitempty"`
	CreatedAt                       *string                                                                                     `json:"created_at,omitempty"`
	ExperimentalDataStreamFeatures  *[]GetPackage_200_Response_InstallationInfo_ExperimentalDataStreamFeatures_Item             `json:"experimental_data_stream_features,omitempty"`
	InstallFormatSchemaVersion      *string                                                                                     `json:"install_format_schema_version,omitempty"`
	InstallSource                   GetPackage200ResponseInstallationInfoInstallSource                                          `json:"install_source"`
	InstallStatus                   GetPackage200ResponseInstallationInfoInstallStatus                                          `json:"install_status"`
	InstalledEs                     []GetPackage_200_Response_InstallationInfo_InstalledEs_Item                                 `json:"installed_es"`
	InstalledKibana                 []GetPackage_200_Response_InstallationInfo_InstalledKibana_Item                             `json:"installed_kibana"`
	InstalledKibanaSpaceId          *string                                                                                     `json:"installed_kibana_space_id,omitempty"`
	LatestExecutedState             *GetPackage_200_Response_InstallationInfo_LatestExecutedState                               `json:"latest_executed_state,omitempty"`
	LatestInstallFailedAttempts     *[]GetPackage_200_Response_InstallationInfo_LatestInstallFailedAttempts_Item                `json:"latest_install_failed_attempts,omitempty"`
	Name                            string                                                                                      `json:"name"`
	Namespaces                      *[]string                                                                                   `json:"namespaces,omitempty"`
	Type                            string                                                                                      `json:"type"`
	UpdatedAt                       *string                                                                                     `json:"updated_at,omitempty"`
	VerificationKeyId               *string                                                                                     `json:"verification_key_id"`
	VerificationStatus              GetPackage200ResponseInstallationInfoVerificationStatus                                     `json:"verification_status"`
	Version                         string                                                                                      `json:"version"`
	AdditionalProperties            map[string]interface{}                                                                      `json:"-"`
}
type GetPackage200ResponseOwnerType string
type GetPackage_200_Response_Owner struct {
	Github               *string                         `json:"github,omitempty"`
	Type                 *GetPackage200ResponseOwnerType `json:"type,omitempty"`
	AdditionalProperties map[string]interface{}          `json:"-"`
}
type GetPackage200ResponseRelease string
type GetPackage_200_Response_Source struct {
	License              string                 `json:"license"`
	AdditionalProperties map[string]interface{} `json:"-"`
}
type GetPackage200ResponseType string
type GetPackage_200_Response struct {
	Agent *struct {
		Privileges *struct {
			Root *bool `json:"root,omitempty"`
		} `json:"privileges,omitempty"`
	} `json:"agent,omitempty"`
	AssetTags *[]struct {
		AssetIds   *[]string `json:"asset_ids,omitempty"`
		AssetTypes *[]string `json:"asset_types,omitempty"`
		Text       string    `json:"text"`
	} `json:"asset_tags,omitempty"`
	Assets               map[string]interface{}                    `json:"assets"`
	Categories           *[]string                                 `json:"categories,omitempty"`
	Conditions           *GetPackage_200_Response_Conditions       `json:"conditions,omitempty"`
	DataStreams          *[]map[string]interface{}                 `json:"data_streams,omitempty"`
	Description          *string                                   `json:"description,omitempty"`
	Discovery            *GetPackage_200_Response_Discovery        `json:"discovery,omitempty"`
	Download             *string                                   `json:"download,omitempty"`
	Elasticsearch        *map[string]interface{}                   `json:"elasticsearch,omitempty"`
	FormatVersion        *string                                   `json:"format_version,omitempty"`
	Icons                *[]GetPackage_200_Response_Icons_Item     `json:"icons,omitempty"`
	InstallationInfo     *GetPackage_200_Response_InstallationInfo `json:"installationInfo,omitempty"`
	Internal             *bool                                     `json:"internal,omitempty"`
	KeepPoliciesUpToDate *bool                                     `json:"keepPoliciesUpToDate,omitempty"`
	LatestVersion        *string                                   `json:"latestVersion,omitempty"`
	License              *string                                   `json:"license,omitempty"`
	LicensePath          *string                                   `json:"licensePath,omitempty"`
	Name                 string                                    `json:"name"`
	Notice               *string                                   `json:"notice,omitempty"`
	Owner                *GetPackage_200_Response_Owner            `json:"owner,omitempty"`
	Path                 *string                                   `json:"path,omitempty"`
	PolicyTemplates      *[]map[string]interface{}                 `json:"policy_templates,omitempty"`
	Readme               *string                                   `json:"readme,omitempty"`
	Release              *GetPackage200ResponseRelease             `json:"release,omitempty"`
	SavedObject          interface{}                               `json:"savedObject"`
	Screenshots          *[]struct {
		DarkMode *bool   `json:"dark_mode,omitempty"`
		Path     *string `json:"path,omitempty"`
		Size     *string `json:"size,omitempty"`
		Src      string  `json:"src"`
		Title    *string `json:"title,omitempty"`
		Type     *string `json:"type,omitempty"`
	} `json:"screenshots,omitempty"`
	SignaturePath        *string                         `json:"signature_path,omitempty"`
	Source               *GetPackage_200_Response_Source `json:"source,omitempty"`
	Status               *string                         `json:"status,omitempty"`
	Title                string                          `json:"title"`
	Type                 *GetPackage200ResponseType      `json:"type,omitempty"`
	Vars                 *[]map[string]interface{}       `json:"vars,omitempty"`
	Version              string                          `json:"version"`
	AdditionalProperties map[string]interface{}          `json:"-"`
}

// Status returns HTTPResponse.Status
func (r GetPackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InstallPackageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta struct {
			InstallSource string `json:"install_source"`
		} `json:"_meta"`
		Items []InstallPackage_200_Items_Item `json:"items"`
		// Deprecated:
		Response *[]InstallPackage_200_Response_Item `json:"response,omitempty"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}
type InstallPackage200Items0 struct {
	Id       string                      `json:"id"`
	OriginId *string                     `json:"originId,omitempty"`
	Type     InstallPackage200Items0Type `json:"type"`
}
type InstallPackage200Items0Type string
type InstallPackage200Items1 struct {
	Deferred *bool                       `json:"deferred,omitempty"`
	Id       string                      `json:"id"`
	Type     InstallPackage200Items1Type `json:"type"`
	Version  *string                     `json:"version,omitempty"`
}
type InstallPackage200Items1Type string
type InstallPackage_200_Items_Item struct {
	union json.RawMessage
}
type InstallPackage200Response0 struct {
	Id       string                         `json:"id"`
	OriginId *string                        `json:"originId,omitempty"`
	Type     InstallPackage200Response0Type `json:"type"`
}
type InstallPackage200Response0Type string
type InstallPackage200Response1 struct {
	Deferred *bool                          `json:"deferred,omitempty"`
	Id       string                         `json:"id"`
	Type     InstallPackage200Response1Type `json:"type"`
	Version  *string                        `json:"version,omitempty"`
}
type InstallPackage200Response1Type string
type InstallPackage_200_Response_Item struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r InstallPackageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InstallPackageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFleetServerHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items   []ServerHost `json:"items"`
		Page    float32      `json:"page"`
		PerPage float32      `json:"perPage"`
		Total   float32      `json:"total"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFleetServerHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetServerHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFleetServerHostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item ServerHost `json:"item"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateFleetServerHostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFleetServerHostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFleetServerHostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id string `json:"id"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteFleetServerHostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFleetServerHostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFleetServerHostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item ServerHost `json:"item"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFleetServerHostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetServerHostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFleetServerHostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item ServerHost `json:"item"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateFleetServerHostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFleetServerHostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOutputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items   []OutputUnion `json:"items"`
		Page    float32       `json:"page"`
		PerPage float32       `json:"perPage"`
		Total   float32       `json:"total"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOutputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOutputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item OutputUnion `json:"item"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id string `json:"id"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
	JSON404 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item OutputUnion `json:"item"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOutputResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item OutputUnion `json:"item"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateOutputResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOutputResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPackagePoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items   []PackagePolicy `json:"items"`
		Page    float32         `json:"page"`
		PerPage float32         `json:"perPage"`
		Total   float32         `json:"total"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPackagePoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPackagePoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreatePackagePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item PackagePolicy `json:"item"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
	JSON409 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreatePackagePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreatePackagePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePackagePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id string `json:"id"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeletePackagePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePackagePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPackagePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item PackagePolicy `json:"item"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
	JSON404 *struct {
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPackagePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPackagePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePackagePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item PackagePolicy `json:"item"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
	JSON403 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdatePackagePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePackagePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAgentPoliciesWithResponse request returning *GetAgentPoliciesResponse
func (c *ClientWithResponses) GetAgentPoliciesWithResponse(ctx context.Context, params *GetAgentPoliciesParams, reqEditors ...RequestEditorFn) (*GetAgentPoliciesResponse, error) {
	rsp, err := c.GetAgentPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAgentPoliciesResponse(rsp)
}

// CreateAgentPolicyWithBodyWithResponse request with arbitrary body returning *CreateAgentPolicyResponse
func (c *ClientWithResponses) CreateAgentPolicyWithBodyWithResponse(ctx context.Context, params *CreateAgentPolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAgentPolicyResponse, error) {
	rsp, err := c.CreateAgentPolicyWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAgentPolicyResponse(rsp)
}

func (c *ClientWithResponses) CreateAgentPolicyWithResponse(ctx context.Context, params *CreateAgentPolicyParams, body CreateAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAgentPolicyResponse, error) {
	rsp, err := c.CreateAgentPolicy(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAgentPolicyResponse(rsp)
}

// DeleteAgentPolicyWithBodyWithResponse request with arbitrary body returning *DeleteAgentPolicyResponse
func (c *ClientWithResponses) DeleteAgentPolicyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteAgentPolicyResponse, error) {
	rsp, err := c.DeleteAgentPolicyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAgentPolicyResponse(rsp)
}

func (c *ClientWithResponses) DeleteAgentPolicyWithResponse(ctx context.Context, body DeleteAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteAgentPolicyResponse, error) {
	rsp, err := c.DeleteAgentPolicy(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAgentPolicyResponse(rsp)
}

// GetAgentPolicyWithResponse request returning *GetAgentPolicyResponse
func (c *ClientWithResponses) GetAgentPolicyWithResponse(ctx context.Context, agentPolicyId string, params *GetAgentPolicyParams, reqEditors ...RequestEditorFn) (*GetAgentPolicyResponse, error) {
	rsp, err := c.GetAgentPolicy(ctx, agentPolicyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAgentPolicyResponse(rsp)
}

// UpdateAgentPolicyWithBodyWithResponse request with arbitrary body returning *UpdateAgentPolicyResponse
func (c *ClientWithResponses) UpdateAgentPolicyWithBodyWithResponse(ctx context.Context, agentPolicyId string, params *UpdateAgentPolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAgentPolicyResponse, error) {
	rsp, err := c.UpdateAgentPolicyWithBody(ctx, agentPolicyId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAgentPolicyResponse(rsp)
}

func (c *ClientWithResponses) UpdateAgentPolicyWithResponse(ctx context.Context, agentPolicyId string, params *UpdateAgentPolicyParams, body UpdateAgentPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAgentPolicyResponse, error) {
	rsp, err := c.UpdateAgentPolicy(ctx, agentPolicyId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAgentPolicyResponse(rsp)
}

// GetEnrollmentApiKeysWithResponse request returning *GetEnrollmentApiKeysResponse
func (c *ClientWithResponses) GetEnrollmentApiKeysWithResponse(ctx context.Context, params *GetEnrollmentApiKeysParams, reqEditors ...RequestEditorFn) (*GetEnrollmentApiKeysResponse, error) {
	rsp, err := c.GetEnrollmentApiKeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEnrollmentApiKeysResponse(rsp)
}

// ListPackagesWithResponse request returning *ListPackagesResponse
func (c *ClientWithResponses) ListPackagesWithResponse(ctx context.Context, params *ListPackagesParams, reqEditors ...RequestEditorFn) (*ListPackagesResponse, error) {
	rsp, err := c.ListPackages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPackagesResponse(rsp)
}

// InstallPackageByUploadWithBodyWithResponse request with arbitrary body returning *InstallPackageByUploadResponse
func (c *ClientWithResponses) InstallPackageByUploadWithBodyWithResponse(ctx context.Context, params *InstallPackageByUploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallPackageByUploadResponse, error) {
	rsp, err := c.InstallPackageByUploadWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallPackageByUploadResponse(rsp)
}

// DeletePackageWithBodyWithResponse request with arbitrary body returning *DeletePackageResponse
func (c *ClientWithResponses) DeletePackageWithBodyWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *DeletePackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeletePackageResponse, error) {
	rsp, err := c.DeletePackageWithBody(ctx, pkgName, pkgVersion, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePackageResponse(rsp)
}

func (c *ClientWithResponses) DeletePackageWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *DeletePackageParams, body DeletePackageJSONRequestBody, reqEditors ...RequestEditorFn) (*DeletePackageResponse, error) {
	rsp, err := c.DeletePackage(ctx, pkgName, pkgVersion, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePackageResponse(rsp)
}

// GetPackageWithResponse request returning *GetPackageResponse
func (c *ClientWithResponses) GetPackageWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *GetPackageParams, reqEditors ...RequestEditorFn) (*GetPackageResponse, error) {
	rsp, err := c.GetPackage(ctx, pkgName, pkgVersion, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPackageResponse(rsp)
}

// InstallPackageWithBodyWithResponse request with arbitrary body returning *InstallPackageResponse
func (c *ClientWithResponses) InstallPackageWithBodyWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *InstallPackageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InstallPackageResponse, error) {
	rsp, err := c.InstallPackageWithBody(ctx, pkgName, pkgVersion, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallPackageResponse(rsp)
}

func (c *ClientWithResponses) InstallPackageWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *InstallPackageParams, body InstallPackageJSONRequestBody, reqEditors ...RequestEditorFn) (*InstallPackageResponse, error) {
	rsp, err := c.InstallPackage(ctx, pkgName, pkgVersion, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInstallPackageResponse(rsp)
}

// GetFleetServerHostsWithResponse request returning *GetFleetServerHostsResponse
func (c *ClientWithResponses) GetFleetServerHostsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFleetServerHostsResponse, error) {
	rsp, err := c.GetFleetServerHosts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetServerHostsResponse(rsp)
}

// CreateFleetServerHostWithBodyWithResponse request with arbitrary body returning *CreateFleetServerHostResponse
func (c *ClientWithResponses) CreateFleetServerHostWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFleetServerHostResponse, error) {
	rsp, err := c.CreateFleetServerHostWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFleetServerHostResponse(rsp)
}

func (c *ClientWithResponses) CreateFleetServerHostWithResponse(ctx context.Context, body CreateFleetServerHostJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFleetServerHostResponse, error) {
	rsp, err := c.CreateFleetServerHost(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFleetServerHostResponse(rsp)
}

// DeleteFleetServerHostWithResponse request returning *DeleteFleetServerHostResponse
func (c *ClientWithResponses) DeleteFleetServerHostWithResponse(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*DeleteFleetServerHostResponse, error) {
	rsp, err := c.DeleteFleetServerHost(ctx, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFleetServerHostResponse(rsp)
}

// GetFleetServerHostWithResponse request returning *GetFleetServerHostResponse
func (c *ClientWithResponses) GetFleetServerHostWithResponse(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*GetFleetServerHostResponse, error) {
	rsp, err := c.GetFleetServerHost(ctx, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetServerHostResponse(rsp)
}

// UpdateFleetServerHostWithBodyWithResponse request with arbitrary body returning *UpdateFleetServerHostResponse
func (c *ClientWithResponses) UpdateFleetServerHostWithBodyWithResponse(ctx context.Context, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFleetServerHostResponse, error) {
	rsp, err := c.UpdateFleetServerHostWithBody(ctx, itemId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFleetServerHostResponse(rsp)
}

func (c *ClientWithResponses) UpdateFleetServerHostWithResponse(ctx context.Context, itemId string, body UpdateFleetServerHostJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFleetServerHostResponse, error) {
	rsp, err := c.UpdateFleetServerHost(ctx, itemId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFleetServerHostResponse(rsp)
}

// GetOutputsWithResponse request returning *GetOutputsResponse
func (c *ClientWithResponses) GetOutputsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetOutputsResponse, error) {
	rsp, err := c.GetOutputs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOutputsResponse(rsp)
}

// CreateOutputWithBodyWithResponse request with arbitrary body returning *CreateOutputResponse
func (c *ClientWithResponses) CreateOutputWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOutputResponse, error) {
	rsp, err := c.CreateOutputWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOutputResponse(rsp)
}

func (c *ClientWithResponses) CreateOutputWithResponse(ctx context.Context, body CreateOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOutputResponse, error) {
	rsp, err := c.CreateOutput(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOutputResponse(rsp)
}

// DeleteOutputWithResponse request returning *DeleteOutputResponse
func (c *ClientWithResponses) DeleteOutputWithResponse(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*DeleteOutputResponse, error) {
	rsp, err := c.DeleteOutput(ctx, outputId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOutputResponse(rsp)
}

// GetOutputWithResponse request returning *GetOutputResponse
func (c *ClientWithResponses) GetOutputWithResponse(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*GetOutputResponse, error) {
	rsp, err := c.GetOutput(ctx, outputId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOutputResponse(rsp)
}

// UpdateOutputWithBodyWithResponse request with arbitrary body returning *UpdateOutputResponse
func (c *ClientWithResponses) UpdateOutputWithBodyWithResponse(ctx context.Context, outputId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOutputResponse, error) {
	rsp, err := c.UpdateOutputWithBody(ctx, outputId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOutputResponse(rsp)
}

func (c *ClientWithResponses) UpdateOutputWithResponse(ctx context.Context, outputId string, body UpdateOutputJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOutputResponse, error) {
	rsp, err := c.UpdateOutput(ctx, outputId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOutputResponse(rsp)
}

// GetPackagePoliciesWithResponse request returning *GetPackagePoliciesResponse
func (c *ClientWithResponses) GetPackagePoliciesWithResponse(ctx context.Context, params *GetPackagePoliciesParams, reqEditors ...RequestEditorFn) (*GetPackagePoliciesResponse, error) {
	rsp, err := c.GetPackagePolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPackagePoliciesResponse(rsp)
}

// CreatePackagePolicyWithBodyWithResponse request with arbitrary body returning *CreatePackagePolicyResponse
func (c *ClientWithResponses) CreatePackagePolicyWithBodyWithResponse(ctx context.Context, params *CreatePackagePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreatePackagePolicyResponse, error) {
	rsp, err := c.CreatePackagePolicyWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePackagePolicyResponse(rsp)
}

func (c *ClientWithResponses) CreatePackagePolicyWithResponse(ctx context.Context, params *CreatePackagePolicyParams, body CreatePackagePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*CreatePackagePolicyResponse, error) {
	rsp, err := c.CreatePackagePolicy(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreatePackagePolicyResponse(rsp)
}

// DeletePackagePolicyWithResponse request returning *DeletePackagePolicyResponse
func (c *ClientWithResponses) DeletePackagePolicyWithResponse(ctx context.Context, packagePolicyId string, params *DeletePackagePolicyParams, reqEditors ...RequestEditorFn) (*DeletePackagePolicyResponse, error) {
	rsp, err := c.DeletePackagePolicy(ctx, packagePolicyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePackagePolicyResponse(rsp)
}

// GetPackagePolicyWithResponse request returning *GetPackagePolicyResponse
func (c *ClientWithResponses) GetPackagePolicyWithResponse(ctx context.Context, packagePolicyId string, params *GetPackagePolicyParams, reqEditors ...RequestEditorFn) (*GetPackagePolicyResponse, error) {
	rsp, err := c.GetPackagePolicy(ctx, packagePolicyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPackagePolicyResponse(rsp)
}

// UpdatePackagePolicyWithBodyWithResponse request with arbitrary body returning *UpdatePackagePolicyResponse
func (c *ClientWithResponses) UpdatePackagePolicyWithBodyWithResponse(ctx context.Context, packagePolicyId string, params *UpdatePackagePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePackagePolicyResponse, error) {
	rsp, err := c.UpdatePackagePolicyWithBody(ctx, packagePolicyId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePackagePolicyResponse(rsp)
}

func (c *ClientWithResponses) UpdatePackagePolicyWithResponse(ctx context.Context, packagePolicyId string, params *UpdatePackagePolicyParams, body UpdatePackagePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePackagePolicyResponse, error) {
	rsp, err := c.UpdatePackagePolicy(ctx, packagePolicyId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePackagePolicyResponse(rsp)
}

// ParseGetAgentPoliciesResponse parses an HTTP response from a GetAgentPoliciesWithResponse call
func ParseGetAgentPoliciesResponse(rsp *http.Response) (*GetAgentPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAgentPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items   []AgentPolicy `json:"items"`
			Page    float32       `json:"page"`
			PerPage float32       `json:"perPage"`
			Total   float32       `json:"total"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateAgentPolicyResponse parses an HTTP response from a CreateAgentPolicyWithResponse call
func ParseCreateAgentPolicyResponse(rsp *http.Response) (*CreateAgentPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAgentPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item AgentPolicy `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteAgentPolicyResponse parses an HTTP response from a DeleteAgentPolicyWithResponse call
func ParseDeleteAgentPolicyResponse(rsp *http.Response) (*DeleteAgentPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAgentPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id   string `json:"id"`
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetAgentPolicyResponse parses an HTTP response from a GetAgentPolicyWithResponse call
func ParseGetAgentPolicyResponse(rsp *http.Response) (*GetAgentPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAgentPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item AgentPolicy `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateAgentPolicyResponse parses an HTTP response from a UpdateAgentPolicyWithResponse call
func ParseUpdateAgentPolicyResponse(rsp *http.Response) (*UpdateAgentPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAgentPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item AgentPolicy `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetEnrollmentApiKeysResponse parses an HTTP response from a GetEnrollmentApiKeysWithResponse call
func ParseGetEnrollmentApiKeysResponse(rsp *http.Response) (*GetEnrollmentApiKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEnrollmentApiKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items []EnrollmentApiKey `json:"items"`
			// Deprecated:
			List []struct {
				// Active When false, the enrollment API key is revoked and cannot be used for enrolling Elastic Agents.
				Active bool `json:"active"`

				// ApiKey The enrollment API key (token) used for enrolling Elastic Agents.
				ApiKey string `json:"api_key"`

				// ApiKeyId The ID of the API key in the Security API.
				ApiKeyId  string `json:"api_key_id"`
				CreatedAt string `json:"created_at"`
				Id        string `json:"id"`

				// Name The name of the enrollment API key.
				Name *string `json:"name,omitempty"`

				// PolicyId The ID of the agent policy the Elastic Agent will be enrolled in.
				PolicyId *string `json:"policy_id,omitempty"`
			} `json:"list"`
			Page    float32 `json:"page"`
			PerPage float32 `json:"perPage"`
			Total   float32 `json:"total"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseListPackagesResponse parses an HTTP response from a ListPackagesWithResponse call
func ParseListPackagesResponse(rsp *http.Response) (*ListPackagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPackagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items    []PackageListItem                 `json:"items"`
			Response *[]ListPackages_200_Response_Item `json:"response,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseInstallPackageByUploadResponse parses an HTTP response from a InstallPackageByUploadWithResponse call
func ParseInstallPackageByUploadResponse(rsp *http.Response) (*InstallPackageByUploadResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstallPackageByUploadResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeletePackageResponse parses an HTTP response from a DeletePackageWithResponse call
func ParseDeletePackageResponse(rsp *http.Response) (*DeletePackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items []DeletePackage_200_Items_Item `json:"items"`
			// Deprecated:
			Response *[]DeletePackage_200_Response_Item `json:"response,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetPackageResponse parses an HTTP response from a GetPackageWithResponse call
func ParseGetPackageResponse(rsp *http.Response) (*GetPackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item     PackageInfo `json:"item"`
			Metadata *struct {
				HasPolicies bool `json:"has_policies"`
			} `json:"metadata,omitempty"`
			// Deprecated:
			Response *GetPackage_200_Response `json:"response,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseInstallPackageResponse parses an HTTP response from a InstallPackageWithResponse call
func ParseInstallPackageResponse(rsp *http.Response) (*InstallPackageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InstallPackageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta struct {
				InstallSource string `json:"install_source"`
			} `json:"_meta"`
			Items []InstallPackage_200_Items_Item `json:"items"`
			// Deprecated:
			Response *[]InstallPackage_200_Response_Item `json:"response,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFleetServerHostsResponse parses an HTTP response from a GetFleetServerHostsWithResponse call
func ParseGetFleetServerHostsResponse(rsp *http.Response) (*GetFleetServerHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetServerHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items   []ServerHost `json:"items"`
			Page    float32      `json:"page"`
			PerPage float32      `json:"perPage"`
			Total   float32      `json:"total"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateFleetServerHostResponse parses an HTTP response from a CreateFleetServerHostWithResponse call
func ParseCreateFleetServerHostResponse(rsp *http.Response) (*CreateFleetServerHostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFleetServerHostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item ServerHost `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteFleetServerHostResponse parses an HTTP response from a DeleteFleetServerHostWithResponse call
func ParseDeleteFleetServerHostResponse(rsp *http.Response) (*DeleteFleetServerHostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFleetServerHostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFleetServerHostResponse parses an HTTP response from a GetFleetServerHostWithResponse call
func ParseGetFleetServerHostResponse(rsp *http.Response) (*GetFleetServerHostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetServerHostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item ServerHost `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateFleetServerHostResponse parses an HTTP response from a UpdateFleetServerHostWithResponse call
func ParseUpdateFleetServerHostResponse(rsp *http.Response) (*UpdateFleetServerHostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFleetServerHostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item ServerHost `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetOutputsResponse parses an HTTP response from a GetOutputsWithResponse call
func ParseGetOutputsResponse(rsp *http.Response) (*GetOutputsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOutputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items   []OutputUnion `json:"items"`
			Page    float32       `json:"page"`
			PerPage float32       `json:"perPage"`
			Total   float32       `json:"total"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateOutputResponse parses an HTTP response from a CreateOutputWithResponse call
func ParseCreateOutputResponse(rsp *http.Response) (*CreateOutputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item OutputUnion `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteOutputResponse parses an HTTP response from a DeleteOutputWithResponse call
func ParseDeleteOutputResponse(rsp *http.Response) (*DeleteOutputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetOutputResponse parses an HTTP response from a GetOutputWithResponse call
func ParseGetOutputResponse(rsp *http.Response) (*GetOutputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item OutputUnion `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateOutputResponse parses an HTTP response from a UpdateOutputWithResponse call
func ParseUpdateOutputResponse(rsp *http.Response) (*UpdateOutputResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOutputResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item OutputUnion `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetPackagePoliciesResponse parses an HTTP response from a GetPackagePoliciesWithResponse call
func ParseGetPackagePoliciesResponse(rsp *http.Response) (*GetPackagePoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPackagePoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items   []PackagePolicy `json:"items"`
			Page    float32         `json:"page"`
			PerPage float32         `json:"perPage"`
			Total   float32         `json:"total"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreatePackagePolicyResponse parses an HTTP response from a CreatePackagePolicyWithResponse call
func ParseCreatePackagePolicyResponse(rsp *http.Response) (*CreatePackagePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreatePackagePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item PackagePolicy `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeletePackagePolicyResponse parses an HTTP response from a DeletePackagePolicyWithResponse call
func ParseDeletePackagePolicyResponse(rsp *http.Response) (*DeletePackagePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePackagePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetPackagePolicyResponse parses an HTTP response from a GetPackagePolicyWithResponse call
func ParseGetPackagePolicyResponse(rsp *http.Response) (*GetPackagePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPackagePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item PackagePolicy `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdatePackagePolicyResponse parses an HTTP response from a UpdatePackagePolicyWithResponse call
func ParseUpdatePackagePolicyResponse(rsp *http.Response) (*UpdatePackagePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePackagePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item PackagePolicy `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}
