// Package kbapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package kbapi

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	ApiKeyAuthScopes = "apiKeyAuth.Scopes"
	BasicAuthScopes  = "basicAuth.Scopes"
)

// Defines values for DataViews404ResponseError.
const (
	NotFound DataViews404ResponseError = "Not Found"
)

// Defines values for DataViews404ResponseStatusCode.
const (
	N404 DataViews404ResponseStatusCode = 404
)

// Defines values for SecurityDetectionsAPIAlertSuppressionDurationUnit.
const (
	H SecurityDetectionsAPIAlertSuppressionDurationUnit = "h"
	M SecurityDetectionsAPIAlertSuppressionDurationUnit = "m"
	S SecurityDetectionsAPIAlertSuppressionDurationUnit = "s"
)

// Defines values for SecurityDetectionsAPIAlertSuppressionMissingFieldsStrategy.
const (
	DoNotSuppress SecurityDetectionsAPIAlertSuppressionMissingFieldsStrategy = "doNotSuppress"
	Suppress      SecurityDetectionsAPIAlertSuppressionMissingFieldsStrategy = "suppress"
)

// Defines values for SecurityDetectionsAPIDefaultParamsCommand.
const (
	Isolate SecurityDetectionsAPIDefaultParamsCommand = "isolate"
)

// Defines values for SecurityDetectionsAPIEndpointResponseActionActionTypeId.
const (
	DotEndpoint SecurityDetectionsAPIEndpointResponseActionActionTypeId = ".endpoint"
)

// Defines values for SecurityDetectionsAPIEqlQueryLanguage.
const (
	SecurityDetectionsAPIEqlQueryLanguageEql SecurityDetectionsAPIEqlQueryLanguage = "eql"
)

// Defines values for SecurityDetectionsAPIEqlRequiredFieldsType.
const (
	SecurityDetectionsAPIEqlRequiredFieldsTypeEql SecurityDetectionsAPIEqlRequiredFieldsType = "eql"
)

// Defines values for SecurityDetectionsAPIEqlRuleType.
const (
	SecurityDetectionsAPIEqlRuleTypeEql SecurityDetectionsAPIEqlRuleType = "eql"
)

// Defines values for SecurityDetectionsAPIEqlRuleCreateFieldsType.
const (
	SecurityDetectionsAPIEqlRuleCreateFieldsTypeEql SecurityDetectionsAPIEqlRuleCreateFieldsType = "eql"
)

// Defines values for SecurityDetectionsAPIEqlRuleCreatePropsType.
const (
	SecurityDetectionsAPIEqlRuleCreatePropsTypeEql SecurityDetectionsAPIEqlRuleCreatePropsType = "eql"
)

// Defines values for SecurityDetectionsAPIEqlRuleResponseFieldsType.
const (
	SecurityDetectionsAPIEqlRuleResponseFieldsTypeEql SecurityDetectionsAPIEqlRuleResponseFieldsType = "eql"
)

// Defines values for SecurityDetectionsAPIEqlRuleUpdatePropsType.
const (
	Eql SecurityDetectionsAPIEqlRuleUpdatePropsType = "eql"
)

// Defines values for SecurityDetectionsAPIEsqlQueryLanguage.
const (
	SecurityDetectionsAPIEsqlQueryLanguageEsql SecurityDetectionsAPIEsqlQueryLanguage = "esql"
)

// Defines values for SecurityDetectionsAPIEsqlRuleType.
const (
	SecurityDetectionsAPIEsqlRuleTypeEsql SecurityDetectionsAPIEsqlRuleType = "esql"
)

// Defines values for SecurityDetectionsAPIEsqlRuleCreateFieldsType.
const (
	SecurityDetectionsAPIEsqlRuleCreateFieldsTypeEsql SecurityDetectionsAPIEsqlRuleCreateFieldsType = "esql"
)

// Defines values for SecurityDetectionsAPIEsqlRuleCreatePropsType.
const (
	SecurityDetectionsAPIEsqlRuleCreatePropsTypeEsql SecurityDetectionsAPIEsqlRuleCreatePropsType = "esql"
)

// Defines values for SecurityDetectionsAPIEsqlRuleRequiredFieldsType.
const (
	SecurityDetectionsAPIEsqlRuleRequiredFieldsTypeEsql SecurityDetectionsAPIEsqlRuleRequiredFieldsType = "esql"
)

// Defines values for SecurityDetectionsAPIEsqlRuleResponseFieldsType.
const (
	SecurityDetectionsAPIEsqlRuleResponseFieldsTypeEsql SecurityDetectionsAPIEsqlRuleResponseFieldsType = "esql"
)

// Defines values for SecurityDetectionsAPIEsqlRuleUpdatePropsType.
const (
	Esql SecurityDetectionsAPIEsqlRuleUpdatePropsType = "esql"
)

// Defines values for SecurityDetectionsAPIExceptionListType.
const (
	Detection                       SecurityDetectionsAPIExceptionListType = "detection"
	Endpoint                        SecurityDetectionsAPIExceptionListType = "endpoint"
	EndpointBlocklists              SecurityDetectionsAPIExceptionListType = "endpoint_blocklists"
	EndpointEvents                  SecurityDetectionsAPIExceptionListType = "endpoint_events"
	EndpointHostIsolationExceptions SecurityDetectionsAPIExceptionListType = "endpoint_host_isolation_exceptions"
	EndpointTrustedApps             SecurityDetectionsAPIExceptionListType = "endpoint_trusted_apps"
	EndpointTrustedDevices          SecurityDetectionsAPIExceptionListType = "endpoint_trusted_devices"
	RuleDefault                     SecurityDetectionsAPIExceptionListType = "rule_default"
)

// Defines values for SecurityDetectionsAPIExternalRuleSourceType.
const (
	External SecurityDetectionsAPIExternalRuleSourceType = "external"
)

// Defines values for SecurityDetectionsAPIInternalRuleSourceType.
const (
	Internal SecurityDetectionsAPIInternalRuleSourceType = "internal"
)

// Defines values for SecurityDetectionsAPIKqlQueryLanguage.
const (
	Kuery  SecurityDetectionsAPIKqlQueryLanguage = "kuery"
	Lucene SecurityDetectionsAPIKqlQueryLanguage = "lucene"
)

// Defines values for SecurityDetectionsAPIMachineLearningRuleType.
const (
	SecurityDetectionsAPIMachineLearningRuleTypeMachineLearning SecurityDetectionsAPIMachineLearningRuleType = "machine_learning"
)

// Defines values for SecurityDetectionsAPIMachineLearningRuleCreateFieldsType.
const (
	SecurityDetectionsAPIMachineLearningRuleCreateFieldsTypeMachineLearning SecurityDetectionsAPIMachineLearningRuleCreateFieldsType = "machine_learning"
)

// Defines values for SecurityDetectionsAPIMachineLearningRuleCreatePropsType.
const (
	SecurityDetectionsAPIMachineLearningRuleCreatePropsTypeMachineLearning SecurityDetectionsAPIMachineLearningRuleCreatePropsType = "machine_learning"
)

// Defines values for SecurityDetectionsAPIMachineLearningRuleRequiredFieldsType.
const (
	SecurityDetectionsAPIMachineLearningRuleRequiredFieldsTypeMachineLearning SecurityDetectionsAPIMachineLearningRuleRequiredFieldsType = "machine_learning"
)

// Defines values for SecurityDetectionsAPIMachineLearningRuleResponseFieldsType.
const (
	SecurityDetectionsAPIMachineLearningRuleResponseFieldsTypeMachineLearning SecurityDetectionsAPIMachineLearningRuleResponseFieldsType = "machine_learning"
)

// Defines values for SecurityDetectionsAPIMachineLearningRuleUpdatePropsType.
const (
	SecurityDetectionsAPIMachineLearningRuleUpdatePropsTypeMachineLearning SecurityDetectionsAPIMachineLearningRuleUpdatePropsType = "machine_learning"
)

// Defines values for SecurityDetectionsAPINewTermsRuleType.
const (
	SecurityDetectionsAPINewTermsRuleTypeNewTerms SecurityDetectionsAPINewTermsRuleType = "new_terms"
)

// Defines values for SecurityDetectionsAPINewTermsRuleCreateFieldsType.
const (
	SecurityDetectionsAPINewTermsRuleCreateFieldsTypeNewTerms SecurityDetectionsAPINewTermsRuleCreateFieldsType = "new_terms"
)

// Defines values for SecurityDetectionsAPINewTermsRuleCreatePropsType.
const (
	SecurityDetectionsAPINewTermsRuleCreatePropsTypeNewTerms SecurityDetectionsAPINewTermsRuleCreatePropsType = "new_terms"
)

// Defines values for SecurityDetectionsAPINewTermsRuleRequiredFieldsType.
const (
	SecurityDetectionsAPINewTermsRuleRequiredFieldsTypeNewTerms SecurityDetectionsAPINewTermsRuleRequiredFieldsType = "new_terms"
)

// Defines values for SecurityDetectionsAPINewTermsRuleResponseFieldsType.
const (
	SecurityDetectionsAPINewTermsRuleResponseFieldsTypeNewTerms SecurityDetectionsAPINewTermsRuleResponseFieldsType = "new_terms"
)

// Defines values for SecurityDetectionsAPINewTermsRuleUpdatePropsType.
const (
	SecurityDetectionsAPINewTermsRuleUpdatePropsTypeNewTerms SecurityDetectionsAPINewTermsRuleUpdatePropsType = "new_terms"
)

// Defines values for SecurityDetectionsAPIOsqueryResponseActionActionTypeId.
const (
	DotOsquery SecurityDetectionsAPIOsqueryResponseActionActionTypeId = ".osquery"
)

// Defines values for SecurityDetectionsAPIProcessesParamsCommand.
const (
	KillProcess    SecurityDetectionsAPIProcessesParamsCommand = "kill-process"
	SuspendProcess SecurityDetectionsAPIProcessesParamsCommand = "suspend-process"
)

// Defines values for SecurityDetectionsAPIQueryRuleType.
const (
	SecurityDetectionsAPIQueryRuleTypeQuery SecurityDetectionsAPIQueryRuleType = "query"
)

// Defines values for SecurityDetectionsAPIQueryRuleCreateFieldsType.
const (
	SecurityDetectionsAPIQueryRuleCreateFieldsTypeQuery SecurityDetectionsAPIQueryRuleCreateFieldsType = "query"
)

// Defines values for SecurityDetectionsAPIQueryRuleCreatePropsType.
const (
	SecurityDetectionsAPIQueryRuleCreatePropsTypeQuery SecurityDetectionsAPIQueryRuleCreatePropsType = "query"
)

// Defines values for SecurityDetectionsAPIQueryRuleRequiredFieldsType.
const (
	SecurityDetectionsAPIQueryRuleRequiredFieldsTypeQuery SecurityDetectionsAPIQueryRuleRequiredFieldsType = "query"
)

// Defines values for SecurityDetectionsAPIQueryRuleResponseFieldsType.
const (
	SecurityDetectionsAPIQueryRuleResponseFieldsTypeQuery SecurityDetectionsAPIQueryRuleResponseFieldsType = "query"
)

// Defines values for SecurityDetectionsAPIQueryRuleUpdatePropsType.
const (
	SecurityDetectionsAPIQueryRuleUpdatePropsTypeQuery SecurityDetectionsAPIQueryRuleUpdatePropsType = "query"
)

// Defines values for SecurityDetectionsAPIRiskScoreMappingOperator.
const (
	SecurityDetectionsAPIRiskScoreMappingOperatorEquals SecurityDetectionsAPIRiskScoreMappingOperator = "equals"
)

// Defines values for SecurityDetectionsAPIRuleActionNotifyWhen.
const (
	OnActionGroupChange SecurityDetectionsAPIRuleActionNotifyWhen = "onActionGroupChange"
	OnActiveAlert       SecurityDetectionsAPIRuleActionNotifyWhen = "onActiveAlert"
	OnThrottleInterval  SecurityDetectionsAPIRuleActionNotifyWhen = "onThrottleInterval"
)

// Defines values for SecurityDetectionsAPIRuleActionThrottle0.
const (
	NoActions SecurityDetectionsAPIRuleActionThrottle0 = "no_actions"
	Rule      SecurityDetectionsAPIRuleActionThrottle0 = "rule"
)

// Defines values for SecurityDetectionsAPIRuleExceptionListNamespaceType.
const (
	Agnostic SecurityDetectionsAPIRuleExceptionListNamespaceType = "agnostic"
	Single   SecurityDetectionsAPIRuleExceptionListNamespaceType = "single"
)

// Defines values for SecurityDetectionsAPIRuleExecutionStatus.
const (
	Failed         SecurityDetectionsAPIRuleExecutionStatus = "failed"
	GoingToRun     SecurityDetectionsAPIRuleExecutionStatus = "going to run"
	PartialFailure SecurityDetectionsAPIRuleExecutionStatus = "partial failure"
	Running        SecurityDetectionsAPIRuleExecutionStatus = "running"
	Succeeded      SecurityDetectionsAPIRuleExecutionStatus = "succeeded"
)

// Defines values for SecurityDetectionsAPISavedObjectResolveAliasPurpose.
const (
	SavedObjectConversion SecurityDetectionsAPISavedObjectResolveAliasPurpose = "savedObjectConversion"
	SavedObjectImport     SecurityDetectionsAPISavedObjectResolveAliasPurpose = "savedObjectImport"
)

// Defines values for SecurityDetectionsAPISavedObjectResolveOutcome.
const (
	AliasMatch SecurityDetectionsAPISavedObjectResolveOutcome = "aliasMatch"
	Conflict   SecurityDetectionsAPISavedObjectResolveOutcome = "conflict"
	ExactMatch SecurityDetectionsAPISavedObjectResolveOutcome = "exactMatch"
)

// Defines values for SecurityDetectionsAPISavedQueryRuleType.
const (
	SecurityDetectionsAPISavedQueryRuleTypeSavedQuery SecurityDetectionsAPISavedQueryRuleType = "saved_query"
)

// Defines values for SecurityDetectionsAPISavedQueryRuleCreateFieldsType.
const (
	SecurityDetectionsAPISavedQueryRuleCreateFieldsTypeSavedQuery SecurityDetectionsAPISavedQueryRuleCreateFieldsType = "saved_query"
)

// Defines values for SecurityDetectionsAPISavedQueryRuleCreatePropsType.
const (
	SecurityDetectionsAPISavedQueryRuleCreatePropsTypeSavedQuery SecurityDetectionsAPISavedQueryRuleCreatePropsType = "saved_query"
)

// Defines values for SecurityDetectionsAPISavedQueryRuleRequiredFieldsType.
const (
	SecurityDetectionsAPISavedQueryRuleRequiredFieldsTypeSavedQuery SecurityDetectionsAPISavedQueryRuleRequiredFieldsType = "saved_query"
)

// Defines values for SecurityDetectionsAPISavedQueryRuleResponseFieldsType.
const (
	SecurityDetectionsAPISavedQueryRuleResponseFieldsTypeSavedQuery SecurityDetectionsAPISavedQueryRuleResponseFieldsType = "saved_query"
)

// Defines values for SecurityDetectionsAPISavedQueryRuleUpdatePropsType.
const (
	SecurityDetectionsAPISavedQueryRuleUpdatePropsTypeSavedQuery SecurityDetectionsAPISavedQueryRuleUpdatePropsType = "saved_query"
)

// Defines values for SecurityDetectionsAPISeverity.
const (
	Critical SecurityDetectionsAPISeverity = "critical"
	High     SecurityDetectionsAPISeverity = "high"
	Low      SecurityDetectionsAPISeverity = "low"
	Medium   SecurityDetectionsAPISeverity = "medium"
)

// Defines values for SecurityDetectionsAPISeverityMappingOperator.
const (
	SecurityDetectionsAPISeverityMappingOperatorEquals SecurityDetectionsAPISeverityMappingOperator = "equals"
)

// Defines values for SecurityDetectionsAPIThreatMappingEntryType.
const (
	Mapping SecurityDetectionsAPIThreatMappingEntryType = "mapping"
)

// Defines values for SecurityDetectionsAPIThreatMatchRuleType.
const (
	SecurityDetectionsAPIThreatMatchRuleTypeThreatMatch SecurityDetectionsAPIThreatMatchRuleType = "threat_match"
)

// Defines values for SecurityDetectionsAPIThreatMatchRuleCreateFieldsType.
const (
	SecurityDetectionsAPIThreatMatchRuleCreateFieldsTypeThreatMatch SecurityDetectionsAPIThreatMatchRuleCreateFieldsType = "threat_match"
)

// Defines values for SecurityDetectionsAPIThreatMatchRuleCreatePropsType.
const (
	SecurityDetectionsAPIThreatMatchRuleCreatePropsTypeThreatMatch SecurityDetectionsAPIThreatMatchRuleCreatePropsType = "threat_match"
)

// Defines values for SecurityDetectionsAPIThreatMatchRuleRequiredFieldsType.
const (
	SecurityDetectionsAPIThreatMatchRuleRequiredFieldsTypeThreatMatch SecurityDetectionsAPIThreatMatchRuleRequiredFieldsType = "threat_match"
)

// Defines values for SecurityDetectionsAPIThreatMatchRuleResponseFieldsType.
const (
	SecurityDetectionsAPIThreatMatchRuleResponseFieldsTypeThreatMatch SecurityDetectionsAPIThreatMatchRuleResponseFieldsType = "threat_match"
)

// Defines values for SecurityDetectionsAPIThreatMatchRuleUpdatePropsType.
const (
	SecurityDetectionsAPIThreatMatchRuleUpdatePropsTypeThreatMatch SecurityDetectionsAPIThreatMatchRuleUpdatePropsType = "threat_match"
)

// Defines values for SecurityDetectionsAPIThresholdRuleType.
const (
	SecurityDetectionsAPIThresholdRuleTypeThreshold SecurityDetectionsAPIThresholdRuleType = "threshold"
)

// Defines values for SecurityDetectionsAPIThresholdRuleCreateFieldsType.
const (
	SecurityDetectionsAPIThresholdRuleCreateFieldsTypeThreshold SecurityDetectionsAPIThresholdRuleCreateFieldsType = "threshold"
)

// Defines values for SecurityDetectionsAPIThresholdRuleCreatePropsType.
const (
	SecurityDetectionsAPIThresholdRuleCreatePropsTypeThreshold SecurityDetectionsAPIThresholdRuleCreatePropsType = "threshold"
)

// Defines values for SecurityDetectionsAPIThresholdRuleRequiredFieldsType.
const (
	SecurityDetectionsAPIThresholdRuleRequiredFieldsTypeThreshold SecurityDetectionsAPIThresholdRuleRequiredFieldsType = "threshold"
)

// Defines values for SecurityDetectionsAPIThresholdRuleResponseFieldsType.
const (
	SecurityDetectionsAPIThresholdRuleResponseFieldsTypeThreshold SecurityDetectionsAPIThresholdRuleResponseFieldsType = "threshold"
)

// Defines values for SecurityDetectionsAPIThresholdRuleUpdatePropsType.
const (
	SecurityDetectionsAPIThresholdRuleUpdatePropsTypeThreshold SecurityDetectionsAPIThresholdRuleUpdatePropsType = "threshold"
)

// Defines values for AgentPolicyMonitoringEnabled.
const (
	AgentPolicyMonitoringEnabledLogs    AgentPolicyMonitoringEnabled = "logs"
	AgentPolicyMonitoringEnabledMetrics AgentPolicyMonitoringEnabled = "metrics"
	AgentPolicyMonitoringEnabledTraces  AgentPolicyMonitoringEnabled = "traces"
)

// Defines values for AgentPolicyPackagePolicies1Inputs0StreamsRelease.
const (
	AgentPolicyPackagePolicies1Inputs0StreamsReleaseBeta         AgentPolicyPackagePolicies1Inputs0StreamsRelease = "beta"
	AgentPolicyPackagePolicies1Inputs0StreamsReleaseExperimental AgentPolicyPackagePolicies1Inputs0StreamsRelease = "experimental"
	AgentPolicyPackagePolicies1Inputs0StreamsReleaseGa           AgentPolicyPackagePolicies1Inputs0StreamsRelease = "ga"
)

// Defines values for AgentPolicyStatus.
const (
	Active   AgentPolicyStatus = "active"
	Inactive AgentPolicyStatus = "inactive"
)

// Defines values for AuthType.
const (
	WebhookAuthenticationBasic AuthType = "webhook-authentication-basic"
	WebhookAuthenticationSsl   AuthType = "webhook-authentication-ssl"
)

// Defines values for CasesWebhookConfigCreateCommentMethod.
const (
	CasesWebhookConfigCreateCommentMethodPatch CasesWebhookConfigCreateCommentMethod = "patch"
	CasesWebhookConfigCreateCommentMethodPost  CasesWebhookConfigCreateCommentMethod = "post"
	CasesWebhookConfigCreateCommentMethodPut   CasesWebhookConfigCreateCommentMethod = "put"
)

// Defines values for CasesWebhookConfigCreateIncidentMethod.
const (
	CasesWebhookConfigCreateIncidentMethodPatch CasesWebhookConfigCreateIncidentMethod = "patch"
	CasesWebhookConfigCreateIncidentMethodPost  CasesWebhookConfigCreateIncidentMethod = "post"
	CasesWebhookConfigCreateIncidentMethodPut   CasesWebhookConfigCreateIncidentMethod = "put"
)

// Defines values for CasesWebhookConfigUpdateIncidentMethod.
const (
	CasesWebhookConfigUpdateIncidentMethodPatch CasesWebhookConfigUpdateIncidentMethod = "patch"
	CasesWebhookConfigUpdateIncidentMethodPost  CasesWebhookConfigUpdateIncidentMethod = "post"
	CasesWebhookConfigUpdateIncidentMethodPut   CasesWebhookConfigUpdateIncidentMethod = "put"
)

// Defines values for CertType.
const (
	SslCrtKey CertType = "ssl-crt-key"
	SslPfx    CertType = "ssl-pfx"
)

// Defines values for EmailConfigService.
const (
	EmailConfigServiceElasticCloud   EmailConfigService = "elastic_cloud"
	EmailConfigServiceExchangeServer EmailConfigService = "exchange_server"
	EmailConfigServiceGmail          EmailConfigService = "gmail"
	EmailConfigServiceOther          EmailConfigService = "other"
	EmailConfigServiceOutlook365     EmailConfigService = "outlook365"
	EmailConfigServiceSes            EmailConfigService = "ses"
)

// Defines values for GenaiAzureConfigApiProvider.
const (
	AzureOpenAI GenaiAzureConfigApiProvider = "Azure OpenAI"
)

// Defines values for GenaiOpenaiConfigApiProvider.
const (
	OpenAI GenaiOpenaiConfigApiProvider = "OpenAI"
)

// Defines values for GenaiOpenaiOtherConfigApiProvider.
const (
	GenaiOpenaiOtherConfigApiProviderOther GenaiOpenaiOtherConfigApiProvider = "Other"
)

// Defines values for GenaiOpenaiOtherConfigVerificationMode.
const (
	GenaiOpenaiOtherConfigVerificationModeCertificate GenaiOpenaiOtherConfigVerificationMode = "certificate"
	GenaiOpenaiOtherConfigVerificationModeFull        GenaiOpenaiOtherConfigVerificationMode = "full"
	GenaiOpenaiOtherConfigVerificationModeNone        GenaiOpenaiOtherConfigVerificationMode = "none"
)

// Defines values for NewOutputElasticsearchPreset.
const (
	NewOutputElasticsearchPresetBalanced   NewOutputElasticsearchPreset = "balanced"
	NewOutputElasticsearchPresetCustom     NewOutputElasticsearchPreset = "custom"
	NewOutputElasticsearchPresetLatency    NewOutputElasticsearchPreset = "latency"
	NewOutputElasticsearchPresetScale      NewOutputElasticsearchPreset = "scale"
	NewOutputElasticsearchPresetThroughput NewOutputElasticsearchPreset = "throughput"
)

// Defines values for NewOutputElasticsearchType.
const (
	NewOutputElasticsearchTypeElasticsearch NewOutputElasticsearchType = "elasticsearch"
)

// Defines values for NewOutputKafkaAuthType.
const (
	NewOutputKafkaAuthTypeKerberos NewOutputKafkaAuthType = "kerberos"
	NewOutputKafkaAuthTypeNone     NewOutputKafkaAuthType = "none"
	NewOutputKafkaAuthTypeSsl      NewOutputKafkaAuthType = "ssl"
	NewOutputKafkaAuthTypeUserPass NewOutputKafkaAuthType = "user_pass"
)

// Defines values for NewOutputKafkaCompression.
const (
	NewOutputKafkaCompressionGzip   NewOutputKafkaCompression = "gzip"
	NewOutputKafkaCompressionLz4    NewOutputKafkaCompression = "lz4"
	NewOutputKafkaCompressionNone   NewOutputKafkaCompression = "none"
	NewOutputKafkaCompressionSnappy NewOutputKafkaCompression = "snappy"
)

// Defines values for NewOutputKafkaPartition.
const (
	NewOutputKafkaPartitionHash       NewOutputKafkaPartition = "hash"
	NewOutputKafkaPartitionRandom     NewOutputKafkaPartition = "random"
	NewOutputKafkaPartitionRoundRobin NewOutputKafkaPartition = "round_robin"
)

// Defines values for NewOutputKafkaRequiredAcks.
const (
	NewOutputKafkaRequiredAcksMinus1 NewOutputKafkaRequiredAcks = -1
	NewOutputKafkaRequiredAcksN0     NewOutputKafkaRequiredAcks = 0
	NewOutputKafkaRequiredAcksN1     NewOutputKafkaRequiredAcks = 1
)

// Defines values for NewOutputKafkaSaslMechanism.
const (
	NewOutputKafkaSaslMechanismPLAIN       NewOutputKafkaSaslMechanism = "PLAIN"
	NewOutputKafkaSaslMechanismSCRAMSHA256 NewOutputKafkaSaslMechanism = "SCRAM-SHA-256"
	NewOutputKafkaSaslMechanismSCRAMSHA512 NewOutputKafkaSaslMechanism = "SCRAM-SHA-512"
)

// Defines values for NewOutputKafkaType.
const (
	NewOutputKafkaTypeKafka NewOutputKafkaType = "kafka"
)

// Defines values for NewOutputLogstashType.
const (
	NewOutputLogstashTypeLogstash NewOutputLogstashType = "logstash"
)

// Defines values for NewOutputRemoteElasticsearchPreset.
const (
	NewOutputRemoteElasticsearchPresetBalanced   NewOutputRemoteElasticsearchPreset = "balanced"
	NewOutputRemoteElasticsearchPresetCustom     NewOutputRemoteElasticsearchPreset = "custom"
	NewOutputRemoteElasticsearchPresetLatency    NewOutputRemoteElasticsearchPreset = "latency"
	NewOutputRemoteElasticsearchPresetScale      NewOutputRemoteElasticsearchPreset = "scale"
	NewOutputRemoteElasticsearchPresetThroughput NewOutputRemoteElasticsearchPreset = "throughput"
)

// Defines values for NewOutputRemoteElasticsearchType.
const (
	NewOutputRemoteElasticsearchTypeRemoteElasticsearch NewOutputRemoteElasticsearchType = "remote_elasticsearch"
)

// Defines values for NewOutputSslVerificationMode.
const (
	NewOutputSslVerificationModeCertificate NewOutputSslVerificationMode = "certificate"
	NewOutputSslVerificationModeFull        NewOutputSslVerificationMode = "full"
	NewOutputSslVerificationModeNone        NewOutputSslVerificationMode = "none"
	NewOutputSslVerificationModeStrict      NewOutputSslVerificationMode = "strict"
)

// Defines values for OutputElasticsearchPreset.
const (
	OutputElasticsearchPresetBalanced   OutputElasticsearchPreset = "balanced"
	OutputElasticsearchPresetCustom     OutputElasticsearchPreset = "custom"
	OutputElasticsearchPresetLatency    OutputElasticsearchPreset = "latency"
	OutputElasticsearchPresetScale      OutputElasticsearchPreset = "scale"
	OutputElasticsearchPresetThroughput OutputElasticsearchPreset = "throughput"
)

// Defines values for OutputElasticsearchType.
const (
	OutputElasticsearchTypeElasticsearch OutputElasticsearchType = "elasticsearch"
)

// Defines values for OutputKafkaAuthType.
const (
	OutputKafkaAuthTypeKerberos OutputKafkaAuthType = "kerberos"
	OutputKafkaAuthTypeNone     OutputKafkaAuthType = "none"
	OutputKafkaAuthTypeSsl      OutputKafkaAuthType = "ssl"
	OutputKafkaAuthTypeUserPass OutputKafkaAuthType = "user_pass"
)

// Defines values for OutputKafkaCompression.
const (
	OutputKafkaCompressionGzip   OutputKafkaCompression = "gzip"
	OutputKafkaCompressionLz4    OutputKafkaCompression = "lz4"
	OutputKafkaCompressionNone   OutputKafkaCompression = "none"
	OutputKafkaCompressionSnappy OutputKafkaCompression = "snappy"
)

// Defines values for OutputKafkaPartition.
const (
	OutputKafkaPartitionHash       OutputKafkaPartition = "hash"
	OutputKafkaPartitionRandom     OutputKafkaPartition = "random"
	OutputKafkaPartitionRoundRobin OutputKafkaPartition = "round_robin"
)

// Defines values for OutputKafkaRequiredAcks.
const (
	OutputKafkaRequiredAcksMinus1 OutputKafkaRequiredAcks = -1
	OutputKafkaRequiredAcksN0     OutputKafkaRequiredAcks = 0
	OutputKafkaRequiredAcksN1     OutputKafkaRequiredAcks = 1
)

// Defines values for OutputKafkaSaslMechanism.
const (
	OutputKafkaSaslMechanismPLAIN       OutputKafkaSaslMechanism = "PLAIN"
	OutputKafkaSaslMechanismSCRAMSHA256 OutputKafkaSaslMechanism = "SCRAM-SHA-256"
	OutputKafkaSaslMechanismSCRAMSHA512 OutputKafkaSaslMechanism = "SCRAM-SHA-512"
)

// Defines values for OutputKafkaType.
const (
	OutputKafkaTypeKafka OutputKafkaType = "kafka"
)

// Defines values for OutputLogstashType.
const (
	OutputLogstashTypeLogstash OutputLogstashType = "logstash"
)

// Defines values for OutputRemoteElasticsearchPreset.
const (
	OutputRemoteElasticsearchPresetBalanced   OutputRemoteElasticsearchPreset = "balanced"
	OutputRemoteElasticsearchPresetCustom     OutputRemoteElasticsearchPreset = "custom"
	OutputRemoteElasticsearchPresetLatency    OutputRemoteElasticsearchPreset = "latency"
	OutputRemoteElasticsearchPresetScale      OutputRemoteElasticsearchPreset = "scale"
	OutputRemoteElasticsearchPresetThroughput OutputRemoteElasticsearchPreset = "throughput"
)

// Defines values for OutputRemoteElasticsearchType.
const (
	OutputRemoteElasticsearchTypeRemoteElasticsearch OutputRemoteElasticsearchType = "remote_elasticsearch"
)

// Defines values for OutputSslVerificationMode.
const (
	OutputSslVerificationModeCertificate OutputSslVerificationMode = "certificate"
	OutputSslVerificationModeFull        OutputSslVerificationMode = "full"
	OutputSslVerificationModeNone        OutputSslVerificationMode = "none"
	OutputSslVerificationModeStrict      OutputSslVerificationMode = "strict"
)

// Defines values for PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0.
const (
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0CspRuleTemplate   PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0 = "csp-rule-template"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0Dashboard         PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0 = "dashboard"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0IndexPattern      PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0 = "index-pattern"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0Lens              PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0 = "lens"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0Map               PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0 = "map"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0MlModule          PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0 = "ml-module"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0OsqueryPackAsset  PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0 = "osquery-pack-asset"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0OsquerySavedQuery PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0 = "osquery-saved-query"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0Search            PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0 = "search"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0SecurityRule      PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0 = "security-rule"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0Tag               PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0 = "tag"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0Visualization     PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0 = "visualization"
)

// Defines values for PackageInfoInstallationInfoInstallSource.
const (
	PackageInfoInstallationInfoInstallSourceBundled  PackageInfoInstallationInfoInstallSource = "bundled"
	PackageInfoInstallationInfoInstallSourceCustom   PackageInfoInstallationInfoInstallSource = "custom"
	PackageInfoInstallationInfoInstallSourceRegistry PackageInfoInstallationInfoInstallSource = "registry"
	PackageInfoInstallationInfoInstallSourceUpload   PackageInfoInstallationInfoInstallSource = "upload"
)

// Defines values for PackageInfoInstallationInfoInstallStatus.
const (
	PackageInfoInstallationInfoInstallStatusInstallFailed PackageInfoInstallationInfoInstallStatus = "install_failed"
	PackageInfoInstallationInfoInstallStatusInstalled     PackageInfoInstallationInfoInstallStatus = "installed"
	PackageInfoInstallationInfoInstallStatusInstalling    PackageInfoInstallationInfoInstallStatus = "installing"
)

// Defines values for PackageInfoInstallationInfoInstalledEsType.
const (
	PackageInfoInstallationInfoInstalledEsTypeComponentTemplate   PackageInfoInstallationInfoInstalledEsType = "component_template"
	PackageInfoInstallationInfoInstalledEsTypeDataStreamIlmPolicy PackageInfoInstallationInfoInstalledEsType = "data_stream_ilm_policy"
	PackageInfoInstallationInfoInstalledEsTypeIlmPolicy           PackageInfoInstallationInfoInstalledEsType = "ilm_policy"
	PackageInfoInstallationInfoInstalledEsTypeIndex               PackageInfoInstallationInfoInstalledEsType = "index"
	PackageInfoInstallationInfoInstalledEsTypeIndexTemplate       PackageInfoInstallationInfoInstalledEsType = "index_template"
	PackageInfoInstallationInfoInstalledEsTypeIngestPipeline      PackageInfoInstallationInfoInstalledEsType = "ingest_pipeline"
	PackageInfoInstallationInfoInstalledEsTypeKnowledgeBase       PackageInfoInstallationInfoInstalledEsType = "knowledge_base"
	PackageInfoInstallationInfoInstalledEsTypeMlModel             PackageInfoInstallationInfoInstalledEsType = "ml_model"
	PackageInfoInstallationInfoInstalledEsTypeTransform           PackageInfoInstallationInfoInstalledEsType = "transform"
)

// Defines values for PackageInfoInstallationInfoInstalledKibanaType0.
const (
	PackageInfoInstallationInfoInstalledKibanaType0CspRuleTemplate   PackageInfoInstallationInfoInstalledKibanaType0 = "csp-rule-template"
	PackageInfoInstallationInfoInstalledKibanaType0Dashboard         PackageInfoInstallationInfoInstalledKibanaType0 = "dashboard"
	PackageInfoInstallationInfoInstalledKibanaType0IndexPattern      PackageInfoInstallationInfoInstalledKibanaType0 = "index-pattern"
	PackageInfoInstallationInfoInstalledKibanaType0Lens              PackageInfoInstallationInfoInstalledKibanaType0 = "lens"
	PackageInfoInstallationInfoInstalledKibanaType0Map               PackageInfoInstallationInfoInstalledKibanaType0 = "map"
	PackageInfoInstallationInfoInstalledKibanaType0MlModule          PackageInfoInstallationInfoInstalledKibanaType0 = "ml-module"
	PackageInfoInstallationInfoInstalledKibanaType0OsqueryPackAsset  PackageInfoInstallationInfoInstalledKibanaType0 = "osquery-pack-asset"
	PackageInfoInstallationInfoInstalledKibanaType0OsquerySavedQuery PackageInfoInstallationInfoInstalledKibanaType0 = "osquery-saved-query"
	PackageInfoInstallationInfoInstalledKibanaType0Search            PackageInfoInstallationInfoInstalledKibanaType0 = "search"
	PackageInfoInstallationInfoInstalledKibanaType0SecurityRule      PackageInfoInstallationInfoInstalledKibanaType0 = "security-rule"
	PackageInfoInstallationInfoInstalledKibanaType0Tag               PackageInfoInstallationInfoInstalledKibanaType0 = "tag"
	PackageInfoInstallationInfoInstalledKibanaType0Visualization     PackageInfoInstallationInfoInstalledKibanaType0 = "visualization"
)

// Defines values for PackageInfoInstallationInfoVerificationStatus.
const (
	PackageInfoInstallationInfoVerificationStatusUnknown    PackageInfoInstallationInfoVerificationStatus = "unknown"
	PackageInfoInstallationInfoVerificationStatusUnverified PackageInfoInstallationInfoVerificationStatus = "unverified"
	PackageInfoInstallationInfoVerificationStatusVerified   PackageInfoInstallationInfoVerificationStatus = "verified"
)

// Defines values for PackageInfoOwnerType.
const (
	PackageInfoOwnerTypeCommunity PackageInfoOwnerType = "community"
	PackageInfoOwnerTypeElastic   PackageInfoOwnerType = "elastic"
	PackageInfoOwnerTypePartner   PackageInfoOwnerType = "partner"
)

// Defines values for PackageInfoRelease.
const (
	PackageInfoReleaseBeta         PackageInfoRelease = "beta"
	PackageInfoReleaseExperimental PackageInfoRelease = "experimental"
	PackageInfoReleaseGa           PackageInfoRelease = "ga"
)

// Defines values for PackageInfoType0.
const (
	PackageInfoType0Integration PackageInfoType0 = "integration"
)

// Defines values for PackageInfoType1.
const (
	PackageInfoType1Input PackageInfoType1 = "input"
)

// Defines values for PackageInfoType2.
const (
	PackageInfoType2Content PackageInfoType2 = "content"
)

// Defines values for PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0.
const (
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0CspRuleTemplate   PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0 = "csp-rule-template"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0Dashboard         PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0 = "dashboard"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0IndexPattern      PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0 = "index-pattern"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0Lens              PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0 = "lens"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0Map               PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0 = "map"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0MlModule          PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0 = "ml-module"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0OsqueryPackAsset  PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0 = "osquery-pack-asset"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0OsquerySavedQuery PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0 = "osquery-saved-query"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0Search            PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0 = "search"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0SecurityRule      PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0 = "security-rule"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0Tag               PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0 = "tag"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0Visualization     PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0 = "visualization"
)

// Defines values for PackageListItemInstallationInfoInstallSource.
const (
	PackageListItemInstallationInfoInstallSourceBundled  PackageListItemInstallationInfoInstallSource = "bundled"
	PackageListItemInstallationInfoInstallSourceCustom   PackageListItemInstallationInfoInstallSource = "custom"
	PackageListItemInstallationInfoInstallSourceRegistry PackageListItemInstallationInfoInstallSource = "registry"
	PackageListItemInstallationInfoInstallSourceUpload   PackageListItemInstallationInfoInstallSource = "upload"
)

// Defines values for PackageListItemInstallationInfoInstallStatus.
const (
	PackageListItemInstallationInfoInstallStatusInstallFailed PackageListItemInstallationInfoInstallStatus = "install_failed"
	PackageListItemInstallationInfoInstallStatusInstalled     PackageListItemInstallationInfoInstallStatus = "installed"
	PackageListItemInstallationInfoInstallStatusInstalling    PackageListItemInstallationInfoInstallStatus = "installing"
)

// Defines values for PackageListItemInstallationInfoInstalledEsType.
const (
	PackageListItemInstallationInfoInstalledEsTypeComponentTemplate   PackageListItemInstallationInfoInstalledEsType = "component_template"
	PackageListItemInstallationInfoInstalledEsTypeDataStreamIlmPolicy PackageListItemInstallationInfoInstalledEsType = "data_stream_ilm_policy"
	PackageListItemInstallationInfoInstalledEsTypeIlmPolicy           PackageListItemInstallationInfoInstalledEsType = "ilm_policy"
	PackageListItemInstallationInfoInstalledEsTypeIndex               PackageListItemInstallationInfoInstalledEsType = "index"
	PackageListItemInstallationInfoInstalledEsTypeIndexTemplate       PackageListItemInstallationInfoInstalledEsType = "index_template"
	PackageListItemInstallationInfoInstalledEsTypeIngestPipeline      PackageListItemInstallationInfoInstalledEsType = "ingest_pipeline"
	PackageListItemInstallationInfoInstalledEsTypeKnowledgeBase       PackageListItemInstallationInfoInstalledEsType = "knowledge_base"
	PackageListItemInstallationInfoInstalledEsTypeMlModel             PackageListItemInstallationInfoInstalledEsType = "ml_model"
	PackageListItemInstallationInfoInstalledEsTypeTransform           PackageListItemInstallationInfoInstalledEsType = "transform"
)

// Defines values for PackageListItemInstallationInfoInstalledKibanaType0.
const (
	PackageListItemInstallationInfoInstalledKibanaType0CspRuleTemplate   PackageListItemInstallationInfoInstalledKibanaType0 = "csp-rule-template"
	PackageListItemInstallationInfoInstalledKibanaType0Dashboard         PackageListItemInstallationInfoInstalledKibanaType0 = "dashboard"
	PackageListItemInstallationInfoInstalledKibanaType0IndexPattern      PackageListItemInstallationInfoInstalledKibanaType0 = "index-pattern"
	PackageListItemInstallationInfoInstalledKibanaType0Lens              PackageListItemInstallationInfoInstalledKibanaType0 = "lens"
	PackageListItemInstallationInfoInstalledKibanaType0Map               PackageListItemInstallationInfoInstalledKibanaType0 = "map"
	PackageListItemInstallationInfoInstalledKibanaType0MlModule          PackageListItemInstallationInfoInstalledKibanaType0 = "ml-module"
	PackageListItemInstallationInfoInstalledKibanaType0OsqueryPackAsset  PackageListItemInstallationInfoInstalledKibanaType0 = "osquery-pack-asset"
	PackageListItemInstallationInfoInstalledKibanaType0OsquerySavedQuery PackageListItemInstallationInfoInstalledKibanaType0 = "osquery-saved-query"
	PackageListItemInstallationInfoInstalledKibanaType0Search            PackageListItemInstallationInfoInstalledKibanaType0 = "search"
	PackageListItemInstallationInfoInstalledKibanaType0SecurityRule      PackageListItemInstallationInfoInstalledKibanaType0 = "security-rule"
	PackageListItemInstallationInfoInstalledKibanaType0Tag               PackageListItemInstallationInfoInstalledKibanaType0 = "tag"
	PackageListItemInstallationInfoInstalledKibanaType0Visualization     PackageListItemInstallationInfoInstalledKibanaType0 = "visualization"
)

// Defines values for PackageListItemInstallationInfoVerificationStatus.
const (
	PackageListItemInstallationInfoVerificationStatusUnknown    PackageListItemInstallationInfoVerificationStatus = "unknown"
	PackageListItemInstallationInfoVerificationStatusUnverified PackageListItemInstallationInfoVerificationStatus = "unverified"
	PackageListItemInstallationInfoVerificationStatusVerified   PackageListItemInstallationInfoVerificationStatus = "verified"
)

// Defines values for PackageListItemOwnerType.
const (
	PackageListItemOwnerTypeCommunity PackageListItemOwnerType = "community"
	PackageListItemOwnerTypeElastic   PackageListItemOwnerType = "elastic"
	PackageListItemOwnerTypePartner   PackageListItemOwnerType = "partner"
)

// Defines values for PackageListItemRelease.
const (
	Beta         PackageListItemRelease = "beta"
	Experimental PackageListItemRelease = "experimental"
	Ga           PackageListItemRelease = "ga"
)

// Defines values for PackageListItemType0.
const (
	PackageListItemType0Integration PackageListItemType0 = "integration"
)

// Defines values for PackageListItemType1.
const (
	PackageListItemType1Input PackageListItemType1 = "input"
)

// Defines values for PackageListItemType2.
const (
	PackageListItemType2Content PackageListItemType2 = "content"
)

// Defines values for ServerHostSslClientAuth.
const (
	ServerHostSslClientAuthNone     ServerHostSslClientAuth = "none"
	ServerHostSslClientAuthOptional ServerHostSslClientAuth = "optional"
	ServerHostSslClientAuthRequired ServerHostSslClientAuth = "required"
)

// Defines values for SwimlaneConfigConnectorType.
const (
	Alerts SwimlaneConfigConnectorType = "alerts"
	All    SwimlaneConfigConnectorType = "all"
	Cases  SwimlaneConfigConnectorType = "cases"
)

// Defines values for UpdateOutputElasticsearchPreset.
const (
	UpdateOutputElasticsearchPresetBalanced   UpdateOutputElasticsearchPreset = "balanced"
	UpdateOutputElasticsearchPresetCustom     UpdateOutputElasticsearchPreset = "custom"
	UpdateOutputElasticsearchPresetLatency    UpdateOutputElasticsearchPreset = "latency"
	UpdateOutputElasticsearchPresetScale      UpdateOutputElasticsearchPreset = "scale"
	UpdateOutputElasticsearchPresetThroughput UpdateOutputElasticsearchPreset = "throughput"
)

// Defines values for UpdateOutputElasticsearchType.
const (
	Elasticsearch UpdateOutputElasticsearchType = "elasticsearch"
)

// Defines values for UpdateOutputKafkaAuthType.
const (
	UpdateOutputKafkaAuthTypeKerberos UpdateOutputKafkaAuthType = "kerberos"
	UpdateOutputKafkaAuthTypeNone     UpdateOutputKafkaAuthType = "none"
	UpdateOutputKafkaAuthTypeSsl      UpdateOutputKafkaAuthType = "ssl"
	UpdateOutputKafkaAuthTypeUserPass UpdateOutputKafkaAuthType = "user_pass"
)

// Defines values for UpdateOutputKafkaCompression.
const (
	UpdateOutputKafkaCompressionGzip   UpdateOutputKafkaCompression = "gzip"
	UpdateOutputKafkaCompressionLz4    UpdateOutputKafkaCompression = "lz4"
	UpdateOutputKafkaCompressionNone   UpdateOutputKafkaCompression = "none"
	UpdateOutputKafkaCompressionSnappy UpdateOutputKafkaCompression = "snappy"
)

// Defines values for UpdateOutputKafkaPartition.
const (
	Hash       UpdateOutputKafkaPartition = "hash"
	Random     UpdateOutputKafkaPartition = "random"
	RoundRobin UpdateOutputKafkaPartition = "round_robin"
)

// Defines values for UpdateOutputKafkaRequiredAcks.
const (
	Minus1 UpdateOutputKafkaRequiredAcks = -1
	N0     UpdateOutputKafkaRequiredAcks = 0
	N1     UpdateOutputKafkaRequiredAcks = 1
)

// Defines values for UpdateOutputKafkaSaslMechanism.
const (
	PLAIN       UpdateOutputKafkaSaslMechanism = "PLAIN"
	SCRAMSHA256 UpdateOutputKafkaSaslMechanism = "SCRAM-SHA-256"
	SCRAMSHA512 UpdateOutputKafkaSaslMechanism = "SCRAM-SHA-512"
)

// Defines values for UpdateOutputKafkaType.
const (
	Kafka UpdateOutputKafkaType = "kafka"
)

// Defines values for UpdateOutputLogstashType.
const (
	Logstash UpdateOutputLogstashType = "logstash"
)

// Defines values for UpdateOutputRemoteElasticsearchPreset.
const (
	UpdateOutputRemoteElasticsearchPresetBalanced   UpdateOutputRemoteElasticsearchPreset = "balanced"
	UpdateOutputRemoteElasticsearchPresetCustom     UpdateOutputRemoteElasticsearchPreset = "custom"
	UpdateOutputRemoteElasticsearchPresetLatency    UpdateOutputRemoteElasticsearchPreset = "latency"
	UpdateOutputRemoteElasticsearchPresetScale      UpdateOutputRemoteElasticsearchPreset = "scale"
	UpdateOutputRemoteElasticsearchPresetThroughput UpdateOutputRemoteElasticsearchPreset = "throughput"
)

// Defines values for UpdateOutputRemoteElasticsearchType.
const (
	RemoteElasticsearch UpdateOutputRemoteElasticsearchType = "remote_elasticsearch"
)

// Defines values for UpdateOutputSslVerificationMode.
const (
	UpdateOutputSslVerificationModeCertificate UpdateOutputSslVerificationMode = "certificate"
	UpdateOutputSslVerificationModeFull        UpdateOutputSslVerificationMode = "full"
	UpdateOutputSslVerificationModeNone        UpdateOutputSslVerificationMode = "none"
	UpdateOutputSslVerificationModeStrict      UpdateOutputSslVerificationMode = "strict"
)

// Defines values for VerificationMode.
const (
	VerificationModeCertificate VerificationMode = "certificate"
	VerificationModeFull        VerificationMode = "full"
	VerificationModeNone        VerificationMode = "none"
)

// Defines values for WebhookConfigMethod.
const (
	WebhookConfigMethodPost WebhookConfigMethod = "post"
	WebhookConfigMethodPut  WebhookConfigMethod = "put"
)

// Defines values for APMUIElasticApiVersion.
const (
	APMUIElasticApiVersionN20231031 APMUIElasticApiVersion = "2023-10-31"
)

// Defines values for DeleteAgentConfigurationParamsElasticApiVersion.
const (
	DeleteAgentConfigurationParamsElasticApiVersionN20231031 DeleteAgentConfigurationParamsElasticApiVersion = "2023-10-31"
)

// Defines values for GetAgentConfigurationsParamsElasticApiVersion.
const (
	GetAgentConfigurationsParamsElasticApiVersionN20231031 GetAgentConfigurationsParamsElasticApiVersion = "2023-10-31"
)

// Defines values for CreateUpdateAgentConfigurationParamsElasticApiVersion.
const (
	CreateUpdateAgentConfigurationParamsElasticApiVersionN20231031 CreateUpdateAgentConfigurationParamsElasticApiVersion = "2023-10-31"
)

// Defines values for GetFleetAgentPoliciesParamsSortOrder.
const (
	GetFleetAgentPoliciesParamsSortOrderAsc  GetFleetAgentPoliciesParamsSortOrder = "asc"
	GetFleetAgentPoliciesParamsSortOrderDesc GetFleetAgentPoliciesParamsSortOrder = "desc"
)

// Defines values for GetFleetAgentPoliciesParamsFormat.
const (
	GetFleetAgentPoliciesParamsFormatLegacy     GetFleetAgentPoliciesParamsFormat = "legacy"
	GetFleetAgentPoliciesParamsFormatSimplified GetFleetAgentPoliciesParamsFormat = "simplified"
)

// Defines values for PostFleetAgentPoliciesJSONBodyMonitoringEnabled.
const (
	PostFleetAgentPoliciesJSONBodyMonitoringEnabledLogs    PostFleetAgentPoliciesJSONBodyMonitoringEnabled = "logs"
	PostFleetAgentPoliciesJSONBodyMonitoringEnabledMetrics PostFleetAgentPoliciesJSONBodyMonitoringEnabled = "metrics"
	PostFleetAgentPoliciesJSONBodyMonitoringEnabledTraces  PostFleetAgentPoliciesJSONBodyMonitoringEnabled = "traces"
)

// Defines values for GetFleetAgentPoliciesAgentpolicyidParamsFormat.
const (
	GetFleetAgentPoliciesAgentpolicyidParamsFormatLegacy     GetFleetAgentPoliciesAgentpolicyidParamsFormat = "legacy"
	GetFleetAgentPoliciesAgentpolicyidParamsFormatSimplified GetFleetAgentPoliciesAgentpolicyidParamsFormat = "simplified"
)

// Defines values for PutFleetAgentPoliciesAgentpolicyidParamsFormat.
const (
	PutFleetAgentPoliciesAgentpolicyidParamsFormatLegacy     PutFleetAgentPoliciesAgentpolicyidParamsFormat = "legacy"
	PutFleetAgentPoliciesAgentpolicyidParamsFormatSimplified PutFleetAgentPoliciesAgentpolicyidParamsFormat = "simplified"
)

// Defines values for PutFleetAgentPoliciesAgentpolicyidJSONBodyMonitoringEnabled.
const (
	Logs    PutFleetAgentPoliciesAgentpolicyidJSONBodyMonitoringEnabled = "logs"
	Metrics PutFleetAgentPoliciesAgentpolicyidJSONBodyMonitoringEnabled = "metrics"
	Traces  PutFleetAgentPoliciesAgentpolicyidJSONBodyMonitoringEnabled = "traces"
)

// Defines values for PostFleetFleetServerHostsJSONBodySslClientAuth.
const (
	PostFleetFleetServerHostsJSONBodySslClientAuthNone     PostFleetFleetServerHostsJSONBodySslClientAuth = "none"
	PostFleetFleetServerHostsJSONBodySslClientAuthOptional PostFleetFleetServerHostsJSONBodySslClientAuth = "optional"
	PostFleetFleetServerHostsJSONBodySslClientAuthRequired PostFleetFleetServerHostsJSONBodySslClientAuth = "required"
)

// Defines values for PutFleetFleetServerHostsItemidJSONBodySslClientAuth.
const (
	PutFleetFleetServerHostsItemidJSONBodySslClientAuthNone     PutFleetFleetServerHostsItemidJSONBodySslClientAuth = "none"
	PutFleetFleetServerHostsItemidJSONBodySslClientAuthOptional PutFleetFleetServerHostsItemidJSONBodySslClientAuth = "optional"
	PutFleetFleetServerHostsItemidJSONBodySslClientAuthRequired PutFleetFleetServerHostsItemidJSONBodySslClientAuth = "required"
)

// Defines values for GetFleetPackagePoliciesParamsSortOrder.
const (
	GetFleetPackagePoliciesParamsSortOrderAsc  GetFleetPackagePoliciesParamsSortOrder = "asc"
	GetFleetPackagePoliciesParamsSortOrderDesc GetFleetPackagePoliciesParamsSortOrder = "desc"
)

// Defines values for GetFleetPackagePoliciesParamsFormat.
const (
	GetFleetPackagePoliciesParamsFormatLegacy     GetFleetPackagePoliciesParamsFormat = "legacy"
	GetFleetPackagePoliciesParamsFormatSimplified GetFleetPackagePoliciesParamsFormat = "simplified"
)

// Defines values for PostFleetPackagePoliciesParamsFormat.
const (
	PostFleetPackagePoliciesParamsFormatLegacy     PostFleetPackagePoliciesParamsFormat = "legacy"
	PostFleetPackagePoliciesParamsFormatSimplified PostFleetPackagePoliciesParamsFormat = "simplified"
)

// Defines values for GetFleetPackagePoliciesPackagepolicyidParamsFormat.
const (
	GetFleetPackagePoliciesPackagepolicyidParamsFormatLegacy     GetFleetPackagePoliciesPackagepolicyidParamsFormat = "legacy"
	GetFleetPackagePoliciesPackagepolicyidParamsFormatSimplified GetFleetPackagePoliciesPackagepolicyidParamsFormat = "simplified"
)

// Defines values for PutFleetPackagePoliciesPackagepolicyidParamsFormat.
const (
	Legacy     PutFleetPackagePoliciesPackagepolicyidParamsFormat = "legacy"
	Simplified PutFleetPackagePoliciesPackagepolicyidParamsFormat = "simplified"
)

// APMUI400Response defines model for APM_UI_400_response.
type APMUI400Response struct {
	// Error Error type
	Error *string `json:"error,omitempty"`

	// Message Error message
	Message *string `json:"message,omitempty"`

	// StatusCode Error status code
	StatusCode *float32 `json:"statusCode,omitempty"`
}

// APMUI401Response defines model for APM_UI_401_response.
type APMUI401Response struct {
	// Error Error type
	Error *string `json:"error,omitempty"`

	// Message Error message
	Message *string `json:"message,omitempty"`

	// StatusCode Error status code
	StatusCode *float32 `json:"statusCode,omitempty"`
}

// APMUI403Response defines model for APM_UI_403_response.
type APMUI403Response struct {
	// Error Error type
	Error *string `json:"error,omitempty"`

	// Message Error message
	Message *string `json:"message,omitempty"`

	// StatusCode Error status code
	StatusCode *float32 `json:"statusCode,omitempty"`
}

// APMUI404Response defines model for APM_UI_404_response.
type APMUI404Response struct {
	// Error Error type
	Error *string `json:"error,omitempty"`

	// Message Error message
	Message *string `json:"message,omitempty"`

	// StatusCode Error status code
	StatusCode *float32 `json:"statusCode,omitempty"`
}

// APMUIAgentConfigurationIntakeObject defines model for APM_UI_agent_configuration_intake_object.
type APMUIAgentConfigurationIntakeObject struct {
	// AgentName The agent name is used by the UI to determine which settings to display.
	AgentName *string `json:"agent_name,omitempty"`

	// Service Service
	Service APMUIServiceObject `json:"service"`

	// Settings Agent configuration settings
	Settings APMUISettingsObject `json:"settings"`
}

// APMUIAgentConfigurationObject Agent configuration
type APMUIAgentConfigurationObject struct {
	// Timestamp Timestamp
	Timestamp float32 `json:"@timestamp"`

	// AgentName Agent name
	AgentName *string `json:"agent_name,omitempty"`

	// AppliedByAgent Applied by agent
	AppliedByAgent *bool `json:"applied_by_agent,omitempty"`

	// Etag `etag` is sent by the APM agent to indicate the `etag` of the last successfully applied configuration. If the `etag` matches an existing configuration its `applied_by_agent` property will be set to `true`. Every time a configuration is edited `applied_by_agent` is reset to `false`.
	Etag string `json:"etag"`

	// Service Service
	Service APMUIServiceObject `json:"service"`

	// Settings Agent configuration settings
	Settings APMUISettingsObject `json:"settings"`
}

// APMUIAgentConfigurationsResponse defines model for APM_UI_agent_configurations_response.
type APMUIAgentConfigurationsResponse struct {
	// Configurations Agent configuration
	Configurations *[]APMUIAgentConfigurationObject `json:"configurations,omitempty"`
}

// APMUIDeleteAgentConfigurationsResponse defines model for APM_UI_delete_agent_configurations_response.
type APMUIDeleteAgentConfigurationsResponse struct {
	// Result Result
	Result *string `json:"result,omitempty"`
}

// APMUIDeleteServiceObject Service
type APMUIDeleteServiceObject struct {
	// Service Service
	Service APMUIServiceObject `json:"service"`
}

// APMUIServiceObject Service
type APMUIServiceObject struct {
	// Environment The environment of the service.
	Environment *string `json:"environment,omitempty"`

	// Name The name of the service.
	Name *string `json:"name,omitempty"`
}

// APMUISettingsObject Agent configuration settings
type APMUISettingsObject map[string]string

// DataViews400Response defines model for Data_views_400_response.
type DataViews400Response struct {
	Error      string  `json:"error"`
	Message    string  `json:"message"`
	StatusCode float32 `json:"statusCode"`
}

// DataViews404Response defines model for Data_views_404_response.
type DataViews404Response struct {
	Error      *DataViews404ResponseError      `json:"error,omitempty"`
	Message    *string                         `json:"message,omitempty"`
	StatusCode *DataViews404ResponseStatusCode `json:"statusCode,omitempty"`
}

// DataViews404ResponseError defines model for DataViews404Response.Error.
type DataViews404ResponseError string

// DataViews404ResponseStatusCode defines model for DataViews404Response.StatusCode.
type DataViews404ResponseStatusCode int

// DataViewsAllownoindex Allows the data view saved object to exist before the data is available.
type DataViewsAllownoindex = bool

// DataViewsCreateDataViewRequestObject defines model for Data_views_create_data_view_request_object.
type DataViewsCreateDataViewRequestObject struct {
	// DataView The data view object.
	DataView DataViewsCreateDataViewRequestObjectInner `json:"data_view"`

	// Override Override an existing data view if a data view with the provided title already exists.
	Override *bool `json:"override,omitempty"`
}

// DataViewsCreateDataViewRequestObjectInner The data view object.
type DataViewsCreateDataViewRequestObjectInner struct {
	// AllowNoIndex Allows the data view saved object to exist before the data is available.
	AllowNoIndex *DataViewsAllownoindex          `json:"allowNoIndex,omitempty"`
	FieldAttrs   *map[string]DataViewsFieldattrs `json:"fieldAttrs,omitempty"`

	// FieldFormats A map of field formats by field name.
	FieldFormats *DataViewsFieldformats  `json:"fieldFormats,omitempty"`
	Fields       *map[string]interface{} `json:"fields,omitempty"`
	Id           *string                 `json:"id,omitempty"`

	// Name The data view name.
	Name *string `json:"name,omitempty"`

	// Namespaces An array of space identifiers for sharing the data view between multiple spaces.
	Namespaces      *DataViewsNamespaces                 `json:"namespaces,omitempty"`
	RuntimeFieldMap *map[string]DataViewsRuntimefieldmap `json:"runtimeFieldMap,omitempty"`

	// SourceFilters The array of field names you want to filter out in Discover.
	SourceFilters *DataViewsSourcefilters `json:"sourceFilters,omitempty"`

	// TimeFieldName The timestamp field name, which you use for time-based data views.
	TimeFieldName *DataViewsTimefieldname `json:"timeFieldName,omitempty"`

	// Title Comma-separated list of data streams, indices, and aliases that you want to search. Supports wildcards (`*`).
	Title DataViewsTitle `json:"title"`

	// Type When set to `rollup`, identifies the rollup data views.
	Type *DataViewsType `json:"type,omitempty"`

	// TypeMeta When you use rollup indices, contains the field list for the rollup data view API endpoints.
	TypeMeta *DataViewsTypemeta `json:"typeMeta,omitempty"`
	Version  *string            `json:"version,omitempty"`
}

// DataViewsDataViewResponseObject defines model for Data_views_data_view_response_object.
type DataViewsDataViewResponseObject struct {
	DataView *DataViewsDataViewResponseObjectInner `json:"data_view,omitempty"`
}

// DataViewsDataViewResponseObjectInner defines model for Data_views_data_view_response_object_inner.
type DataViewsDataViewResponseObjectInner struct {
	// AllowNoIndex Allows the data view saved object to exist before the data is available.
	AllowNoIndex *DataViewsAllownoindex          `json:"allowNoIndex,omitempty"`
	FieldAttrs   *map[string]DataViewsFieldattrs `json:"fieldAttrs,omitempty"`

	// FieldFormats A map of field formats by field name.
	FieldFormats *DataViewsFieldformats  `json:"fieldFormats,omitempty"`
	Fields       *map[string]interface{} `json:"fields,omitempty"`
	Id           *string                 `json:"id,omitempty"`

	// Name The data view name.
	Name *string `json:"name,omitempty"`

	// Namespaces An array of space identifiers for sharing the data view between multiple spaces.
	Namespaces      *DataViewsNamespaces                 `json:"namespaces,omitempty"`
	RuntimeFieldMap *map[string]DataViewsRuntimefieldmap `json:"runtimeFieldMap,omitempty"`

	// SourceFilters The array of field names you want to filter out in Discover.
	SourceFilters *DataViewsSourcefilters `json:"sourceFilters,omitempty"`

	// TimeFieldName The timestamp field name, which you use for time-based data views.
	TimeFieldName *DataViewsTimefieldname `json:"timeFieldName,omitempty"`

	// Title Comma-separated list of data streams, indices, and aliases that you want to search. Supports wildcards (`*`).
	Title *DataViewsTitle `json:"title,omitempty"`

	// TypeMeta When you use rollup indices, contains the field list for the rollup data view API endpoints.
	TypeMeta *DataViewsTypemetaResponse `json:"typeMeta,omitempty"`
	Version  *string                    `json:"version,omitempty"`
}

// DataViewsFieldattrs A map of field attributes by field name.
type DataViewsFieldattrs struct {
	// Count Popularity count for the field.
	Count *int `json:"count,omitempty"`

	// CustomDescription Custom description for the field.
	CustomDescription *string `json:"customDescription,omitempty"`

	// CustomLabel Custom label for the field.
	CustomLabel *string `json:"customLabel,omitempty"`
}

// DataViewsFieldformat defines model for Data_views_fieldformat.
type DataViewsFieldformat struct {
	Id     *string                     `json:"id,omitempty"`
	Params *DataViewsFieldformatParams `json:"params,omitempty"`
}

// DataViewsFieldformatParams defines model for Data_views_fieldformat_params.
type DataViewsFieldformatParams struct {
	Colors                 *[]DataViewsFieldformatParamsColor  `json:"colors,omitempty"`
	FieldLength            *int                                `json:"fieldLength,omitempty"`
	FieldType              *string                             `json:"fieldType,omitempty"`
	Height                 *int                                `json:"height,omitempty"`
	IncludeSpaceWithSuffix *bool                               `json:"includeSpaceWithSuffix,omitempty"`
	InputFormat            *string                             `json:"inputFormat,omitempty"`
	LabelTemplate          *string                             `json:"labelTemplate,omitempty"`
	LookupEntries          *[]DataViewsFieldformatParamsLookup `json:"lookupEntries,omitempty"`
	OutputFormat           *string                             `json:"outputFormat,omitempty"`
	OutputPrecision        *int                                `json:"outputPrecision,omitempty"`
	Pattern                *string                             `json:"pattern,omitempty"`
	Timezone               *string                             `json:"timezone,omitempty"`
	Transform              *string                             `json:"transform,omitempty"`
	Type                   *string                             `json:"type,omitempty"`
	UnknownKeyValue        *string                             `json:"unknownKeyValue,omitempty"`
	UrlTemplate            *string                             `json:"urlTemplate,omitempty"`
	UseShortSuffix         *bool                               `json:"useShortSuffix,omitempty"`
	Width                  *int                                `json:"width,omitempty"`
}

// DataViewsFieldformatParamsColor defines model for Data_views_fieldformat_params_color.
type DataViewsFieldformatParamsColor struct {
	Background *string `json:"background,omitempty"`
	Range      *string `json:"range,omitempty"`
	Regex      *string `json:"regex,omitempty"`
	Text       *string `json:"text,omitempty"`
}

// DataViewsFieldformatParamsLookup defines model for Data_views_fieldformat_params_lookup.
type DataViewsFieldformatParamsLookup struct {
	Key   *string `json:"key,omitempty"`
	Value *string `json:"value,omitempty"`
}

// DataViewsFieldformats A map of field formats by field name.
type DataViewsFieldformats map[string]DataViewsFieldformat

// DataViewsNamespaces An array of space identifiers for sharing the data view between multiple spaces.
type DataViewsNamespaces = []string

// DataViewsRuntimefieldmap A map of runtime field definitions by field name.
type DataViewsRuntimefieldmap struct {
	Script DataViewsRuntimefieldmapScript `json:"script"`

	// Type Mapping type of the runtime field.
	Type string `json:"type"`
}

// DataViewsRuntimefieldmapScript defines model for Data_views_runtimefieldmap_script.
type DataViewsRuntimefieldmapScript struct {
	// Source Script for the runtime field.
	Source *string `json:"source,omitempty"`
}

// DataViewsSourcefilterItem defines model for Data_views_sourcefilter_item.
type DataViewsSourcefilterItem struct {
	Value string `json:"value"`
}

// DataViewsSourcefilters The array of field names you want to filter out in Discover.
type DataViewsSourcefilters = []DataViewsSourcefilterItem

// DataViewsTimefieldname The timestamp field name, which you use for time-based data views.
type DataViewsTimefieldname = string

// DataViewsTitle Comma-separated list of data streams, indices, and aliases that you want to search. Supports wildcards (`*`).
type DataViewsTitle = string

// DataViewsType When set to `rollup`, identifies the rollup data views.
type DataViewsType = string

// DataViewsTypemeta When you use rollup indices, contains the field list for the rollup data view API endpoints.
type DataViewsTypemeta struct {
	// Aggs A map of rollup restrictions by aggregation type and field name.
	Aggs map[string]interface{} `json:"aggs"`

	// Params Properties for retrieving rollup fields.
	Params map[string]interface{} `json:"params"`
}

// DataViewsTypemetaResponse When you use rollup indices, contains the field list for the rollup data view API endpoints.
type DataViewsTypemetaResponse struct {
	// Aggs A map of rollup restrictions by aggregation type and field name.
	Aggs *map[string]interface{} `json:"aggs,omitempty"`

	// Params Properties for retrieving rollup fields.
	Params *map[string]interface{} `json:"params,omitempty"`
}

// DataViewsUpdateDataViewRequestObject defines model for Data_views_update_data_view_request_object.
type DataViewsUpdateDataViewRequestObject struct {
	// DataView The data view properties you want to update. Only the specified properties are updated in the data view. Unspecified fields stay as they are persisted.
	DataView DataViewsUpdateDataViewRequestObjectInner `json:"data_view"`

	// RefreshFields Reloads the data view fields after the data view is updated.
	RefreshFields *bool `json:"refresh_fields,omitempty"`
}

// DataViewsUpdateDataViewRequestObjectInner The data view properties you want to update. Only the specified properties are updated in the data view. Unspecified fields stay as they are persisted.
type DataViewsUpdateDataViewRequestObjectInner struct {
	// AllowNoIndex Allows the data view saved object to exist before the data is available.
	AllowNoIndex *DataViewsAllownoindex `json:"allowNoIndex,omitempty"`

	// FieldFormats A map of field formats by field name.
	FieldFormats    *DataViewsFieldformats               `json:"fieldFormats,omitempty"`
	Fields          *map[string]interface{}              `json:"fields,omitempty"`
	Name            *string                              `json:"name,omitempty"`
	RuntimeFieldMap *map[string]DataViewsRuntimefieldmap `json:"runtimeFieldMap,omitempty"`

	// SourceFilters The array of field names you want to filter out in Discover.
	SourceFilters *DataViewsSourcefilters `json:"sourceFilters,omitempty"`

	// TimeFieldName The timestamp field name, which you use for time-based data views.
	TimeFieldName *DataViewsTimefieldname `json:"timeFieldName,omitempty"`

	// Title Comma-separated list of data streams, indices, and aliases that you want to search. Supports wildcards (`*`).
	Title *DataViewsTitle `json:"title,omitempty"`

	// Type When set to `rollup`, identifies the rollup data views.
	Type *DataViewsType `json:"type,omitempty"`

	// TypeMeta When you use rollup indices, contains the field list for the rollup data view API endpoints.
	TypeMeta *DataViewsTypemeta `json:"typeMeta,omitempty"`
}

// SecurityDetectionsAPIAlertSuppression Defines alert suppression configuration.
type SecurityDetectionsAPIAlertSuppression struct {
	Duration *SecurityDetectionsAPIAlertSuppressionDuration `json:"duration,omitempty"`
	GroupBy  SecurityDetectionsAPIAlertSuppressionGroupBy   `json:"group_by"`

	// MissingFieldsStrategy Describes how alerts will be generated for documents with missing suppress by fields:
	// doNotSuppress - per each document a separate alert will be created
	// suppress - only alert will be created per suppress by bucket
	MissingFieldsStrategy *SecurityDetectionsAPIAlertSuppressionMissingFieldsStrategy `json:"missing_fields_strategy,omitempty"`
}

// SecurityDetectionsAPIAlertSuppressionDuration defines model for Security_Detections_API_AlertSuppressionDuration.
type SecurityDetectionsAPIAlertSuppressionDuration struct {
	// Unit Time unit
	Unit  SecurityDetectionsAPIAlertSuppressionDurationUnit `json:"unit"`
	Value int                                               `json:"value"`
}

// SecurityDetectionsAPIAlertSuppressionDurationUnit Time unit
type SecurityDetectionsAPIAlertSuppressionDurationUnit string

// SecurityDetectionsAPIAlertSuppressionGroupBy defines model for Security_Detections_API_AlertSuppressionGroupBy.
type SecurityDetectionsAPIAlertSuppressionGroupBy = []string

// SecurityDetectionsAPIAlertSuppressionMissingFieldsStrategy Describes how alerts will be generated for documents with missing suppress by fields:
// doNotSuppress - per each document a separate alert will be created
// suppress - only alert will be created per suppress by bucket
type SecurityDetectionsAPIAlertSuppressionMissingFieldsStrategy string

// SecurityDetectionsAPIAlertsIndex (deprecated) Has no effect.
type SecurityDetectionsAPIAlertsIndex = string

// SecurityDetectionsAPIAlertsIndexNamespace Has no effect.
type SecurityDetectionsAPIAlertsIndexNamespace = string

// SecurityDetectionsAPIAnomalyThreshold Anomaly score threshold above which the rule creates an alert. Valid values are from 0 to 100.
type SecurityDetectionsAPIAnomalyThreshold = int

// SecurityDetectionsAPIBuildingBlockType Determines if the rule acts as a building block. If yes, the value must be `default`.
// By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
// For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
type SecurityDetectionsAPIBuildingBlockType = string

// SecurityDetectionsAPIConcurrentSearches defines model for Security_Detections_API_ConcurrentSearches.
type SecurityDetectionsAPIConcurrentSearches = int

// SecurityDetectionsAPIDataViewId defines model for Security_Detections_API_DataViewId.
type SecurityDetectionsAPIDataViewId = string

// SecurityDetectionsAPIDefaultParams defines model for Security_Detections_API_DefaultParams.
type SecurityDetectionsAPIDefaultParams struct {
	Command SecurityDetectionsAPIDefaultParamsCommand `json:"command"`
	Comment *string                                   `json:"comment,omitempty"`
}

// SecurityDetectionsAPIDefaultParamsCommand defines model for SecurityDetectionsAPIDefaultParams.Command.
type SecurityDetectionsAPIDefaultParamsCommand string

// SecurityDetectionsAPIEcsMapping Map Osquery results columns or static values to Elastic Common Schema (ECS) fields. Example: "ecs_mapping": {"process.pid": {"field": "pid"}}
type SecurityDetectionsAPIEcsMapping map[string]struct {
	Field *string                                `json:"field,omitempty"`
	Value *SecurityDetectionsAPIEcsMapping_Value `json:"value,omitempty"`
}

// SecurityDetectionsAPIEcsMappingValue0 defines model for .
type SecurityDetectionsAPIEcsMappingValue0 = string

// SecurityDetectionsAPIEcsMappingValue1 defines model for .
type SecurityDetectionsAPIEcsMappingValue1 = []string

// SecurityDetectionsAPIEcsMapping_Value defines model for SecurityDetectionsAPIEcsMapping.Value.
type SecurityDetectionsAPIEcsMapping_Value struct {
	union json.RawMessage
}

// SecurityDetectionsAPIEndpointResponseAction defines model for Security_Detections_API_EndpointResponseAction.
type SecurityDetectionsAPIEndpointResponseAction struct {
	ActionTypeId SecurityDetectionsAPIEndpointResponseActionActionTypeId `json:"action_type_id"`
	Params       SecurityDetectionsAPIEndpointResponseAction_Params      `json:"params"`
}

// SecurityDetectionsAPIEndpointResponseActionActionTypeId defines model for SecurityDetectionsAPIEndpointResponseAction.ActionTypeId.
type SecurityDetectionsAPIEndpointResponseActionActionTypeId string

// SecurityDetectionsAPIEndpointResponseAction_Params defines model for SecurityDetectionsAPIEndpointResponseAction.Params.
type SecurityDetectionsAPIEndpointResponseAction_Params struct {
	union json.RawMessage
}

// SecurityDetectionsAPIEqlOptionalFields defines model for Security_Detections_API_EqlOptionalFields.
type SecurityDetectionsAPIEqlOptionalFields struct {
	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression      *SecurityDetectionsAPIAlertSuppression      `json:"alert_suppression,omitempty"`
	DataViewId            *SecurityDetectionsAPIDataViewId            `json:"data_view_id,omitempty"`
	EventCategoryOverride *SecurityDetectionsAPIEventCategoryOverride `json:"event_category_override,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`

	// TiebreakerField Sets a secondary field for sorting events
	TiebreakerField *SecurityDetectionsAPITiebreakerField `json:"tiebreaker_field,omitempty"`

	// TimestampField Specifies the name of the event timestamp field used for sorting a sequence of events. Not to be confused with `timestamp_override`, which specifies the more general field used for querying events within a range. Defaults to the @timestamp ECS field.
	TimestampField *SecurityDetectionsAPITimestampField `json:"timestamp_field,omitempty"`
}

// SecurityDetectionsAPIEqlQueryLanguage defines model for Security_Detections_API_EqlQueryLanguage.
type SecurityDetectionsAPIEqlQueryLanguage string

// SecurityDetectionsAPIEqlRequiredFields defines model for Security_Detections_API_EqlRequiredFields.
type SecurityDetectionsAPIEqlRequiredFields struct {
	Language SecurityDetectionsAPIEqlQueryLanguage `json:"language"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// Type Rule type
	Type SecurityDetectionsAPIEqlRequiredFieldsType `json:"type"`
}

// SecurityDetectionsAPIEqlRequiredFieldsType Rule type
type SecurityDetectionsAPIEqlRequiredFieldsType string

// SecurityDetectionsAPIEqlRule defines model for Security_Detections_API_EqlRule.
type SecurityDetectionsAPIEqlRule struct {
	// Actions Array defining the automated actions (notifications) taken when alerts are generated.
	Actions []SecurityDetectionsAPIRuleAction `json:"actions"`

	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression                `json:"alert_suppression,omitempty"`
	AliasPurpose     *SecurityDetectionsAPISavedObjectResolveAliasPurpose  `json:"alias_purpose,omitempty"`
	AliasTargetId    *SecurityDetectionsAPISavedObjectResolveAliasTargetId `json:"alias_target_id,omitempty"`

	// Author The rules author.
	Author SecurityDetectionsAPIRuleAuthorArray `json:"author"`

	// BuildingBlockType Determines if the rule acts as a building block. If yes, the value must be `default`.
	// By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
	// For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
	BuildingBlockType *SecurityDetectionsAPIBuildingBlockType `json:"building_block_type,omitempty"`
	CreatedAt         time.Time                               `json:"created_at"`
	CreatedBy         string                                  `json:"created_by"`
	DataViewId        *SecurityDetectionsAPIDataViewId        `json:"data_view_id,omitempty"`

	// Description The rules description.
	Description SecurityDetectionsAPIRuleDescription `json:"description"`

	// Enabled Determines whether the rule is enabled. Defaults to true.
	Enabled               SecurityDetectionsAPIIsRuleEnabled          `json:"enabled"`
	EventCategoryOverride *SecurityDetectionsAPIEventCategoryOverride `json:"event_category_override,omitempty"`
	ExceptionsList        []SecurityDetectionsAPIRuleExceptionList    `json:"exceptions_list"`

	// ExecutionSummary Summary of the last execution of a rule.
	// > info
	// > This field is under development and its usage or schema may change
	ExecutionSummary *SecurityDetectionsAPIRuleExecutionSummary `json:"execution_summary,omitempty"`

	// FalsePositives String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
	FalsePositives SecurityDetectionsAPIRuleFalsePositiveArray `json:"false_positives"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// From Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
	From SecurityDetectionsAPIRuleIntervalFrom `json:"from"`

	// Id A universally unique identifier
	Id SecurityDetectionsAPIRuleObjectId `json:"id"`

	// Immutable This field determines whether the rule is a prebuilt Elastic rule. It will be replaced with the `rule_source` field.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Immutable SecurityDetectionsAPIIsRuleImmutable `json:"immutable"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`

	// Interval Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
	Interval SecurityDetectionsAPIRuleInterval `json:"interval"`

	// InvestigationFields Schema for fields relating to investigation fields. These are user defined fields we use to highlight
	// in various features in the UI such as alert details flyout and exceptions auto-population from alert.
	InvestigationFields *SecurityDetectionsAPIInvestigationFields `json:"investigation_fields,omitempty"`
	Language            SecurityDetectionsAPIEqlQueryLanguage     `json:"language"`

	// License The rule's license.
	License *SecurityDetectionsAPIRuleLicense `json:"license,omitempty"`

	// MaxSignals Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
	// > info
	// > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
	MaxSignals SecurityDetectionsAPIMaxSignals `json:"max_signals"`

	// Meta Placeholder for metadata about the rule.
	// > info
	// > This field is overwritten when you save changes to the rules settings.
	Meta *SecurityDetectionsAPIRuleMetadata `json:"meta,omitempty"`

	// Name A human-readable name for the rule.
	Name SecurityDetectionsAPIRuleName `json:"name"`

	// Namespace Has no effect.
	Namespace *SecurityDetectionsAPIAlertsIndexNamespace `json:"namespace,omitempty"`

	// Note Notes to help investigate alerts produced by the rule.
	Note    *SecurityDetectionsAPIInvestigationGuide        `json:"note,omitempty"`
	Outcome *SecurityDetectionsAPISavedObjectResolveOutcome `json:"outcome,omitempty"`

	// OutputIndex (deprecated) Has no effect.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	OutputIndex *SecurityDetectionsAPIAlertsIndex `json:"output_index,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// References Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
	References          SecurityDetectionsAPIRuleReferenceArray      `json:"references"`
	RelatedIntegrations SecurityDetectionsAPIRelatedIntegrationArray `json:"related_integrations"`
	RequiredFields      SecurityDetectionsAPIRequiredFieldArray      `json:"required_fields"`
	ResponseActions     *[]SecurityDetectionsAPIResponseAction       `json:"response_actions,omitempty"`

	// Revision The rule's revision number.
	//
	// It represents the version of rule's object in Kibana. It is set to `0` when the rule is installed or created and then gets incremented on each update.
	// > info
	// > Not all updates to any rule fields will increment the revision. Only those fields that are considered static `rule parameters` can trigger revision increments. For example, an update to a rule's query or index fields will increment the rule's revision by `1`. However, changes to dynamic or technical fields like enabled or execution_summary will not cause revision increments.
	Revision SecurityDetectionsAPIRuleRevision `json:"revision"`

	// RiskScore A numerical representation of the alert's severity from 0 to 100, where:
	// * `0` - `21` represents low severity
	// * `22` - `47` represents medium severity
	// * `48` - `73` represents high severity
	// * `74` - `100` represents critical severity
	RiskScore SecurityDetectionsAPIRiskScore `json:"risk_score"`

	// RiskScoreMapping Overrides generated alerts' risk_score with a value from the source event
	RiskScoreMapping SecurityDetectionsAPIRiskScoreMapping `json:"risk_score_mapping"`

	// RuleId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
	RuleId SecurityDetectionsAPIRuleSignatureId `json:"rule_id"`

	// RuleNameOverride Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
	RuleNameOverride *SecurityDetectionsAPIRuleNameOverride `json:"rule_name_override,omitempty"`

	// RuleSource Discriminated union that determines whether the rule is internally sourced (created within the Kibana app) or has an external source, such as the Elastic Prebuilt rules repo.
	RuleSource SecurityDetectionsAPIRuleSource `json:"rule_source"`

	// Setup Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
	Setup SecurityDetectionsAPISetupGuide `json:"setup"`

	// Severity Severity level of alerts produced by the rule, which must be one of the following:
	// * `low`: Alerts that are of interest but generally not considered to be security incidents
	// * `medium`: Alerts that require investigation
	// * `high`: Alerts that require immediate investigation
	// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
	Severity SecurityDetectionsAPISeverity `json:"severity"`

	// SeverityMapping Overrides generated alerts' severity with values from the source event
	SeverityMapping SecurityDetectionsAPISeverityMapping `json:"severity_mapping"`

	// Tags String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
	Tags   SecurityDetectionsAPIRuleTagArray `json:"tags"`
	Threat SecurityDetectionsAPIThreatArray  `json:"threat"`

	// Throttle Defines how often rule actions are taken.
	Throttle *SecurityDetectionsAPIRuleActionThrottle `json:"throttle,omitempty"`

	// TiebreakerField Sets a secondary field for sorting events
	TiebreakerField *SecurityDetectionsAPITiebreakerField `json:"tiebreaker_field,omitempty"`

	// TimelineId Timeline template ID
	TimelineId *SecurityDetectionsAPITimelineTemplateId `json:"timeline_id,omitempty"`

	// TimelineTitle Timeline template title
	TimelineTitle *SecurityDetectionsAPITimelineTemplateTitle `json:"timeline_title,omitempty"`

	// TimestampField Specifies the name of the event timestamp field used for sorting a sequence of events. Not to be confused with `timestamp_override`, which specifies the more general field used for querying events within a range. Defaults to the @timestamp ECS field.
	TimestampField *SecurityDetectionsAPITimestampField `json:"timestamp_field,omitempty"`

	// TimestampOverride Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
	TimestampOverride *SecurityDetectionsAPITimestampOverride `json:"timestamp_override,omitempty"`

	// TimestampOverrideFallbackDisabled Disables the fallback to the event's @timestamp field
	TimestampOverrideFallbackDisabled *SecurityDetectionsAPITimestampOverrideFallbackDisabled `json:"timestamp_override_fallback_disabled,omitempty"`
	To                                SecurityDetectionsAPIRuleIntervalTo                     `json:"to"`

	// Type Rule type
	Type      SecurityDetectionsAPIEqlRuleType `json:"type"`
	UpdatedAt time.Time                        `json:"updated_at"`
	UpdatedBy string                           `json:"updated_by"`

	// Version The rule's version number.
	//
	// - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
	// - For custom rules it is set to `1` when the rule is created.
	// > info
	// > It is not incremented on each update. Compare this to the `revision` field.
	Version SecurityDetectionsAPIRuleVersion `json:"version"`
}

// SecurityDetectionsAPIEqlRuleType Rule type
type SecurityDetectionsAPIEqlRuleType string

// SecurityDetectionsAPIEqlRuleCreateFields defines model for Security_Detections_API_EqlRuleCreateFields.
type SecurityDetectionsAPIEqlRuleCreateFields struct {
	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression      *SecurityDetectionsAPIAlertSuppression      `json:"alert_suppression,omitempty"`
	DataViewId            *SecurityDetectionsAPIDataViewId            `json:"data_view_id,omitempty"`
	EventCategoryOverride *SecurityDetectionsAPIEventCategoryOverride `json:"event_category_override,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index    *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`
	Language SecurityDetectionsAPIEqlQueryLanguage   `json:"language"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// TiebreakerField Sets a secondary field for sorting events
	TiebreakerField *SecurityDetectionsAPITiebreakerField `json:"tiebreaker_field,omitempty"`

	// TimestampField Specifies the name of the event timestamp field used for sorting a sequence of events. Not to be confused with `timestamp_override`, which specifies the more general field used for querying events within a range. Defaults to the @timestamp ECS field.
	TimestampField *SecurityDetectionsAPITimestampField `json:"timestamp_field,omitempty"`

	// Type Rule type
	Type SecurityDetectionsAPIEqlRuleCreateFieldsType `json:"type"`
}

// SecurityDetectionsAPIEqlRuleCreateFieldsType Rule type
type SecurityDetectionsAPIEqlRuleCreateFieldsType string

// SecurityDetectionsAPIEqlRuleCreateProps defines model for Security_Detections_API_EqlRuleCreateProps.
type SecurityDetectionsAPIEqlRuleCreateProps struct {
	// Actions Array defining the automated actions (notifications) taken when alerts are generated.
	Actions *[]SecurityDetectionsAPIRuleAction `json:"actions,omitempty"`

	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression                `json:"alert_suppression,omitempty"`
	AliasPurpose     *SecurityDetectionsAPISavedObjectResolveAliasPurpose  `json:"alias_purpose,omitempty"`
	AliasTargetId    *SecurityDetectionsAPISavedObjectResolveAliasTargetId `json:"alias_target_id,omitempty"`

	// Author The rules author.
	Author *SecurityDetectionsAPIRuleAuthorArray `json:"author,omitempty"`

	// BuildingBlockType Determines if the rule acts as a building block. If yes, the value must be `default`.
	// By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
	// For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
	BuildingBlockType *SecurityDetectionsAPIBuildingBlockType `json:"building_block_type,omitempty"`
	DataViewId        *SecurityDetectionsAPIDataViewId        `json:"data_view_id,omitempty"`

	// Description The rules description.
	Description SecurityDetectionsAPIRuleDescription `json:"description"`

	// Enabled Determines whether the rule is enabled. Defaults to true.
	Enabled               *SecurityDetectionsAPIIsRuleEnabled         `json:"enabled,omitempty"`
	EventCategoryOverride *SecurityDetectionsAPIEventCategoryOverride `json:"event_category_override,omitempty"`
	ExceptionsList        *[]SecurityDetectionsAPIRuleExceptionList   `json:"exceptions_list,omitempty"`

	// FalsePositives String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
	FalsePositives *SecurityDetectionsAPIRuleFalsePositiveArray `json:"false_positives,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// From Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
	From *SecurityDetectionsAPIRuleIntervalFrom `json:"from,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`

	// Interval Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
	Interval *SecurityDetectionsAPIRuleInterval `json:"interval,omitempty"`

	// InvestigationFields Schema for fields relating to investigation fields. These are user defined fields we use to highlight
	// in various features in the UI such as alert details flyout and exceptions auto-population from alert.
	InvestigationFields *SecurityDetectionsAPIInvestigationFields `json:"investigation_fields,omitempty"`
	Language            SecurityDetectionsAPIEqlQueryLanguage     `json:"language"`

	// License The rule's license.
	License *SecurityDetectionsAPIRuleLicense `json:"license,omitempty"`

	// MaxSignals Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
	// > info
	// > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
	MaxSignals *SecurityDetectionsAPIMaxSignals `json:"max_signals,omitempty"`

	// Meta Placeholder for metadata about the rule.
	// > info
	// > This field is overwritten when you save changes to the rules settings.
	Meta *SecurityDetectionsAPIRuleMetadata `json:"meta,omitempty"`

	// Name A human-readable name for the rule.
	Name SecurityDetectionsAPIRuleName `json:"name"`

	// Namespace Has no effect.
	Namespace *SecurityDetectionsAPIAlertsIndexNamespace `json:"namespace,omitempty"`

	// Note Notes to help investigate alerts produced by the rule.
	Note    *SecurityDetectionsAPIInvestigationGuide        `json:"note,omitempty"`
	Outcome *SecurityDetectionsAPISavedObjectResolveOutcome `json:"outcome,omitempty"`

	// OutputIndex (deprecated) Has no effect.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	OutputIndex *SecurityDetectionsAPIAlertsIndex `json:"output_index,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// References Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
	References          *SecurityDetectionsAPIRuleReferenceArray      `json:"references,omitempty"`
	RelatedIntegrations *SecurityDetectionsAPIRelatedIntegrationArray `json:"related_integrations,omitempty"`

	// RequiredFields Elasticsearch fields and their types that need to be present for the rule to function.
	// > info
	// > The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.
	RequiredFields  *[]SecurityDetectionsAPIRequiredFieldInput `json:"required_fields,omitempty"`
	ResponseActions *[]SecurityDetectionsAPIResponseAction     `json:"response_actions,omitempty"`

	// RiskScore A numerical representation of the alert's severity from 0 to 100, where:
	// * `0` - `21` represents low severity
	// * `22` - `47` represents medium severity
	// * `48` - `73` represents high severity
	// * `74` - `100` represents critical severity
	RiskScore SecurityDetectionsAPIRiskScore `json:"risk_score"`

	// RiskScoreMapping Overrides generated alerts' risk_score with a value from the source event
	RiskScoreMapping *SecurityDetectionsAPIRiskScoreMapping `json:"risk_score_mapping,omitempty"`

	// RuleId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
	RuleId *SecurityDetectionsAPIRuleSignatureId `json:"rule_id,omitempty"`

	// RuleNameOverride Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
	RuleNameOverride *SecurityDetectionsAPIRuleNameOverride `json:"rule_name_override,omitempty"`

	// Setup Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
	Setup *SecurityDetectionsAPISetupGuide `json:"setup,omitempty"`

	// Severity Severity level of alerts produced by the rule, which must be one of the following:
	// * `low`: Alerts that are of interest but generally not considered to be security incidents
	// * `medium`: Alerts that require investigation
	// * `high`: Alerts that require immediate investigation
	// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
	Severity SecurityDetectionsAPISeverity `json:"severity"`

	// SeverityMapping Overrides generated alerts' severity with values from the source event
	SeverityMapping *SecurityDetectionsAPISeverityMapping `json:"severity_mapping,omitempty"`

	// Tags String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
	Tags   *SecurityDetectionsAPIRuleTagArray `json:"tags,omitempty"`
	Threat *SecurityDetectionsAPIThreatArray  `json:"threat,omitempty"`

	// Throttle Defines how often rule actions are taken.
	Throttle *SecurityDetectionsAPIRuleActionThrottle `json:"throttle,omitempty"`

	// TiebreakerField Sets a secondary field for sorting events
	TiebreakerField *SecurityDetectionsAPITiebreakerField `json:"tiebreaker_field,omitempty"`

	// TimelineId Timeline template ID
	TimelineId *SecurityDetectionsAPITimelineTemplateId `json:"timeline_id,omitempty"`

	// TimelineTitle Timeline template title
	TimelineTitle *SecurityDetectionsAPITimelineTemplateTitle `json:"timeline_title,omitempty"`

	// TimestampField Specifies the name of the event timestamp field used for sorting a sequence of events. Not to be confused with `timestamp_override`, which specifies the more general field used for querying events within a range. Defaults to the @timestamp ECS field.
	TimestampField *SecurityDetectionsAPITimestampField `json:"timestamp_field,omitempty"`

	// TimestampOverride Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
	TimestampOverride *SecurityDetectionsAPITimestampOverride `json:"timestamp_override,omitempty"`

	// TimestampOverrideFallbackDisabled Disables the fallback to the event's @timestamp field
	TimestampOverrideFallbackDisabled *SecurityDetectionsAPITimestampOverrideFallbackDisabled `json:"timestamp_override_fallback_disabled,omitempty"`
	To                                *SecurityDetectionsAPIRuleIntervalTo                    `json:"to,omitempty"`

	// Type Rule type
	Type SecurityDetectionsAPIEqlRuleCreatePropsType `json:"type"`

	// Version The rule's version number.
	//
	// - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
	// - For custom rules it is set to `1` when the rule is created.
	// > info
	// > It is not incremented on each update. Compare this to the `revision` field.
	Version *SecurityDetectionsAPIRuleVersion `json:"version,omitempty"`
}

// SecurityDetectionsAPIEqlRuleCreatePropsType Rule type
type SecurityDetectionsAPIEqlRuleCreatePropsType string

// SecurityDetectionsAPIEqlRuleResponseFields defines model for Security_Detections_API_EqlRuleResponseFields.
type SecurityDetectionsAPIEqlRuleResponseFields struct {
	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression      *SecurityDetectionsAPIAlertSuppression      `json:"alert_suppression,omitempty"`
	DataViewId            *SecurityDetectionsAPIDataViewId            `json:"data_view_id,omitempty"`
	EventCategoryOverride *SecurityDetectionsAPIEventCategoryOverride `json:"event_category_override,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index    *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`
	Language SecurityDetectionsAPIEqlQueryLanguage   `json:"language"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// TiebreakerField Sets a secondary field for sorting events
	TiebreakerField *SecurityDetectionsAPITiebreakerField `json:"tiebreaker_field,omitempty"`

	// TimestampField Specifies the name of the event timestamp field used for sorting a sequence of events. Not to be confused with `timestamp_override`, which specifies the more general field used for querying events within a range. Defaults to the @timestamp ECS field.
	TimestampField *SecurityDetectionsAPITimestampField `json:"timestamp_field,omitempty"`

	// Type Rule type
	Type SecurityDetectionsAPIEqlRuleResponseFieldsType `json:"type"`
}

// SecurityDetectionsAPIEqlRuleResponseFieldsType Rule type
type SecurityDetectionsAPIEqlRuleResponseFieldsType string

// SecurityDetectionsAPIEqlRuleUpdateProps defines model for Security_Detections_API_EqlRuleUpdateProps.
type SecurityDetectionsAPIEqlRuleUpdateProps struct {
	// Actions Array defining the automated actions (notifications) taken when alerts are generated.
	Actions *[]SecurityDetectionsAPIRuleAction `json:"actions,omitempty"`

	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression                `json:"alert_suppression,omitempty"`
	AliasPurpose     *SecurityDetectionsAPISavedObjectResolveAliasPurpose  `json:"alias_purpose,omitempty"`
	AliasTargetId    *SecurityDetectionsAPISavedObjectResolveAliasTargetId `json:"alias_target_id,omitempty"`

	// Author The rules author.
	Author *SecurityDetectionsAPIRuleAuthorArray `json:"author,omitempty"`

	// BuildingBlockType Determines if the rule acts as a building block. If yes, the value must be `default`.
	// By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
	// For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
	BuildingBlockType *SecurityDetectionsAPIBuildingBlockType `json:"building_block_type,omitempty"`
	DataViewId        *SecurityDetectionsAPIDataViewId        `json:"data_view_id,omitempty"`

	// Description The rules description.
	Description SecurityDetectionsAPIRuleDescription `json:"description"`

	// Enabled Determines whether the rule is enabled. Defaults to true.
	Enabled               *SecurityDetectionsAPIIsRuleEnabled         `json:"enabled,omitempty"`
	EventCategoryOverride *SecurityDetectionsAPIEventCategoryOverride `json:"event_category_override,omitempty"`
	ExceptionsList        *[]SecurityDetectionsAPIRuleExceptionList   `json:"exceptions_list,omitempty"`

	// FalsePositives String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
	FalsePositives *SecurityDetectionsAPIRuleFalsePositiveArray `json:"false_positives,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// From Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
	From *SecurityDetectionsAPIRuleIntervalFrom `json:"from,omitempty"`

	// Id A universally unique identifier
	Id *SecurityDetectionsAPIRuleObjectId `json:"id,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`

	// Interval Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
	Interval *SecurityDetectionsAPIRuleInterval `json:"interval,omitempty"`

	// InvestigationFields Schema for fields relating to investigation fields. These are user defined fields we use to highlight
	// in various features in the UI such as alert details flyout and exceptions auto-population from alert.
	InvestigationFields *SecurityDetectionsAPIInvestigationFields `json:"investigation_fields,omitempty"`
	Language            SecurityDetectionsAPIEqlQueryLanguage     `json:"language"`

	// License The rule's license.
	License *SecurityDetectionsAPIRuleLicense `json:"license,omitempty"`

	// MaxSignals Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
	// > info
	// > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
	MaxSignals *SecurityDetectionsAPIMaxSignals `json:"max_signals,omitempty"`

	// Meta Placeholder for metadata about the rule.
	// > info
	// > This field is overwritten when you save changes to the rules settings.
	Meta *SecurityDetectionsAPIRuleMetadata `json:"meta,omitempty"`

	// Name A human-readable name for the rule.
	Name SecurityDetectionsAPIRuleName `json:"name"`

	// Namespace Has no effect.
	Namespace *SecurityDetectionsAPIAlertsIndexNamespace `json:"namespace,omitempty"`

	// Note Notes to help investigate alerts produced by the rule.
	Note    *SecurityDetectionsAPIInvestigationGuide        `json:"note,omitempty"`
	Outcome *SecurityDetectionsAPISavedObjectResolveOutcome `json:"outcome,omitempty"`

	// OutputIndex (deprecated) Has no effect.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	OutputIndex *SecurityDetectionsAPIAlertsIndex `json:"output_index,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// References Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
	References          *SecurityDetectionsAPIRuleReferenceArray      `json:"references,omitempty"`
	RelatedIntegrations *SecurityDetectionsAPIRelatedIntegrationArray `json:"related_integrations,omitempty"`

	// RequiredFields Elasticsearch fields and their types that need to be present for the rule to function.
	// > info
	// > The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.
	RequiredFields  *[]SecurityDetectionsAPIRequiredFieldInput `json:"required_fields,omitempty"`
	ResponseActions *[]SecurityDetectionsAPIResponseAction     `json:"response_actions,omitempty"`

	// RiskScore A numerical representation of the alert's severity from 0 to 100, where:
	// * `0` - `21` represents low severity
	// * `22` - `47` represents medium severity
	// * `48` - `73` represents high severity
	// * `74` - `100` represents critical severity
	RiskScore SecurityDetectionsAPIRiskScore `json:"risk_score"`

	// RiskScoreMapping Overrides generated alerts' risk_score with a value from the source event
	RiskScoreMapping *SecurityDetectionsAPIRiskScoreMapping `json:"risk_score_mapping,omitempty"`

	// RuleId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
	RuleId *SecurityDetectionsAPIRuleSignatureId `json:"rule_id,omitempty"`

	// RuleNameOverride Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
	RuleNameOverride *SecurityDetectionsAPIRuleNameOverride `json:"rule_name_override,omitempty"`

	// Setup Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
	Setup *SecurityDetectionsAPISetupGuide `json:"setup,omitempty"`

	// Severity Severity level of alerts produced by the rule, which must be one of the following:
	// * `low`: Alerts that are of interest but generally not considered to be security incidents
	// * `medium`: Alerts that require investigation
	// * `high`: Alerts that require immediate investigation
	// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
	Severity SecurityDetectionsAPISeverity `json:"severity"`

	// SeverityMapping Overrides generated alerts' severity with values from the source event
	SeverityMapping *SecurityDetectionsAPISeverityMapping `json:"severity_mapping,omitempty"`

	// Tags String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
	Tags   *SecurityDetectionsAPIRuleTagArray `json:"tags,omitempty"`
	Threat *SecurityDetectionsAPIThreatArray  `json:"threat,omitempty"`

	// Throttle Defines how often rule actions are taken.
	Throttle *SecurityDetectionsAPIRuleActionThrottle `json:"throttle,omitempty"`

	// TiebreakerField Sets a secondary field for sorting events
	TiebreakerField *SecurityDetectionsAPITiebreakerField `json:"tiebreaker_field,omitempty"`

	// TimelineId Timeline template ID
	TimelineId *SecurityDetectionsAPITimelineTemplateId `json:"timeline_id,omitempty"`

	// TimelineTitle Timeline template title
	TimelineTitle *SecurityDetectionsAPITimelineTemplateTitle `json:"timeline_title,omitempty"`

	// TimestampField Specifies the name of the event timestamp field used for sorting a sequence of events. Not to be confused with `timestamp_override`, which specifies the more general field used for querying events within a range. Defaults to the @timestamp ECS field.
	TimestampField *SecurityDetectionsAPITimestampField `json:"timestamp_field,omitempty"`

	// TimestampOverride Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
	TimestampOverride *SecurityDetectionsAPITimestampOverride `json:"timestamp_override,omitempty"`

	// TimestampOverrideFallbackDisabled Disables the fallback to the event's @timestamp field
	TimestampOverrideFallbackDisabled *SecurityDetectionsAPITimestampOverrideFallbackDisabled `json:"timestamp_override_fallback_disabled,omitempty"`
	To                                *SecurityDetectionsAPIRuleIntervalTo                    `json:"to,omitempty"`

	// Type Rule type
	Type SecurityDetectionsAPIEqlRuleUpdatePropsType `json:"type"`

	// Version The rule's version number.
	//
	// - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
	// - For custom rules it is set to `1` when the rule is created.
	// > info
	// > It is not incremented on each update. Compare this to the `revision` field.
	Version *SecurityDetectionsAPIRuleVersion `json:"version,omitempty"`
}

// SecurityDetectionsAPIEqlRuleUpdatePropsType Rule type
type SecurityDetectionsAPIEqlRuleUpdatePropsType string

// SecurityDetectionsAPIEsqlQueryLanguage defines model for Security_Detections_API_EsqlQueryLanguage.
type SecurityDetectionsAPIEsqlQueryLanguage string

// SecurityDetectionsAPIEsqlRule defines model for Security_Detections_API_EsqlRule.
type SecurityDetectionsAPIEsqlRule struct {
	// Actions Array defining the automated actions (notifications) taken when alerts are generated.
	Actions []SecurityDetectionsAPIRuleAction `json:"actions"`

	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression                `json:"alert_suppression,omitempty"`
	AliasPurpose     *SecurityDetectionsAPISavedObjectResolveAliasPurpose  `json:"alias_purpose,omitempty"`
	AliasTargetId    *SecurityDetectionsAPISavedObjectResolveAliasTargetId `json:"alias_target_id,omitempty"`

	// Author The rules author.
	Author SecurityDetectionsAPIRuleAuthorArray `json:"author"`

	// BuildingBlockType Determines if the rule acts as a building block. If yes, the value must be `default`.
	// By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
	// For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
	BuildingBlockType *SecurityDetectionsAPIBuildingBlockType `json:"building_block_type,omitempty"`
	CreatedAt         time.Time                               `json:"created_at"`
	CreatedBy         string                                  `json:"created_by"`

	// Description The rules description.
	Description SecurityDetectionsAPIRuleDescription `json:"description"`

	// Enabled Determines whether the rule is enabled. Defaults to true.
	Enabled        SecurityDetectionsAPIIsRuleEnabled       `json:"enabled"`
	ExceptionsList []SecurityDetectionsAPIRuleExceptionList `json:"exceptions_list"`

	// ExecutionSummary Summary of the last execution of a rule.
	// > info
	// > This field is under development and its usage or schema may change
	ExecutionSummary *SecurityDetectionsAPIRuleExecutionSummary `json:"execution_summary,omitempty"`

	// FalsePositives String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
	FalsePositives SecurityDetectionsAPIRuleFalsePositiveArray `json:"false_positives"`

	// From Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
	From SecurityDetectionsAPIRuleIntervalFrom `json:"from"`

	// Id A universally unique identifier
	Id SecurityDetectionsAPIRuleObjectId `json:"id"`

	// Immutable This field determines whether the rule is a prebuilt Elastic rule. It will be replaced with the `rule_source` field.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Immutable SecurityDetectionsAPIIsRuleImmutable `json:"immutable"`

	// Interval Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
	Interval SecurityDetectionsAPIRuleInterval `json:"interval"`

	// InvestigationFields Schema for fields relating to investigation fields. These are user defined fields we use to highlight
	// in various features in the UI such as alert details flyout and exceptions auto-population from alert.
	InvestigationFields *SecurityDetectionsAPIInvestigationFields `json:"investigation_fields,omitempty"`
	Language            SecurityDetectionsAPIEsqlQueryLanguage    `json:"language"`

	// License The rule's license.
	License *SecurityDetectionsAPIRuleLicense `json:"license,omitempty"`

	// MaxSignals Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
	// > info
	// > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
	MaxSignals SecurityDetectionsAPIMaxSignals `json:"max_signals"`

	// Meta Placeholder for metadata about the rule.
	// > info
	// > This field is overwritten when you save changes to the rules settings.
	Meta *SecurityDetectionsAPIRuleMetadata `json:"meta,omitempty"`

	// Name A human-readable name for the rule.
	Name SecurityDetectionsAPIRuleName `json:"name"`

	// Namespace Has no effect.
	Namespace *SecurityDetectionsAPIAlertsIndexNamespace `json:"namespace,omitempty"`

	// Note Notes to help investigate alerts produced by the rule.
	Note    *SecurityDetectionsAPIInvestigationGuide        `json:"note,omitempty"`
	Outcome *SecurityDetectionsAPISavedObjectResolveOutcome `json:"outcome,omitempty"`

	// OutputIndex (deprecated) Has no effect.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	OutputIndex *SecurityDetectionsAPIAlertsIndex `json:"output_index,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// References Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
	References          SecurityDetectionsAPIRuleReferenceArray      `json:"references"`
	RelatedIntegrations SecurityDetectionsAPIRelatedIntegrationArray `json:"related_integrations"`
	RequiredFields      SecurityDetectionsAPIRequiredFieldArray      `json:"required_fields"`
	ResponseActions     *[]SecurityDetectionsAPIResponseAction       `json:"response_actions,omitempty"`

	// Revision The rule's revision number.
	//
	// It represents the version of rule's object in Kibana. It is set to `0` when the rule is installed or created and then gets incremented on each update.
	// > info
	// > Not all updates to any rule fields will increment the revision. Only those fields that are considered static `rule parameters` can trigger revision increments. For example, an update to a rule's query or index fields will increment the rule's revision by `1`. However, changes to dynamic or technical fields like enabled or execution_summary will not cause revision increments.
	Revision SecurityDetectionsAPIRuleRevision `json:"revision"`

	// RiskScore A numerical representation of the alert's severity from 0 to 100, where:
	// * `0` - `21` represents low severity
	// * `22` - `47` represents medium severity
	// * `48` - `73` represents high severity
	// * `74` - `100` represents critical severity
	RiskScore SecurityDetectionsAPIRiskScore `json:"risk_score"`

	// RiskScoreMapping Overrides generated alerts' risk_score with a value from the source event
	RiskScoreMapping SecurityDetectionsAPIRiskScoreMapping `json:"risk_score_mapping"`

	// RuleId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
	RuleId SecurityDetectionsAPIRuleSignatureId `json:"rule_id"`

	// RuleNameOverride Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
	RuleNameOverride *SecurityDetectionsAPIRuleNameOverride `json:"rule_name_override,omitempty"`

	// RuleSource Discriminated union that determines whether the rule is internally sourced (created within the Kibana app) or has an external source, such as the Elastic Prebuilt rules repo.
	RuleSource SecurityDetectionsAPIRuleSource `json:"rule_source"`

	// Setup Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
	Setup SecurityDetectionsAPISetupGuide `json:"setup"`

	// Severity Severity level of alerts produced by the rule, which must be one of the following:
	// * `low`: Alerts that are of interest but generally not considered to be security incidents
	// * `medium`: Alerts that require investigation
	// * `high`: Alerts that require immediate investigation
	// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
	Severity SecurityDetectionsAPISeverity `json:"severity"`

	// SeverityMapping Overrides generated alerts' severity with values from the source event
	SeverityMapping SecurityDetectionsAPISeverityMapping `json:"severity_mapping"`

	// Tags String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
	Tags   SecurityDetectionsAPIRuleTagArray `json:"tags"`
	Threat SecurityDetectionsAPIThreatArray  `json:"threat"`

	// Throttle Defines how often rule actions are taken.
	Throttle *SecurityDetectionsAPIRuleActionThrottle `json:"throttle,omitempty"`

	// TimelineId Timeline template ID
	TimelineId *SecurityDetectionsAPITimelineTemplateId `json:"timeline_id,omitempty"`

	// TimelineTitle Timeline template title
	TimelineTitle *SecurityDetectionsAPITimelineTemplateTitle `json:"timeline_title,omitempty"`

	// TimestampOverride Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
	TimestampOverride *SecurityDetectionsAPITimestampOverride `json:"timestamp_override,omitempty"`

	// TimestampOverrideFallbackDisabled Disables the fallback to the event's @timestamp field
	TimestampOverrideFallbackDisabled *SecurityDetectionsAPITimestampOverrideFallbackDisabled `json:"timestamp_override_fallback_disabled,omitempty"`
	To                                SecurityDetectionsAPIRuleIntervalTo                     `json:"to"`

	// Type Rule type
	Type      SecurityDetectionsAPIEsqlRuleType `json:"type"`
	UpdatedAt time.Time                         `json:"updated_at"`
	UpdatedBy string                            `json:"updated_by"`

	// Version The rule's version number.
	//
	// - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
	// - For custom rules it is set to `1` when the rule is created.
	// > info
	// > It is not incremented on each update. Compare this to the `revision` field.
	Version SecurityDetectionsAPIRuleVersion `json:"version"`
}

// SecurityDetectionsAPIEsqlRuleType Rule type
type SecurityDetectionsAPIEsqlRuleType string

// SecurityDetectionsAPIEsqlRuleCreateFields defines model for Security_Detections_API_EsqlRuleCreateFields.
type SecurityDetectionsAPIEsqlRuleCreateFields struct {
	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression `json:"alert_suppression,omitempty"`
	Language         SecurityDetectionsAPIEsqlQueryLanguage `json:"language"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// Type Rule type
	Type SecurityDetectionsAPIEsqlRuleCreateFieldsType `json:"type"`
}

// SecurityDetectionsAPIEsqlRuleCreateFieldsType Rule type
type SecurityDetectionsAPIEsqlRuleCreateFieldsType string

// SecurityDetectionsAPIEsqlRuleCreateProps defines model for Security_Detections_API_EsqlRuleCreateProps.
type SecurityDetectionsAPIEsqlRuleCreateProps struct {
	// Actions Array defining the automated actions (notifications) taken when alerts are generated.
	Actions *[]SecurityDetectionsAPIRuleAction `json:"actions,omitempty"`

	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression                `json:"alert_suppression,omitempty"`
	AliasPurpose     *SecurityDetectionsAPISavedObjectResolveAliasPurpose  `json:"alias_purpose,omitempty"`
	AliasTargetId    *SecurityDetectionsAPISavedObjectResolveAliasTargetId `json:"alias_target_id,omitempty"`

	// Author The rules author.
	Author *SecurityDetectionsAPIRuleAuthorArray `json:"author,omitempty"`

	// BuildingBlockType Determines if the rule acts as a building block. If yes, the value must be `default`.
	// By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
	// For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
	BuildingBlockType *SecurityDetectionsAPIBuildingBlockType `json:"building_block_type,omitempty"`

	// Description The rules description.
	Description SecurityDetectionsAPIRuleDescription `json:"description"`

	// Enabled Determines whether the rule is enabled. Defaults to true.
	Enabled        *SecurityDetectionsAPIIsRuleEnabled       `json:"enabled,omitempty"`
	ExceptionsList *[]SecurityDetectionsAPIRuleExceptionList `json:"exceptions_list,omitempty"`

	// FalsePositives String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
	FalsePositives *SecurityDetectionsAPIRuleFalsePositiveArray `json:"false_positives,omitempty"`

	// From Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
	From *SecurityDetectionsAPIRuleIntervalFrom `json:"from,omitempty"`

	// Interval Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
	Interval *SecurityDetectionsAPIRuleInterval `json:"interval,omitempty"`

	// InvestigationFields Schema for fields relating to investigation fields. These are user defined fields we use to highlight
	// in various features in the UI such as alert details flyout and exceptions auto-population from alert.
	InvestigationFields *SecurityDetectionsAPIInvestigationFields `json:"investigation_fields,omitempty"`
	Language            SecurityDetectionsAPIEsqlQueryLanguage    `json:"language"`

	// License The rule's license.
	License *SecurityDetectionsAPIRuleLicense `json:"license,omitempty"`

	// MaxSignals Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
	// > info
	// > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
	MaxSignals *SecurityDetectionsAPIMaxSignals `json:"max_signals,omitempty"`

	// Meta Placeholder for metadata about the rule.
	// > info
	// > This field is overwritten when you save changes to the rules settings.
	Meta *SecurityDetectionsAPIRuleMetadata `json:"meta,omitempty"`

	// Name A human-readable name for the rule.
	Name SecurityDetectionsAPIRuleName `json:"name"`

	// Namespace Has no effect.
	Namespace *SecurityDetectionsAPIAlertsIndexNamespace `json:"namespace,omitempty"`

	// Note Notes to help investigate alerts produced by the rule.
	Note    *SecurityDetectionsAPIInvestigationGuide        `json:"note,omitempty"`
	Outcome *SecurityDetectionsAPISavedObjectResolveOutcome `json:"outcome,omitempty"`

	// OutputIndex (deprecated) Has no effect.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	OutputIndex *SecurityDetectionsAPIAlertsIndex `json:"output_index,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// References Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
	References          *SecurityDetectionsAPIRuleReferenceArray      `json:"references,omitempty"`
	RelatedIntegrations *SecurityDetectionsAPIRelatedIntegrationArray `json:"related_integrations,omitempty"`

	// RequiredFields Elasticsearch fields and their types that need to be present for the rule to function.
	// > info
	// > The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.
	RequiredFields  *[]SecurityDetectionsAPIRequiredFieldInput `json:"required_fields,omitempty"`
	ResponseActions *[]SecurityDetectionsAPIResponseAction     `json:"response_actions,omitempty"`

	// RiskScore A numerical representation of the alert's severity from 0 to 100, where:
	// * `0` - `21` represents low severity
	// * `22` - `47` represents medium severity
	// * `48` - `73` represents high severity
	// * `74` - `100` represents critical severity
	RiskScore SecurityDetectionsAPIRiskScore `json:"risk_score"`

	// RiskScoreMapping Overrides generated alerts' risk_score with a value from the source event
	RiskScoreMapping *SecurityDetectionsAPIRiskScoreMapping `json:"risk_score_mapping,omitempty"`

	// RuleId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
	RuleId *SecurityDetectionsAPIRuleSignatureId `json:"rule_id,omitempty"`

	// RuleNameOverride Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
	RuleNameOverride *SecurityDetectionsAPIRuleNameOverride `json:"rule_name_override,omitempty"`

	// Setup Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
	Setup *SecurityDetectionsAPISetupGuide `json:"setup,omitempty"`

	// Severity Severity level of alerts produced by the rule, which must be one of the following:
	// * `low`: Alerts that are of interest but generally not considered to be security incidents
	// * `medium`: Alerts that require investigation
	// * `high`: Alerts that require immediate investigation
	// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
	Severity SecurityDetectionsAPISeverity `json:"severity"`

	// SeverityMapping Overrides generated alerts' severity with values from the source event
	SeverityMapping *SecurityDetectionsAPISeverityMapping `json:"severity_mapping,omitempty"`

	// Tags String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
	Tags   *SecurityDetectionsAPIRuleTagArray `json:"tags,omitempty"`
	Threat *SecurityDetectionsAPIThreatArray  `json:"threat,omitempty"`

	// Throttle Defines how often rule actions are taken.
	Throttle *SecurityDetectionsAPIRuleActionThrottle `json:"throttle,omitempty"`

	// TimelineId Timeline template ID
	TimelineId *SecurityDetectionsAPITimelineTemplateId `json:"timeline_id,omitempty"`

	// TimelineTitle Timeline template title
	TimelineTitle *SecurityDetectionsAPITimelineTemplateTitle `json:"timeline_title,omitempty"`

	// TimestampOverride Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
	TimestampOverride *SecurityDetectionsAPITimestampOverride `json:"timestamp_override,omitempty"`

	// TimestampOverrideFallbackDisabled Disables the fallback to the event's @timestamp field
	TimestampOverrideFallbackDisabled *SecurityDetectionsAPITimestampOverrideFallbackDisabled `json:"timestamp_override_fallback_disabled,omitempty"`
	To                                *SecurityDetectionsAPIRuleIntervalTo                    `json:"to,omitempty"`

	// Type Rule type
	Type SecurityDetectionsAPIEsqlRuleCreatePropsType `json:"type"`

	// Version The rule's version number.
	//
	// - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
	// - For custom rules it is set to `1` when the rule is created.
	// > info
	// > It is not incremented on each update. Compare this to the `revision` field.
	Version *SecurityDetectionsAPIRuleVersion `json:"version,omitempty"`
}

// SecurityDetectionsAPIEsqlRuleCreatePropsType Rule type
type SecurityDetectionsAPIEsqlRuleCreatePropsType string

// SecurityDetectionsAPIEsqlRuleOptionalFields defines model for Security_Detections_API_EsqlRuleOptionalFields.
type SecurityDetectionsAPIEsqlRuleOptionalFields struct {
	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression `json:"alert_suppression,omitempty"`
}

// SecurityDetectionsAPIEsqlRuleRequiredFields defines model for Security_Detections_API_EsqlRuleRequiredFields.
type SecurityDetectionsAPIEsqlRuleRequiredFields struct {
	Language SecurityDetectionsAPIEsqlQueryLanguage `json:"language"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// Type Rule type
	Type SecurityDetectionsAPIEsqlRuleRequiredFieldsType `json:"type"`
}

// SecurityDetectionsAPIEsqlRuleRequiredFieldsType Rule type
type SecurityDetectionsAPIEsqlRuleRequiredFieldsType string

// SecurityDetectionsAPIEsqlRuleResponseFields defines model for Security_Detections_API_EsqlRuleResponseFields.
type SecurityDetectionsAPIEsqlRuleResponseFields struct {
	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression `json:"alert_suppression,omitempty"`
	Language         SecurityDetectionsAPIEsqlQueryLanguage `json:"language"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// Type Rule type
	Type SecurityDetectionsAPIEsqlRuleResponseFieldsType `json:"type"`
}

// SecurityDetectionsAPIEsqlRuleResponseFieldsType Rule type
type SecurityDetectionsAPIEsqlRuleResponseFieldsType string

// SecurityDetectionsAPIEsqlRuleUpdateProps defines model for Security_Detections_API_EsqlRuleUpdateProps.
type SecurityDetectionsAPIEsqlRuleUpdateProps struct {
	// Actions Array defining the automated actions (notifications) taken when alerts are generated.
	Actions *[]SecurityDetectionsAPIRuleAction `json:"actions,omitempty"`

	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression                `json:"alert_suppression,omitempty"`
	AliasPurpose     *SecurityDetectionsAPISavedObjectResolveAliasPurpose  `json:"alias_purpose,omitempty"`
	AliasTargetId    *SecurityDetectionsAPISavedObjectResolveAliasTargetId `json:"alias_target_id,omitempty"`

	// Author The rules author.
	Author *SecurityDetectionsAPIRuleAuthorArray `json:"author,omitempty"`

	// BuildingBlockType Determines if the rule acts as a building block. If yes, the value must be `default`.
	// By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
	// For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
	BuildingBlockType *SecurityDetectionsAPIBuildingBlockType `json:"building_block_type,omitempty"`

	// Description The rules description.
	Description SecurityDetectionsAPIRuleDescription `json:"description"`

	// Enabled Determines whether the rule is enabled. Defaults to true.
	Enabled        *SecurityDetectionsAPIIsRuleEnabled       `json:"enabled,omitempty"`
	ExceptionsList *[]SecurityDetectionsAPIRuleExceptionList `json:"exceptions_list,omitempty"`

	// FalsePositives String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
	FalsePositives *SecurityDetectionsAPIRuleFalsePositiveArray `json:"false_positives,omitempty"`

	// From Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
	From *SecurityDetectionsAPIRuleIntervalFrom `json:"from,omitempty"`

	// Id A universally unique identifier
	Id *SecurityDetectionsAPIRuleObjectId `json:"id,omitempty"`

	// Interval Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
	Interval *SecurityDetectionsAPIRuleInterval `json:"interval,omitempty"`

	// InvestigationFields Schema for fields relating to investigation fields. These are user defined fields we use to highlight
	// in various features in the UI such as alert details flyout and exceptions auto-population from alert.
	InvestigationFields *SecurityDetectionsAPIInvestigationFields `json:"investigation_fields,omitempty"`
	Language            SecurityDetectionsAPIEsqlQueryLanguage    `json:"language"`

	// License The rule's license.
	License *SecurityDetectionsAPIRuleLicense `json:"license,omitempty"`

	// MaxSignals Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
	// > info
	// > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
	MaxSignals *SecurityDetectionsAPIMaxSignals `json:"max_signals,omitempty"`

	// Meta Placeholder for metadata about the rule.
	// > info
	// > This field is overwritten when you save changes to the rules settings.
	Meta *SecurityDetectionsAPIRuleMetadata `json:"meta,omitempty"`

	// Name A human-readable name for the rule.
	Name SecurityDetectionsAPIRuleName `json:"name"`

	// Namespace Has no effect.
	Namespace *SecurityDetectionsAPIAlertsIndexNamespace `json:"namespace,omitempty"`

	// Note Notes to help investigate alerts produced by the rule.
	Note    *SecurityDetectionsAPIInvestigationGuide        `json:"note,omitempty"`
	Outcome *SecurityDetectionsAPISavedObjectResolveOutcome `json:"outcome,omitempty"`

	// OutputIndex (deprecated) Has no effect.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	OutputIndex *SecurityDetectionsAPIAlertsIndex `json:"output_index,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// References Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
	References          *SecurityDetectionsAPIRuleReferenceArray      `json:"references,omitempty"`
	RelatedIntegrations *SecurityDetectionsAPIRelatedIntegrationArray `json:"related_integrations,omitempty"`

	// RequiredFields Elasticsearch fields and their types that need to be present for the rule to function.
	// > info
	// > The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.
	RequiredFields  *[]SecurityDetectionsAPIRequiredFieldInput `json:"required_fields,omitempty"`
	ResponseActions *[]SecurityDetectionsAPIResponseAction     `json:"response_actions,omitempty"`

	// RiskScore A numerical representation of the alert's severity from 0 to 100, where:
	// * `0` - `21` represents low severity
	// * `22` - `47` represents medium severity
	// * `48` - `73` represents high severity
	// * `74` - `100` represents critical severity
	RiskScore SecurityDetectionsAPIRiskScore `json:"risk_score"`

	// RiskScoreMapping Overrides generated alerts' risk_score with a value from the source event
	RiskScoreMapping *SecurityDetectionsAPIRiskScoreMapping `json:"risk_score_mapping,omitempty"`

	// RuleId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
	RuleId *SecurityDetectionsAPIRuleSignatureId `json:"rule_id,omitempty"`

	// RuleNameOverride Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
	RuleNameOverride *SecurityDetectionsAPIRuleNameOverride `json:"rule_name_override,omitempty"`

	// Setup Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
	Setup *SecurityDetectionsAPISetupGuide `json:"setup,omitempty"`

	// Severity Severity level of alerts produced by the rule, which must be one of the following:
	// * `low`: Alerts that are of interest but generally not considered to be security incidents
	// * `medium`: Alerts that require investigation
	// * `high`: Alerts that require immediate investigation
	// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
	Severity SecurityDetectionsAPISeverity `json:"severity"`

	// SeverityMapping Overrides generated alerts' severity with values from the source event
	SeverityMapping *SecurityDetectionsAPISeverityMapping `json:"severity_mapping,omitempty"`

	// Tags String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
	Tags   *SecurityDetectionsAPIRuleTagArray `json:"tags,omitempty"`
	Threat *SecurityDetectionsAPIThreatArray  `json:"threat,omitempty"`

	// Throttle Defines how often rule actions are taken.
	Throttle *SecurityDetectionsAPIRuleActionThrottle `json:"throttle,omitempty"`

	// TimelineId Timeline template ID
	TimelineId *SecurityDetectionsAPITimelineTemplateId `json:"timeline_id,omitempty"`

	// TimelineTitle Timeline template title
	TimelineTitle *SecurityDetectionsAPITimelineTemplateTitle `json:"timeline_title,omitempty"`

	// TimestampOverride Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
	TimestampOverride *SecurityDetectionsAPITimestampOverride `json:"timestamp_override,omitempty"`

	// TimestampOverrideFallbackDisabled Disables the fallback to the event's @timestamp field
	TimestampOverrideFallbackDisabled *SecurityDetectionsAPITimestampOverrideFallbackDisabled `json:"timestamp_override_fallback_disabled,omitempty"`
	To                                *SecurityDetectionsAPIRuleIntervalTo                    `json:"to,omitempty"`

	// Type Rule type
	Type SecurityDetectionsAPIEsqlRuleUpdatePropsType `json:"type"`

	// Version The rule's version number.
	//
	// - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
	// - For custom rules it is set to `1` when the rule is created.
	// > info
	// > It is not incremented on each update. Compare this to the `revision` field.
	Version *SecurityDetectionsAPIRuleVersion `json:"version,omitempty"`
}

// SecurityDetectionsAPIEsqlRuleUpdatePropsType Rule type
type SecurityDetectionsAPIEsqlRuleUpdatePropsType string

// SecurityDetectionsAPIEventCategoryOverride defines model for Security_Detections_API_EventCategoryOverride.
type SecurityDetectionsAPIEventCategoryOverride = string

// SecurityDetectionsAPIExceptionListType The exception type
type SecurityDetectionsAPIExceptionListType string

// SecurityDetectionsAPIExternalRuleSource Type of rule source for externally sourced rules, i.e. rules that have an external source, such as the Elastic Prebuilt rules repo.
type SecurityDetectionsAPIExternalRuleSource struct {
	// IsCustomized Determines whether an external/prebuilt rule has been customized by the user (i.e. any of its fields have been modified and diverged from the base value).
	IsCustomized SecurityDetectionsAPIIsExternalRuleCustomized `json:"is_customized"`
	Type         SecurityDetectionsAPIExternalRuleSourceType   `json:"type"`
}

// SecurityDetectionsAPIExternalRuleSourceType defines model for SecurityDetectionsAPIExternalRuleSource.Type.
type SecurityDetectionsAPIExternalRuleSourceType string

// SecurityDetectionsAPIHistoryWindowStart Start date to use when checking if a term has been seen before. Supports relative dates  for example, now-30d will search the last 30 days of data when checking if a term is new. We do not recommend using absolute dates, which can cause issues with rule performance due to querying increasing amounts of data over time.
type SecurityDetectionsAPIHistoryWindowStart = string

// SecurityDetectionsAPIIndexPatternArray Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
// > info
// > This field is not supported for ES|QL rules.
type SecurityDetectionsAPIIndexPatternArray = []string

// SecurityDetectionsAPIInternalRuleSource Type of rule source for internally sourced rules, i.e. created within the Kibana apps.
type SecurityDetectionsAPIInternalRuleSource struct {
	Type SecurityDetectionsAPIInternalRuleSourceType `json:"type"`
}

// SecurityDetectionsAPIInternalRuleSourceType defines model for SecurityDetectionsAPIInternalRuleSource.Type.
type SecurityDetectionsAPIInternalRuleSourceType string

// SecurityDetectionsAPIInvestigationFields Schema for fields relating to investigation fields. These are user defined fields we use to highlight
// in various features in the UI such as alert details flyout and exceptions auto-population from alert.
type SecurityDetectionsAPIInvestigationFields struct {
	FieldNames []SecurityDetectionsAPINonEmptyString `json:"field_names"`
}

// SecurityDetectionsAPIInvestigationGuide Notes to help investigate alerts produced by the rule.
type SecurityDetectionsAPIInvestigationGuide = string

// SecurityDetectionsAPIIsExternalRuleCustomized Determines whether an external/prebuilt rule has been customized by the user (i.e. any of its fields have been modified and diverged from the base value).
type SecurityDetectionsAPIIsExternalRuleCustomized = bool

// SecurityDetectionsAPIIsRuleEnabled Determines whether the rule is enabled. Defaults to true.
type SecurityDetectionsAPIIsRuleEnabled = bool

// SecurityDetectionsAPIIsRuleImmutable This field determines whether the rule is a prebuilt Elastic rule. It will be replaced with the `rule_source` field.
type SecurityDetectionsAPIIsRuleImmutable = bool

// SecurityDetectionsAPIItemsPerSearch defines model for Security_Detections_API_ItemsPerSearch.
type SecurityDetectionsAPIItemsPerSearch = int

// SecurityDetectionsAPIKqlQueryLanguage defines model for Security_Detections_API_KqlQueryLanguage.
type SecurityDetectionsAPIKqlQueryLanguage string

// SecurityDetectionsAPIMachineLearningJobId Machine learning job ID(s) the rule monitors for anomaly scores.
type SecurityDetectionsAPIMachineLearningJobId struct {
	union json.RawMessage
}

// SecurityDetectionsAPIMachineLearningJobId0 defines model for .
type SecurityDetectionsAPIMachineLearningJobId0 = string

// SecurityDetectionsAPIMachineLearningJobId1 defines model for .
type SecurityDetectionsAPIMachineLearningJobId1 = []string

// SecurityDetectionsAPIMachineLearningRule defines model for Security_Detections_API_MachineLearningRule.
type SecurityDetectionsAPIMachineLearningRule struct {
	// Actions Array defining the automated actions (notifications) taken when alerts are generated.
	Actions []SecurityDetectionsAPIRuleAction `json:"actions"`

	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression                `json:"alert_suppression,omitempty"`
	AliasPurpose     *SecurityDetectionsAPISavedObjectResolveAliasPurpose  `json:"alias_purpose,omitempty"`
	AliasTargetId    *SecurityDetectionsAPISavedObjectResolveAliasTargetId `json:"alias_target_id,omitempty"`

	// AnomalyThreshold Anomaly score threshold above which the rule creates an alert. Valid values are from 0 to 100.
	AnomalyThreshold SecurityDetectionsAPIAnomalyThreshold `json:"anomaly_threshold"`

	// Author The rules author.
	Author SecurityDetectionsAPIRuleAuthorArray `json:"author"`

	// BuildingBlockType Determines if the rule acts as a building block. If yes, the value must be `default`.
	// By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
	// For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
	BuildingBlockType *SecurityDetectionsAPIBuildingBlockType `json:"building_block_type,omitempty"`
	CreatedAt         time.Time                               `json:"created_at"`
	CreatedBy         string                                  `json:"created_by"`

	// Description The rules description.
	Description SecurityDetectionsAPIRuleDescription `json:"description"`

	// Enabled Determines whether the rule is enabled. Defaults to true.
	Enabled        SecurityDetectionsAPIIsRuleEnabled       `json:"enabled"`
	ExceptionsList []SecurityDetectionsAPIRuleExceptionList `json:"exceptions_list"`

	// ExecutionSummary Summary of the last execution of a rule.
	// > info
	// > This field is under development and its usage or schema may change
	ExecutionSummary *SecurityDetectionsAPIRuleExecutionSummary `json:"execution_summary,omitempty"`

	// FalsePositives String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
	FalsePositives SecurityDetectionsAPIRuleFalsePositiveArray `json:"false_positives"`

	// From Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
	From SecurityDetectionsAPIRuleIntervalFrom `json:"from"`

	// Id A universally unique identifier
	Id SecurityDetectionsAPIRuleObjectId `json:"id"`

	// Immutable This field determines whether the rule is a prebuilt Elastic rule. It will be replaced with the `rule_source` field.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Immutable SecurityDetectionsAPIIsRuleImmutable `json:"immutable"`

	// Interval Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
	Interval SecurityDetectionsAPIRuleInterval `json:"interval"`

	// InvestigationFields Schema for fields relating to investigation fields. These are user defined fields we use to highlight
	// in various features in the UI such as alert details flyout and exceptions auto-population from alert.
	InvestigationFields *SecurityDetectionsAPIInvestigationFields `json:"investigation_fields,omitempty"`

	// License The rule's license.
	License *SecurityDetectionsAPIRuleLicense `json:"license,omitempty"`

	// MachineLearningJobId Machine learning job ID(s) the rule monitors for anomaly scores.
	MachineLearningJobId SecurityDetectionsAPIMachineLearningJobId `json:"machine_learning_job_id"`

	// MaxSignals Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
	// > info
	// > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
	MaxSignals SecurityDetectionsAPIMaxSignals `json:"max_signals"`

	// Meta Placeholder for metadata about the rule.
	// > info
	// > This field is overwritten when you save changes to the rules settings.
	Meta *SecurityDetectionsAPIRuleMetadata `json:"meta,omitempty"`

	// Name A human-readable name for the rule.
	Name SecurityDetectionsAPIRuleName `json:"name"`

	// Namespace Has no effect.
	Namespace *SecurityDetectionsAPIAlertsIndexNamespace `json:"namespace,omitempty"`

	// Note Notes to help investigate alerts produced by the rule.
	Note    *SecurityDetectionsAPIInvestigationGuide        `json:"note,omitempty"`
	Outcome *SecurityDetectionsAPISavedObjectResolveOutcome `json:"outcome,omitempty"`

	// OutputIndex (deprecated) Has no effect.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	OutputIndex *SecurityDetectionsAPIAlertsIndex `json:"output_index,omitempty"`

	// References Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
	References          SecurityDetectionsAPIRuleReferenceArray      `json:"references"`
	RelatedIntegrations SecurityDetectionsAPIRelatedIntegrationArray `json:"related_integrations"`
	RequiredFields      SecurityDetectionsAPIRequiredFieldArray      `json:"required_fields"`
	ResponseActions     *[]SecurityDetectionsAPIResponseAction       `json:"response_actions,omitempty"`

	// Revision The rule's revision number.
	//
	// It represents the version of rule's object in Kibana. It is set to `0` when the rule is installed or created and then gets incremented on each update.
	// > info
	// > Not all updates to any rule fields will increment the revision. Only those fields that are considered static `rule parameters` can trigger revision increments. For example, an update to a rule's query or index fields will increment the rule's revision by `1`. However, changes to dynamic or technical fields like enabled or execution_summary will not cause revision increments.
	Revision SecurityDetectionsAPIRuleRevision `json:"revision"`

	// RiskScore A numerical representation of the alert's severity from 0 to 100, where:
	// * `0` - `21` represents low severity
	// * `22` - `47` represents medium severity
	// * `48` - `73` represents high severity
	// * `74` - `100` represents critical severity
	RiskScore SecurityDetectionsAPIRiskScore `json:"risk_score"`

	// RiskScoreMapping Overrides generated alerts' risk_score with a value from the source event
	RiskScoreMapping SecurityDetectionsAPIRiskScoreMapping `json:"risk_score_mapping"`

	// RuleId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
	RuleId SecurityDetectionsAPIRuleSignatureId `json:"rule_id"`

	// RuleNameOverride Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
	RuleNameOverride *SecurityDetectionsAPIRuleNameOverride `json:"rule_name_override,omitempty"`

	// RuleSource Discriminated union that determines whether the rule is internally sourced (created within the Kibana app) or has an external source, such as the Elastic Prebuilt rules repo.
	RuleSource SecurityDetectionsAPIRuleSource `json:"rule_source"`

	// Setup Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
	Setup SecurityDetectionsAPISetupGuide `json:"setup"`

	// Severity Severity level of alerts produced by the rule, which must be one of the following:
	// * `low`: Alerts that are of interest but generally not considered to be security incidents
	// * `medium`: Alerts that require investigation
	// * `high`: Alerts that require immediate investigation
	// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
	Severity SecurityDetectionsAPISeverity `json:"severity"`

	// SeverityMapping Overrides generated alerts' severity with values from the source event
	SeverityMapping SecurityDetectionsAPISeverityMapping `json:"severity_mapping"`

	// Tags String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
	Tags   SecurityDetectionsAPIRuleTagArray `json:"tags"`
	Threat SecurityDetectionsAPIThreatArray  `json:"threat"`

	// Throttle Defines how often rule actions are taken.
	Throttle *SecurityDetectionsAPIRuleActionThrottle `json:"throttle,omitempty"`

	// TimelineId Timeline template ID
	TimelineId *SecurityDetectionsAPITimelineTemplateId `json:"timeline_id,omitempty"`

	// TimelineTitle Timeline template title
	TimelineTitle *SecurityDetectionsAPITimelineTemplateTitle `json:"timeline_title,omitempty"`

	// TimestampOverride Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
	TimestampOverride *SecurityDetectionsAPITimestampOverride `json:"timestamp_override,omitempty"`

	// TimestampOverrideFallbackDisabled Disables the fallback to the event's @timestamp field
	TimestampOverrideFallbackDisabled *SecurityDetectionsAPITimestampOverrideFallbackDisabled `json:"timestamp_override_fallback_disabled,omitempty"`
	To                                SecurityDetectionsAPIRuleIntervalTo                     `json:"to"`

	// Type Rule type
	Type      SecurityDetectionsAPIMachineLearningRuleType `json:"type"`
	UpdatedAt time.Time                                    `json:"updated_at"`
	UpdatedBy string                                       `json:"updated_by"`

	// Version The rule's version number.
	//
	// - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
	// - For custom rules it is set to `1` when the rule is created.
	// > info
	// > It is not incremented on each update. Compare this to the `revision` field.
	Version SecurityDetectionsAPIRuleVersion `json:"version"`
}

// SecurityDetectionsAPIMachineLearningRuleType Rule type
type SecurityDetectionsAPIMachineLearningRuleType string

// SecurityDetectionsAPIMachineLearningRuleCreateFields defines model for Security_Detections_API_MachineLearningRuleCreateFields.
type SecurityDetectionsAPIMachineLearningRuleCreateFields struct {
	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression `json:"alert_suppression,omitempty"`

	// AnomalyThreshold Anomaly score threshold above which the rule creates an alert. Valid values are from 0 to 100.
	AnomalyThreshold SecurityDetectionsAPIAnomalyThreshold `json:"anomaly_threshold"`

	// MachineLearningJobId Machine learning job ID(s) the rule monitors for anomaly scores.
	MachineLearningJobId SecurityDetectionsAPIMachineLearningJobId `json:"machine_learning_job_id"`

	// Type Rule type
	Type SecurityDetectionsAPIMachineLearningRuleCreateFieldsType `json:"type"`
}

// SecurityDetectionsAPIMachineLearningRuleCreateFieldsType Rule type
type SecurityDetectionsAPIMachineLearningRuleCreateFieldsType string

// SecurityDetectionsAPIMachineLearningRuleCreateProps defines model for Security_Detections_API_MachineLearningRuleCreateProps.
type SecurityDetectionsAPIMachineLearningRuleCreateProps struct {
	// Actions Array defining the automated actions (notifications) taken when alerts are generated.
	Actions *[]SecurityDetectionsAPIRuleAction `json:"actions,omitempty"`

	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression                `json:"alert_suppression,omitempty"`
	AliasPurpose     *SecurityDetectionsAPISavedObjectResolveAliasPurpose  `json:"alias_purpose,omitempty"`
	AliasTargetId    *SecurityDetectionsAPISavedObjectResolveAliasTargetId `json:"alias_target_id,omitempty"`

	// AnomalyThreshold Anomaly score threshold above which the rule creates an alert. Valid values are from 0 to 100.
	AnomalyThreshold SecurityDetectionsAPIAnomalyThreshold `json:"anomaly_threshold"`

	// Author The rules author.
	Author *SecurityDetectionsAPIRuleAuthorArray `json:"author,omitempty"`

	// BuildingBlockType Determines if the rule acts as a building block. If yes, the value must be `default`.
	// By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
	// For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
	BuildingBlockType *SecurityDetectionsAPIBuildingBlockType `json:"building_block_type,omitempty"`

	// Description The rules description.
	Description SecurityDetectionsAPIRuleDescription `json:"description"`

	// Enabled Determines whether the rule is enabled. Defaults to true.
	Enabled        *SecurityDetectionsAPIIsRuleEnabled       `json:"enabled,omitempty"`
	ExceptionsList *[]SecurityDetectionsAPIRuleExceptionList `json:"exceptions_list,omitempty"`

	// FalsePositives String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
	FalsePositives *SecurityDetectionsAPIRuleFalsePositiveArray `json:"false_positives,omitempty"`

	// From Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
	From *SecurityDetectionsAPIRuleIntervalFrom `json:"from,omitempty"`

	// Interval Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
	Interval *SecurityDetectionsAPIRuleInterval `json:"interval,omitempty"`

	// InvestigationFields Schema for fields relating to investigation fields. These are user defined fields we use to highlight
	// in various features in the UI such as alert details flyout and exceptions auto-population from alert.
	InvestigationFields *SecurityDetectionsAPIInvestigationFields `json:"investigation_fields,omitempty"`

	// License The rule's license.
	License *SecurityDetectionsAPIRuleLicense `json:"license,omitempty"`

	// MachineLearningJobId Machine learning job ID(s) the rule monitors for anomaly scores.
	MachineLearningJobId SecurityDetectionsAPIMachineLearningJobId `json:"machine_learning_job_id"`

	// MaxSignals Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
	// > info
	// > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
	MaxSignals *SecurityDetectionsAPIMaxSignals `json:"max_signals,omitempty"`

	// Meta Placeholder for metadata about the rule.
	// > info
	// > This field is overwritten when you save changes to the rules settings.
	Meta *SecurityDetectionsAPIRuleMetadata `json:"meta,omitempty"`

	// Name A human-readable name for the rule.
	Name SecurityDetectionsAPIRuleName `json:"name"`

	// Namespace Has no effect.
	Namespace *SecurityDetectionsAPIAlertsIndexNamespace `json:"namespace,omitempty"`

	// Note Notes to help investigate alerts produced by the rule.
	Note    *SecurityDetectionsAPIInvestigationGuide        `json:"note,omitempty"`
	Outcome *SecurityDetectionsAPISavedObjectResolveOutcome `json:"outcome,omitempty"`

	// OutputIndex (deprecated) Has no effect.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	OutputIndex *SecurityDetectionsAPIAlertsIndex `json:"output_index,omitempty"`

	// References Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
	References          *SecurityDetectionsAPIRuleReferenceArray      `json:"references,omitempty"`
	RelatedIntegrations *SecurityDetectionsAPIRelatedIntegrationArray `json:"related_integrations,omitempty"`

	// RequiredFields Elasticsearch fields and their types that need to be present for the rule to function.
	// > info
	// > The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.
	RequiredFields  *[]SecurityDetectionsAPIRequiredFieldInput `json:"required_fields,omitempty"`
	ResponseActions *[]SecurityDetectionsAPIResponseAction     `json:"response_actions,omitempty"`

	// RiskScore A numerical representation of the alert's severity from 0 to 100, where:
	// * `0` - `21` represents low severity
	// * `22` - `47` represents medium severity
	// * `48` - `73` represents high severity
	// * `74` - `100` represents critical severity
	RiskScore SecurityDetectionsAPIRiskScore `json:"risk_score"`

	// RiskScoreMapping Overrides generated alerts' risk_score with a value from the source event
	RiskScoreMapping *SecurityDetectionsAPIRiskScoreMapping `json:"risk_score_mapping,omitempty"`

	// RuleId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
	RuleId *SecurityDetectionsAPIRuleSignatureId `json:"rule_id,omitempty"`

	// RuleNameOverride Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
	RuleNameOverride *SecurityDetectionsAPIRuleNameOverride `json:"rule_name_override,omitempty"`

	// Setup Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
	Setup *SecurityDetectionsAPISetupGuide `json:"setup,omitempty"`

	// Severity Severity level of alerts produced by the rule, which must be one of the following:
	// * `low`: Alerts that are of interest but generally not considered to be security incidents
	// * `medium`: Alerts that require investigation
	// * `high`: Alerts that require immediate investigation
	// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
	Severity SecurityDetectionsAPISeverity `json:"severity"`

	// SeverityMapping Overrides generated alerts' severity with values from the source event
	SeverityMapping *SecurityDetectionsAPISeverityMapping `json:"severity_mapping,omitempty"`

	// Tags String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
	Tags   *SecurityDetectionsAPIRuleTagArray `json:"tags,omitempty"`
	Threat *SecurityDetectionsAPIThreatArray  `json:"threat,omitempty"`

	// Throttle Defines how often rule actions are taken.
	Throttle *SecurityDetectionsAPIRuleActionThrottle `json:"throttle,omitempty"`

	// TimelineId Timeline template ID
	TimelineId *SecurityDetectionsAPITimelineTemplateId `json:"timeline_id,omitempty"`

	// TimelineTitle Timeline template title
	TimelineTitle *SecurityDetectionsAPITimelineTemplateTitle `json:"timeline_title,omitempty"`

	// TimestampOverride Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
	TimestampOverride *SecurityDetectionsAPITimestampOverride `json:"timestamp_override,omitempty"`

	// TimestampOverrideFallbackDisabled Disables the fallback to the event's @timestamp field
	TimestampOverrideFallbackDisabled *SecurityDetectionsAPITimestampOverrideFallbackDisabled `json:"timestamp_override_fallback_disabled,omitempty"`
	To                                *SecurityDetectionsAPIRuleIntervalTo                    `json:"to,omitempty"`

	// Type Rule type
	Type SecurityDetectionsAPIMachineLearningRuleCreatePropsType `json:"type"`

	// Version The rule's version number.
	//
	// - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
	// - For custom rules it is set to `1` when the rule is created.
	// > info
	// > It is not incremented on each update. Compare this to the `revision` field.
	Version *SecurityDetectionsAPIRuleVersion `json:"version,omitempty"`
}

// SecurityDetectionsAPIMachineLearningRuleCreatePropsType Rule type
type SecurityDetectionsAPIMachineLearningRuleCreatePropsType string

// SecurityDetectionsAPIMachineLearningRuleOptionalFields defines model for Security_Detections_API_MachineLearningRuleOptionalFields.
type SecurityDetectionsAPIMachineLearningRuleOptionalFields struct {
	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression `json:"alert_suppression,omitempty"`
}

// SecurityDetectionsAPIMachineLearningRuleRequiredFields defines model for Security_Detections_API_MachineLearningRuleRequiredFields.
type SecurityDetectionsAPIMachineLearningRuleRequiredFields struct {
	// AnomalyThreshold Anomaly score threshold above which the rule creates an alert. Valid values are from 0 to 100.
	AnomalyThreshold SecurityDetectionsAPIAnomalyThreshold `json:"anomaly_threshold"`

	// MachineLearningJobId Machine learning job ID(s) the rule monitors for anomaly scores.
	MachineLearningJobId SecurityDetectionsAPIMachineLearningJobId `json:"machine_learning_job_id"`

	// Type Rule type
	Type SecurityDetectionsAPIMachineLearningRuleRequiredFieldsType `json:"type"`
}

// SecurityDetectionsAPIMachineLearningRuleRequiredFieldsType Rule type
type SecurityDetectionsAPIMachineLearningRuleRequiredFieldsType string

// SecurityDetectionsAPIMachineLearningRuleResponseFields defines model for Security_Detections_API_MachineLearningRuleResponseFields.
type SecurityDetectionsAPIMachineLearningRuleResponseFields struct {
	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression `json:"alert_suppression,omitempty"`

	// AnomalyThreshold Anomaly score threshold above which the rule creates an alert. Valid values are from 0 to 100.
	AnomalyThreshold SecurityDetectionsAPIAnomalyThreshold `json:"anomaly_threshold"`

	// MachineLearningJobId Machine learning job ID(s) the rule monitors for anomaly scores.
	MachineLearningJobId SecurityDetectionsAPIMachineLearningJobId `json:"machine_learning_job_id"`

	// Type Rule type
	Type SecurityDetectionsAPIMachineLearningRuleResponseFieldsType `json:"type"`
}

// SecurityDetectionsAPIMachineLearningRuleResponseFieldsType Rule type
type SecurityDetectionsAPIMachineLearningRuleResponseFieldsType string

// SecurityDetectionsAPIMachineLearningRuleUpdateProps defines model for Security_Detections_API_MachineLearningRuleUpdateProps.
type SecurityDetectionsAPIMachineLearningRuleUpdateProps struct {
	// Actions Array defining the automated actions (notifications) taken when alerts are generated.
	Actions *[]SecurityDetectionsAPIRuleAction `json:"actions,omitempty"`

	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression                `json:"alert_suppression,omitempty"`
	AliasPurpose     *SecurityDetectionsAPISavedObjectResolveAliasPurpose  `json:"alias_purpose,omitempty"`
	AliasTargetId    *SecurityDetectionsAPISavedObjectResolveAliasTargetId `json:"alias_target_id,omitempty"`

	// AnomalyThreshold Anomaly score threshold above which the rule creates an alert. Valid values are from 0 to 100.
	AnomalyThreshold SecurityDetectionsAPIAnomalyThreshold `json:"anomaly_threshold"`

	// Author The rules author.
	Author *SecurityDetectionsAPIRuleAuthorArray `json:"author,omitempty"`

	// BuildingBlockType Determines if the rule acts as a building block. If yes, the value must be `default`.
	// By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
	// For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
	BuildingBlockType *SecurityDetectionsAPIBuildingBlockType `json:"building_block_type,omitempty"`

	// Description The rules description.
	Description SecurityDetectionsAPIRuleDescription `json:"description"`

	// Enabled Determines whether the rule is enabled. Defaults to true.
	Enabled        *SecurityDetectionsAPIIsRuleEnabled       `json:"enabled,omitempty"`
	ExceptionsList *[]SecurityDetectionsAPIRuleExceptionList `json:"exceptions_list,omitempty"`

	// FalsePositives String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
	FalsePositives *SecurityDetectionsAPIRuleFalsePositiveArray `json:"false_positives,omitempty"`

	// From Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
	From *SecurityDetectionsAPIRuleIntervalFrom `json:"from,omitempty"`

	// Id A universally unique identifier
	Id *SecurityDetectionsAPIRuleObjectId `json:"id,omitempty"`

	// Interval Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
	Interval *SecurityDetectionsAPIRuleInterval `json:"interval,omitempty"`

	// InvestigationFields Schema for fields relating to investigation fields. These are user defined fields we use to highlight
	// in various features in the UI such as alert details flyout and exceptions auto-population from alert.
	InvestigationFields *SecurityDetectionsAPIInvestigationFields `json:"investigation_fields,omitempty"`

	// License The rule's license.
	License *SecurityDetectionsAPIRuleLicense `json:"license,omitempty"`

	// MachineLearningJobId Machine learning job ID(s) the rule monitors for anomaly scores.
	MachineLearningJobId SecurityDetectionsAPIMachineLearningJobId `json:"machine_learning_job_id"`

	// MaxSignals Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
	// > info
	// > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
	MaxSignals *SecurityDetectionsAPIMaxSignals `json:"max_signals,omitempty"`

	// Meta Placeholder for metadata about the rule.
	// > info
	// > This field is overwritten when you save changes to the rules settings.
	Meta *SecurityDetectionsAPIRuleMetadata `json:"meta,omitempty"`

	// Name A human-readable name for the rule.
	Name SecurityDetectionsAPIRuleName `json:"name"`

	// Namespace Has no effect.
	Namespace *SecurityDetectionsAPIAlertsIndexNamespace `json:"namespace,omitempty"`

	// Note Notes to help investigate alerts produced by the rule.
	Note    *SecurityDetectionsAPIInvestigationGuide        `json:"note,omitempty"`
	Outcome *SecurityDetectionsAPISavedObjectResolveOutcome `json:"outcome,omitempty"`

	// OutputIndex (deprecated) Has no effect.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	OutputIndex *SecurityDetectionsAPIAlertsIndex `json:"output_index,omitempty"`

	// References Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
	References          *SecurityDetectionsAPIRuleReferenceArray      `json:"references,omitempty"`
	RelatedIntegrations *SecurityDetectionsAPIRelatedIntegrationArray `json:"related_integrations,omitempty"`

	// RequiredFields Elasticsearch fields and their types that need to be present for the rule to function.
	// > info
	// > The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.
	RequiredFields  *[]SecurityDetectionsAPIRequiredFieldInput `json:"required_fields,omitempty"`
	ResponseActions *[]SecurityDetectionsAPIResponseAction     `json:"response_actions,omitempty"`

	// RiskScore A numerical representation of the alert's severity from 0 to 100, where:
	// * `0` - `21` represents low severity
	// * `22` - `47` represents medium severity
	// * `48` - `73` represents high severity
	// * `74` - `100` represents critical severity
	RiskScore SecurityDetectionsAPIRiskScore `json:"risk_score"`

	// RiskScoreMapping Overrides generated alerts' risk_score with a value from the source event
	RiskScoreMapping *SecurityDetectionsAPIRiskScoreMapping `json:"risk_score_mapping,omitempty"`

	// RuleId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
	RuleId *SecurityDetectionsAPIRuleSignatureId `json:"rule_id,omitempty"`

	// RuleNameOverride Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
	RuleNameOverride *SecurityDetectionsAPIRuleNameOverride `json:"rule_name_override,omitempty"`

	// Setup Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
	Setup *SecurityDetectionsAPISetupGuide `json:"setup,omitempty"`

	// Severity Severity level of alerts produced by the rule, which must be one of the following:
	// * `low`: Alerts that are of interest but generally not considered to be security incidents
	// * `medium`: Alerts that require investigation
	// * `high`: Alerts that require immediate investigation
	// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
	Severity SecurityDetectionsAPISeverity `json:"severity"`

	// SeverityMapping Overrides generated alerts' severity with values from the source event
	SeverityMapping *SecurityDetectionsAPISeverityMapping `json:"severity_mapping,omitempty"`

	// Tags String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
	Tags   *SecurityDetectionsAPIRuleTagArray `json:"tags,omitempty"`
	Threat *SecurityDetectionsAPIThreatArray  `json:"threat,omitempty"`

	// Throttle Defines how often rule actions are taken.
	Throttle *SecurityDetectionsAPIRuleActionThrottle `json:"throttle,omitempty"`

	// TimelineId Timeline template ID
	TimelineId *SecurityDetectionsAPITimelineTemplateId `json:"timeline_id,omitempty"`

	// TimelineTitle Timeline template title
	TimelineTitle *SecurityDetectionsAPITimelineTemplateTitle `json:"timeline_title,omitempty"`

	// TimestampOverride Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
	TimestampOverride *SecurityDetectionsAPITimestampOverride `json:"timestamp_override,omitempty"`

	// TimestampOverrideFallbackDisabled Disables the fallback to the event's @timestamp field
	TimestampOverrideFallbackDisabled *SecurityDetectionsAPITimestampOverrideFallbackDisabled `json:"timestamp_override_fallback_disabled,omitempty"`
	To                                *SecurityDetectionsAPIRuleIntervalTo                    `json:"to,omitempty"`

	// Type Rule type
	Type SecurityDetectionsAPIMachineLearningRuleUpdatePropsType `json:"type"`

	// Version The rule's version number.
	//
	// - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
	// - For custom rules it is set to `1` when the rule is created.
	// > info
	// > It is not incremented on each update. Compare this to the `revision` field.
	Version *SecurityDetectionsAPIRuleVersion `json:"version,omitempty"`
}

// SecurityDetectionsAPIMachineLearningRuleUpdatePropsType Rule type
type SecurityDetectionsAPIMachineLearningRuleUpdatePropsType string

// SecurityDetectionsAPIMaxSignals Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
// > info
// > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
type SecurityDetectionsAPIMaxSignals = int

// SecurityDetectionsAPINewTermsFields Fields to monitor for new values.
type SecurityDetectionsAPINewTermsFields = []string

// SecurityDetectionsAPINewTermsRule defines model for Security_Detections_API_NewTermsRule.
type SecurityDetectionsAPINewTermsRule struct {
	// Actions Array defining the automated actions (notifications) taken when alerts are generated.
	Actions []SecurityDetectionsAPIRuleAction `json:"actions"`

	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression                `json:"alert_suppression,omitempty"`
	AliasPurpose     *SecurityDetectionsAPISavedObjectResolveAliasPurpose  `json:"alias_purpose,omitempty"`
	AliasTargetId    *SecurityDetectionsAPISavedObjectResolveAliasTargetId `json:"alias_target_id,omitempty"`

	// Author The rules author.
	Author SecurityDetectionsAPIRuleAuthorArray `json:"author"`

	// BuildingBlockType Determines if the rule acts as a building block. If yes, the value must be `default`.
	// By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
	// For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
	BuildingBlockType *SecurityDetectionsAPIBuildingBlockType `json:"building_block_type,omitempty"`
	CreatedAt         time.Time                               `json:"created_at"`
	CreatedBy         string                                  `json:"created_by"`
	DataViewId        *SecurityDetectionsAPIDataViewId        `json:"data_view_id,omitempty"`

	// Description The rules description.
	Description SecurityDetectionsAPIRuleDescription `json:"description"`

	// Enabled Determines whether the rule is enabled. Defaults to true.
	Enabled        SecurityDetectionsAPIIsRuleEnabled       `json:"enabled"`
	ExceptionsList []SecurityDetectionsAPIRuleExceptionList `json:"exceptions_list"`

	// ExecutionSummary Summary of the last execution of a rule.
	// > info
	// > This field is under development and its usage or schema may change
	ExecutionSummary *SecurityDetectionsAPIRuleExecutionSummary `json:"execution_summary,omitempty"`

	// FalsePositives String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
	FalsePositives SecurityDetectionsAPIRuleFalsePositiveArray `json:"false_positives"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// From Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
	From SecurityDetectionsAPIRuleIntervalFrom `json:"from"`

	// HistoryWindowStart Start date to use when checking if a term has been seen before. Supports relative dates  for example, now-30d will search the last 30 days of data when checking if a term is new. We do not recommend using absolute dates, which can cause issues with rule performance due to querying increasing amounts of data over time.
	HistoryWindowStart SecurityDetectionsAPIHistoryWindowStart `json:"history_window_start"`

	// Id A universally unique identifier
	Id SecurityDetectionsAPIRuleObjectId `json:"id"`

	// Immutable This field determines whether the rule is a prebuilt Elastic rule. It will be replaced with the `rule_source` field.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Immutable SecurityDetectionsAPIIsRuleImmutable `json:"immutable"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`

	// Interval Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
	Interval SecurityDetectionsAPIRuleInterval `json:"interval"`

	// InvestigationFields Schema for fields relating to investigation fields. These are user defined fields we use to highlight
	// in various features in the UI such as alert details flyout and exceptions auto-population from alert.
	InvestigationFields *SecurityDetectionsAPIInvestigationFields `json:"investigation_fields,omitempty"`
	Language            SecurityDetectionsAPIKqlQueryLanguage     `json:"language"`

	// License The rule's license.
	License *SecurityDetectionsAPIRuleLicense `json:"license,omitempty"`

	// MaxSignals Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
	// > info
	// > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
	MaxSignals SecurityDetectionsAPIMaxSignals `json:"max_signals"`

	// Meta Placeholder for metadata about the rule.
	// > info
	// > This field is overwritten when you save changes to the rules settings.
	Meta *SecurityDetectionsAPIRuleMetadata `json:"meta,omitempty"`

	// Name A human-readable name for the rule.
	Name SecurityDetectionsAPIRuleName `json:"name"`

	// Namespace Has no effect.
	Namespace *SecurityDetectionsAPIAlertsIndexNamespace `json:"namespace,omitempty"`

	// NewTermsFields Fields to monitor for new values.
	NewTermsFields SecurityDetectionsAPINewTermsFields `json:"new_terms_fields"`

	// Note Notes to help investigate alerts produced by the rule.
	Note    *SecurityDetectionsAPIInvestigationGuide        `json:"note,omitempty"`
	Outcome *SecurityDetectionsAPISavedObjectResolveOutcome `json:"outcome,omitempty"`

	// OutputIndex (deprecated) Has no effect.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	OutputIndex *SecurityDetectionsAPIAlertsIndex `json:"output_index,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// References Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
	References          SecurityDetectionsAPIRuleReferenceArray      `json:"references"`
	RelatedIntegrations SecurityDetectionsAPIRelatedIntegrationArray `json:"related_integrations"`
	RequiredFields      SecurityDetectionsAPIRequiredFieldArray      `json:"required_fields"`
	ResponseActions     *[]SecurityDetectionsAPIResponseAction       `json:"response_actions,omitempty"`

	// Revision The rule's revision number.
	//
	// It represents the version of rule's object in Kibana. It is set to `0` when the rule is installed or created and then gets incremented on each update.
	// > info
	// > Not all updates to any rule fields will increment the revision. Only those fields that are considered static `rule parameters` can trigger revision increments. For example, an update to a rule's query or index fields will increment the rule's revision by `1`. However, changes to dynamic or technical fields like enabled or execution_summary will not cause revision increments.
	Revision SecurityDetectionsAPIRuleRevision `json:"revision"`

	// RiskScore A numerical representation of the alert's severity from 0 to 100, where:
	// * `0` - `21` represents low severity
	// * `22` - `47` represents medium severity
	// * `48` - `73` represents high severity
	// * `74` - `100` represents critical severity
	RiskScore SecurityDetectionsAPIRiskScore `json:"risk_score"`

	// RiskScoreMapping Overrides generated alerts' risk_score with a value from the source event
	RiskScoreMapping SecurityDetectionsAPIRiskScoreMapping `json:"risk_score_mapping"`

	// RuleId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
	RuleId SecurityDetectionsAPIRuleSignatureId `json:"rule_id"`

	// RuleNameOverride Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
	RuleNameOverride *SecurityDetectionsAPIRuleNameOverride `json:"rule_name_override,omitempty"`

	// RuleSource Discriminated union that determines whether the rule is internally sourced (created within the Kibana app) or has an external source, such as the Elastic Prebuilt rules repo.
	RuleSource SecurityDetectionsAPIRuleSource `json:"rule_source"`

	// Setup Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
	Setup SecurityDetectionsAPISetupGuide `json:"setup"`

	// Severity Severity level of alerts produced by the rule, which must be one of the following:
	// * `low`: Alerts that are of interest but generally not considered to be security incidents
	// * `medium`: Alerts that require investigation
	// * `high`: Alerts that require immediate investigation
	// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
	Severity SecurityDetectionsAPISeverity `json:"severity"`

	// SeverityMapping Overrides generated alerts' severity with values from the source event
	SeverityMapping SecurityDetectionsAPISeverityMapping `json:"severity_mapping"`

	// Tags String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
	Tags   SecurityDetectionsAPIRuleTagArray `json:"tags"`
	Threat SecurityDetectionsAPIThreatArray  `json:"threat"`

	// Throttle Defines how often rule actions are taken.
	Throttle *SecurityDetectionsAPIRuleActionThrottle `json:"throttle,omitempty"`

	// TimelineId Timeline template ID
	TimelineId *SecurityDetectionsAPITimelineTemplateId `json:"timeline_id,omitempty"`

	// TimelineTitle Timeline template title
	TimelineTitle *SecurityDetectionsAPITimelineTemplateTitle `json:"timeline_title,omitempty"`

	// TimestampOverride Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
	TimestampOverride *SecurityDetectionsAPITimestampOverride `json:"timestamp_override,omitempty"`

	// TimestampOverrideFallbackDisabled Disables the fallback to the event's @timestamp field
	TimestampOverrideFallbackDisabled *SecurityDetectionsAPITimestampOverrideFallbackDisabled `json:"timestamp_override_fallback_disabled,omitempty"`
	To                                SecurityDetectionsAPIRuleIntervalTo                     `json:"to"`

	// Type Rule type
	Type      SecurityDetectionsAPINewTermsRuleType `json:"type"`
	UpdatedAt time.Time                             `json:"updated_at"`
	UpdatedBy string                                `json:"updated_by"`

	// Version The rule's version number.
	//
	// - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
	// - For custom rules it is set to `1` when the rule is created.
	// > info
	// > It is not incremented on each update. Compare this to the `revision` field.
	Version SecurityDetectionsAPIRuleVersion `json:"version"`
}

// SecurityDetectionsAPINewTermsRuleType Rule type
type SecurityDetectionsAPINewTermsRuleType string

// SecurityDetectionsAPINewTermsRuleCreateFields defines model for Security_Detections_API_NewTermsRuleCreateFields.
type SecurityDetectionsAPINewTermsRuleCreateFields struct {
	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression `json:"alert_suppression,omitempty"`
	DataViewId       *SecurityDetectionsAPIDataViewId       `json:"data_view_id,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// HistoryWindowStart Start date to use when checking if a term has been seen before. Supports relative dates  for example, now-30d will search the last 30 days of data when checking if a term is new. We do not recommend using absolute dates, which can cause issues with rule performance due to querying increasing amounts of data over time.
	HistoryWindowStart SecurityDetectionsAPIHistoryWindowStart `json:"history_window_start"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index    *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`
	Language *SecurityDetectionsAPIKqlQueryLanguage  `json:"language,omitempty"`

	// NewTermsFields Fields to monitor for new values.
	NewTermsFields SecurityDetectionsAPINewTermsFields `json:"new_terms_fields"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// Type Rule type
	Type SecurityDetectionsAPINewTermsRuleCreateFieldsType `json:"type"`
}

// SecurityDetectionsAPINewTermsRuleCreateFieldsType Rule type
type SecurityDetectionsAPINewTermsRuleCreateFieldsType string

// SecurityDetectionsAPINewTermsRuleCreateProps defines model for Security_Detections_API_NewTermsRuleCreateProps.
type SecurityDetectionsAPINewTermsRuleCreateProps struct {
	// Actions Array defining the automated actions (notifications) taken when alerts are generated.
	Actions *[]SecurityDetectionsAPIRuleAction `json:"actions,omitempty"`

	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression                `json:"alert_suppression,omitempty"`
	AliasPurpose     *SecurityDetectionsAPISavedObjectResolveAliasPurpose  `json:"alias_purpose,omitempty"`
	AliasTargetId    *SecurityDetectionsAPISavedObjectResolveAliasTargetId `json:"alias_target_id,omitempty"`

	// Author The rules author.
	Author *SecurityDetectionsAPIRuleAuthorArray `json:"author,omitempty"`

	// BuildingBlockType Determines if the rule acts as a building block. If yes, the value must be `default`.
	// By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
	// For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
	BuildingBlockType *SecurityDetectionsAPIBuildingBlockType `json:"building_block_type,omitempty"`
	DataViewId        *SecurityDetectionsAPIDataViewId        `json:"data_view_id,omitempty"`

	// Description The rules description.
	Description SecurityDetectionsAPIRuleDescription `json:"description"`

	// Enabled Determines whether the rule is enabled. Defaults to true.
	Enabled        *SecurityDetectionsAPIIsRuleEnabled       `json:"enabled,omitempty"`
	ExceptionsList *[]SecurityDetectionsAPIRuleExceptionList `json:"exceptions_list,omitempty"`

	// FalsePositives String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
	FalsePositives *SecurityDetectionsAPIRuleFalsePositiveArray `json:"false_positives,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// From Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
	From *SecurityDetectionsAPIRuleIntervalFrom `json:"from,omitempty"`

	// HistoryWindowStart Start date to use when checking if a term has been seen before. Supports relative dates  for example, now-30d will search the last 30 days of data when checking if a term is new. We do not recommend using absolute dates, which can cause issues with rule performance due to querying increasing amounts of data over time.
	HistoryWindowStart SecurityDetectionsAPIHistoryWindowStart `json:"history_window_start"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`

	// Interval Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
	Interval *SecurityDetectionsAPIRuleInterval `json:"interval,omitempty"`

	// InvestigationFields Schema for fields relating to investigation fields. These are user defined fields we use to highlight
	// in various features in the UI such as alert details flyout and exceptions auto-population from alert.
	InvestigationFields *SecurityDetectionsAPIInvestigationFields `json:"investigation_fields,omitempty"`
	Language            *SecurityDetectionsAPIKqlQueryLanguage    `json:"language,omitempty"`

	// License The rule's license.
	License *SecurityDetectionsAPIRuleLicense `json:"license,omitempty"`

	// MaxSignals Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
	// > info
	// > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
	MaxSignals *SecurityDetectionsAPIMaxSignals `json:"max_signals,omitempty"`

	// Meta Placeholder for metadata about the rule.
	// > info
	// > This field is overwritten when you save changes to the rules settings.
	Meta *SecurityDetectionsAPIRuleMetadata `json:"meta,omitempty"`

	// Name A human-readable name for the rule.
	Name SecurityDetectionsAPIRuleName `json:"name"`

	// Namespace Has no effect.
	Namespace *SecurityDetectionsAPIAlertsIndexNamespace `json:"namespace,omitempty"`

	// NewTermsFields Fields to monitor for new values.
	NewTermsFields SecurityDetectionsAPINewTermsFields `json:"new_terms_fields"`

	// Note Notes to help investigate alerts produced by the rule.
	Note    *SecurityDetectionsAPIInvestigationGuide        `json:"note,omitempty"`
	Outcome *SecurityDetectionsAPISavedObjectResolveOutcome `json:"outcome,omitempty"`

	// OutputIndex (deprecated) Has no effect.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	OutputIndex *SecurityDetectionsAPIAlertsIndex `json:"output_index,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// References Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
	References          *SecurityDetectionsAPIRuleReferenceArray      `json:"references,omitempty"`
	RelatedIntegrations *SecurityDetectionsAPIRelatedIntegrationArray `json:"related_integrations,omitempty"`

	// RequiredFields Elasticsearch fields and their types that need to be present for the rule to function.
	// > info
	// > The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.
	RequiredFields  *[]SecurityDetectionsAPIRequiredFieldInput `json:"required_fields,omitempty"`
	ResponseActions *[]SecurityDetectionsAPIResponseAction     `json:"response_actions,omitempty"`

	// RiskScore A numerical representation of the alert's severity from 0 to 100, where:
	// * `0` - `21` represents low severity
	// * `22` - `47` represents medium severity
	// * `48` - `73` represents high severity
	// * `74` - `100` represents critical severity
	RiskScore SecurityDetectionsAPIRiskScore `json:"risk_score"`

	// RiskScoreMapping Overrides generated alerts' risk_score with a value from the source event
	RiskScoreMapping *SecurityDetectionsAPIRiskScoreMapping `json:"risk_score_mapping,omitempty"`

	// RuleId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
	RuleId *SecurityDetectionsAPIRuleSignatureId `json:"rule_id,omitempty"`

	// RuleNameOverride Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
	RuleNameOverride *SecurityDetectionsAPIRuleNameOverride `json:"rule_name_override,omitempty"`

	// Setup Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
	Setup *SecurityDetectionsAPISetupGuide `json:"setup,omitempty"`

	// Severity Severity level of alerts produced by the rule, which must be one of the following:
	// * `low`: Alerts that are of interest but generally not considered to be security incidents
	// * `medium`: Alerts that require investigation
	// * `high`: Alerts that require immediate investigation
	// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
	Severity SecurityDetectionsAPISeverity `json:"severity"`

	// SeverityMapping Overrides generated alerts' severity with values from the source event
	SeverityMapping *SecurityDetectionsAPISeverityMapping `json:"severity_mapping,omitempty"`

	// Tags String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
	Tags   *SecurityDetectionsAPIRuleTagArray `json:"tags,omitempty"`
	Threat *SecurityDetectionsAPIThreatArray  `json:"threat,omitempty"`

	// Throttle Defines how often rule actions are taken.
	Throttle *SecurityDetectionsAPIRuleActionThrottle `json:"throttle,omitempty"`

	// TimelineId Timeline template ID
	TimelineId *SecurityDetectionsAPITimelineTemplateId `json:"timeline_id,omitempty"`

	// TimelineTitle Timeline template title
	TimelineTitle *SecurityDetectionsAPITimelineTemplateTitle `json:"timeline_title,omitempty"`

	// TimestampOverride Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
	TimestampOverride *SecurityDetectionsAPITimestampOverride `json:"timestamp_override,omitempty"`

	// TimestampOverrideFallbackDisabled Disables the fallback to the event's @timestamp field
	TimestampOverrideFallbackDisabled *SecurityDetectionsAPITimestampOverrideFallbackDisabled `json:"timestamp_override_fallback_disabled,omitempty"`
	To                                *SecurityDetectionsAPIRuleIntervalTo                    `json:"to,omitempty"`

	// Type Rule type
	Type SecurityDetectionsAPINewTermsRuleCreatePropsType `json:"type"`

	// Version The rule's version number.
	//
	// - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
	// - For custom rules it is set to `1` when the rule is created.
	// > info
	// > It is not incremented on each update. Compare this to the `revision` field.
	Version *SecurityDetectionsAPIRuleVersion `json:"version,omitempty"`
}

// SecurityDetectionsAPINewTermsRuleCreatePropsType Rule type
type SecurityDetectionsAPINewTermsRuleCreatePropsType string

// SecurityDetectionsAPINewTermsRuleDefaultableFields defines model for Security_Detections_API_NewTermsRuleDefaultableFields.
type SecurityDetectionsAPINewTermsRuleDefaultableFields struct {
	Language *SecurityDetectionsAPIKqlQueryLanguage `json:"language,omitempty"`
}

// SecurityDetectionsAPINewTermsRuleOptionalFields defines model for Security_Detections_API_NewTermsRuleOptionalFields.
type SecurityDetectionsAPINewTermsRuleOptionalFields struct {
	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression `json:"alert_suppression,omitempty"`
	DataViewId       *SecurityDetectionsAPIDataViewId       `json:"data_view_id,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`
}

// SecurityDetectionsAPINewTermsRuleRequiredFields defines model for Security_Detections_API_NewTermsRuleRequiredFields.
type SecurityDetectionsAPINewTermsRuleRequiredFields struct {
	// HistoryWindowStart Start date to use when checking if a term has been seen before. Supports relative dates  for example, now-30d will search the last 30 days of data when checking if a term is new. We do not recommend using absolute dates, which can cause issues with rule performance due to querying increasing amounts of data over time.
	HistoryWindowStart SecurityDetectionsAPIHistoryWindowStart `json:"history_window_start"`

	// NewTermsFields Fields to monitor for new values.
	NewTermsFields SecurityDetectionsAPINewTermsFields `json:"new_terms_fields"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// Type Rule type
	Type SecurityDetectionsAPINewTermsRuleRequiredFieldsType `json:"type"`
}

// SecurityDetectionsAPINewTermsRuleRequiredFieldsType Rule type
type SecurityDetectionsAPINewTermsRuleRequiredFieldsType string

// SecurityDetectionsAPINewTermsRuleResponseFields defines model for Security_Detections_API_NewTermsRuleResponseFields.
type SecurityDetectionsAPINewTermsRuleResponseFields struct {
	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression `json:"alert_suppression,omitempty"`
	DataViewId       *SecurityDetectionsAPIDataViewId       `json:"data_view_id,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// HistoryWindowStart Start date to use when checking if a term has been seen before. Supports relative dates  for example, now-30d will search the last 30 days of data when checking if a term is new. We do not recommend using absolute dates, which can cause issues with rule performance due to querying increasing amounts of data over time.
	HistoryWindowStart SecurityDetectionsAPIHistoryWindowStart `json:"history_window_start"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index    *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`
	Language SecurityDetectionsAPIKqlQueryLanguage   `json:"language"`

	// NewTermsFields Fields to monitor for new values.
	NewTermsFields SecurityDetectionsAPINewTermsFields `json:"new_terms_fields"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// Type Rule type
	Type SecurityDetectionsAPINewTermsRuleResponseFieldsType `json:"type"`
}

// SecurityDetectionsAPINewTermsRuleResponseFieldsType Rule type
type SecurityDetectionsAPINewTermsRuleResponseFieldsType string

// SecurityDetectionsAPINewTermsRuleUpdateProps defines model for Security_Detections_API_NewTermsRuleUpdateProps.
type SecurityDetectionsAPINewTermsRuleUpdateProps struct {
	// Actions Array defining the automated actions (notifications) taken when alerts are generated.
	Actions *[]SecurityDetectionsAPIRuleAction `json:"actions,omitempty"`

	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression                `json:"alert_suppression,omitempty"`
	AliasPurpose     *SecurityDetectionsAPISavedObjectResolveAliasPurpose  `json:"alias_purpose,omitempty"`
	AliasTargetId    *SecurityDetectionsAPISavedObjectResolveAliasTargetId `json:"alias_target_id,omitempty"`

	// Author The rules author.
	Author *SecurityDetectionsAPIRuleAuthorArray `json:"author,omitempty"`

	// BuildingBlockType Determines if the rule acts as a building block. If yes, the value must be `default`.
	// By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
	// For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
	BuildingBlockType *SecurityDetectionsAPIBuildingBlockType `json:"building_block_type,omitempty"`
	DataViewId        *SecurityDetectionsAPIDataViewId        `json:"data_view_id,omitempty"`

	// Description The rules description.
	Description SecurityDetectionsAPIRuleDescription `json:"description"`

	// Enabled Determines whether the rule is enabled. Defaults to true.
	Enabled        *SecurityDetectionsAPIIsRuleEnabled       `json:"enabled,omitempty"`
	ExceptionsList *[]SecurityDetectionsAPIRuleExceptionList `json:"exceptions_list,omitempty"`

	// FalsePositives String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
	FalsePositives *SecurityDetectionsAPIRuleFalsePositiveArray `json:"false_positives,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// From Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
	From *SecurityDetectionsAPIRuleIntervalFrom `json:"from,omitempty"`

	// HistoryWindowStart Start date to use when checking if a term has been seen before. Supports relative dates  for example, now-30d will search the last 30 days of data when checking if a term is new. We do not recommend using absolute dates, which can cause issues with rule performance due to querying increasing amounts of data over time.
	HistoryWindowStart SecurityDetectionsAPIHistoryWindowStart `json:"history_window_start"`

	// Id A universally unique identifier
	Id *SecurityDetectionsAPIRuleObjectId `json:"id,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`

	// Interval Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
	Interval *SecurityDetectionsAPIRuleInterval `json:"interval,omitempty"`

	// InvestigationFields Schema for fields relating to investigation fields. These are user defined fields we use to highlight
	// in various features in the UI such as alert details flyout and exceptions auto-population from alert.
	InvestigationFields *SecurityDetectionsAPIInvestigationFields `json:"investigation_fields,omitempty"`
	Language            *SecurityDetectionsAPIKqlQueryLanguage    `json:"language,omitempty"`

	// License The rule's license.
	License *SecurityDetectionsAPIRuleLicense `json:"license,omitempty"`

	// MaxSignals Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
	// > info
	// > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
	MaxSignals *SecurityDetectionsAPIMaxSignals `json:"max_signals,omitempty"`

	// Meta Placeholder for metadata about the rule.
	// > info
	// > This field is overwritten when you save changes to the rules settings.
	Meta *SecurityDetectionsAPIRuleMetadata `json:"meta,omitempty"`

	// Name A human-readable name for the rule.
	Name SecurityDetectionsAPIRuleName `json:"name"`

	// Namespace Has no effect.
	Namespace *SecurityDetectionsAPIAlertsIndexNamespace `json:"namespace,omitempty"`

	// NewTermsFields Fields to monitor for new values.
	NewTermsFields SecurityDetectionsAPINewTermsFields `json:"new_terms_fields"`

	// Note Notes to help investigate alerts produced by the rule.
	Note    *SecurityDetectionsAPIInvestigationGuide        `json:"note,omitempty"`
	Outcome *SecurityDetectionsAPISavedObjectResolveOutcome `json:"outcome,omitempty"`

	// OutputIndex (deprecated) Has no effect.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	OutputIndex *SecurityDetectionsAPIAlertsIndex `json:"output_index,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// References Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
	References          *SecurityDetectionsAPIRuleReferenceArray      `json:"references,omitempty"`
	RelatedIntegrations *SecurityDetectionsAPIRelatedIntegrationArray `json:"related_integrations,omitempty"`

	// RequiredFields Elasticsearch fields and their types that need to be present for the rule to function.
	// > info
	// > The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.
	RequiredFields  *[]SecurityDetectionsAPIRequiredFieldInput `json:"required_fields,omitempty"`
	ResponseActions *[]SecurityDetectionsAPIResponseAction     `json:"response_actions,omitempty"`

	// RiskScore A numerical representation of the alert's severity from 0 to 100, where:
	// * `0` - `21` represents low severity
	// * `22` - `47` represents medium severity
	// * `48` - `73` represents high severity
	// * `74` - `100` represents critical severity
	RiskScore SecurityDetectionsAPIRiskScore `json:"risk_score"`

	// RiskScoreMapping Overrides generated alerts' risk_score with a value from the source event
	RiskScoreMapping *SecurityDetectionsAPIRiskScoreMapping `json:"risk_score_mapping,omitempty"`

	// RuleId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
	RuleId *SecurityDetectionsAPIRuleSignatureId `json:"rule_id,omitempty"`

	// RuleNameOverride Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
	RuleNameOverride *SecurityDetectionsAPIRuleNameOverride `json:"rule_name_override,omitempty"`

	// Setup Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
	Setup *SecurityDetectionsAPISetupGuide `json:"setup,omitempty"`

	// Severity Severity level of alerts produced by the rule, which must be one of the following:
	// * `low`: Alerts that are of interest but generally not considered to be security incidents
	// * `medium`: Alerts that require investigation
	// * `high`: Alerts that require immediate investigation
	// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
	Severity SecurityDetectionsAPISeverity `json:"severity"`

	// SeverityMapping Overrides generated alerts' severity with values from the source event
	SeverityMapping *SecurityDetectionsAPISeverityMapping `json:"severity_mapping,omitempty"`

	// Tags String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
	Tags   *SecurityDetectionsAPIRuleTagArray `json:"tags,omitempty"`
	Threat *SecurityDetectionsAPIThreatArray  `json:"threat,omitempty"`

	// Throttle Defines how often rule actions are taken.
	Throttle *SecurityDetectionsAPIRuleActionThrottle `json:"throttle,omitempty"`

	// TimelineId Timeline template ID
	TimelineId *SecurityDetectionsAPITimelineTemplateId `json:"timeline_id,omitempty"`

	// TimelineTitle Timeline template title
	TimelineTitle *SecurityDetectionsAPITimelineTemplateTitle `json:"timeline_title,omitempty"`

	// TimestampOverride Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
	TimestampOverride *SecurityDetectionsAPITimestampOverride `json:"timestamp_override,omitempty"`

	// TimestampOverrideFallbackDisabled Disables the fallback to the event's @timestamp field
	TimestampOverrideFallbackDisabled *SecurityDetectionsAPITimestampOverrideFallbackDisabled `json:"timestamp_override_fallback_disabled,omitempty"`
	To                                *SecurityDetectionsAPIRuleIntervalTo                    `json:"to,omitempty"`

	// Type Rule type
	Type SecurityDetectionsAPINewTermsRuleUpdatePropsType `json:"type"`

	// Version The rule's version number.
	//
	// - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
	// - For custom rules it is set to `1` when the rule is created.
	// > info
	// > It is not incremented on each update. Compare this to the `revision` field.
	Version *SecurityDetectionsAPIRuleVersion `json:"version,omitempty"`
}

// SecurityDetectionsAPINewTermsRuleUpdatePropsType Rule type
type SecurityDetectionsAPINewTermsRuleUpdatePropsType string

// SecurityDetectionsAPINonEmptyString A string that does not contain only whitespace characters
type SecurityDetectionsAPINonEmptyString = string

// SecurityDetectionsAPIOsqueryParams defines model for Security_Detections_API_OsqueryParams.
type SecurityDetectionsAPIOsqueryParams struct {
	// EcsMapping Map Osquery results columns or static values to Elastic Common Schema (ECS) fields. Example: "ecs_mapping": {"process.pid": {"field": "pid"}}
	EcsMapping *SecurityDetectionsAPIEcsMapping `json:"ecs_mapping,omitempty"`

	// PackId To specify a query pack, use the packId field. Example: "packId": "processes_elastic"
	PackId  *string                              `json:"pack_id,omitempty"`
	Queries *[]SecurityDetectionsAPIOsqueryQuery `json:"queries,omitempty"`

	// Query To run a single query, use the query field and enter a SQL query. Example: "query": "SELECT * FROM processes;"
	Query *string `json:"query,omitempty"`

	// SavedQueryId To run a saved query, use the saved_query_id field and specify the saved query ID. Example: "saved_query_id": "processes_elastic"
	SavedQueryId *string `json:"saved_query_id,omitempty"`

	// Timeout A timeout period, in seconds, after which the query will stop running. Overwriting the default timeout allows you to support queries that require more time to complete. The default and minimum supported value is 60. The maximum supported value is 900. Example: "timeout": 120.
	Timeout *float32 `json:"timeout,omitempty"`
}

// SecurityDetectionsAPIOsqueryQuery defines model for Security_Detections_API_OsqueryQuery.
type SecurityDetectionsAPIOsqueryQuery struct {
	// EcsMapping Map Osquery results columns or static values to Elastic Common Schema (ECS) fields. Example: "ecs_mapping": {"process.pid": {"field": "pid"}}
	EcsMapping *SecurityDetectionsAPIEcsMapping `json:"ecs_mapping,omitempty"`

	// Id Query ID
	Id       string  `json:"id"`
	Platform *string `json:"platform,omitempty"`

	// Query Query to run
	Query    string `json:"query"`
	Removed  *bool  `json:"removed,omitempty"`
	Snapshot *bool  `json:"snapshot,omitempty"`

	// Version Query version
	Version *string `json:"version,omitempty"`
}

// SecurityDetectionsAPIOsqueryResponseAction defines model for Security_Detections_API_OsqueryResponseAction.
type SecurityDetectionsAPIOsqueryResponseAction struct {
	ActionTypeId SecurityDetectionsAPIOsqueryResponseActionActionTypeId `json:"action_type_id"`
	Params       SecurityDetectionsAPIOsqueryParams                     `json:"params"`
}

// SecurityDetectionsAPIOsqueryResponseActionActionTypeId defines model for SecurityDetectionsAPIOsqueryResponseAction.ActionTypeId.
type SecurityDetectionsAPIOsqueryResponseActionActionTypeId string

// SecurityDetectionsAPIProcessesParams defines model for Security_Detections_API_ProcessesParams.
type SecurityDetectionsAPIProcessesParams struct {
	// Command To run an endpoint response action, specify a value for the command field. Example: "command": "isolate"
	Command SecurityDetectionsAPIProcessesParamsCommand `json:"command"`

	// Comment Add a note that explains or describes the action. You can find your comment in the response actions history log. Example: "comment": "Check processes"
	Comment *string `json:"comment,omitempty"`
	Config  struct {
		// Field Field to use instead of process.pid
		Field string `json:"field"`

		// Overwrite Whether to overwrite field with process.pid
		Overwrite *bool `json:"overwrite,omitempty"`
	} `json:"config"`
}

// SecurityDetectionsAPIProcessesParamsCommand To run an endpoint response action, specify a value for the command field. Example: "command": "isolate"
type SecurityDetectionsAPIProcessesParamsCommand string

// SecurityDetectionsAPIQueryRule defines model for Security_Detections_API_QueryRule.
type SecurityDetectionsAPIQueryRule struct {
	// Actions Array defining the automated actions (notifications) taken when alerts are generated.
	Actions []SecurityDetectionsAPIRuleAction `json:"actions"`

	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression                `json:"alert_suppression,omitempty"`
	AliasPurpose     *SecurityDetectionsAPISavedObjectResolveAliasPurpose  `json:"alias_purpose,omitempty"`
	AliasTargetId    *SecurityDetectionsAPISavedObjectResolveAliasTargetId `json:"alias_target_id,omitempty"`

	// Author The rules author.
	Author SecurityDetectionsAPIRuleAuthorArray `json:"author"`

	// BuildingBlockType Determines if the rule acts as a building block. If yes, the value must be `default`.
	// By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
	// For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
	BuildingBlockType *SecurityDetectionsAPIBuildingBlockType `json:"building_block_type,omitempty"`
	CreatedAt         time.Time                               `json:"created_at"`
	CreatedBy         string                                  `json:"created_by"`
	DataViewId        *SecurityDetectionsAPIDataViewId        `json:"data_view_id,omitempty"`

	// Description The rules description.
	Description SecurityDetectionsAPIRuleDescription `json:"description"`

	// Enabled Determines whether the rule is enabled. Defaults to true.
	Enabled        SecurityDetectionsAPIIsRuleEnabled       `json:"enabled"`
	ExceptionsList []SecurityDetectionsAPIRuleExceptionList `json:"exceptions_list"`

	// ExecutionSummary Summary of the last execution of a rule.
	// > info
	// > This field is under development and its usage or schema may change
	ExecutionSummary *SecurityDetectionsAPIRuleExecutionSummary `json:"execution_summary,omitempty"`

	// FalsePositives String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
	FalsePositives SecurityDetectionsAPIRuleFalsePositiveArray `json:"false_positives"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// From Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
	From SecurityDetectionsAPIRuleIntervalFrom `json:"from"`

	// Id A universally unique identifier
	Id SecurityDetectionsAPIRuleObjectId `json:"id"`

	// Immutable This field determines whether the rule is a prebuilt Elastic rule. It will be replaced with the `rule_source` field.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Immutable SecurityDetectionsAPIIsRuleImmutable `json:"immutable"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`

	// Interval Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
	Interval SecurityDetectionsAPIRuleInterval `json:"interval"`

	// InvestigationFields Schema for fields relating to investigation fields. These are user defined fields we use to highlight
	// in various features in the UI such as alert details flyout and exceptions auto-population from alert.
	InvestigationFields *SecurityDetectionsAPIInvestigationFields `json:"investigation_fields,omitempty"`
	Language            SecurityDetectionsAPIKqlQueryLanguage     `json:"language"`

	// License The rule's license.
	License *SecurityDetectionsAPIRuleLicense `json:"license,omitempty"`

	// MaxSignals Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
	// > info
	// > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
	MaxSignals SecurityDetectionsAPIMaxSignals `json:"max_signals"`

	// Meta Placeholder for metadata about the rule.
	// > info
	// > This field is overwritten when you save changes to the rules settings.
	Meta *SecurityDetectionsAPIRuleMetadata `json:"meta,omitempty"`

	// Name A human-readable name for the rule.
	Name SecurityDetectionsAPIRuleName `json:"name"`

	// Namespace Has no effect.
	Namespace *SecurityDetectionsAPIAlertsIndexNamespace `json:"namespace,omitempty"`

	// Note Notes to help investigate alerts produced by the rule.
	Note    *SecurityDetectionsAPIInvestigationGuide        `json:"note,omitempty"`
	Outcome *SecurityDetectionsAPISavedObjectResolveOutcome `json:"outcome,omitempty"`

	// OutputIndex (deprecated) Has no effect.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	OutputIndex *SecurityDetectionsAPIAlertsIndex `json:"output_index,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// References Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
	References          SecurityDetectionsAPIRuleReferenceArray      `json:"references"`
	RelatedIntegrations SecurityDetectionsAPIRelatedIntegrationArray `json:"related_integrations"`
	RequiredFields      SecurityDetectionsAPIRequiredFieldArray      `json:"required_fields"`
	ResponseActions     *[]SecurityDetectionsAPIResponseAction       `json:"response_actions,omitempty"`

	// Revision The rule's revision number.
	//
	// It represents the version of rule's object in Kibana. It is set to `0` when the rule is installed or created and then gets incremented on each update.
	// > info
	// > Not all updates to any rule fields will increment the revision. Only those fields that are considered static `rule parameters` can trigger revision increments. For example, an update to a rule's query or index fields will increment the rule's revision by `1`. However, changes to dynamic or technical fields like enabled or execution_summary will not cause revision increments.
	Revision SecurityDetectionsAPIRuleRevision `json:"revision"`

	// RiskScore A numerical representation of the alert's severity from 0 to 100, where:
	// * `0` - `21` represents low severity
	// * `22` - `47` represents medium severity
	// * `48` - `73` represents high severity
	// * `74` - `100` represents critical severity
	RiskScore SecurityDetectionsAPIRiskScore `json:"risk_score"`

	// RiskScoreMapping Overrides generated alerts' risk_score with a value from the source event
	RiskScoreMapping SecurityDetectionsAPIRiskScoreMapping `json:"risk_score_mapping"`

	// RuleId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
	RuleId SecurityDetectionsAPIRuleSignatureId `json:"rule_id"`

	// RuleNameOverride Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
	RuleNameOverride *SecurityDetectionsAPIRuleNameOverride `json:"rule_name_override,omitempty"`

	// RuleSource Discriminated union that determines whether the rule is internally sourced (created within the Kibana app) or has an external source, such as the Elastic Prebuilt rules repo.
	RuleSource SecurityDetectionsAPIRuleSource `json:"rule_source"`

	// SavedId Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
	SavedId *SecurityDetectionsAPISavedQueryId `json:"saved_id,omitempty"`

	// Setup Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
	Setup SecurityDetectionsAPISetupGuide `json:"setup"`

	// Severity Severity level of alerts produced by the rule, which must be one of the following:
	// * `low`: Alerts that are of interest but generally not considered to be security incidents
	// * `medium`: Alerts that require investigation
	// * `high`: Alerts that require immediate investigation
	// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
	Severity SecurityDetectionsAPISeverity `json:"severity"`

	// SeverityMapping Overrides generated alerts' severity with values from the source event
	SeverityMapping SecurityDetectionsAPISeverityMapping `json:"severity_mapping"`

	// Tags String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
	Tags   SecurityDetectionsAPIRuleTagArray `json:"tags"`
	Threat SecurityDetectionsAPIThreatArray  `json:"threat"`

	// Throttle Defines how often rule actions are taken.
	Throttle *SecurityDetectionsAPIRuleActionThrottle `json:"throttle,omitempty"`

	// TimelineId Timeline template ID
	TimelineId *SecurityDetectionsAPITimelineTemplateId `json:"timeline_id,omitempty"`

	// TimelineTitle Timeline template title
	TimelineTitle *SecurityDetectionsAPITimelineTemplateTitle `json:"timeline_title,omitempty"`

	// TimestampOverride Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
	TimestampOverride *SecurityDetectionsAPITimestampOverride `json:"timestamp_override,omitempty"`

	// TimestampOverrideFallbackDisabled Disables the fallback to the event's @timestamp field
	TimestampOverrideFallbackDisabled *SecurityDetectionsAPITimestampOverrideFallbackDisabled `json:"timestamp_override_fallback_disabled,omitempty"`
	To                                SecurityDetectionsAPIRuleIntervalTo                     `json:"to"`

	// Type Rule type
	Type      SecurityDetectionsAPIQueryRuleType `json:"type"`
	UpdatedAt time.Time                          `json:"updated_at"`
	UpdatedBy string                             `json:"updated_by"`

	// Version The rule's version number.
	//
	// - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
	// - For custom rules it is set to `1` when the rule is created.
	// > info
	// > It is not incremented on each update. Compare this to the `revision` field.
	Version SecurityDetectionsAPIRuleVersion `json:"version"`
}

// SecurityDetectionsAPIQueryRuleType Rule type
type SecurityDetectionsAPIQueryRuleType string

// SecurityDetectionsAPIQueryRuleCreateFields defines model for Security_Detections_API_QueryRuleCreateFields.
type SecurityDetectionsAPIQueryRuleCreateFields struct {
	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression `json:"alert_suppression,omitempty"`
	DataViewId       *SecurityDetectionsAPIDataViewId       `json:"data_view_id,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index    *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`
	Language *SecurityDetectionsAPIKqlQueryLanguage  `json:"language,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query *SecurityDetectionsAPIRuleQuery `json:"query,omitempty"`

	// SavedId Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
	SavedId *SecurityDetectionsAPISavedQueryId `json:"saved_id,omitempty"`

	// Type Rule type
	Type SecurityDetectionsAPIQueryRuleCreateFieldsType `json:"type"`
}

// SecurityDetectionsAPIQueryRuleCreateFieldsType Rule type
type SecurityDetectionsAPIQueryRuleCreateFieldsType string

// SecurityDetectionsAPIQueryRuleCreateProps defines model for Security_Detections_API_QueryRuleCreateProps.
type SecurityDetectionsAPIQueryRuleCreateProps struct {
	// Actions Array defining the automated actions (notifications) taken when alerts are generated.
	Actions *[]SecurityDetectionsAPIRuleAction `json:"actions,omitempty"`

	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression                `json:"alert_suppression,omitempty"`
	AliasPurpose     *SecurityDetectionsAPISavedObjectResolveAliasPurpose  `json:"alias_purpose,omitempty"`
	AliasTargetId    *SecurityDetectionsAPISavedObjectResolveAliasTargetId `json:"alias_target_id,omitempty"`

	// Author The rules author.
	Author *SecurityDetectionsAPIRuleAuthorArray `json:"author,omitempty"`

	// BuildingBlockType Determines if the rule acts as a building block. If yes, the value must be `default`.
	// By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
	// For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
	BuildingBlockType *SecurityDetectionsAPIBuildingBlockType `json:"building_block_type,omitempty"`
	DataViewId        *SecurityDetectionsAPIDataViewId        `json:"data_view_id,omitempty"`

	// Description The rules description.
	Description SecurityDetectionsAPIRuleDescription `json:"description"`

	// Enabled Determines whether the rule is enabled. Defaults to true.
	Enabled        *SecurityDetectionsAPIIsRuleEnabled       `json:"enabled,omitempty"`
	ExceptionsList *[]SecurityDetectionsAPIRuleExceptionList `json:"exceptions_list,omitempty"`

	// FalsePositives String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
	FalsePositives *SecurityDetectionsAPIRuleFalsePositiveArray `json:"false_positives,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// From Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
	From *SecurityDetectionsAPIRuleIntervalFrom `json:"from,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`

	// Interval Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
	Interval *SecurityDetectionsAPIRuleInterval `json:"interval,omitempty"`

	// InvestigationFields Schema for fields relating to investigation fields. These are user defined fields we use to highlight
	// in various features in the UI such as alert details flyout and exceptions auto-population from alert.
	InvestigationFields *SecurityDetectionsAPIInvestigationFields `json:"investigation_fields,omitempty"`
	Language            *SecurityDetectionsAPIKqlQueryLanguage    `json:"language,omitempty"`

	// License The rule's license.
	License *SecurityDetectionsAPIRuleLicense `json:"license,omitempty"`

	// MaxSignals Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
	// > info
	// > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
	MaxSignals *SecurityDetectionsAPIMaxSignals `json:"max_signals,omitempty"`

	// Meta Placeholder for metadata about the rule.
	// > info
	// > This field is overwritten when you save changes to the rules settings.
	Meta *SecurityDetectionsAPIRuleMetadata `json:"meta,omitempty"`

	// Name A human-readable name for the rule.
	Name SecurityDetectionsAPIRuleName `json:"name"`

	// Namespace Has no effect.
	Namespace *SecurityDetectionsAPIAlertsIndexNamespace `json:"namespace,omitempty"`

	// Note Notes to help investigate alerts produced by the rule.
	Note    *SecurityDetectionsAPIInvestigationGuide        `json:"note,omitempty"`
	Outcome *SecurityDetectionsAPISavedObjectResolveOutcome `json:"outcome,omitempty"`

	// OutputIndex (deprecated) Has no effect.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	OutputIndex *SecurityDetectionsAPIAlertsIndex `json:"output_index,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query *SecurityDetectionsAPIRuleQuery `json:"query,omitempty"`

	// References Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
	References          *SecurityDetectionsAPIRuleReferenceArray      `json:"references,omitempty"`
	RelatedIntegrations *SecurityDetectionsAPIRelatedIntegrationArray `json:"related_integrations,omitempty"`

	// RequiredFields Elasticsearch fields and their types that need to be present for the rule to function.
	// > info
	// > The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.
	RequiredFields  *[]SecurityDetectionsAPIRequiredFieldInput `json:"required_fields,omitempty"`
	ResponseActions *[]SecurityDetectionsAPIResponseAction     `json:"response_actions,omitempty"`

	// RiskScore A numerical representation of the alert's severity from 0 to 100, where:
	// * `0` - `21` represents low severity
	// * `22` - `47` represents medium severity
	// * `48` - `73` represents high severity
	// * `74` - `100` represents critical severity
	RiskScore SecurityDetectionsAPIRiskScore `json:"risk_score"`

	// RiskScoreMapping Overrides generated alerts' risk_score with a value from the source event
	RiskScoreMapping *SecurityDetectionsAPIRiskScoreMapping `json:"risk_score_mapping,omitempty"`

	// RuleId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
	RuleId *SecurityDetectionsAPIRuleSignatureId `json:"rule_id,omitempty"`

	// RuleNameOverride Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
	RuleNameOverride *SecurityDetectionsAPIRuleNameOverride `json:"rule_name_override,omitempty"`

	// SavedId Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
	SavedId *SecurityDetectionsAPISavedQueryId `json:"saved_id,omitempty"`

	// Setup Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
	Setup *SecurityDetectionsAPISetupGuide `json:"setup,omitempty"`

	// Severity Severity level of alerts produced by the rule, which must be one of the following:
	// * `low`: Alerts that are of interest but generally not considered to be security incidents
	// * `medium`: Alerts that require investigation
	// * `high`: Alerts that require immediate investigation
	// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
	Severity SecurityDetectionsAPISeverity `json:"severity"`

	// SeverityMapping Overrides generated alerts' severity with values from the source event
	SeverityMapping *SecurityDetectionsAPISeverityMapping `json:"severity_mapping,omitempty"`

	// Tags String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
	Tags   *SecurityDetectionsAPIRuleTagArray `json:"tags,omitempty"`
	Threat *SecurityDetectionsAPIThreatArray  `json:"threat,omitempty"`

	// Throttle Defines how often rule actions are taken.
	Throttle *SecurityDetectionsAPIRuleActionThrottle `json:"throttle,omitempty"`

	// TimelineId Timeline template ID
	TimelineId *SecurityDetectionsAPITimelineTemplateId `json:"timeline_id,omitempty"`

	// TimelineTitle Timeline template title
	TimelineTitle *SecurityDetectionsAPITimelineTemplateTitle `json:"timeline_title,omitempty"`

	// TimestampOverride Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
	TimestampOverride *SecurityDetectionsAPITimestampOverride `json:"timestamp_override,omitempty"`

	// TimestampOverrideFallbackDisabled Disables the fallback to the event's @timestamp field
	TimestampOverrideFallbackDisabled *SecurityDetectionsAPITimestampOverrideFallbackDisabled `json:"timestamp_override_fallback_disabled,omitempty"`
	To                                *SecurityDetectionsAPIRuleIntervalTo                    `json:"to,omitempty"`

	// Type Rule type
	Type SecurityDetectionsAPIQueryRuleCreatePropsType `json:"type"`

	// Version The rule's version number.
	//
	// - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
	// - For custom rules it is set to `1` when the rule is created.
	// > info
	// > It is not incremented on each update. Compare this to the `revision` field.
	Version *SecurityDetectionsAPIRuleVersion `json:"version,omitempty"`
}

// SecurityDetectionsAPIQueryRuleCreatePropsType Rule type
type SecurityDetectionsAPIQueryRuleCreatePropsType string

// SecurityDetectionsAPIQueryRuleDefaultableFields defines model for Security_Detections_API_QueryRuleDefaultableFields.
type SecurityDetectionsAPIQueryRuleDefaultableFields struct {
	Language *SecurityDetectionsAPIKqlQueryLanguage `json:"language,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query *SecurityDetectionsAPIRuleQuery `json:"query,omitempty"`
}

// SecurityDetectionsAPIQueryRuleOptionalFields defines model for Security_Detections_API_QueryRuleOptionalFields.
type SecurityDetectionsAPIQueryRuleOptionalFields struct {
	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression `json:"alert_suppression,omitempty"`
	DataViewId       *SecurityDetectionsAPIDataViewId       `json:"data_view_id,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`

	// SavedId Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
	SavedId *SecurityDetectionsAPISavedQueryId `json:"saved_id,omitempty"`
}

// SecurityDetectionsAPIQueryRuleRequiredFields defines model for Security_Detections_API_QueryRuleRequiredFields.
type SecurityDetectionsAPIQueryRuleRequiredFields struct {
	// Type Rule type
	Type SecurityDetectionsAPIQueryRuleRequiredFieldsType `json:"type"`
}

// SecurityDetectionsAPIQueryRuleRequiredFieldsType Rule type
type SecurityDetectionsAPIQueryRuleRequiredFieldsType string

// SecurityDetectionsAPIQueryRuleResponseFields defines model for Security_Detections_API_QueryRuleResponseFields.
type SecurityDetectionsAPIQueryRuleResponseFields struct {
	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression `json:"alert_suppression,omitempty"`
	DataViewId       *SecurityDetectionsAPIDataViewId       `json:"data_view_id,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index    *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`
	Language SecurityDetectionsAPIKqlQueryLanguage   `json:"language"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// SavedId Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
	SavedId *SecurityDetectionsAPISavedQueryId `json:"saved_id,omitempty"`

	// Type Rule type
	Type SecurityDetectionsAPIQueryRuleResponseFieldsType `json:"type"`
}

// SecurityDetectionsAPIQueryRuleResponseFieldsType Rule type
type SecurityDetectionsAPIQueryRuleResponseFieldsType string

// SecurityDetectionsAPIQueryRuleUpdateProps defines model for Security_Detections_API_QueryRuleUpdateProps.
type SecurityDetectionsAPIQueryRuleUpdateProps struct {
	// Actions Array defining the automated actions (notifications) taken when alerts are generated.
	Actions *[]SecurityDetectionsAPIRuleAction `json:"actions,omitempty"`

	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression                `json:"alert_suppression,omitempty"`
	AliasPurpose     *SecurityDetectionsAPISavedObjectResolveAliasPurpose  `json:"alias_purpose,omitempty"`
	AliasTargetId    *SecurityDetectionsAPISavedObjectResolveAliasTargetId `json:"alias_target_id,omitempty"`

	// Author The rules author.
	Author *SecurityDetectionsAPIRuleAuthorArray `json:"author,omitempty"`

	// BuildingBlockType Determines if the rule acts as a building block. If yes, the value must be `default`.
	// By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
	// For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
	BuildingBlockType *SecurityDetectionsAPIBuildingBlockType `json:"building_block_type,omitempty"`
	DataViewId        *SecurityDetectionsAPIDataViewId        `json:"data_view_id,omitempty"`

	// Description The rules description.
	Description SecurityDetectionsAPIRuleDescription `json:"description"`

	// Enabled Determines whether the rule is enabled. Defaults to true.
	Enabled        *SecurityDetectionsAPIIsRuleEnabled       `json:"enabled,omitempty"`
	ExceptionsList *[]SecurityDetectionsAPIRuleExceptionList `json:"exceptions_list,omitempty"`

	// FalsePositives String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
	FalsePositives *SecurityDetectionsAPIRuleFalsePositiveArray `json:"false_positives,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// From Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
	From *SecurityDetectionsAPIRuleIntervalFrom `json:"from,omitempty"`

	// Id A universally unique identifier
	Id *SecurityDetectionsAPIRuleObjectId `json:"id,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`

	// Interval Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
	Interval *SecurityDetectionsAPIRuleInterval `json:"interval,omitempty"`

	// InvestigationFields Schema for fields relating to investigation fields. These are user defined fields we use to highlight
	// in various features in the UI such as alert details flyout and exceptions auto-population from alert.
	InvestigationFields *SecurityDetectionsAPIInvestigationFields `json:"investigation_fields,omitempty"`
	Language            *SecurityDetectionsAPIKqlQueryLanguage    `json:"language,omitempty"`

	// License The rule's license.
	License *SecurityDetectionsAPIRuleLicense `json:"license,omitempty"`

	// MaxSignals Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
	// > info
	// > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
	MaxSignals *SecurityDetectionsAPIMaxSignals `json:"max_signals,omitempty"`

	// Meta Placeholder for metadata about the rule.
	// > info
	// > This field is overwritten when you save changes to the rules settings.
	Meta *SecurityDetectionsAPIRuleMetadata `json:"meta,omitempty"`

	// Name A human-readable name for the rule.
	Name SecurityDetectionsAPIRuleName `json:"name"`

	// Namespace Has no effect.
	Namespace *SecurityDetectionsAPIAlertsIndexNamespace `json:"namespace,omitempty"`

	// Note Notes to help investigate alerts produced by the rule.
	Note    *SecurityDetectionsAPIInvestigationGuide        `json:"note,omitempty"`
	Outcome *SecurityDetectionsAPISavedObjectResolveOutcome `json:"outcome,omitempty"`

	// OutputIndex (deprecated) Has no effect.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	OutputIndex *SecurityDetectionsAPIAlertsIndex `json:"output_index,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query *SecurityDetectionsAPIRuleQuery `json:"query,omitempty"`

	// References Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
	References          *SecurityDetectionsAPIRuleReferenceArray      `json:"references,omitempty"`
	RelatedIntegrations *SecurityDetectionsAPIRelatedIntegrationArray `json:"related_integrations,omitempty"`

	// RequiredFields Elasticsearch fields and their types that need to be present for the rule to function.
	// > info
	// > The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.
	RequiredFields  *[]SecurityDetectionsAPIRequiredFieldInput `json:"required_fields,omitempty"`
	ResponseActions *[]SecurityDetectionsAPIResponseAction     `json:"response_actions,omitempty"`

	// RiskScore A numerical representation of the alert's severity from 0 to 100, where:
	// * `0` - `21` represents low severity
	// * `22` - `47` represents medium severity
	// * `48` - `73` represents high severity
	// * `74` - `100` represents critical severity
	RiskScore SecurityDetectionsAPIRiskScore `json:"risk_score"`

	// RiskScoreMapping Overrides generated alerts' risk_score with a value from the source event
	RiskScoreMapping *SecurityDetectionsAPIRiskScoreMapping `json:"risk_score_mapping,omitempty"`

	// RuleId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
	RuleId *SecurityDetectionsAPIRuleSignatureId `json:"rule_id,omitempty"`

	// RuleNameOverride Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
	RuleNameOverride *SecurityDetectionsAPIRuleNameOverride `json:"rule_name_override,omitempty"`

	// SavedId Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
	SavedId *SecurityDetectionsAPISavedQueryId `json:"saved_id,omitempty"`

	// Setup Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
	Setup *SecurityDetectionsAPISetupGuide `json:"setup,omitempty"`

	// Severity Severity level of alerts produced by the rule, which must be one of the following:
	// * `low`: Alerts that are of interest but generally not considered to be security incidents
	// * `medium`: Alerts that require investigation
	// * `high`: Alerts that require immediate investigation
	// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
	Severity SecurityDetectionsAPISeverity `json:"severity"`

	// SeverityMapping Overrides generated alerts' severity with values from the source event
	SeverityMapping *SecurityDetectionsAPISeverityMapping `json:"severity_mapping,omitempty"`

	// Tags String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
	Tags   *SecurityDetectionsAPIRuleTagArray `json:"tags,omitempty"`
	Threat *SecurityDetectionsAPIThreatArray  `json:"threat,omitempty"`

	// Throttle Defines how often rule actions are taken.
	Throttle *SecurityDetectionsAPIRuleActionThrottle `json:"throttle,omitempty"`

	// TimelineId Timeline template ID
	TimelineId *SecurityDetectionsAPITimelineTemplateId `json:"timeline_id,omitempty"`

	// TimelineTitle Timeline template title
	TimelineTitle *SecurityDetectionsAPITimelineTemplateTitle `json:"timeline_title,omitempty"`

	// TimestampOverride Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
	TimestampOverride *SecurityDetectionsAPITimestampOverride `json:"timestamp_override,omitempty"`

	// TimestampOverrideFallbackDisabled Disables the fallback to the event's @timestamp field
	TimestampOverrideFallbackDisabled *SecurityDetectionsAPITimestampOverrideFallbackDisabled `json:"timestamp_override_fallback_disabled,omitempty"`
	To                                *SecurityDetectionsAPIRuleIntervalTo                    `json:"to,omitempty"`

	// Type Rule type
	Type SecurityDetectionsAPIQueryRuleUpdatePropsType `json:"type"`

	// Version The rule's version number.
	//
	// - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
	// - For custom rules it is set to `1` when the rule is created.
	// > info
	// > It is not incremented on each update. Compare this to the `revision` field.
	Version *SecurityDetectionsAPIRuleVersion `json:"version,omitempty"`
}

// SecurityDetectionsAPIQueryRuleUpdatePropsType Rule type
type SecurityDetectionsAPIQueryRuleUpdatePropsType string

// SecurityDetectionsAPIRelatedIntegration Related integration is a potential dependency of a rule. It's assumed that if the user installs
// one of the related integrations of a rule, the rule might start to work properly because it will
// have source events (generated by this integration) potentially matching the rule's query.
//
// NOTE: Proper work is not guaranteed, because a related integration, if installed, can be
// configured differently or generate data that is not necessarily relevant for this rule.
//
// Related integration is a combination of a Fleet package and (optionally) one of the
// package's "integrations" that this package contains. It is represented by 3 properties:
//
// - `package`: name of the package (required, unique id)
// - `version`: version of the package (required, semver-compatible)
// - `integration`: name of the integration of this package (optional, id within the package)
//
// There are Fleet packages like `windows` that contain only one integration; in this case,
// `integration` should be unspecified. There are also packages like `aws` and `azure` that contain
// several integrations; in this case, `integration` should be specified.
type SecurityDetectionsAPIRelatedIntegration struct {
	// Integration A string that does not contain only whitespace characters
	Integration *SecurityDetectionsAPINonEmptyString `json:"integration,omitempty"`

	// Package A string that does not contain only whitespace characters
	Package SecurityDetectionsAPINonEmptyString `json:"package"`

	// Version A string that does not contain only whitespace characters
	Version SecurityDetectionsAPINonEmptyString `json:"version"`
}

// SecurityDetectionsAPIRelatedIntegrationArray defines model for Security_Detections_API_RelatedIntegrationArray.
type SecurityDetectionsAPIRelatedIntegrationArray = []SecurityDetectionsAPIRelatedIntegration

// SecurityDetectionsAPIRequiredField Describes an Elasticsearch field that is needed for the rule to function.
//
// Almost all types of Security rules check source event documents for a match to some kind of
// query or filter. If a document has certain field with certain values, then it's a match and
// the rule will generate an alert.
//
// Required field is an event field that must be present in the source indices of a given rule.
//
// @example
//
//	const standardEcsField: RequiredField = {
//	  name: 'event.action',
//	  type: 'keyword',
//	  ecs: true,
//	};
//
// @example
//
//	const nonEcsField: RequiredField = {
//	  name: 'winlog.event_data.AttributeLDAPDisplayName',
//	  type: 'keyword',
//	  ecs: false,
//	};
type SecurityDetectionsAPIRequiredField struct {
	// Ecs Indicates whether the field is ECS-compliant. This property is only present in responses. Its value is computed based on fields name and type.
	Ecs bool `json:"ecs"`

	// Name Name of an Elasticsearch field
	Name string `json:"name"`

	// Type Type of the Elasticsearch field
	Type string `json:"type"`
}

// SecurityDetectionsAPIRequiredFieldArray defines model for Security_Detections_API_RequiredFieldArray.
type SecurityDetectionsAPIRequiredFieldArray = []SecurityDetectionsAPIRequiredField

// SecurityDetectionsAPIRequiredFieldInput Input parameters to create a RequiredField. Does not include the `ecs` field, because `ecs` is calculated on the backend based on the field name and type.
type SecurityDetectionsAPIRequiredFieldInput struct {
	// Name Name of an Elasticsearch field
	Name string `json:"name"`

	// Type Type of the Elasticsearch field
	Type string `json:"type"`
}

// SecurityDetectionsAPIResponseAction defines model for Security_Detections_API_ResponseAction.
type SecurityDetectionsAPIResponseAction struct {
	union json.RawMessage
}

// SecurityDetectionsAPIResponseFields defines model for Security_Detections_API_ResponseFields.
type SecurityDetectionsAPIResponseFields struct {
	CreatedAt time.Time `json:"created_at"`
	CreatedBy string    `json:"created_by"`

	// ExecutionSummary Summary of the last execution of a rule.
	// > info
	// > This field is under development and its usage or schema may change
	ExecutionSummary *SecurityDetectionsAPIRuleExecutionSummary `json:"execution_summary,omitempty"`

	// Id A universally unique identifier
	Id SecurityDetectionsAPIRuleObjectId `json:"id"`

	// Immutable This field determines whether the rule is a prebuilt Elastic rule. It will be replaced with the `rule_source` field.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Immutable      SecurityDetectionsAPIIsRuleImmutable    `json:"immutable"`
	RequiredFields SecurityDetectionsAPIRequiredFieldArray `json:"required_fields"`

	// Revision The rule's revision number.
	//
	// It represents the version of rule's object in Kibana. It is set to `0` when the rule is installed or created and then gets incremented on each update.
	// > info
	// > Not all updates to any rule fields will increment the revision. Only those fields that are considered static `rule parameters` can trigger revision increments. For example, an update to a rule's query or index fields will increment the rule's revision by `1`. However, changes to dynamic or technical fields like enabled or execution_summary will not cause revision increments.
	Revision SecurityDetectionsAPIRuleRevision `json:"revision"`

	// RuleId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
	RuleId SecurityDetectionsAPIRuleSignatureId `json:"rule_id"`

	// RuleSource Discriminated union that determines whether the rule is internally sourced (created within the Kibana app) or has an external source, such as the Elastic Prebuilt rules repo.
	RuleSource SecurityDetectionsAPIRuleSource `json:"rule_source"`
	UpdatedAt  time.Time                       `json:"updated_at"`
	UpdatedBy  string                          `json:"updated_by"`
}

// SecurityDetectionsAPIRiskScore A numerical representation of the alert's severity from 0 to 100, where:
// * `0` - `21` represents low severity
// * `22` - `47` represents medium severity
// * `48` - `73` represents high severity
// * `74` - `100` represents critical severity
type SecurityDetectionsAPIRiskScore = int

// SecurityDetectionsAPIRiskScoreMapping Overrides generated alerts' risk_score with a value from the source event
type SecurityDetectionsAPIRiskScoreMapping = []struct {
	// Field Source event field used to override the default `risk_score`.
	Field    string                                        `json:"field"`
	Operator SecurityDetectionsAPIRiskScoreMappingOperator `json:"operator"`

	// RiskScore A numerical representation of the alert's severity from 0 to 100, where:
	// * `0` - `21` represents low severity
	// * `22` - `47` represents medium severity
	// * `48` - `73` represents high severity
	// * `74` - `100` represents critical severity
	RiskScore *SecurityDetectionsAPIRiskScore `json:"risk_score,omitempty"`
	Value     string                          `json:"value"`
}

// SecurityDetectionsAPIRiskScoreMappingOperator defines model for SecurityDetectionsAPIRiskScoreMapping.Operator.
type SecurityDetectionsAPIRiskScoreMappingOperator string

// SecurityDetectionsAPIRuleAction defines model for Security_Detections_API_RuleAction.
type SecurityDetectionsAPIRuleAction struct {
	// ActionTypeId The action type used for sending notifications, can be:
	//
	//   - `.slack`
	//   - `.slack_api`
	//   - `.email`
	//   - `.index`
	//   - `.pagerduty`
	//   - `.swimlane`
	//   - `.webhook`
	//   - `.servicenow`
	//   - `.servicenow-itom`
	//   - `.servicenow-sir`
	//   - `.jira`
	//   - `.resilient`
	//   - `.opsgenie`
	//   - `.teams`
	//   - `.torq`
	//   - `.tines`
	//   - `.d3security`
	ActionTypeId string `json:"action_type_id"`

	// AlertsFilter Object containing an actions conditional filters.
	//
	// - `timeframe` (object, optional): Object containing the time frame for when this action can be run.
	//     - `days` (array of integers, required): List of days of the week on which this action will be run. Days of the week are expressed as numbers between `1-7`, where `1` is Monday and `7` is Sunday. To select all days of the week, enter an empty array.
	//     - `hours` (object, required): The hours of the day during which this action will run. Hours of the day are expressed as two strings in the format `hh:mm` in `24` hour time. A start of `00:00` and an end of `24:00` means the action can run all day.
	//         - start (string, required): Start time in `hh:mm` format.
	//         - end (string, required): End time in `hh:mm` format.
	//     - `timezone` (string, required): An ISO timezone name, such as `Europe/Madrid` or `America/New_York`. Specific offsets such as `UTC` or `UTC+1` will also work, but lack built-in DST.
	// - `query` (object, optional): Object containing a query filter which gets applied to an action and determines whether the action should run.
	//     - `kql` (string, required): A KQL string.
	//     - `filters` (array of objects, required): Array of filter objects, as defined in the `kbn-es-query` package.
	AlertsFilter *SecurityDetectionsAPIRuleActionAlertsFilter `json:"alerts_filter,omitempty"`

	// Frequency The action frequency defines when the action runs (for example, only on rule execution or at specific time intervals).
	Frequency *SecurityDetectionsAPIRuleActionFrequency `json:"frequency,omitempty"`

	// Group Optionally groups actions by use cases. Use `default` for alert notifications.
	Group *SecurityDetectionsAPIRuleActionGroup `json:"group,omitempty"`

	// Id The connector ID.
	Id SecurityDetectionsAPIRuleActionId `json:"id"`

	// Params Object containing the allowed connector fields, which varies according to the connector type.
	//
	// For Slack:
	//
	//   - `message` (string, required): The notification message.
	//
	// For email:
	//
	//   - `to`, `cc`, `bcc` (string): Email addresses to which the notifications are sent. At least one field must have a value.
	//   - `subject` (string, optional): Email subject line.
	//   - `message` (string, required): Email body text.
	//
	// For Webhook:
	//
	//   - `body` (string, required): JSON payload.
	//
	// For PagerDuty:
	//
	//   - `severity` (string, required): Severity of on the alert notification, can be: `Critical`, `Error`, `Warning` or `Info`.
	//   - `eventAction` (string, required): Event [action type](https://v2.developer.pagerduty.com/docs/events-api-v2#event-action), which can be `trigger`, `resolve`, or `acknowledge`.
	//   - `dedupKey` (string, optional): Groups alert notifications with the same PagerDuty alert.
	//   - `timestamp` (DateTime, optional): ISO-8601 format [timestamp](https://v2.developer.pagerduty.com/docs/types#datetime).
	//   - `component` (string, optional): Source machine component responsible for the event, for example `security-solution`.
	//   - `group` (string, optional): Enables logical grouping of service components.
	//   - `source` (string, optional): The affected system. Defaults to the Kibana saved object ID of the action.
	//   - `summary` (string, options): Summary of the event. Defaults to `No summary provided`. Maximum length is 1024 characters.
	//   - `class` (string, optional): Value indicating the class/type of the event.
	Params SecurityDetectionsAPIRuleActionParams `json:"params"`

	// Uuid A string that does not contain only whitespace characters
	Uuid *SecurityDetectionsAPINonEmptyString `json:"uuid,omitempty"`
}

// SecurityDetectionsAPIRuleActionAlertsFilter Object containing an actions conditional filters.
//
// - `timeframe` (object, optional): Object containing the time frame for when this action can be run.
//   - `days` (array of integers, required): List of days of the week on which this action will be run. Days of the week are expressed as numbers between `1-7`, where `1` is Monday and `7` is Sunday. To select all days of the week, enter an empty array.
//   - `hours` (object, required): The hours of the day during which this action will run. Hours of the day are expressed as two strings in the format `hh:mm` in `24` hour time. A start of `00:00` and an end of `24:00` means the action can run all day.
//   - start (string, required): Start time in `hh:mm` format.
//   - end (string, required): End time in `hh:mm` format.
//   - `timezone` (string, required): An ISO timezone name, such as `Europe/Madrid` or `America/New_York`. Specific offsets such as `UTC` or `UTC+1` will also work, but lack built-in DST.
//
// - `query` (object, optional): Object containing a query filter which gets applied to an action and determines whether the action should run.
//   - `kql` (string, required): A KQL string.
//   - `filters` (array of objects, required): Array of filter objects, as defined in the `kbn-es-query` package.
type SecurityDetectionsAPIRuleActionAlertsFilter map[string]interface{}

// SecurityDetectionsAPIRuleActionFrequency The action frequency defines when the action runs (for example, only on rule execution or at specific time intervals).
type SecurityDetectionsAPIRuleActionFrequency struct {
	// NotifyWhen Defines how often rules run actions.
	NotifyWhen SecurityDetectionsAPIRuleActionNotifyWhen `json:"notifyWhen"`

	// Summary Action summary indicates whether we will send a summary notification about all the generate alerts or notification per individual alert
	Summary bool `json:"summary"`

	// Throttle Defines how often rule actions are taken.
	Throttle SecurityDetectionsAPIRuleActionThrottle `json:"throttle"`
}

// SecurityDetectionsAPIRuleActionGroup Optionally groups actions by use cases. Use `default` for alert notifications.
type SecurityDetectionsAPIRuleActionGroup = string

// SecurityDetectionsAPIRuleActionId The connector ID.
type SecurityDetectionsAPIRuleActionId = string

// SecurityDetectionsAPIRuleActionNotifyWhen Defines how often rules run actions.
type SecurityDetectionsAPIRuleActionNotifyWhen string

// SecurityDetectionsAPIRuleActionParams Object containing the allowed connector fields, which varies according to the connector type.
//
// For Slack:
//
//   - `message` (string, required): The notification message.
//
// For email:
//
//   - `to`, `cc`, `bcc` (string): Email addresses to which the notifications are sent. At least one field must have a value.
//   - `subject` (string, optional): Email subject line.
//   - `message` (string, required): Email body text.
//
// For Webhook:
//
//   - `body` (string, required): JSON payload.
//
// For PagerDuty:
//
//   - `severity` (string, required): Severity of on the alert notification, can be: `Critical`, `Error`, `Warning` or `Info`.
//   - `eventAction` (string, required): Event [action type](https://v2.developer.pagerduty.com/docs/events-api-v2#event-action), which can be `trigger`, `resolve`, or `acknowledge`.
//   - `dedupKey` (string, optional): Groups alert notifications with the same PagerDuty alert.
//   - `timestamp` (DateTime, optional): ISO-8601 format [timestamp](https://v2.developer.pagerduty.com/docs/types#datetime).
//   - `component` (string, optional): Source machine component responsible for the event, for example `security-solution`.
//   - `group` (string, optional): Enables logical grouping of service components.
//   - `source` (string, optional): The affected system. Defaults to the Kibana saved object ID of the action.
//   - `summary` (string, options): Summary of the event. Defaults to `No summary provided`. Maximum length is 1024 characters.
//   - `class` (string, optional): Value indicating the class/type of the event.
type SecurityDetectionsAPIRuleActionParams map[string]interface{}

// SecurityDetectionsAPIRuleActionThrottle Defines how often rule actions are taken.
type SecurityDetectionsAPIRuleActionThrottle struct {
	union json.RawMessage
}

// SecurityDetectionsAPIRuleActionThrottle0 defines model for SecurityDetectionsAPIRuleActionThrottle.0.
type SecurityDetectionsAPIRuleActionThrottle0 string

// SecurityDetectionsAPIRuleActionThrottle1 Time interval in seconds, minutes, hours, or days.
type SecurityDetectionsAPIRuleActionThrottle1 = string

// SecurityDetectionsAPIRuleAuthorArray The rules author.
type SecurityDetectionsAPIRuleAuthorArray = []string

// SecurityDetectionsAPIRuleCreateProps defines model for Security_Detections_API_RuleCreateProps.
type SecurityDetectionsAPIRuleCreateProps struct {
	union json.RawMessage
}

// SecurityDetectionsAPIRuleDescription The rules description.
type SecurityDetectionsAPIRuleDescription = string

// SecurityDetectionsAPIRuleExceptionList Array of [exception containers](https://www.elastic.co/guide/en/security/current/exceptions-api-overview.html), which define exceptions that prevent the rule from generating alerts even when its other criteria are met.
type SecurityDetectionsAPIRuleExceptionList struct {
	// Id ID of the exception container
	Id string `json:"id"`

	// ListId List ID of the exception container
	ListId string `json:"list_id"`

	// NamespaceType Determines the exceptions validity in rule's Kibana space
	NamespaceType SecurityDetectionsAPIRuleExceptionListNamespaceType `json:"namespace_type"`

	// Type The exception type
	Type SecurityDetectionsAPIExceptionListType `json:"type"`
}

// SecurityDetectionsAPIRuleExceptionListNamespaceType Determines the exceptions validity in rule's Kibana space
type SecurityDetectionsAPIRuleExceptionListNamespaceType string

// SecurityDetectionsAPIRuleExecutionMetrics defines model for Security_Detections_API_RuleExecutionMetrics.
type SecurityDetectionsAPIRuleExecutionMetrics struct {
	// ExecutionGapDurationS Duration in seconds of execution gap
	ExecutionGapDurationS *int `json:"execution_gap_duration_s,omitempty"`

	// FrozenIndicesQueriedCount Count of frozen indices queried during the rule execution. These indices could not be entirely excluded after applying the time range filter.
	FrozenIndicesQueriedCount *int `json:"frozen_indices_queried_count,omitempty"`

	// GapRange Range of the execution gap
	GapRange *struct {
		// Gte Start date of the execution gap
		Gte string `json:"gte"`

		// Lte End date of the execution gap
		Lte string `json:"lte"`
	} `json:"gap_range,omitempty"`

	// TotalEnrichmentDurationMs Total time spent enriching documents during current rule execution cycle
	TotalEnrichmentDurationMs *int `json:"total_enrichment_duration_ms,omitempty"`

	// TotalIndexingDurationMs Total time spent indexing documents during current rule execution cycle
	TotalIndexingDurationMs *int `json:"total_indexing_duration_ms,omitempty"`

	// TotalSearchDurationMs Total time spent performing ES searches as measured by Kibana; includes network latency and time spent serializing/deserializing request/response
	TotalSearchDurationMs *int `json:"total_search_duration_ms,omitempty"`
}

// SecurityDetectionsAPIRuleExecutionStatus Custom execution status of Security rules that is different from the status used in the Alerting Framework. We merge our custom status with the Framework's status to determine the resulting status of a rule.
// - going to run - @deprecated Replaced by the 'running' status but left for backwards compatibility with rule execution events already written to Event Log in the prior versions of Kibana. Don't use when writing rule status changes.
// - running - Rule execution started but not reached any intermediate or final status.
// - partial failure - Rule can partially fail for various reasons either in the middle of an execution (in this case we update its status right away) or in the end of it. So currently this status can be both intermediate and final at the same time. A typical reason for a partial failure: not all the indices that the rule searches over actually exist.
// - failed - Rule failed to execute due to unhandled exception or a reason defined in the business logic of its executor function.
// - succeeded - Rule executed successfully without any issues. Note: this status is just an indication of a rule's "health". The rule might or might not generate any alerts despite of it.
type SecurityDetectionsAPIRuleExecutionStatus string

// SecurityDetectionsAPIRuleExecutionStatusOrder defines model for Security_Detections_API_RuleExecutionStatusOrder.
type SecurityDetectionsAPIRuleExecutionStatusOrder = int

// SecurityDetectionsAPIRuleExecutionSummary Summary of the last execution of a rule.
// > info
// > This field is under development and its usage or schema may change
type SecurityDetectionsAPIRuleExecutionSummary struct {
	LastExecution struct {
		// Date Date of the last execution
		Date    time.Time                                 `json:"date"`
		Message string                                    `json:"message"`
		Metrics SecurityDetectionsAPIRuleExecutionMetrics `json:"metrics"`

		// Status Custom execution status of Security rules that is different from the status used in the Alerting Framework. We merge our custom status with the Framework's status to determine the resulting status of a rule.
		// - going to run - @deprecated Replaced by the 'running' status but left for backwards compatibility with rule execution events already written to Event Log in the prior versions of Kibana. Don't use when writing rule status changes.
		// - running - Rule execution started but not reached any intermediate or final status.
		// - partial failure - Rule can partially fail for various reasons either in the middle of an execution (in this case we update its status right away) or in the end of it. So currently this status can be both intermediate and final at the same time. A typical reason for a partial failure: not all the indices that the rule searches over actually exist.
		// - failed - Rule failed to execute due to unhandled exception or a reason defined in the business logic of its executor function.
		// - succeeded - Rule executed successfully without any issues. Note: this status is just an indication of a rule's "health". The rule might or might not generate any alerts despite of it.
		Status      SecurityDetectionsAPIRuleExecutionStatus      `json:"status"`
		StatusOrder SecurityDetectionsAPIRuleExecutionStatusOrder `json:"status_order"`
	} `json:"last_execution"`
}

// SecurityDetectionsAPIRuleFalsePositiveArray String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
type SecurityDetectionsAPIRuleFalsePositiveArray = []string

// SecurityDetectionsAPIRuleFilterArray The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
// > info
// > This field is not supported for ES|QL rules.
type SecurityDetectionsAPIRuleFilterArray = []interface{}

// SecurityDetectionsAPIRuleInterval Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
type SecurityDetectionsAPIRuleInterval = string

// SecurityDetectionsAPIRuleIntervalFrom Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
type SecurityDetectionsAPIRuleIntervalFrom = string

// SecurityDetectionsAPIRuleIntervalTo defines model for Security_Detections_API_RuleIntervalTo.
type SecurityDetectionsAPIRuleIntervalTo = string

// SecurityDetectionsAPIRuleLicense The rule's license.
type SecurityDetectionsAPIRuleLicense = string

// SecurityDetectionsAPIRuleMetadata Placeholder for metadata about the rule.
// > info
// > This field is overwritten when you save changes to the rules settings.
type SecurityDetectionsAPIRuleMetadata map[string]interface{}

// SecurityDetectionsAPIRuleName A human-readable name for the rule.
type SecurityDetectionsAPIRuleName = string

// SecurityDetectionsAPIRuleNameOverride Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
type SecurityDetectionsAPIRuleNameOverride = string

// SecurityDetectionsAPIRuleObjectId A universally unique identifier
type SecurityDetectionsAPIRuleObjectId = SecurityDetectionsAPIUUID

// SecurityDetectionsAPIRuleQuery [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
//
// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
type SecurityDetectionsAPIRuleQuery = string

// SecurityDetectionsAPIRuleReferenceArray Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
type SecurityDetectionsAPIRuleReferenceArray = []string

// SecurityDetectionsAPIRuleResponse defines model for Security_Detections_API_RuleResponse.
type SecurityDetectionsAPIRuleResponse struct {
	union json.RawMessage
}

// SecurityDetectionsAPIRuleRevision The rule's revision number.
//
// It represents the version of rule's object in Kibana. It is set to `0` when the rule is installed or created and then gets incremented on each update.
// > info
// > Not all updates to any rule fields will increment the revision. Only those fields that are considered static `rule parameters` can trigger revision increments. For example, an update to a rule's query or index fields will increment the rule's revision by `1`. However, changes to dynamic or technical fields like enabled or execution_summary will not cause revision increments.
type SecurityDetectionsAPIRuleRevision = int

// SecurityDetectionsAPIRuleSignatureId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
type SecurityDetectionsAPIRuleSignatureId = string

// SecurityDetectionsAPIRuleSource Discriminated union that determines whether the rule is internally sourced (created within the Kibana app) or has an external source, such as the Elastic Prebuilt rules repo.
type SecurityDetectionsAPIRuleSource struct {
	union json.RawMessage
}

// SecurityDetectionsAPIRuleTagArray String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
type SecurityDetectionsAPIRuleTagArray = []string

// SecurityDetectionsAPIRuleUpdateProps defines model for Security_Detections_API_RuleUpdateProps.
type SecurityDetectionsAPIRuleUpdateProps struct {
	union json.RawMessage
}

// SecurityDetectionsAPIRuleVersion The rule's version number.
//
// - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
// - For custom rules it is set to `1` when the rule is created.
// > info
// > It is not incremented on each update. Compare this to the `revision` field.
type SecurityDetectionsAPIRuleVersion = int

// SecurityDetectionsAPISavedObjectResolveAliasPurpose defines model for Security_Detections_API_SavedObjectResolveAliasPurpose.
type SecurityDetectionsAPISavedObjectResolveAliasPurpose string

// SecurityDetectionsAPISavedObjectResolveAliasTargetId defines model for Security_Detections_API_SavedObjectResolveAliasTargetId.
type SecurityDetectionsAPISavedObjectResolveAliasTargetId = string

// SecurityDetectionsAPISavedObjectResolveOutcome defines model for Security_Detections_API_SavedObjectResolveOutcome.
type SecurityDetectionsAPISavedObjectResolveOutcome string

// SecurityDetectionsAPISavedQueryId Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
type SecurityDetectionsAPISavedQueryId = string

// SecurityDetectionsAPISavedQueryRule defines model for Security_Detections_API_SavedQueryRule.
type SecurityDetectionsAPISavedQueryRule struct {
	// Actions Array defining the automated actions (notifications) taken when alerts are generated.
	Actions []SecurityDetectionsAPIRuleAction `json:"actions"`

	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression                `json:"alert_suppression,omitempty"`
	AliasPurpose     *SecurityDetectionsAPISavedObjectResolveAliasPurpose  `json:"alias_purpose,omitempty"`
	AliasTargetId    *SecurityDetectionsAPISavedObjectResolveAliasTargetId `json:"alias_target_id,omitempty"`

	// Author The rules author.
	Author SecurityDetectionsAPIRuleAuthorArray `json:"author"`

	// BuildingBlockType Determines if the rule acts as a building block. If yes, the value must be `default`.
	// By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
	// For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
	BuildingBlockType *SecurityDetectionsAPIBuildingBlockType `json:"building_block_type,omitempty"`
	CreatedAt         time.Time                               `json:"created_at"`
	CreatedBy         string                                  `json:"created_by"`
	DataViewId        *SecurityDetectionsAPIDataViewId        `json:"data_view_id,omitempty"`

	// Description The rules description.
	Description SecurityDetectionsAPIRuleDescription `json:"description"`

	// Enabled Determines whether the rule is enabled. Defaults to true.
	Enabled        SecurityDetectionsAPIIsRuleEnabled       `json:"enabled"`
	ExceptionsList []SecurityDetectionsAPIRuleExceptionList `json:"exceptions_list"`

	// ExecutionSummary Summary of the last execution of a rule.
	// > info
	// > This field is under development and its usage or schema may change
	ExecutionSummary *SecurityDetectionsAPIRuleExecutionSummary `json:"execution_summary,omitempty"`

	// FalsePositives String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
	FalsePositives SecurityDetectionsAPIRuleFalsePositiveArray `json:"false_positives"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// From Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
	From SecurityDetectionsAPIRuleIntervalFrom `json:"from"`

	// Id A universally unique identifier
	Id SecurityDetectionsAPIRuleObjectId `json:"id"`

	// Immutable This field determines whether the rule is a prebuilt Elastic rule. It will be replaced with the `rule_source` field.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Immutable SecurityDetectionsAPIIsRuleImmutable `json:"immutable"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`

	// Interval Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
	Interval SecurityDetectionsAPIRuleInterval `json:"interval"`

	// InvestigationFields Schema for fields relating to investigation fields. These are user defined fields we use to highlight
	// in various features in the UI such as alert details flyout and exceptions auto-population from alert.
	InvestigationFields *SecurityDetectionsAPIInvestigationFields `json:"investigation_fields,omitempty"`
	Language            SecurityDetectionsAPIKqlQueryLanguage     `json:"language"`

	// License The rule's license.
	License *SecurityDetectionsAPIRuleLicense `json:"license,omitempty"`

	// MaxSignals Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
	// > info
	// > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
	MaxSignals SecurityDetectionsAPIMaxSignals `json:"max_signals"`

	// Meta Placeholder for metadata about the rule.
	// > info
	// > This field is overwritten when you save changes to the rules settings.
	Meta *SecurityDetectionsAPIRuleMetadata `json:"meta,omitempty"`

	// Name A human-readable name for the rule.
	Name SecurityDetectionsAPIRuleName `json:"name"`

	// Namespace Has no effect.
	Namespace *SecurityDetectionsAPIAlertsIndexNamespace `json:"namespace,omitempty"`

	// Note Notes to help investigate alerts produced by the rule.
	Note    *SecurityDetectionsAPIInvestigationGuide        `json:"note,omitempty"`
	Outcome *SecurityDetectionsAPISavedObjectResolveOutcome `json:"outcome,omitempty"`

	// OutputIndex (deprecated) Has no effect.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	OutputIndex *SecurityDetectionsAPIAlertsIndex `json:"output_index,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query *SecurityDetectionsAPIRuleQuery `json:"query,omitempty"`

	// References Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
	References          SecurityDetectionsAPIRuleReferenceArray      `json:"references"`
	RelatedIntegrations SecurityDetectionsAPIRelatedIntegrationArray `json:"related_integrations"`
	RequiredFields      SecurityDetectionsAPIRequiredFieldArray      `json:"required_fields"`
	ResponseActions     *[]SecurityDetectionsAPIResponseAction       `json:"response_actions,omitempty"`

	// Revision The rule's revision number.
	//
	// It represents the version of rule's object in Kibana. It is set to `0` when the rule is installed or created and then gets incremented on each update.
	// > info
	// > Not all updates to any rule fields will increment the revision. Only those fields that are considered static `rule parameters` can trigger revision increments. For example, an update to a rule's query or index fields will increment the rule's revision by `1`. However, changes to dynamic or technical fields like enabled or execution_summary will not cause revision increments.
	Revision SecurityDetectionsAPIRuleRevision `json:"revision"`

	// RiskScore A numerical representation of the alert's severity from 0 to 100, where:
	// * `0` - `21` represents low severity
	// * `22` - `47` represents medium severity
	// * `48` - `73` represents high severity
	// * `74` - `100` represents critical severity
	RiskScore SecurityDetectionsAPIRiskScore `json:"risk_score"`

	// RiskScoreMapping Overrides generated alerts' risk_score with a value from the source event
	RiskScoreMapping SecurityDetectionsAPIRiskScoreMapping `json:"risk_score_mapping"`

	// RuleId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
	RuleId SecurityDetectionsAPIRuleSignatureId `json:"rule_id"`

	// RuleNameOverride Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
	RuleNameOverride *SecurityDetectionsAPIRuleNameOverride `json:"rule_name_override,omitempty"`

	// RuleSource Discriminated union that determines whether the rule is internally sourced (created within the Kibana app) or has an external source, such as the Elastic Prebuilt rules repo.
	RuleSource SecurityDetectionsAPIRuleSource `json:"rule_source"`

	// SavedId Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
	SavedId SecurityDetectionsAPISavedQueryId `json:"saved_id"`

	// Setup Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
	Setup SecurityDetectionsAPISetupGuide `json:"setup"`

	// Severity Severity level of alerts produced by the rule, which must be one of the following:
	// * `low`: Alerts that are of interest but generally not considered to be security incidents
	// * `medium`: Alerts that require investigation
	// * `high`: Alerts that require immediate investigation
	// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
	Severity SecurityDetectionsAPISeverity `json:"severity"`

	// SeverityMapping Overrides generated alerts' severity with values from the source event
	SeverityMapping SecurityDetectionsAPISeverityMapping `json:"severity_mapping"`

	// Tags String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
	Tags   SecurityDetectionsAPIRuleTagArray `json:"tags"`
	Threat SecurityDetectionsAPIThreatArray  `json:"threat"`

	// Throttle Defines how often rule actions are taken.
	Throttle *SecurityDetectionsAPIRuleActionThrottle `json:"throttle,omitempty"`

	// TimelineId Timeline template ID
	TimelineId *SecurityDetectionsAPITimelineTemplateId `json:"timeline_id,omitempty"`

	// TimelineTitle Timeline template title
	TimelineTitle *SecurityDetectionsAPITimelineTemplateTitle `json:"timeline_title,omitempty"`

	// TimestampOverride Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
	TimestampOverride *SecurityDetectionsAPITimestampOverride `json:"timestamp_override,omitempty"`

	// TimestampOverrideFallbackDisabled Disables the fallback to the event's @timestamp field
	TimestampOverrideFallbackDisabled *SecurityDetectionsAPITimestampOverrideFallbackDisabled `json:"timestamp_override_fallback_disabled,omitempty"`
	To                                SecurityDetectionsAPIRuleIntervalTo                     `json:"to"`

	// Type Rule type
	Type      SecurityDetectionsAPISavedQueryRuleType `json:"type"`
	UpdatedAt time.Time                               `json:"updated_at"`
	UpdatedBy string                                  `json:"updated_by"`

	// Version The rule's version number.
	//
	// - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
	// - For custom rules it is set to `1` when the rule is created.
	// > info
	// > It is not incremented on each update. Compare this to the `revision` field.
	Version SecurityDetectionsAPIRuleVersion `json:"version"`
}

// SecurityDetectionsAPISavedQueryRuleType Rule type
type SecurityDetectionsAPISavedQueryRuleType string

// SecurityDetectionsAPISavedQueryRuleCreateFields defines model for Security_Detections_API_SavedQueryRuleCreateFields.
type SecurityDetectionsAPISavedQueryRuleCreateFields struct {
	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression `json:"alert_suppression,omitempty"`
	DataViewId       *SecurityDetectionsAPIDataViewId       `json:"data_view_id,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index    *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`
	Language *SecurityDetectionsAPIKqlQueryLanguage  `json:"language,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query *SecurityDetectionsAPIRuleQuery `json:"query,omitempty"`

	// SavedId Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
	SavedId SecurityDetectionsAPISavedQueryId `json:"saved_id"`

	// Type Rule type
	Type SecurityDetectionsAPISavedQueryRuleCreateFieldsType `json:"type"`
}

// SecurityDetectionsAPISavedQueryRuleCreateFieldsType Rule type
type SecurityDetectionsAPISavedQueryRuleCreateFieldsType string

// SecurityDetectionsAPISavedQueryRuleCreateProps defines model for Security_Detections_API_SavedQueryRuleCreateProps.
type SecurityDetectionsAPISavedQueryRuleCreateProps struct {
	// Actions Array defining the automated actions (notifications) taken when alerts are generated.
	Actions *[]SecurityDetectionsAPIRuleAction `json:"actions,omitempty"`

	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression                `json:"alert_suppression,omitempty"`
	AliasPurpose     *SecurityDetectionsAPISavedObjectResolveAliasPurpose  `json:"alias_purpose,omitempty"`
	AliasTargetId    *SecurityDetectionsAPISavedObjectResolveAliasTargetId `json:"alias_target_id,omitempty"`

	// Author The rules author.
	Author *SecurityDetectionsAPIRuleAuthorArray `json:"author,omitempty"`

	// BuildingBlockType Determines if the rule acts as a building block. If yes, the value must be `default`.
	// By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
	// For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
	BuildingBlockType *SecurityDetectionsAPIBuildingBlockType `json:"building_block_type,omitempty"`
	DataViewId        *SecurityDetectionsAPIDataViewId        `json:"data_view_id,omitempty"`

	// Description The rules description.
	Description SecurityDetectionsAPIRuleDescription `json:"description"`

	// Enabled Determines whether the rule is enabled. Defaults to true.
	Enabled        *SecurityDetectionsAPIIsRuleEnabled       `json:"enabled,omitempty"`
	ExceptionsList *[]SecurityDetectionsAPIRuleExceptionList `json:"exceptions_list,omitempty"`

	// FalsePositives String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
	FalsePositives *SecurityDetectionsAPIRuleFalsePositiveArray `json:"false_positives,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// From Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
	From *SecurityDetectionsAPIRuleIntervalFrom `json:"from,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`

	// Interval Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
	Interval *SecurityDetectionsAPIRuleInterval `json:"interval,omitempty"`

	// InvestigationFields Schema for fields relating to investigation fields. These are user defined fields we use to highlight
	// in various features in the UI such as alert details flyout and exceptions auto-population from alert.
	InvestigationFields *SecurityDetectionsAPIInvestigationFields `json:"investigation_fields,omitempty"`
	Language            *SecurityDetectionsAPIKqlQueryLanguage    `json:"language,omitempty"`

	// License The rule's license.
	License *SecurityDetectionsAPIRuleLicense `json:"license,omitempty"`

	// MaxSignals Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
	// > info
	// > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
	MaxSignals *SecurityDetectionsAPIMaxSignals `json:"max_signals,omitempty"`

	// Meta Placeholder for metadata about the rule.
	// > info
	// > This field is overwritten when you save changes to the rules settings.
	Meta *SecurityDetectionsAPIRuleMetadata `json:"meta,omitempty"`

	// Name A human-readable name for the rule.
	Name SecurityDetectionsAPIRuleName `json:"name"`

	// Namespace Has no effect.
	Namespace *SecurityDetectionsAPIAlertsIndexNamespace `json:"namespace,omitempty"`

	// Note Notes to help investigate alerts produced by the rule.
	Note    *SecurityDetectionsAPIInvestigationGuide        `json:"note,omitempty"`
	Outcome *SecurityDetectionsAPISavedObjectResolveOutcome `json:"outcome,omitempty"`

	// OutputIndex (deprecated) Has no effect.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	OutputIndex *SecurityDetectionsAPIAlertsIndex `json:"output_index,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query *SecurityDetectionsAPIRuleQuery `json:"query,omitempty"`

	// References Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
	References          *SecurityDetectionsAPIRuleReferenceArray      `json:"references,omitempty"`
	RelatedIntegrations *SecurityDetectionsAPIRelatedIntegrationArray `json:"related_integrations,omitempty"`

	// RequiredFields Elasticsearch fields and their types that need to be present for the rule to function.
	// > info
	// > The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.
	RequiredFields  *[]SecurityDetectionsAPIRequiredFieldInput `json:"required_fields,omitempty"`
	ResponseActions *[]SecurityDetectionsAPIResponseAction     `json:"response_actions,omitempty"`

	// RiskScore A numerical representation of the alert's severity from 0 to 100, where:
	// * `0` - `21` represents low severity
	// * `22` - `47` represents medium severity
	// * `48` - `73` represents high severity
	// * `74` - `100` represents critical severity
	RiskScore SecurityDetectionsAPIRiskScore `json:"risk_score"`

	// RiskScoreMapping Overrides generated alerts' risk_score with a value from the source event
	RiskScoreMapping *SecurityDetectionsAPIRiskScoreMapping `json:"risk_score_mapping,omitempty"`

	// RuleId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
	RuleId *SecurityDetectionsAPIRuleSignatureId `json:"rule_id,omitempty"`

	// RuleNameOverride Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
	RuleNameOverride *SecurityDetectionsAPIRuleNameOverride `json:"rule_name_override,omitempty"`

	// SavedId Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
	SavedId SecurityDetectionsAPISavedQueryId `json:"saved_id"`

	// Setup Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
	Setup *SecurityDetectionsAPISetupGuide `json:"setup,omitempty"`

	// Severity Severity level of alerts produced by the rule, which must be one of the following:
	// * `low`: Alerts that are of interest but generally not considered to be security incidents
	// * `medium`: Alerts that require investigation
	// * `high`: Alerts that require immediate investigation
	// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
	Severity SecurityDetectionsAPISeverity `json:"severity"`

	// SeverityMapping Overrides generated alerts' severity with values from the source event
	SeverityMapping *SecurityDetectionsAPISeverityMapping `json:"severity_mapping,omitempty"`

	// Tags String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
	Tags   *SecurityDetectionsAPIRuleTagArray `json:"tags,omitempty"`
	Threat *SecurityDetectionsAPIThreatArray  `json:"threat,omitempty"`

	// Throttle Defines how often rule actions are taken.
	Throttle *SecurityDetectionsAPIRuleActionThrottle `json:"throttle,omitempty"`

	// TimelineId Timeline template ID
	TimelineId *SecurityDetectionsAPITimelineTemplateId `json:"timeline_id,omitempty"`

	// TimelineTitle Timeline template title
	TimelineTitle *SecurityDetectionsAPITimelineTemplateTitle `json:"timeline_title,omitempty"`

	// TimestampOverride Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
	TimestampOverride *SecurityDetectionsAPITimestampOverride `json:"timestamp_override,omitempty"`

	// TimestampOverrideFallbackDisabled Disables the fallback to the event's @timestamp field
	TimestampOverrideFallbackDisabled *SecurityDetectionsAPITimestampOverrideFallbackDisabled `json:"timestamp_override_fallback_disabled,omitempty"`
	To                                *SecurityDetectionsAPIRuleIntervalTo                    `json:"to,omitempty"`

	// Type Rule type
	Type SecurityDetectionsAPISavedQueryRuleCreatePropsType `json:"type"`

	// Version The rule's version number.
	//
	// - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
	// - For custom rules it is set to `1` when the rule is created.
	// > info
	// > It is not incremented on each update. Compare this to the `revision` field.
	Version *SecurityDetectionsAPIRuleVersion `json:"version,omitempty"`
}

// SecurityDetectionsAPISavedQueryRuleCreatePropsType Rule type
type SecurityDetectionsAPISavedQueryRuleCreatePropsType string

// SecurityDetectionsAPISavedQueryRuleDefaultableFields defines model for Security_Detections_API_SavedQueryRuleDefaultableFields.
type SecurityDetectionsAPISavedQueryRuleDefaultableFields struct {
	Language *SecurityDetectionsAPIKqlQueryLanguage `json:"language,omitempty"`
}

// SecurityDetectionsAPISavedQueryRuleOptionalFields defines model for Security_Detections_API_SavedQueryRuleOptionalFields.
type SecurityDetectionsAPISavedQueryRuleOptionalFields struct {
	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression `json:"alert_suppression,omitempty"`
	DataViewId       *SecurityDetectionsAPIDataViewId       `json:"data_view_id,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query *SecurityDetectionsAPIRuleQuery `json:"query,omitempty"`
}

// SecurityDetectionsAPISavedQueryRuleRequiredFields defines model for Security_Detections_API_SavedQueryRuleRequiredFields.
type SecurityDetectionsAPISavedQueryRuleRequiredFields struct {
	// SavedId Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
	SavedId SecurityDetectionsAPISavedQueryId `json:"saved_id"`

	// Type Rule type
	Type SecurityDetectionsAPISavedQueryRuleRequiredFieldsType `json:"type"`
}

// SecurityDetectionsAPISavedQueryRuleRequiredFieldsType Rule type
type SecurityDetectionsAPISavedQueryRuleRequiredFieldsType string

// SecurityDetectionsAPISavedQueryRuleResponseFields defines model for Security_Detections_API_SavedQueryRuleResponseFields.
type SecurityDetectionsAPISavedQueryRuleResponseFields struct {
	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression `json:"alert_suppression,omitempty"`
	DataViewId       *SecurityDetectionsAPIDataViewId       `json:"data_view_id,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index    *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`
	Language SecurityDetectionsAPIKqlQueryLanguage   `json:"language"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query *SecurityDetectionsAPIRuleQuery `json:"query,omitempty"`

	// SavedId Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
	SavedId SecurityDetectionsAPISavedQueryId `json:"saved_id"`

	// Type Rule type
	Type SecurityDetectionsAPISavedQueryRuleResponseFieldsType `json:"type"`
}

// SecurityDetectionsAPISavedQueryRuleResponseFieldsType Rule type
type SecurityDetectionsAPISavedQueryRuleResponseFieldsType string

// SecurityDetectionsAPISavedQueryRuleUpdateProps defines model for Security_Detections_API_SavedQueryRuleUpdateProps.
type SecurityDetectionsAPISavedQueryRuleUpdateProps struct {
	// Actions Array defining the automated actions (notifications) taken when alerts are generated.
	Actions *[]SecurityDetectionsAPIRuleAction `json:"actions,omitempty"`

	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression                `json:"alert_suppression,omitempty"`
	AliasPurpose     *SecurityDetectionsAPISavedObjectResolveAliasPurpose  `json:"alias_purpose,omitempty"`
	AliasTargetId    *SecurityDetectionsAPISavedObjectResolveAliasTargetId `json:"alias_target_id,omitempty"`

	// Author The rules author.
	Author *SecurityDetectionsAPIRuleAuthorArray `json:"author,omitempty"`

	// BuildingBlockType Determines if the rule acts as a building block. If yes, the value must be `default`.
	// By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
	// For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
	BuildingBlockType *SecurityDetectionsAPIBuildingBlockType `json:"building_block_type,omitempty"`
	DataViewId        *SecurityDetectionsAPIDataViewId        `json:"data_view_id,omitempty"`

	// Description The rules description.
	Description SecurityDetectionsAPIRuleDescription `json:"description"`

	// Enabled Determines whether the rule is enabled. Defaults to true.
	Enabled        *SecurityDetectionsAPIIsRuleEnabled       `json:"enabled,omitempty"`
	ExceptionsList *[]SecurityDetectionsAPIRuleExceptionList `json:"exceptions_list,omitempty"`

	// FalsePositives String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
	FalsePositives *SecurityDetectionsAPIRuleFalsePositiveArray `json:"false_positives,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// From Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
	From *SecurityDetectionsAPIRuleIntervalFrom `json:"from,omitempty"`

	// Id A universally unique identifier
	Id *SecurityDetectionsAPIRuleObjectId `json:"id,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`

	// Interval Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
	Interval *SecurityDetectionsAPIRuleInterval `json:"interval,omitempty"`

	// InvestigationFields Schema for fields relating to investigation fields. These are user defined fields we use to highlight
	// in various features in the UI such as alert details flyout and exceptions auto-population from alert.
	InvestigationFields *SecurityDetectionsAPIInvestigationFields `json:"investigation_fields,omitempty"`
	Language            *SecurityDetectionsAPIKqlQueryLanguage    `json:"language,omitempty"`

	// License The rule's license.
	License *SecurityDetectionsAPIRuleLicense `json:"license,omitempty"`

	// MaxSignals Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
	// > info
	// > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
	MaxSignals *SecurityDetectionsAPIMaxSignals `json:"max_signals,omitempty"`

	// Meta Placeholder for metadata about the rule.
	// > info
	// > This field is overwritten when you save changes to the rules settings.
	Meta *SecurityDetectionsAPIRuleMetadata `json:"meta,omitempty"`

	// Name A human-readable name for the rule.
	Name SecurityDetectionsAPIRuleName `json:"name"`

	// Namespace Has no effect.
	Namespace *SecurityDetectionsAPIAlertsIndexNamespace `json:"namespace,omitempty"`

	// Note Notes to help investigate alerts produced by the rule.
	Note    *SecurityDetectionsAPIInvestigationGuide        `json:"note,omitempty"`
	Outcome *SecurityDetectionsAPISavedObjectResolveOutcome `json:"outcome,omitempty"`

	// OutputIndex (deprecated) Has no effect.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	OutputIndex *SecurityDetectionsAPIAlertsIndex `json:"output_index,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query *SecurityDetectionsAPIRuleQuery `json:"query,omitempty"`

	// References Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
	References          *SecurityDetectionsAPIRuleReferenceArray      `json:"references,omitempty"`
	RelatedIntegrations *SecurityDetectionsAPIRelatedIntegrationArray `json:"related_integrations,omitempty"`

	// RequiredFields Elasticsearch fields and their types that need to be present for the rule to function.
	// > info
	// > The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.
	RequiredFields  *[]SecurityDetectionsAPIRequiredFieldInput `json:"required_fields,omitempty"`
	ResponseActions *[]SecurityDetectionsAPIResponseAction     `json:"response_actions,omitempty"`

	// RiskScore A numerical representation of the alert's severity from 0 to 100, where:
	// * `0` - `21` represents low severity
	// * `22` - `47` represents medium severity
	// * `48` - `73` represents high severity
	// * `74` - `100` represents critical severity
	RiskScore SecurityDetectionsAPIRiskScore `json:"risk_score"`

	// RiskScoreMapping Overrides generated alerts' risk_score with a value from the source event
	RiskScoreMapping *SecurityDetectionsAPIRiskScoreMapping `json:"risk_score_mapping,omitempty"`

	// RuleId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
	RuleId *SecurityDetectionsAPIRuleSignatureId `json:"rule_id,omitempty"`

	// RuleNameOverride Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
	RuleNameOverride *SecurityDetectionsAPIRuleNameOverride `json:"rule_name_override,omitempty"`

	// SavedId Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
	SavedId SecurityDetectionsAPISavedQueryId `json:"saved_id"`

	// Setup Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
	Setup *SecurityDetectionsAPISetupGuide `json:"setup,omitempty"`

	// Severity Severity level of alerts produced by the rule, which must be one of the following:
	// * `low`: Alerts that are of interest but generally not considered to be security incidents
	// * `medium`: Alerts that require investigation
	// * `high`: Alerts that require immediate investigation
	// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
	Severity SecurityDetectionsAPISeverity `json:"severity"`

	// SeverityMapping Overrides generated alerts' severity with values from the source event
	SeverityMapping *SecurityDetectionsAPISeverityMapping `json:"severity_mapping,omitempty"`

	// Tags String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
	Tags   *SecurityDetectionsAPIRuleTagArray `json:"tags,omitempty"`
	Threat *SecurityDetectionsAPIThreatArray  `json:"threat,omitempty"`

	// Throttle Defines how often rule actions are taken.
	Throttle *SecurityDetectionsAPIRuleActionThrottle `json:"throttle,omitempty"`

	// TimelineId Timeline template ID
	TimelineId *SecurityDetectionsAPITimelineTemplateId `json:"timeline_id,omitempty"`

	// TimelineTitle Timeline template title
	TimelineTitle *SecurityDetectionsAPITimelineTemplateTitle `json:"timeline_title,omitempty"`

	// TimestampOverride Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
	TimestampOverride *SecurityDetectionsAPITimestampOverride `json:"timestamp_override,omitempty"`

	// TimestampOverrideFallbackDisabled Disables the fallback to the event's @timestamp field
	TimestampOverrideFallbackDisabled *SecurityDetectionsAPITimestampOverrideFallbackDisabled `json:"timestamp_override_fallback_disabled,omitempty"`
	To                                *SecurityDetectionsAPIRuleIntervalTo                    `json:"to,omitempty"`

	// Type Rule type
	Type SecurityDetectionsAPISavedQueryRuleUpdatePropsType `json:"type"`

	// Version The rule's version number.
	//
	// - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
	// - For custom rules it is set to `1` when the rule is created.
	// > info
	// > It is not incremented on each update. Compare this to the `revision` field.
	Version *SecurityDetectionsAPIRuleVersion `json:"version,omitempty"`
}

// SecurityDetectionsAPISavedQueryRuleUpdatePropsType Rule type
type SecurityDetectionsAPISavedQueryRuleUpdatePropsType string

// SecurityDetectionsAPISetupGuide Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
type SecurityDetectionsAPISetupGuide = string

// SecurityDetectionsAPISeverity Severity level of alerts produced by the rule, which must be one of the following:
// * `low`: Alerts that are of interest but generally not considered to be security incidents
// * `medium`: Alerts that require investigation
// * `high`: Alerts that require immediate investigation
// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
type SecurityDetectionsAPISeverity string

// SecurityDetectionsAPISeverityMapping Overrides generated alerts' severity with values from the source event
type SecurityDetectionsAPISeverityMapping = []struct {
	// Field Source event field used to override the default `severity`.
	Field    string                                       `json:"field"`
	Operator SecurityDetectionsAPISeverityMappingOperator `json:"operator"`

	// Severity Severity level of alerts produced by the rule, which must be one of the following:
	// * `low`: Alerts that are of interest but generally not considered to be security incidents
	// * `medium`: Alerts that require investigation
	// * `high`: Alerts that require immediate investigation
	// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
	Severity SecurityDetectionsAPISeverity `json:"severity"`
	Value    string                        `json:"value"`
}

// SecurityDetectionsAPISeverityMappingOperator defines model for SecurityDetectionsAPISeverityMapping.Operator.
type SecurityDetectionsAPISeverityMappingOperator string

// SecurityDetectionsAPIThreat > info
// > Currently, only threats described using the MITRE ATT&CK&trade; framework are supported.
type SecurityDetectionsAPIThreat struct {
	// Framework Relevant attack framework
	Framework string `json:"framework"`

	// Tactic Object containing information on the attack type
	Tactic SecurityDetectionsAPIThreatTactic `json:"tactic"`

	// Technique Array containing information on the attack techniques (optional)
	Technique *[]SecurityDetectionsAPIThreatTechnique `json:"technique,omitempty"`
}

// SecurityDetectionsAPIThreatArray defines model for Security_Detections_API_ThreatArray.
type SecurityDetectionsAPIThreatArray = []SecurityDetectionsAPIThreat

// SecurityDetectionsAPIThreatFilters defines model for Security_Detections_API_ThreatFilters.
type SecurityDetectionsAPIThreatFilters = []interface{}

// SecurityDetectionsAPIThreatIndex Elasticsearch indices used to check which field values generate alerts.
type SecurityDetectionsAPIThreatIndex = []string

// SecurityDetectionsAPIThreatIndicatorPath Defines the path to the threat indicator in the indicator documents (optional)
type SecurityDetectionsAPIThreatIndicatorPath = string

// SecurityDetectionsAPIThreatMapping Array of entries objects that define mappings between the source event fields and the values in the Elasticsearch threat index. Each entries object must contain these fields:
//
// - field: field from the event indices on which the rule runs
// - type: must be mapping
// - value: field from the Elasticsearch threat index
//
// You can use Boolean and and or logic to define the conditions for when matching fields and values generate alerts. Sibling entries objects are evaluated using or logic, whereas multiple entries in a single entries object use and logic. See Example of Threat Match rule which uses both `and` and `or` logic.
type SecurityDetectionsAPIThreatMapping = []struct {
	Entries []SecurityDetectionsAPIThreatMappingEntry `json:"entries"`
}

// SecurityDetectionsAPIThreatMappingEntry defines model for Security_Detections_API_ThreatMappingEntry.
type SecurityDetectionsAPIThreatMappingEntry struct {
	// Field A string that does not contain only whitespace characters
	Field  SecurityDetectionsAPINonEmptyString         `json:"field"`
	Negate *bool                                       `json:"negate,omitempty"`
	Type   SecurityDetectionsAPIThreatMappingEntryType `json:"type"`

	// Value A string that does not contain only whitespace characters
	Value SecurityDetectionsAPINonEmptyString `json:"value"`
}

// SecurityDetectionsAPIThreatMappingEntryType defines model for SecurityDetectionsAPIThreatMappingEntry.Type.
type SecurityDetectionsAPIThreatMappingEntryType string

// SecurityDetectionsAPIThreatMatchRule defines model for Security_Detections_API_ThreatMatchRule.
type SecurityDetectionsAPIThreatMatchRule struct {
	// Actions Array defining the automated actions (notifications) taken when alerts are generated.
	Actions []SecurityDetectionsAPIRuleAction `json:"actions"`

	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression                `json:"alert_suppression,omitempty"`
	AliasPurpose     *SecurityDetectionsAPISavedObjectResolveAliasPurpose  `json:"alias_purpose,omitempty"`
	AliasTargetId    *SecurityDetectionsAPISavedObjectResolveAliasTargetId `json:"alias_target_id,omitempty"`

	// Author The rules author.
	Author SecurityDetectionsAPIRuleAuthorArray `json:"author"`

	// BuildingBlockType Determines if the rule acts as a building block. If yes, the value must be `default`.
	// By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
	// For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
	BuildingBlockType  *SecurityDetectionsAPIBuildingBlockType  `json:"building_block_type,omitempty"`
	ConcurrentSearches *SecurityDetectionsAPIConcurrentSearches `json:"concurrent_searches,omitempty"`
	CreatedAt          time.Time                                `json:"created_at"`
	CreatedBy          string                                   `json:"created_by"`
	DataViewId         *SecurityDetectionsAPIDataViewId         `json:"data_view_id,omitempty"`

	// Description The rules description.
	Description SecurityDetectionsAPIRuleDescription `json:"description"`

	// Enabled Determines whether the rule is enabled. Defaults to true.
	Enabled        SecurityDetectionsAPIIsRuleEnabled       `json:"enabled"`
	ExceptionsList []SecurityDetectionsAPIRuleExceptionList `json:"exceptions_list"`

	// ExecutionSummary Summary of the last execution of a rule.
	// > info
	// > This field is under development and its usage or schema may change
	ExecutionSummary *SecurityDetectionsAPIRuleExecutionSummary `json:"execution_summary,omitempty"`

	// FalsePositives String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
	FalsePositives SecurityDetectionsAPIRuleFalsePositiveArray `json:"false_positives"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// From Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
	From SecurityDetectionsAPIRuleIntervalFrom `json:"from"`

	// Id A universally unique identifier
	Id SecurityDetectionsAPIRuleObjectId `json:"id"`

	// Immutable This field determines whether the rule is a prebuilt Elastic rule. It will be replaced with the `rule_source` field.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Immutable SecurityDetectionsAPIIsRuleImmutable `json:"immutable"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`

	// Interval Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
	Interval SecurityDetectionsAPIRuleInterval `json:"interval"`

	// InvestigationFields Schema for fields relating to investigation fields. These are user defined fields we use to highlight
	// in various features in the UI such as alert details flyout and exceptions auto-population from alert.
	InvestigationFields *SecurityDetectionsAPIInvestigationFields `json:"investigation_fields,omitempty"`
	ItemsPerSearch      *SecurityDetectionsAPIItemsPerSearch      `json:"items_per_search,omitempty"`
	Language            SecurityDetectionsAPIKqlQueryLanguage     `json:"language"`

	// License The rule's license.
	License *SecurityDetectionsAPIRuleLicense `json:"license,omitempty"`

	// MaxSignals Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
	// > info
	// > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
	MaxSignals SecurityDetectionsAPIMaxSignals `json:"max_signals"`

	// Meta Placeholder for metadata about the rule.
	// > info
	// > This field is overwritten when you save changes to the rules settings.
	Meta *SecurityDetectionsAPIRuleMetadata `json:"meta,omitempty"`

	// Name A human-readable name for the rule.
	Name SecurityDetectionsAPIRuleName `json:"name"`

	// Namespace Has no effect.
	Namespace *SecurityDetectionsAPIAlertsIndexNamespace `json:"namespace,omitempty"`

	// Note Notes to help investigate alerts produced by the rule.
	Note    *SecurityDetectionsAPIInvestigationGuide        `json:"note,omitempty"`
	Outcome *SecurityDetectionsAPISavedObjectResolveOutcome `json:"outcome,omitempty"`

	// OutputIndex (deprecated) Has no effect.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	OutputIndex *SecurityDetectionsAPIAlertsIndex `json:"output_index,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// References Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
	References          SecurityDetectionsAPIRuleReferenceArray      `json:"references"`
	RelatedIntegrations SecurityDetectionsAPIRelatedIntegrationArray `json:"related_integrations"`
	RequiredFields      SecurityDetectionsAPIRequiredFieldArray      `json:"required_fields"`
	ResponseActions     *[]SecurityDetectionsAPIResponseAction       `json:"response_actions,omitempty"`

	// Revision The rule's revision number.
	//
	// It represents the version of rule's object in Kibana. It is set to `0` when the rule is installed or created and then gets incremented on each update.
	// > info
	// > Not all updates to any rule fields will increment the revision. Only those fields that are considered static `rule parameters` can trigger revision increments. For example, an update to a rule's query or index fields will increment the rule's revision by `1`. However, changes to dynamic or technical fields like enabled or execution_summary will not cause revision increments.
	Revision SecurityDetectionsAPIRuleRevision `json:"revision"`

	// RiskScore A numerical representation of the alert's severity from 0 to 100, where:
	// * `0` - `21` represents low severity
	// * `22` - `47` represents medium severity
	// * `48` - `73` represents high severity
	// * `74` - `100` represents critical severity
	RiskScore SecurityDetectionsAPIRiskScore `json:"risk_score"`

	// RiskScoreMapping Overrides generated alerts' risk_score with a value from the source event
	RiskScoreMapping SecurityDetectionsAPIRiskScoreMapping `json:"risk_score_mapping"`

	// RuleId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
	RuleId SecurityDetectionsAPIRuleSignatureId `json:"rule_id"`

	// RuleNameOverride Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
	RuleNameOverride *SecurityDetectionsAPIRuleNameOverride `json:"rule_name_override,omitempty"`

	// RuleSource Discriminated union that determines whether the rule is internally sourced (created within the Kibana app) or has an external source, such as the Elastic Prebuilt rules repo.
	RuleSource SecurityDetectionsAPIRuleSource `json:"rule_source"`

	// SavedId Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
	SavedId *SecurityDetectionsAPISavedQueryId `json:"saved_id,omitempty"`

	// Setup Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
	Setup SecurityDetectionsAPISetupGuide `json:"setup"`

	// Severity Severity level of alerts produced by the rule, which must be one of the following:
	// * `low`: Alerts that are of interest but generally not considered to be security incidents
	// * `medium`: Alerts that require investigation
	// * `high`: Alerts that require immediate investigation
	// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
	Severity SecurityDetectionsAPISeverity `json:"severity"`

	// SeverityMapping Overrides generated alerts' severity with values from the source event
	SeverityMapping SecurityDetectionsAPISeverityMapping `json:"severity_mapping"`

	// Tags String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
	Tags          SecurityDetectionsAPIRuleTagArray   `json:"tags"`
	Threat        SecurityDetectionsAPIThreatArray    `json:"threat"`
	ThreatFilters *SecurityDetectionsAPIThreatFilters `json:"threat_filters,omitempty"`

	// ThreatIndex Elasticsearch indices used to check which field values generate alerts.
	ThreatIndex SecurityDetectionsAPIThreatIndex `json:"threat_index"`

	// ThreatIndicatorPath Defines the path to the threat indicator in the indicator documents (optional)
	ThreatIndicatorPath *SecurityDetectionsAPIThreatIndicatorPath `json:"threat_indicator_path,omitempty"`
	ThreatLanguage      *SecurityDetectionsAPIKqlQueryLanguage    `json:"threat_language,omitempty"`

	// ThreatMapping Array of entries objects that define mappings between the source event fields and the values in the Elasticsearch threat index. Each entries object must contain these fields:
	//
	// - field: field from the event indices on which the rule runs
	// - type: must be mapping
	// - value: field from the Elasticsearch threat index
	//
	// You can use Boolean and and or logic to define the conditions for when matching fields and values generate alerts. Sibling entries objects are evaluated using or logic, whereas multiple entries in a single entries object use and logic. See Example of Threat Match rule which uses both `and` and `or` logic.
	ThreatMapping SecurityDetectionsAPIThreatMapping `json:"threat_mapping"`

	// ThreatQuery Query used to determine which fields in the Elasticsearch index are used for generating alerts.
	ThreatQuery SecurityDetectionsAPIThreatQuery `json:"threat_query"`

	// Throttle Defines how often rule actions are taken.
	Throttle *SecurityDetectionsAPIRuleActionThrottle `json:"throttle,omitempty"`

	// TimelineId Timeline template ID
	TimelineId *SecurityDetectionsAPITimelineTemplateId `json:"timeline_id,omitempty"`

	// TimelineTitle Timeline template title
	TimelineTitle *SecurityDetectionsAPITimelineTemplateTitle `json:"timeline_title,omitempty"`

	// TimestampOverride Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
	TimestampOverride *SecurityDetectionsAPITimestampOverride `json:"timestamp_override,omitempty"`

	// TimestampOverrideFallbackDisabled Disables the fallback to the event's @timestamp field
	TimestampOverrideFallbackDisabled *SecurityDetectionsAPITimestampOverrideFallbackDisabled `json:"timestamp_override_fallback_disabled,omitempty"`
	To                                SecurityDetectionsAPIRuleIntervalTo                     `json:"to"`

	// Type Rule type
	Type      SecurityDetectionsAPIThreatMatchRuleType `json:"type"`
	UpdatedAt time.Time                                `json:"updated_at"`
	UpdatedBy string                                   `json:"updated_by"`

	// Version The rule's version number.
	//
	// - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
	// - For custom rules it is set to `1` when the rule is created.
	// > info
	// > It is not incremented on each update. Compare this to the `revision` field.
	Version SecurityDetectionsAPIRuleVersion `json:"version"`
}

// SecurityDetectionsAPIThreatMatchRuleType Rule type
type SecurityDetectionsAPIThreatMatchRuleType string

// SecurityDetectionsAPIThreatMatchRuleCreateFields defines model for Security_Detections_API_ThreatMatchRuleCreateFields.
type SecurityDetectionsAPIThreatMatchRuleCreateFields struct {
	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression   *SecurityDetectionsAPIAlertSuppression   `json:"alert_suppression,omitempty"`
	ConcurrentSearches *SecurityDetectionsAPIConcurrentSearches `json:"concurrent_searches,omitempty"`
	DataViewId         *SecurityDetectionsAPIDataViewId         `json:"data_view_id,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index          *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`
	ItemsPerSearch *SecurityDetectionsAPIItemsPerSearch    `json:"items_per_search,omitempty"`
	Language       *SecurityDetectionsAPIKqlQueryLanguage  `json:"language,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// SavedId Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
	SavedId       *SecurityDetectionsAPISavedQueryId  `json:"saved_id,omitempty"`
	ThreatFilters *SecurityDetectionsAPIThreatFilters `json:"threat_filters,omitempty"`

	// ThreatIndex Elasticsearch indices used to check which field values generate alerts.
	ThreatIndex SecurityDetectionsAPIThreatIndex `json:"threat_index"`

	// ThreatIndicatorPath Defines the path to the threat indicator in the indicator documents (optional)
	ThreatIndicatorPath *SecurityDetectionsAPIThreatIndicatorPath `json:"threat_indicator_path,omitempty"`
	ThreatLanguage      *SecurityDetectionsAPIKqlQueryLanguage    `json:"threat_language,omitempty"`

	// ThreatMapping Array of entries objects that define mappings between the source event fields and the values in the Elasticsearch threat index. Each entries object must contain these fields:
	//
	// - field: field from the event indices on which the rule runs
	// - type: must be mapping
	// - value: field from the Elasticsearch threat index
	//
	// You can use Boolean and and or logic to define the conditions for when matching fields and values generate alerts. Sibling entries objects are evaluated using or logic, whereas multiple entries in a single entries object use and logic. See Example of Threat Match rule which uses both `and` and `or` logic.
	ThreatMapping SecurityDetectionsAPIThreatMapping `json:"threat_mapping"`

	// ThreatQuery Query used to determine which fields in the Elasticsearch index are used for generating alerts.
	ThreatQuery SecurityDetectionsAPIThreatQuery `json:"threat_query"`

	// Type Rule type
	Type SecurityDetectionsAPIThreatMatchRuleCreateFieldsType `json:"type"`
}

// SecurityDetectionsAPIThreatMatchRuleCreateFieldsType Rule type
type SecurityDetectionsAPIThreatMatchRuleCreateFieldsType string

// SecurityDetectionsAPIThreatMatchRuleCreateProps defines model for Security_Detections_API_ThreatMatchRuleCreateProps.
type SecurityDetectionsAPIThreatMatchRuleCreateProps struct {
	// Actions Array defining the automated actions (notifications) taken when alerts are generated.
	Actions *[]SecurityDetectionsAPIRuleAction `json:"actions,omitempty"`

	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression                `json:"alert_suppression,omitempty"`
	AliasPurpose     *SecurityDetectionsAPISavedObjectResolveAliasPurpose  `json:"alias_purpose,omitempty"`
	AliasTargetId    *SecurityDetectionsAPISavedObjectResolveAliasTargetId `json:"alias_target_id,omitempty"`

	// Author The rules author.
	Author *SecurityDetectionsAPIRuleAuthorArray `json:"author,omitempty"`

	// BuildingBlockType Determines if the rule acts as a building block. If yes, the value must be `default`.
	// By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
	// For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
	BuildingBlockType  *SecurityDetectionsAPIBuildingBlockType  `json:"building_block_type,omitempty"`
	ConcurrentSearches *SecurityDetectionsAPIConcurrentSearches `json:"concurrent_searches,omitempty"`
	DataViewId         *SecurityDetectionsAPIDataViewId         `json:"data_view_id,omitempty"`

	// Description The rules description.
	Description SecurityDetectionsAPIRuleDescription `json:"description"`

	// Enabled Determines whether the rule is enabled. Defaults to true.
	Enabled        *SecurityDetectionsAPIIsRuleEnabled       `json:"enabled,omitempty"`
	ExceptionsList *[]SecurityDetectionsAPIRuleExceptionList `json:"exceptions_list,omitempty"`

	// FalsePositives String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
	FalsePositives *SecurityDetectionsAPIRuleFalsePositiveArray `json:"false_positives,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// From Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
	From *SecurityDetectionsAPIRuleIntervalFrom `json:"from,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`

	// Interval Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
	Interval *SecurityDetectionsAPIRuleInterval `json:"interval,omitempty"`

	// InvestigationFields Schema for fields relating to investigation fields. These are user defined fields we use to highlight
	// in various features in the UI such as alert details flyout and exceptions auto-population from alert.
	InvestigationFields *SecurityDetectionsAPIInvestigationFields `json:"investigation_fields,omitempty"`
	ItemsPerSearch      *SecurityDetectionsAPIItemsPerSearch      `json:"items_per_search,omitempty"`
	Language            *SecurityDetectionsAPIKqlQueryLanguage    `json:"language,omitempty"`

	// License The rule's license.
	License *SecurityDetectionsAPIRuleLicense `json:"license,omitempty"`

	// MaxSignals Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
	// > info
	// > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
	MaxSignals *SecurityDetectionsAPIMaxSignals `json:"max_signals,omitempty"`

	// Meta Placeholder for metadata about the rule.
	// > info
	// > This field is overwritten when you save changes to the rules settings.
	Meta *SecurityDetectionsAPIRuleMetadata `json:"meta,omitempty"`

	// Name A human-readable name for the rule.
	Name SecurityDetectionsAPIRuleName `json:"name"`

	// Namespace Has no effect.
	Namespace *SecurityDetectionsAPIAlertsIndexNamespace `json:"namespace,omitempty"`

	// Note Notes to help investigate alerts produced by the rule.
	Note    *SecurityDetectionsAPIInvestigationGuide        `json:"note,omitempty"`
	Outcome *SecurityDetectionsAPISavedObjectResolveOutcome `json:"outcome,omitempty"`

	// OutputIndex (deprecated) Has no effect.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	OutputIndex *SecurityDetectionsAPIAlertsIndex `json:"output_index,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// References Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
	References          *SecurityDetectionsAPIRuleReferenceArray      `json:"references,omitempty"`
	RelatedIntegrations *SecurityDetectionsAPIRelatedIntegrationArray `json:"related_integrations,omitempty"`

	// RequiredFields Elasticsearch fields and their types that need to be present for the rule to function.
	// > info
	// > The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.
	RequiredFields  *[]SecurityDetectionsAPIRequiredFieldInput `json:"required_fields,omitempty"`
	ResponseActions *[]SecurityDetectionsAPIResponseAction     `json:"response_actions,omitempty"`

	// RiskScore A numerical representation of the alert's severity from 0 to 100, where:
	// * `0` - `21` represents low severity
	// * `22` - `47` represents medium severity
	// * `48` - `73` represents high severity
	// * `74` - `100` represents critical severity
	RiskScore SecurityDetectionsAPIRiskScore `json:"risk_score"`

	// RiskScoreMapping Overrides generated alerts' risk_score with a value from the source event
	RiskScoreMapping *SecurityDetectionsAPIRiskScoreMapping `json:"risk_score_mapping,omitempty"`

	// RuleId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
	RuleId *SecurityDetectionsAPIRuleSignatureId `json:"rule_id,omitempty"`

	// RuleNameOverride Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
	RuleNameOverride *SecurityDetectionsAPIRuleNameOverride `json:"rule_name_override,omitempty"`

	// SavedId Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
	SavedId *SecurityDetectionsAPISavedQueryId `json:"saved_id,omitempty"`

	// Setup Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
	Setup *SecurityDetectionsAPISetupGuide `json:"setup,omitempty"`

	// Severity Severity level of alerts produced by the rule, which must be one of the following:
	// * `low`: Alerts that are of interest but generally not considered to be security incidents
	// * `medium`: Alerts that require investigation
	// * `high`: Alerts that require immediate investigation
	// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
	Severity SecurityDetectionsAPISeverity `json:"severity"`

	// SeverityMapping Overrides generated alerts' severity with values from the source event
	SeverityMapping *SecurityDetectionsAPISeverityMapping `json:"severity_mapping,omitempty"`

	// Tags String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
	Tags          *SecurityDetectionsAPIRuleTagArray  `json:"tags,omitempty"`
	Threat        *SecurityDetectionsAPIThreatArray   `json:"threat,omitempty"`
	ThreatFilters *SecurityDetectionsAPIThreatFilters `json:"threat_filters,omitempty"`

	// ThreatIndex Elasticsearch indices used to check which field values generate alerts.
	ThreatIndex SecurityDetectionsAPIThreatIndex `json:"threat_index"`

	// ThreatIndicatorPath Defines the path to the threat indicator in the indicator documents (optional)
	ThreatIndicatorPath *SecurityDetectionsAPIThreatIndicatorPath `json:"threat_indicator_path,omitempty"`
	ThreatLanguage      *SecurityDetectionsAPIKqlQueryLanguage    `json:"threat_language,omitempty"`

	// ThreatMapping Array of entries objects that define mappings between the source event fields and the values in the Elasticsearch threat index. Each entries object must contain these fields:
	//
	// - field: field from the event indices on which the rule runs
	// - type: must be mapping
	// - value: field from the Elasticsearch threat index
	//
	// You can use Boolean and and or logic to define the conditions for when matching fields and values generate alerts. Sibling entries objects are evaluated using or logic, whereas multiple entries in a single entries object use and logic. See Example of Threat Match rule which uses both `and` and `or` logic.
	ThreatMapping SecurityDetectionsAPIThreatMapping `json:"threat_mapping"`

	// ThreatQuery Query used to determine which fields in the Elasticsearch index are used for generating alerts.
	ThreatQuery SecurityDetectionsAPIThreatQuery `json:"threat_query"`

	// Throttle Defines how often rule actions are taken.
	Throttle *SecurityDetectionsAPIRuleActionThrottle `json:"throttle,omitempty"`

	// TimelineId Timeline template ID
	TimelineId *SecurityDetectionsAPITimelineTemplateId `json:"timeline_id,omitempty"`

	// TimelineTitle Timeline template title
	TimelineTitle *SecurityDetectionsAPITimelineTemplateTitle `json:"timeline_title,omitempty"`

	// TimestampOverride Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
	TimestampOverride *SecurityDetectionsAPITimestampOverride `json:"timestamp_override,omitempty"`

	// TimestampOverrideFallbackDisabled Disables the fallback to the event's @timestamp field
	TimestampOverrideFallbackDisabled *SecurityDetectionsAPITimestampOverrideFallbackDisabled `json:"timestamp_override_fallback_disabled,omitempty"`
	To                                *SecurityDetectionsAPIRuleIntervalTo                    `json:"to,omitempty"`

	// Type Rule type
	Type SecurityDetectionsAPIThreatMatchRuleCreatePropsType `json:"type"`

	// Version The rule's version number.
	//
	// - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
	// - For custom rules it is set to `1` when the rule is created.
	// > info
	// > It is not incremented on each update. Compare this to the `revision` field.
	Version *SecurityDetectionsAPIRuleVersion `json:"version,omitempty"`
}

// SecurityDetectionsAPIThreatMatchRuleCreatePropsType Rule type
type SecurityDetectionsAPIThreatMatchRuleCreatePropsType string

// SecurityDetectionsAPIThreatMatchRuleDefaultableFields defines model for Security_Detections_API_ThreatMatchRuleDefaultableFields.
type SecurityDetectionsAPIThreatMatchRuleDefaultableFields struct {
	Language *SecurityDetectionsAPIKqlQueryLanguage `json:"language,omitempty"`
}

// SecurityDetectionsAPIThreatMatchRuleOptionalFields defines model for Security_Detections_API_ThreatMatchRuleOptionalFields.
type SecurityDetectionsAPIThreatMatchRuleOptionalFields struct {
	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression   *SecurityDetectionsAPIAlertSuppression   `json:"alert_suppression,omitempty"`
	ConcurrentSearches *SecurityDetectionsAPIConcurrentSearches `json:"concurrent_searches,omitempty"`
	DataViewId         *SecurityDetectionsAPIDataViewId         `json:"data_view_id,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index          *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`
	ItemsPerSearch *SecurityDetectionsAPIItemsPerSearch    `json:"items_per_search,omitempty"`

	// SavedId Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
	SavedId       *SecurityDetectionsAPISavedQueryId  `json:"saved_id,omitempty"`
	ThreatFilters *SecurityDetectionsAPIThreatFilters `json:"threat_filters,omitempty"`

	// ThreatIndicatorPath Defines the path to the threat indicator in the indicator documents (optional)
	ThreatIndicatorPath *SecurityDetectionsAPIThreatIndicatorPath `json:"threat_indicator_path,omitempty"`
	ThreatLanguage      *SecurityDetectionsAPIKqlQueryLanguage    `json:"threat_language,omitempty"`
}

// SecurityDetectionsAPIThreatMatchRuleRequiredFields defines model for Security_Detections_API_ThreatMatchRuleRequiredFields.
type SecurityDetectionsAPIThreatMatchRuleRequiredFields struct {
	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// ThreatIndex Elasticsearch indices used to check which field values generate alerts.
	ThreatIndex SecurityDetectionsAPIThreatIndex `json:"threat_index"`

	// ThreatMapping Array of entries objects that define mappings between the source event fields and the values in the Elasticsearch threat index. Each entries object must contain these fields:
	//
	// - field: field from the event indices on which the rule runs
	// - type: must be mapping
	// - value: field from the Elasticsearch threat index
	//
	// You can use Boolean and and or logic to define the conditions for when matching fields and values generate alerts. Sibling entries objects are evaluated using or logic, whereas multiple entries in a single entries object use and logic. See Example of Threat Match rule which uses both `and` and `or` logic.
	ThreatMapping SecurityDetectionsAPIThreatMapping `json:"threat_mapping"`

	// ThreatQuery Query used to determine which fields in the Elasticsearch index are used for generating alerts.
	ThreatQuery SecurityDetectionsAPIThreatQuery `json:"threat_query"`

	// Type Rule type
	Type SecurityDetectionsAPIThreatMatchRuleRequiredFieldsType `json:"type"`
}

// SecurityDetectionsAPIThreatMatchRuleRequiredFieldsType Rule type
type SecurityDetectionsAPIThreatMatchRuleRequiredFieldsType string

// SecurityDetectionsAPIThreatMatchRuleResponseFields defines model for Security_Detections_API_ThreatMatchRuleResponseFields.
type SecurityDetectionsAPIThreatMatchRuleResponseFields struct {
	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression   *SecurityDetectionsAPIAlertSuppression   `json:"alert_suppression,omitempty"`
	ConcurrentSearches *SecurityDetectionsAPIConcurrentSearches `json:"concurrent_searches,omitempty"`
	DataViewId         *SecurityDetectionsAPIDataViewId         `json:"data_view_id,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index          *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`
	ItemsPerSearch *SecurityDetectionsAPIItemsPerSearch    `json:"items_per_search,omitempty"`
	Language       SecurityDetectionsAPIKqlQueryLanguage   `json:"language"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// SavedId Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
	SavedId       *SecurityDetectionsAPISavedQueryId  `json:"saved_id,omitempty"`
	ThreatFilters *SecurityDetectionsAPIThreatFilters `json:"threat_filters,omitempty"`

	// ThreatIndex Elasticsearch indices used to check which field values generate alerts.
	ThreatIndex SecurityDetectionsAPIThreatIndex `json:"threat_index"`

	// ThreatIndicatorPath Defines the path to the threat indicator in the indicator documents (optional)
	ThreatIndicatorPath *SecurityDetectionsAPIThreatIndicatorPath `json:"threat_indicator_path,omitempty"`
	ThreatLanguage      *SecurityDetectionsAPIKqlQueryLanguage    `json:"threat_language,omitempty"`

	// ThreatMapping Array of entries objects that define mappings between the source event fields and the values in the Elasticsearch threat index. Each entries object must contain these fields:
	//
	// - field: field from the event indices on which the rule runs
	// - type: must be mapping
	// - value: field from the Elasticsearch threat index
	//
	// You can use Boolean and and or logic to define the conditions for when matching fields and values generate alerts. Sibling entries objects are evaluated using or logic, whereas multiple entries in a single entries object use and logic. See Example of Threat Match rule which uses both `and` and `or` logic.
	ThreatMapping SecurityDetectionsAPIThreatMapping `json:"threat_mapping"`

	// ThreatQuery Query used to determine which fields in the Elasticsearch index are used for generating alerts.
	ThreatQuery SecurityDetectionsAPIThreatQuery `json:"threat_query"`

	// Type Rule type
	Type SecurityDetectionsAPIThreatMatchRuleResponseFieldsType `json:"type"`
}

// SecurityDetectionsAPIThreatMatchRuleResponseFieldsType Rule type
type SecurityDetectionsAPIThreatMatchRuleResponseFieldsType string

// SecurityDetectionsAPIThreatMatchRuleUpdateProps defines model for Security_Detections_API_ThreatMatchRuleUpdateProps.
type SecurityDetectionsAPIThreatMatchRuleUpdateProps struct {
	// Actions Array defining the automated actions (notifications) taken when alerts are generated.
	Actions *[]SecurityDetectionsAPIRuleAction `json:"actions,omitempty"`

	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIAlertSuppression                `json:"alert_suppression,omitempty"`
	AliasPurpose     *SecurityDetectionsAPISavedObjectResolveAliasPurpose  `json:"alias_purpose,omitempty"`
	AliasTargetId    *SecurityDetectionsAPISavedObjectResolveAliasTargetId `json:"alias_target_id,omitempty"`

	// Author The rules author.
	Author *SecurityDetectionsAPIRuleAuthorArray `json:"author,omitempty"`

	// BuildingBlockType Determines if the rule acts as a building block. If yes, the value must be `default`.
	// By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
	// For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
	BuildingBlockType  *SecurityDetectionsAPIBuildingBlockType  `json:"building_block_type,omitempty"`
	ConcurrentSearches *SecurityDetectionsAPIConcurrentSearches `json:"concurrent_searches,omitempty"`
	DataViewId         *SecurityDetectionsAPIDataViewId         `json:"data_view_id,omitempty"`

	// Description The rules description.
	Description SecurityDetectionsAPIRuleDescription `json:"description"`

	// Enabled Determines whether the rule is enabled. Defaults to true.
	Enabled        *SecurityDetectionsAPIIsRuleEnabled       `json:"enabled,omitempty"`
	ExceptionsList *[]SecurityDetectionsAPIRuleExceptionList `json:"exceptions_list,omitempty"`

	// FalsePositives String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
	FalsePositives *SecurityDetectionsAPIRuleFalsePositiveArray `json:"false_positives,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// From Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
	From *SecurityDetectionsAPIRuleIntervalFrom `json:"from,omitempty"`

	// Id A universally unique identifier
	Id *SecurityDetectionsAPIRuleObjectId `json:"id,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`

	// Interval Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
	Interval *SecurityDetectionsAPIRuleInterval `json:"interval,omitempty"`

	// InvestigationFields Schema for fields relating to investigation fields. These are user defined fields we use to highlight
	// in various features in the UI such as alert details flyout and exceptions auto-population from alert.
	InvestigationFields *SecurityDetectionsAPIInvestigationFields `json:"investigation_fields,omitempty"`
	ItemsPerSearch      *SecurityDetectionsAPIItemsPerSearch      `json:"items_per_search,omitempty"`
	Language            *SecurityDetectionsAPIKqlQueryLanguage    `json:"language,omitempty"`

	// License The rule's license.
	License *SecurityDetectionsAPIRuleLicense `json:"license,omitempty"`

	// MaxSignals Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
	// > info
	// > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
	MaxSignals *SecurityDetectionsAPIMaxSignals `json:"max_signals,omitempty"`

	// Meta Placeholder for metadata about the rule.
	// > info
	// > This field is overwritten when you save changes to the rules settings.
	Meta *SecurityDetectionsAPIRuleMetadata `json:"meta,omitempty"`

	// Name A human-readable name for the rule.
	Name SecurityDetectionsAPIRuleName `json:"name"`

	// Namespace Has no effect.
	Namespace *SecurityDetectionsAPIAlertsIndexNamespace `json:"namespace,omitempty"`

	// Note Notes to help investigate alerts produced by the rule.
	Note    *SecurityDetectionsAPIInvestigationGuide        `json:"note,omitempty"`
	Outcome *SecurityDetectionsAPISavedObjectResolveOutcome `json:"outcome,omitempty"`

	// OutputIndex (deprecated) Has no effect.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	OutputIndex *SecurityDetectionsAPIAlertsIndex `json:"output_index,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// References Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
	References          *SecurityDetectionsAPIRuleReferenceArray      `json:"references,omitempty"`
	RelatedIntegrations *SecurityDetectionsAPIRelatedIntegrationArray `json:"related_integrations,omitempty"`

	// RequiredFields Elasticsearch fields and their types that need to be present for the rule to function.
	// > info
	// > The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.
	RequiredFields  *[]SecurityDetectionsAPIRequiredFieldInput `json:"required_fields,omitempty"`
	ResponseActions *[]SecurityDetectionsAPIResponseAction     `json:"response_actions,omitempty"`

	// RiskScore A numerical representation of the alert's severity from 0 to 100, where:
	// * `0` - `21` represents low severity
	// * `22` - `47` represents medium severity
	// * `48` - `73` represents high severity
	// * `74` - `100` represents critical severity
	RiskScore SecurityDetectionsAPIRiskScore `json:"risk_score"`

	// RiskScoreMapping Overrides generated alerts' risk_score with a value from the source event
	RiskScoreMapping *SecurityDetectionsAPIRiskScoreMapping `json:"risk_score_mapping,omitempty"`

	// RuleId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
	RuleId *SecurityDetectionsAPIRuleSignatureId `json:"rule_id,omitempty"`

	// RuleNameOverride Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
	RuleNameOverride *SecurityDetectionsAPIRuleNameOverride `json:"rule_name_override,omitempty"`

	// SavedId Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
	SavedId *SecurityDetectionsAPISavedQueryId `json:"saved_id,omitempty"`

	// Setup Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
	Setup *SecurityDetectionsAPISetupGuide `json:"setup,omitempty"`

	// Severity Severity level of alerts produced by the rule, which must be one of the following:
	// * `low`: Alerts that are of interest but generally not considered to be security incidents
	// * `medium`: Alerts that require investigation
	// * `high`: Alerts that require immediate investigation
	// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
	Severity SecurityDetectionsAPISeverity `json:"severity"`

	// SeverityMapping Overrides generated alerts' severity with values from the source event
	SeverityMapping *SecurityDetectionsAPISeverityMapping `json:"severity_mapping,omitempty"`

	// Tags String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
	Tags          *SecurityDetectionsAPIRuleTagArray  `json:"tags,omitempty"`
	Threat        *SecurityDetectionsAPIThreatArray   `json:"threat,omitempty"`
	ThreatFilters *SecurityDetectionsAPIThreatFilters `json:"threat_filters,omitempty"`

	// ThreatIndex Elasticsearch indices used to check which field values generate alerts.
	ThreatIndex SecurityDetectionsAPIThreatIndex `json:"threat_index"`

	// ThreatIndicatorPath Defines the path to the threat indicator in the indicator documents (optional)
	ThreatIndicatorPath *SecurityDetectionsAPIThreatIndicatorPath `json:"threat_indicator_path,omitempty"`
	ThreatLanguage      *SecurityDetectionsAPIKqlQueryLanguage    `json:"threat_language,omitempty"`

	// ThreatMapping Array of entries objects that define mappings between the source event fields and the values in the Elasticsearch threat index. Each entries object must contain these fields:
	//
	// - field: field from the event indices on which the rule runs
	// - type: must be mapping
	// - value: field from the Elasticsearch threat index
	//
	// You can use Boolean and and or logic to define the conditions for when matching fields and values generate alerts. Sibling entries objects are evaluated using or logic, whereas multiple entries in a single entries object use and logic. See Example of Threat Match rule which uses both `and` and `or` logic.
	ThreatMapping SecurityDetectionsAPIThreatMapping `json:"threat_mapping"`

	// ThreatQuery Query used to determine which fields in the Elasticsearch index are used for generating alerts.
	ThreatQuery SecurityDetectionsAPIThreatQuery `json:"threat_query"`

	// Throttle Defines how often rule actions are taken.
	Throttle *SecurityDetectionsAPIRuleActionThrottle `json:"throttle,omitempty"`

	// TimelineId Timeline template ID
	TimelineId *SecurityDetectionsAPITimelineTemplateId `json:"timeline_id,omitempty"`

	// TimelineTitle Timeline template title
	TimelineTitle *SecurityDetectionsAPITimelineTemplateTitle `json:"timeline_title,omitempty"`

	// TimestampOverride Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
	TimestampOverride *SecurityDetectionsAPITimestampOverride `json:"timestamp_override,omitempty"`

	// TimestampOverrideFallbackDisabled Disables the fallback to the event's @timestamp field
	TimestampOverrideFallbackDisabled *SecurityDetectionsAPITimestampOverrideFallbackDisabled `json:"timestamp_override_fallback_disabled,omitempty"`
	To                                *SecurityDetectionsAPIRuleIntervalTo                    `json:"to,omitempty"`

	// Type Rule type
	Type SecurityDetectionsAPIThreatMatchRuleUpdatePropsType `json:"type"`

	// Version The rule's version number.
	//
	// - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
	// - For custom rules it is set to `1` when the rule is created.
	// > info
	// > It is not incremented on each update. Compare this to the `revision` field.
	Version *SecurityDetectionsAPIRuleVersion `json:"version,omitempty"`
}

// SecurityDetectionsAPIThreatMatchRuleUpdatePropsType Rule type
type SecurityDetectionsAPIThreatMatchRuleUpdatePropsType string

// SecurityDetectionsAPIThreatQuery Query used to determine which fields in the Elasticsearch index are used for generating alerts.
type SecurityDetectionsAPIThreatQuery = string

// SecurityDetectionsAPIThreatSubtechnique defines model for Security_Detections_API_ThreatSubtechnique.
type SecurityDetectionsAPIThreatSubtechnique struct {
	// Id Subtechnique ID
	Id string `json:"id"`

	// Name Subtechnique name
	Name string `json:"name"`

	// Reference Subtechnique reference
	Reference string `json:"reference"`
}

// SecurityDetectionsAPIThreatTactic Object containing information on the attack type
type SecurityDetectionsAPIThreatTactic struct {
	// Id Tactic ID
	Id string `json:"id"`

	// Name Tactic name
	Name string `json:"name"`

	// Reference Tactic reference
	Reference string `json:"reference"`
}

// SecurityDetectionsAPIThreatTechnique defines model for Security_Detections_API_ThreatTechnique.
type SecurityDetectionsAPIThreatTechnique struct {
	// Id Technique ID
	Id string `json:"id"`

	// Name Technique name
	Name string `json:"name"`

	// Reference Technique reference
	Reference string `json:"reference"`

	// Subtechnique Array containing more specific information on the attack technique.
	Subtechnique *[]SecurityDetectionsAPIThreatSubtechnique `json:"subtechnique,omitempty"`
}

// SecurityDetectionsAPIThreshold defines model for Security_Detections_API_Threshold.
type SecurityDetectionsAPIThreshold struct {
	// Cardinality The field on which the cardinality is applied.
	Cardinality *SecurityDetectionsAPIThresholdCardinality `json:"cardinality,omitempty"`

	// Field The field on which the threshold is applied. If you specify an empty array ([]), alerts are generated when the query returns at least the number of results specified in the value field.
	Field SecurityDetectionsAPIThresholdField `json:"field"`

	// Value The threshold value from which an alert is generated.
	Value SecurityDetectionsAPIThresholdValue `json:"value"`
}

// SecurityDetectionsAPIThresholdAlertSuppression Defines alert suppression configuration.
type SecurityDetectionsAPIThresholdAlertSuppression struct {
	Duration SecurityDetectionsAPIAlertSuppressionDuration `json:"duration"`
}

// SecurityDetectionsAPIThresholdCardinality The field on which the cardinality is applied.
type SecurityDetectionsAPIThresholdCardinality = []struct {
	// Field The field on which to calculate and compare the cardinality.
	Field string `json:"field"`

	// Value The threshold value from which an alert is generated based on unique number of values of cardinality.field.
	Value int `json:"value"`
}

// SecurityDetectionsAPIThresholdField The field on which the threshold is applied. If you specify an empty array ([]), alerts are generated when the query returns at least the number of results specified in the value field.
type SecurityDetectionsAPIThresholdField struct {
	union json.RawMessage
}

// SecurityDetectionsAPIThresholdField0 defines model for .
type SecurityDetectionsAPIThresholdField0 = string

// SecurityDetectionsAPIThresholdField1 defines model for .
type SecurityDetectionsAPIThresholdField1 = []string

// SecurityDetectionsAPIThresholdRule defines model for Security_Detections_API_ThresholdRule.
type SecurityDetectionsAPIThresholdRule struct {
	// Actions Array defining the automated actions (notifications) taken when alerts are generated.
	Actions []SecurityDetectionsAPIRuleAction `json:"actions"`

	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIThresholdAlertSuppression       `json:"alert_suppression,omitempty"`
	AliasPurpose     *SecurityDetectionsAPISavedObjectResolveAliasPurpose  `json:"alias_purpose,omitempty"`
	AliasTargetId    *SecurityDetectionsAPISavedObjectResolveAliasTargetId `json:"alias_target_id,omitempty"`

	// Author The rules author.
	Author SecurityDetectionsAPIRuleAuthorArray `json:"author"`

	// BuildingBlockType Determines if the rule acts as a building block. If yes, the value must be `default`.
	// By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
	// For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
	BuildingBlockType *SecurityDetectionsAPIBuildingBlockType `json:"building_block_type,omitempty"`
	CreatedAt         time.Time                               `json:"created_at"`
	CreatedBy         string                                  `json:"created_by"`
	DataViewId        *SecurityDetectionsAPIDataViewId        `json:"data_view_id,omitempty"`

	// Description The rules description.
	Description SecurityDetectionsAPIRuleDescription `json:"description"`

	// Enabled Determines whether the rule is enabled. Defaults to true.
	Enabled        SecurityDetectionsAPIIsRuleEnabled       `json:"enabled"`
	ExceptionsList []SecurityDetectionsAPIRuleExceptionList `json:"exceptions_list"`

	// ExecutionSummary Summary of the last execution of a rule.
	// > info
	// > This field is under development and its usage or schema may change
	ExecutionSummary *SecurityDetectionsAPIRuleExecutionSummary `json:"execution_summary,omitempty"`

	// FalsePositives String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
	FalsePositives SecurityDetectionsAPIRuleFalsePositiveArray `json:"false_positives"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// From Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
	From SecurityDetectionsAPIRuleIntervalFrom `json:"from"`

	// Id A universally unique identifier
	Id SecurityDetectionsAPIRuleObjectId `json:"id"`

	// Immutable This field determines whether the rule is a prebuilt Elastic rule. It will be replaced with the `rule_source` field.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Immutable SecurityDetectionsAPIIsRuleImmutable `json:"immutable"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`

	// Interval Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
	Interval SecurityDetectionsAPIRuleInterval `json:"interval"`

	// InvestigationFields Schema for fields relating to investigation fields. These are user defined fields we use to highlight
	// in various features in the UI such as alert details flyout and exceptions auto-population from alert.
	InvestigationFields *SecurityDetectionsAPIInvestigationFields `json:"investigation_fields,omitempty"`
	Language            SecurityDetectionsAPIKqlQueryLanguage     `json:"language"`

	// License The rule's license.
	License *SecurityDetectionsAPIRuleLicense `json:"license,omitempty"`

	// MaxSignals Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
	// > info
	// > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
	MaxSignals SecurityDetectionsAPIMaxSignals `json:"max_signals"`

	// Meta Placeholder for metadata about the rule.
	// > info
	// > This field is overwritten when you save changes to the rules settings.
	Meta *SecurityDetectionsAPIRuleMetadata `json:"meta,omitempty"`

	// Name A human-readable name for the rule.
	Name SecurityDetectionsAPIRuleName `json:"name"`

	// Namespace Has no effect.
	Namespace *SecurityDetectionsAPIAlertsIndexNamespace `json:"namespace,omitempty"`

	// Note Notes to help investigate alerts produced by the rule.
	Note    *SecurityDetectionsAPIInvestigationGuide        `json:"note,omitempty"`
	Outcome *SecurityDetectionsAPISavedObjectResolveOutcome `json:"outcome,omitempty"`

	// OutputIndex (deprecated) Has no effect.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	OutputIndex *SecurityDetectionsAPIAlertsIndex `json:"output_index,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// References Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
	References          SecurityDetectionsAPIRuleReferenceArray      `json:"references"`
	RelatedIntegrations SecurityDetectionsAPIRelatedIntegrationArray `json:"related_integrations"`
	RequiredFields      SecurityDetectionsAPIRequiredFieldArray      `json:"required_fields"`
	ResponseActions     *[]SecurityDetectionsAPIResponseAction       `json:"response_actions,omitempty"`

	// Revision The rule's revision number.
	//
	// It represents the version of rule's object in Kibana. It is set to `0` when the rule is installed or created and then gets incremented on each update.
	// > info
	// > Not all updates to any rule fields will increment the revision. Only those fields that are considered static `rule parameters` can trigger revision increments. For example, an update to a rule's query or index fields will increment the rule's revision by `1`. However, changes to dynamic or technical fields like enabled or execution_summary will not cause revision increments.
	Revision SecurityDetectionsAPIRuleRevision `json:"revision"`

	// RiskScore A numerical representation of the alert's severity from 0 to 100, where:
	// * `0` - `21` represents low severity
	// * `22` - `47` represents medium severity
	// * `48` - `73` represents high severity
	// * `74` - `100` represents critical severity
	RiskScore SecurityDetectionsAPIRiskScore `json:"risk_score"`

	// RiskScoreMapping Overrides generated alerts' risk_score with a value from the source event
	RiskScoreMapping SecurityDetectionsAPIRiskScoreMapping `json:"risk_score_mapping"`

	// RuleId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
	RuleId SecurityDetectionsAPIRuleSignatureId `json:"rule_id"`

	// RuleNameOverride Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
	RuleNameOverride *SecurityDetectionsAPIRuleNameOverride `json:"rule_name_override,omitempty"`

	// RuleSource Discriminated union that determines whether the rule is internally sourced (created within the Kibana app) or has an external source, such as the Elastic Prebuilt rules repo.
	RuleSource SecurityDetectionsAPIRuleSource `json:"rule_source"`

	// SavedId Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
	SavedId *SecurityDetectionsAPISavedQueryId `json:"saved_id,omitempty"`

	// Setup Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
	Setup SecurityDetectionsAPISetupGuide `json:"setup"`

	// Severity Severity level of alerts produced by the rule, which must be one of the following:
	// * `low`: Alerts that are of interest but generally not considered to be security incidents
	// * `medium`: Alerts that require investigation
	// * `high`: Alerts that require immediate investigation
	// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
	Severity SecurityDetectionsAPISeverity `json:"severity"`

	// SeverityMapping Overrides generated alerts' severity with values from the source event
	SeverityMapping SecurityDetectionsAPISeverityMapping `json:"severity_mapping"`

	// Tags String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
	Tags      SecurityDetectionsAPIRuleTagArray `json:"tags"`
	Threat    SecurityDetectionsAPIThreatArray  `json:"threat"`
	Threshold SecurityDetectionsAPIThreshold    `json:"threshold"`

	// Throttle Defines how often rule actions are taken.
	Throttle *SecurityDetectionsAPIRuleActionThrottle `json:"throttle,omitempty"`

	// TimelineId Timeline template ID
	TimelineId *SecurityDetectionsAPITimelineTemplateId `json:"timeline_id,omitempty"`

	// TimelineTitle Timeline template title
	TimelineTitle *SecurityDetectionsAPITimelineTemplateTitle `json:"timeline_title,omitempty"`

	// TimestampOverride Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
	TimestampOverride *SecurityDetectionsAPITimestampOverride `json:"timestamp_override,omitempty"`

	// TimestampOverrideFallbackDisabled Disables the fallback to the event's @timestamp field
	TimestampOverrideFallbackDisabled *SecurityDetectionsAPITimestampOverrideFallbackDisabled `json:"timestamp_override_fallback_disabled,omitempty"`
	To                                SecurityDetectionsAPIRuleIntervalTo                     `json:"to"`

	// Type Rule type
	Type      SecurityDetectionsAPIThresholdRuleType `json:"type"`
	UpdatedAt time.Time                              `json:"updated_at"`
	UpdatedBy string                                 `json:"updated_by"`

	// Version The rule's version number.
	//
	// - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
	// - For custom rules it is set to `1` when the rule is created.
	// > info
	// > It is not incremented on each update. Compare this to the `revision` field.
	Version SecurityDetectionsAPIRuleVersion `json:"version"`
}

// SecurityDetectionsAPIThresholdRuleType Rule type
type SecurityDetectionsAPIThresholdRuleType string

// SecurityDetectionsAPIThresholdRuleCreateFields defines model for Security_Detections_API_ThresholdRuleCreateFields.
type SecurityDetectionsAPIThresholdRuleCreateFields struct {
	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIThresholdAlertSuppression `json:"alert_suppression,omitempty"`
	DataViewId       *SecurityDetectionsAPIDataViewId                `json:"data_view_id,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index    *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`
	Language *SecurityDetectionsAPIKqlQueryLanguage  `json:"language,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// SavedId Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
	SavedId   *SecurityDetectionsAPISavedQueryId `json:"saved_id,omitempty"`
	Threshold SecurityDetectionsAPIThreshold     `json:"threshold"`

	// Type Rule type
	Type SecurityDetectionsAPIThresholdRuleCreateFieldsType `json:"type"`
}

// SecurityDetectionsAPIThresholdRuleCreateFieldsType Rule type
type SecurityDetectionsAPIThresholdRuleCreateFieldsType string

// SecurityDetectionsAPIThresholdRuleCreateProps defines model for Security_Detections_API_ThresholdRuleCreateProps.
type SecurityDetectionsAPIThresholdRuleCreateProps struct {
	// Actions Array defining the automated actions (notifications) taken when alerts are generated.
	Actions *[]SecurityDetectionsAPIRuleAction `json:"actions,omitempty"`

	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIThresholdAlertSuppression       `json:"alert_suppression,omitempty"`
	AliasPurpose     *SecurityDetectionsAPISavedObjectResolveAliasPurpose  `json:"alias_purpose,omitempty"`
	AliasTargetId    *SecurityDetectionsAPISavedObjectResolveAliasTargetId `json:"alias_target_id,omitempty"`

	// Author The rules author.
	Author *SecurityDetectionsAPIRuleAuthorArray `json:"author,omitempty"`

	// BuildingBlockType Determines if the rule acts as a building block. If yes, the value must be `default`.
	// By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
	// For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
	BuildingBlockType *SecurityDetectionsAPIBuildingBlockType `json:"building_block_type,omitempty"`
	DataViewId        *SecurityDetectionsAPIDataViewId        `json:"data_view_id,omitempty"`

	// Description The rules description.
	Description SecurityDetectionsAPIRuleDescription `json:"description"`

	// Enabled Determines whether the rule is enabled. Defaults to true.
	Enabled        *SecurityDetectionsAPIIsRuleEnabled       `json:"enabled,omitempty"`
	ExceptionsList *[]SecurityDetectionsAPIRuleExceptionList `json:"exceptions_list,omitempty"`

	// FalsePositives String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
	FalsePositives *SecurityDetectionsAPIRuleFalsePositiveArray `json:"false_positives,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// From Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
	From *SecurityDetectionsAPIRuleIntervalFrom `json:"from,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`

	// Interval Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
	Interval *SecurityDetectionsAPIRuleInterval `json:"interval,omitempty"`

	// InvestigationFields Schema for fields relating to investigation fields. These are user defined fields we use to highlight
	// in various features in the UI such as alert details flyout and exceptions auto-population from alert.
	InvestigationFields *SecurityDetectionsAPIInvestigationFields `json:"investigation_fields,omitempty"`
	Language            *SecurityDetectionsAPIKqlQueryLanguage    `json:"language,omitempty"`

	// License The rule's license.
	License *SecurityDetectionsAPIRuleLicense `json:"license,omitempty"`

	// MaxSignals Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
	// > info
	// > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
	MaxSignals *SecurityDetectionsAPIMaxSignals `json:"max_signals,omitempty"`

	// Meta Placeholder for metadata about the rule.
	// > info
	// > This field is overwritten when you save changes to the rules settings.
	Meta *SecurityDetectionsAPIRuleMetadata `json:"meta,omitempty"`

	// Name A human-readable name for the rule.
	Name SecurityDetectionsAPIRuleName `json:"name"`

	// Namespace Has no effect.
	Namespace *SecurityDetectionsAPIAlertsIndexNamespace `json:"namespace,omitempty"`

	// Note Notes to help investigate alerts produced by the rule.
	Note    *SecurityDetectionsAPIInvestigationGuide        `json:"note,omitempty"`
	Outcome *SecurityDetectionsAPISavedObjectResolveOutcome `json:"outcome,omitempty"`

	// OutputIndex (deprecated) Has no effect.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	OutputIndex *SecurityDetectionsAPIAlertsIndex `json:"output_index,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// References Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
	References          *SecurityDetectionsAPIRuleReferenceArray      `json:"references,omitempty"`
	RelatedIntegrations *SecurityDetectionsAPIRelatedIntegrationArray `json:"related_integrations,omitempty"`

	// RequiredFields Elasticsearch fields and their types that need to be present for the rule to function.
	// > info
	// > The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.
	RequiredFields  *[]SecurityDetectionsAPIRequiredFieldInput `json:"required_fields,omitempty"`
	ResponseActions *[]SecurityDetectionsAPIResponseAction     `json:"response_actions,omitempty"`

	// RiskScore A numerical representation of the alert's severity from 0 to 100, where:
	// * `0` - `21` represents low severity
	// * `22` - `47` represents medium severity
	// * `48` - `73` represents high severity
	// * `74` - `100` represents critical severity
	RiskScore SecurityDetectionsAPIRiskScore `json:"risk_score"`

	// RiskScoreMapping Overrides generated alerts' risk_score with a value from the source event
	RiskScoreMapping *SecurityDetectionsAPIRiskScoreMapping `json:"risk_score_mapping,omitempty"`

	// RuleId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
	RuleId *SecurityDetectionsAPIRuleSignatureId `json:"rule_id,omitempty"`

	// RuleNameOverride Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
	RuleNameOverride *SecurityDetectionsAPIRuleNameOverride `json:"rule_name_override,omitempty"`

	// SavedId Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
	SavedId *SecurityDetectionsAPISavedQueryId `json:"saved_id,omitempty"`

	// Setup Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
	Setup *SecurityDetectionsAPISetupGuide `json:"setup,omitempty"`

	// Severity Severity level of alerts produced by the rule, which must be one of the following:
	// * `low`: Alerts that are of interest but generally not considered to be security incidents
	// * `medium`: Alerts that require investigation
	// * `high`: Alerts that require immediate investigation
	// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
	Severity SecurityDetectionsAPISeverity `json:"severity"`

	// SeverityMapping Overrides generated alerts' severity with values from the source event
	SeverityMapping *SecurityDetectionsAPISeverityMapping `json:"severity_mapping,omitempty"`

	// Tags String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
	Tags      *SecurityDetectionsAPIRuleTagArray `json:"tags,omitempty"`
	Threat    *SecurityDetectionsAPIThreatArray  `json:"threat,omitempty"`
	Threshold SecurityDetectionsAPIThreshold     `json:"threshold"`

	// Throttle Defines how often rule actions are taken.
	Throttle *SecurityDetectionsAPIRuleActionThrottle `json:"throttle,omitempty"`

	// TimelineId Timeline template ID
	TimelineId *SecurityDetectionsAPITimelineTemplateId `json:"timeline_id,omitempty"`

	// TimelineTitle Timeline template title
	TimelineTitle *SecurityDetectionsAPITimelineTemplateTitle `json:"timeline_title,omitempty"`

	// TimestampOverride Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
	TimestampOverride *SecurityDetectionsAPITimestampOverride `json:"timestamp_override,omitempty"`

	// TimestampOverrideFallbackDisabled Disables the fallback to the event's @timestamp field
	TimestampOverrideFallbackDisabled *SecurityDetectionsAPITimestampOverrideFallbackDisabled `json:"timestamp_override_fallback_disabled,omitempty"`
	To                                *SecurityDetectionsAPIRuleIntervalTo                    `json:"to,omitempty"`

	// Type Rule type
	Type SecurityDetectionsAPIThresholdRuleCreatePropsType `json:"type"`

	// Version The rule's version number.
	//
	// - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
	// - For custom rules it is set to `1` when the rule is created.
	// > info
	// > It is not incremented on each update. Compare this to the `revision` field.
	Version *SecurityDetectionsAPIRuleVersion `json:"version,omitempty"`
}

// SecurityDetectionsAPIThresholdRuleCreatePropsType Rule type
type SecurityDetectionsAPIThresholdRuleCreatePropsType string

// SecurityDetectionsAPIThresholdRuleDefaultableFields defines model for Security_Detections_API_ThresholdRuleDefaultableFields.
type SecurityDetectionsAPIThresholdRuleDefaultableFields struct {
	Language *SecurityDetectionsAPIKqlQueryLanguage `json:"language,omitempty"`
}

// SecurityDetectionsAPIThresholdRuleOptionalFields defines model for Security_Detections_API_ThresholdRuleOptionalFields.
type SecurityDetectionsAPIThresholdRuleOptionalFields struct {
	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIThresholdAlertSuppression `json:"alert_suppression,omitempty"`
	DataViewId       *SecurityDetectionsAPIDataViewId                `json:"data_view_id,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`

	// SavedId Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
	SavedId *SecurityDetectionsAPISavedQueryId `json:"saved_id,omitempty"`
}

// SecurityDetectionsAPIThresholdRuleRequiredFields defines model for Security_Detections_API_ThresholdRuleRequiredFields.
type SecurityDetectionsAPIThresholdRuleRequiredFields struct {
	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query     SecurityDetectionsAPIRuleQuery `json:"query"`
	Threshold SecurityDetectionsAPIThreshold `json:"threshold"`

	// Type Rule type
	Type SecurityDetectionsAPIThresholdRuleRequiredFieldsType `json:"type"`
}

// SecurityDetectionsAPIThresholdRuleRequiredFieldsType Rule type
type SecurityDetectionsAPIThresholdRuleRequiredFieldsType string

// SecurityDetectionsAPIThresholdRuleResponseFields defines model for Security_Detections_API_ThresholdRuleResponseFields.
type SecurityDetectionsAPIThresholdRuleResponseFields struct {
	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIThresholdAlertSuppression `json:"alert_suppression,omitempty"`
	DataViewId       *SecurityDetectionsAPIDataViewId                `json:"data_view_id,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index    *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`
	Language SecurityDetectionsAPIKqlQueryLanguage   `json:"language"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// SavedId Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
	SavedId   *SecurityDetectionsAPISavedQueryId `json:"saved_id,omitempty"`
	Threshold SecurityDetectionsAPIThreshold     `json:"threshold"`

	// Type Rule type
	Type SecurityDetectionsAPIThresholdRuleResponseFieldsType `json:"type"`
}

// SecurityDetectionsAPIThresholdRuleResponseFieldsType Rule type
type SecurityDetectionsAPIThresholdRuleResponseFieldsType string

// SecurityDetectionsAPIThresholdRuleUpdateProps defines model for Security_Detections_API_ThresholdRuleUpdateProps.
type SecurityDetectionsAPIThresholdRuleUpdateProps struct {
	// Actions Array defining the automated actions (notifications) taken when alerts are generated.
	Actions *[]SecurityDetectionsAPIRuleAction `json:"actions,omitempty"`

	// AlertSuppression Defines alert suppression configuration.
	AlertSuppression *SecurityDetectionsAPIThresholdAlertSuppression       `json:"alert_suppression,omitempty"`
	AliasPurpose     *SecurityDetectionsAPISavedObjectResolveAliasPurpose  `json:"alias_purpose,omitempty"`
	AliasTargetId    *SecurityDetectionsAPISavedObjectResolveAliasTargetId `json:"alias_target_id,omitempty"`

	// Author The rules author.
	Author *SecurityDetectionsAPIRuleAuthorArray `json:"author,omitempty"`

	// BuildingBlockType Determines if the rule acts as a building block. If yes, the value must be `default`.
	// By default, building-block alerts are not displayed in the UI. These rules are used as a foundation for other rules that do generate alerts.
	// For more information, refer to [About building block rules](https://www.elastic.co/guide/en/security/current/building-block-rule.html).
	BuildingBlockType *SecurityDetectionsAPIBuildingBlockType `json:"building_block_type,omitempty"`
	DataViewId        *SecurityDetectionsAPIDataViewId        `json:"data_view_id,omitempty"`

	// Description The rules description.
	Description SecurityDetectionsAPIRuleDescription `json:"description"`

	// Enabled Determines whether the rule is enabled. Defaults to true.
	Enabled        *SecurityDetectionsAPIIsRuleEnabled       `json:"enabled,omitempty"`
	ExceptionsList *[]SecurityDetectionsAPIRuleExceptionList `json:"exceptions_list,omitempty"`

	// FalsePositives String array used to describe common reasons why the rule may issue false-positive alerts. Defaults to an empty array.
	FalsePositives *SecurityDetectionsAPIRuleFalsePositiveArray `json:"false_positives,omitempty"`

	// Filters The query and filter context array used to define the conditions for when alerts are created from events. Defaults to an empty array.
	// > info
	// > This field is not supported for ES|QL rules.
	Filters *SecurityDetectionsAPIRuleFilterArray `json:"filters,omitempty"`

	// From Time from which data is analyzed each time the rule runs, using a date math range. For example, now-4200s means the rule analyzes data from 70 minutes before its start time. Defaults to now-6m (analyzes data from 6 minutes before the start time).
	From *SecurityDetectionsAPIRuleIntervalFrom `json:"from,omitempty"`

	// Id A universally unique identifier
	Id *SecurityDetectionsAPIRuleObjectId `json:"id,omitempty"`

	// Index Indices on which the rule functions. Defaults to the Security Solution indices defined on the Kibana Advanced Settings page (Kibana  Stack Management  Advanced Settings  `securitySolution:defaultIndex`).
	// > info
	// > This field is not supported for ES|QL rules.
	Index *SecurityDetectionsAPIIndexPatternArray `json:"index,omitempty"`

	// Interval Frequency of rule execution, using a date math range. For example, "1h" means the rule runs every hour. Defaults to 5m (5 minutes).
	Interval *SecurityDetectionsAPIRuleInterval `json:"interval,omitempty"`

	// InvestigationFields Schema for fields relating to investigation fields. These are user defined fields we use to highlight
	// in various features in the UI such as alert details flyout and exceptions auto-population from alert.
	InvestigationFields *SecurityDetectionsAPIInvestigationFields `json:"investigation_fields,omitempty"`
	Language            *SecurityDetectionsAPIKqlQueryLanguage    `json:"language,omitempty"`

	// License The rule's license.
	License *SecurityDetectionsAPIRuleLicense `json:"license,omitempty"`

	// MaxSignals Maximum number of alerts the rule can create during a single run (the rules Max alerts per run [advanced setting](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#rule-ui-advanced-params) value).
	// > info
	// > This setting can be superseded by the [Kibana configuration setting](https://www.elastic.co/guide/en/kibana/current/alert-action-settings-kb.html#alert-settings) `xpack.alerting.rules.run.alerts.max`, which determines the maximum alerts generated by any rule in the Kibana alerting framework. For example, if `xpack.alerting.rules.run.alerts.max` is set to 1000, the rule can generate no more than 1000 alerts even if `max_signals` is set higher.
	MaxSignals *SecurityDetectionsAPIMaxSignals `json:"max_signals,omitempty"`

	// Meta Placeholder for metadata about the rule.
	// > info
	// > This field is overwritten when you save changes to the rules settings.
	Meta *SecurityDetectionsAPIRuleMetadata `json:"meta,omitempty"`

	// Name A human-readable name for the rule.
	Name SecurityDetectionsAPIRuleName `json:"name"`

	// Namespace Has no effect.
	Namespace *SecurityDetectionsAPIAlertsIndexNamespace `json:"namespace,omitempty"`

	// Note Notes to help investigate alerts produced by the rule.
	Note    *SecurityDetectionsAPIInvestigationGuide        `json:"note,omitempty"`
	Outcome *SecurityDetectionsAPISavedObjectResolveOutcome `json:"outcome,omitempty"`

	// OutputIndex (deprecated) Has no effect.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	OutputIndex *SecurityDetectionsAPIAlertsIndex `json:"output_index,omitempty"`

	// Query [Query](https://www.elastic.co/guide/en/kibana/8.17/search.html) used by the rule to create alerts.
	//
	// - For indicator match rules, only the querys results are used to determine whether an alert is generated.
	// - ES|QL rules have additional query requirements. Refer to [Create ES|QL](https://www.elastic.co/guide/en/security/current/rules-ui-create.html#create-esql-rule) rules for more information.
	Query SecurityDetectionsAPIRuleQuery `json:"query"`

	// References Array containing notes about or references to relevant information about the rule. Defaults to an empty array.
	References          *SecurityDetectionsAPIRuleReferenceArray      `json:"references,omitempty"`
	RelatedIntegrations *SecurityDetectionsAPIRelatedIntegrationArray `json:"related_integrations,omitempty"`

	// RequiredFields Elasticsearch fields and their types that need to be present for the rule to function.
	// > info
	// > The value of `required_fields` does not affect the rules behavior, and specifying it incorrectly wont cause the rule to fail. Use `required_fields` as an informational property to document the fields that the rule expects to be present in the data.
	RequiredFields  *[]SecurityDetectionsAPIRequiredFieldInput `json:"required_fields,omitempty"`
	ResponseActions *[]SecurityDetectionsAPIResponseAction     `json:"response_actions,omitempty"`

	// RiskScore A numerical representation of the alert's severity from 0 to 100, where:
	// * `0` - `21` represents low severity
	// * `22` - `47` represents medium severity
	// * `48` - `73` represents high severity
	// * `74` - `100` represents critical severity
	RiskScore SecurityDetectionsAPIRiskScore `json:"risk_score"`

	// RiskScoreMapping Overrides generated alerts' risk_score with a value from the source event
	RiskScoreMapping *SecurityDetectionsAPIRiskScoreMapping `json:"risk_score_mapping,omitempty"`

	// RuleId A stable unique identifier for the rule object. It can be assigned during rule creation. It can be any string, but often is a UUID. It should be unique not only within a given Kibana space, but also across spaces and Elastic environments. The same prebuilt Elastic rule, when installed in two different Kibana spaces or two different Elastic environments, will have the same `rule_id`s.
	RuleId *SecurityDetectionsAPIRuleSignatureId `json:"rule_id,omitempty"`

	// RuleNameOverride Sets which field in the source event is used to populate the alert's `signal.rule.name` value (in the UI, this value is displayed on the Rules page in the Rule column). When unspecified, the rules `name` value is used. The source field must be a string data type.
	RuleNameOverride *SecurityDetectionsAPIRuleNameOverride `json:"rule_name_override,omitempty"`

	// SavedId Kibana [saved search](https://www.elastic.co/guide/en/kibana/current/save-open-search.html) used by the rule to create alerts.
	SavedId *SecurityDetectionsAPISavedQueryId `json:"saved_id,omitempty"`

	// Setup Populates the rules setup guide with instructions on rule prerequisites such as required integrations, configuration steps, and anything else needed for the rule to work correctly.
	Setup *SecurityDetectionsAPISetupGuide `json:"setup,omitempty"`

	// Severity Severity level of alerts produced by the rule, which must be one of the following:
	// * `low`: Alerts that are of interest but generally not considered to be security incidents
	// * `medium`: Alerts that require investigation
	// * `high`: Alerts that require immediate investigation
	// * `critical`: Alerts that indicate it is highly likely a security incident has occurred
	Severity SecurityDetectionsAPISeverity `json:"severity"`

	// SeverityMapping Overrides generated alerts' severity with values from the source event
	SeverityMapping *SecurityDetectionsAPISeverityMapping `json:"severity_mapping,omitempty"`

	// Tags String array containing words and phrases to help categorize, filter, and search rules. Defaults to an empty array.
	Tags      *SecurityDetectionsAPIRuleTagArray `json:"tags,omitempty"`
	Threat    *SecurityDetectionsAPIThreatArray  `json:"threat,omitempty"`
	Threshold SecurityDetectionsAPIThreshold     `json:"threshold"`

	// Throttle Defines how often rule actions are taken.
	Throttle *SecurityDetectionsAPIRuleActionThrottle `json:"throttle,omitempty"`

	// TimelineId Timeline template ID
	TimelineId *SecurityDetectionsAPITimelineTemplateId `json:"timeline_id,omitempty"`

	// TimelineTitle Timeline template title
	TimelineTitle *SecurityDetectionsAPITimelineTemplateTitle `json:"timeline_title,omitempty"`

	// TimestampOverride Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
	TimestampOverride *SecurityDetectionsAPITimestampOverride `json:"timestamp_override,omitempty"`

	// TimestampOverrideFallbackDisabled Disables the fallback to the event's @timestamp field
	TimestampOverrideFallbackDisabled *SecurityDetectionsAPITimestampOverrideFallbackDisabled `json:"timestamp_override_fallback_disabled,omitempty"`
	To                                *SecurityDetectionsAPIRuleIntervalTo                    `json:"to,omitempty"`

	// Type Rule type
	Type SecurityDetectionsAPIThresholdRuleUpdatePropsType `json:"type"`

	// Version The rule's version number.
	//
	// - For prebuilt rules it represents the version of the rule's content in the source [detection-rules](https://github.com/elastic/detection-rules) repository (and the corresponding `security_detection_engine` Fleet package that is used for distributing prebuilt rules).
	// - For custom rules it is set to `1` when the rule is created.
	// > info
	// > It is not incremented on each update. Compare this to the `revision` field.
	Version *SecurityDetectionsAPIRuleVersion `json:"version,omitempty"`
}

// SecurityDetectionsAPIThresholdRuleUpdatePropsType Rule type
type SecurityDetectionsAPIThresholdRuleUpdatePropsType string

// SecurityDetectionsAPIThresholdValue The threshold value from which an alert is generated.
type SecurityDetectionsAPIThresholdValue = int

// SecurityDetectionsAPITiebreakerField Sets a secondary field for sorting events
type SecurityDetectionsAPITiebreakerField = string

// SecurityDetectionsAPITimelineTemplateId Timeline template ID
type SecurityDetectionsAPITimelineTemplateId = string

// SecurityDetectionsAPITimelineTemplateTitle Timeline template title
type SecurityDetectionsAPITimelineTemplateTitle = string

// SecurityDetectionsAPITimestampField Specifies the name of the event timestamp field used for sorting a sequence of events. Not to be confused with `timestamp_override`, which specifies the more general field used for querying events within a range. Defaults to the @timestamp ECS field.
type SecurityDetectionsAPITimestampField = string

// SecurityDetectionsAPITimestampOverride Sets the time field used to query indices. When unspecified, rules query the `@timestamp` field. The source field must be an Elasticsearch date data type.
type SecurityDetectionsAPITimestampOverride = string

// SecurityDetectionsAPITimestampOverrideFallbackDisabled Disables the fallback to the event's @timestamp field
type SecurityDetectionsAPITimestampOverrideFallbackDisabled = bool

// SecurityDetectionsAPIUUID A universally unique identifier
type SecurityDetectionsAPIUUID = openapi_types.UUID

// SyntheticsGetParameterResponse defines model for Synthetics_getParameterResponse.
type SyntheticsGetParameterResponse struct {
	// Description The description of the parameter. It is included in the response if the user has read-only permissions to the Synthetics app.
	Description *string `json:"description,omitempty"`

	// Id The unique identifier of the parameter.
	Id *string `json:"id,omitempty"`

	// Key The key of the parameter.
	Key *string `json:"key,omitempty"`

	// Namespaces The namespaces associated with the parameter. It is included in the response if the user has read-only permissions to the Synthetics app.
	Namespaces *[]string `json:"namespaces,omitempty"`

	// Tags An array of tags associated with the parameter. It is included in the response if the user has read-only permissions to the Synthetics app.
	Tags *[]string `json:"tags,omitempty"`

	// Value The value associated with the parameter. It will be included in the response if the user has write permissions.
	Value *string `json:"value,omitempty"`
}

// SyntheticsParameterRequest defines model for Synthetics_parameterRequest.
type SyntheticsParameterRequest struct {
	// Description A description of the parameter.
	Description *string `json:"description,omitempty"`

	// Key The key of the parameter.
	Key string `json:"key"`

	// ShareAcrossSpaces Specify whether the parameter should be shared across spaces.
	ShareAcrossSpaces *bool `json:"share_across_spaces,omitempty"`

	// Tags An array of tags to categorize the parameter.
	Tags *[]string `json:"tags,omitempty"`

	// Value The value associated with the parameter.
	Value string `json:"value"`
}

// SyntheticsPostParameterResponse defines model for Synthetics_postParameterResponse.
type SyntheticsPostParameterResponse struct {
	// Description A description of the parameter.
	Description *string `json:"description,omitempty"`

	// Id The unique identifier for the parameter.
	Id *string `json:"id,omitempty"`

	// Key The parameter key.
	Key *string `json:"key,omitempty"`

	// ShareAcrossSpaces Indicates whether the parameter is shared across spaces.
	ShareAcrossSpaces *bool `json:"share_across_spaces,omitempty"`

	// Tags An array of tags associated with the parameter.
	Tags *[]string `json:"tags,omitempty"`

	// Value The value associated with the parameter.
	Value *string `json:"value,omitempty"`
}

// AgentPolicy defines model for agent_policy.
type AgentPolicy struct {
	AdvancedSettings *struct {
		AgentDownloadTargetDirectory       interface{} `json:"agent_download_target_directory,omitempty"`
		AgentDownloadTimeout               interface{} `json:"agent_download_timeout,omitempty"`
		AgentLimitsGoMaxProcs              interface{} `json:"agent_limits_go_max_procs,omitempty"`
		AgentLoggingFilesInterval          interface{} `json:"agent_logging_files_interval,omitempty"`
		AgentLoggingFilesKeepfiles         interface{} `json:"agent_logging_files_keepfiles,omitempty"`
		AgentLoggingFilesRotateeverybytes  interface{} `json:"agent_logging_files_rotateeverybytes,omitempty"`
		AgentLoggingLevel                  interface{} `json:"agent_logging_level,omitempty"`
		AgentLoggingMetricsPeriod          interface{} `json:"agent_logging_metrics_period,omitempty"`
		AgentLoggingToFiles                interface{} `json:"agent_logging_to_files,omitempty"`
		AgentMonitoringRuntimeExperimental interface{} `json:"agent_monitoring_runtime_experimental,omitempty"`
	} `json:"advanced_settings,omitempty"`
	AgentFeatures *[]struct {
		Enabled bool   `json:"enabled"`
		Name    string `json:"name"`
	} `json:"agent_features,omitempty"`
	Agentless *struct {
		CloudConnectors *struct {
			Enabled   bool    `json:"enabled"`
			TargetCsp *string `json:"target_csp,omitempty"`
		} `json:"cloud_connectors,omitempty"`
		Resources *struct {
			Requests *struct {
				Cpu    *string `json:"cpu,omitempty"`
				Memory *string `json:"memory,omitempty"`
			} `json:"requests,omitempty"`
		} `json:"resources,omitempty"`
	} `json:"agentless,omitempty"`
	Agents            *float32 `json:"agents,omitempty"`
	DataOutputId      *string  `json:"data_output_id,omitempty"`
	Description       *string  `json:"description,omitempty"`
	DownloadSourceId  *string  `json:"download_source_id,omitempty"`
	FleetServerHostId *string  `json:"fleet_server_host_id,omitempty"`

	// GlobalDataTags User defined data tags that are added to all of the inputs. The values can be strings or numbers.
	GlobalDataTags       *[]AgentPolicyGlobalDataTagsItem `json:"global_data_tags,omitempty"`
	HasFleetServer       *bool                            `json:"has_fleet_server,omitempty"`
	Id                   string                           `json:"id"`
	InactivityTimeout    *float32                         `json:"inactivity_timeout,omitempty"`
	IsDefault            *bool                            `json:"is_default,omitempty"`
	IsDefaultFleetServer *bool                            `json:"is_default_fleet_server,omitempty"`
	IsManaged            bool                             `json:"is_managed"`
	IsPreconfigured      *bool                            `json:"is_preconfigured,omitempty"`

	// IsProtected Indicates whether the agent policy has tamper protection enabled. Default false.
	IsProtected bool `json:"is_protected"`

	// KeepMonitoringAlive When set to true, monitoring will be enabled but logs/metrics collection will be disabled
	KeepMonitoringAlive   *bool `json:"keep_monitoring_alive,omitempty"`
	MonitoringDiagnostics *struct {
		Limit *struct {
			Burst    *float32 `json:"burst,omitempty"`
			Interval *string  `json:"interval,omitempty"`
		} `json:"limit,omitempty"`
		Uploader *struct {
			InitDur    *string  `json:"init_dur,omitempty"`
			MaxDur     *string  `json:"max_dur,omitempty"`
			MaxRetries *float32 `json:"max_retries,omitempty"`
		} `json:"uploader,omitempty"`
	} `json:"monitoring_diagnostics,omitempty"`
	MonitoringEnabled *[]AgentPolicyMonitoringEnabled `json:"monitoring_enabled,omitempty"`
	MonitoringHttp    *struct {
		Buffer *struct {
			Enabled *bool `json:"enabled,omitempty"`
		} `json:"buffer,omitempty"`
		Enabled *bool    `json:"enabled,omitempty"`
		Host    *string  `json:"host,omitempty"`
		Port    *float32 `json:"port,omitempty"`
	} `json:"monitoring_http,omitempty"`
	MonitoringOutputId     *string `json:"monitoring_output_id,omitempty"`
	MonitoringPprofEnabled *bool   `json:"monitoring_pprof_enabled,omitempty"`
	Name                   string  `json:"name"`
	Namespace              string  `json:"namespace"`

	// Overrides Override settings that are defined in the agent policy. Input settings cannot be overridden. The override option should be used only in unusual circumstances and not as a routine procedure.
	Overrides        *map[string]interface{}      `json:"overrides,omitempty"`
	PackagePolicies  *AgentPolicy_PackagePolicies `json:"package_policies,omitempty"`
	RequiredVersions *[]struct {
		// Percentage Target percentage of agents to auto upgrade
		Percentage float32 `json:"percentage"`

		// Version Target version for automatic agent upgrade
		Version string `json:"version"`
	} `json:"required_versions,omitempty"`
	Revision      float32           `json:"revision"`
	SchemaVersion *string           `json:"schema_version,omitempty"`
	SpaceIds      *[]string         `json:"space_ids,omitempty"`
	Status        AgentPolicyStatus `json:"status"`

	// SupportsAgentless Indicates whether the agent policy supports agentless integrations.
	SupportsAgentless  *bool    `json:"supports_agentless,omitempty"`
	UnenrollTimeout    *float32 `json:"unenroll_timeout,omitempty"`
	UnprivilegedAgents *float32 `json:"unprivileged_agents,omitempty"`
	UpdatedAt          string   `json:"updated_at"`
	UpdatedBy          string   `json:"updated_by"`
	Version            *string  `json:"version,omitempty"`
}

// AgentPolicyMonitoringEnabled defines model for AgentPolicy.MonitoringEnabled.
type AgentPolicyMonitoringEnabled string

// AgentPolicyPackagePolicies0 defines model for .
type AgentPolicyPackagePolicies0 = []string

// AgentPolicyPackagePolicies1 This field is present only when retrieving a single agent policy, or when retrieving a list of agent policies with the ?full=true parameter
type AgentPolicyPackagePolicies1 = []struct {
	// AdditionalDatastreamsPermissions Additional datastream permissions, that will be added to the agent policy.
	AdditionalDatastreamsPermissions *[]string `json:"additional_datastreams_permissions,omitempty"`
	Agents                           *float32  `json:"agents,omitempty"`
	CreatedAt                        string    `json:"created_at"`
	CreatedBy                        string    `json:"created_by"`

	// Description Package policy description
	Description   *string                                      `json:"description,omitempty"`
	Elasticsearch *AgentPolicy_PackagePolicies_1_Elasticsearch `json:"elasticsearch,omitempty"`
	Enabled       bool                                         `json:"enabled"`
	Id            string                                       `json:"id"`
	Inputs        AgentPolicy_PackagePolicies_1_Inputs         `json:"inputs"`
	IsManaged     *bool                                        `json:"is_managed,omitempty"`

	// Name Package policy name (should be unique)
	Name string `json:"name"`

	// Namespace The package policy namespace. Leave blank to inherit the agent policy's namespace.
	Namespace *string `json:"namespace,omitempty"`
	OutputId  *string `json:"output_id,omitempty"`

	// Overrides Override settings that are defined in the package policy. The override option should be used only in unusual circumstances and not as a routine procedure.
	Overrides *struct {
		Inputs *map[string]interface{} `json:"inputs,omitempty"`
	} `json:"overrides,omitempty"`
	Package *struct {
		ExperimentalDataStreamFeatures *[]struct {
			DataStream string `json:"data_stream"`
			Features   struct {
				DocValueOnlyNumeric *bool `json:"doc_value_only_numeric,omitempty"`
				DocValueOnlyOther   *bool `json:"doc_value_only_other,omitempty"`
				SyntheticSource     *bool `json:"synthetic_source,omitempty"`
				Tsdb                *bool `json:"tsdb,omitempty"`
			} `json:"features"`
		} `json:"experimental_data_stream_features,omitempty"`

		// Name Package name
		Name         string  `json:"name"`
		RequiresRoot *bool   `json:"requires_root,omitempty"`
		Title        *string `json:"title,omitempty"`

		// Version Package version
		Version string `json:"version"`
	} `json:"package,omitempty"`

	// PolicyId Agent policy ID where that package policy will be added
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	PolicyId         *string   `json:"policy_id,omitempty"`
	PolicyIds        *[]string `json:"policy_ids,omitempty"`
	Revision         float32   `json:"revision"`
	SecretReferences *[]struct {
		Id string `json:"id"`
	} `json:"secret_references,omitempty"`
	SpaceIds *[]string `json:"spaceIds,omitempty"`

	// SupportsAgentless Indicates whether the package policy belongs to an agentless agent policy.
	SupportsAgentless *bool                               `json:"supports_agentless,omitempty"`
	UpdatedAt         string                              `json:"updated_at"`
	UpdatedBy         string                              `json:"updated_by"`
	Vars              *AgentPolicy_PackagePolicies_1_Vars `json:"vars,omitempty"`
	Version           *string                             `json:"version,omitempty"`
}

// AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges defines model for AgentPolicy.PackagePolicies.1.Elasticsearch.Privileges.
type AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges struct {
	Cluster              *[]string              `json:"cluster,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// AgentPolicy_PackagePolicies_1_Elasticsearch defines model for AgentPolicy.PackagePolicies.1.Elasticsearch.
type AgentPolicy_PackagePolicies_1_Elasticsearch struct {
	Privileges           *AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges `json:"privileges,omitempty"`
	AdditionalProperties map[string]interface{}                                  `json:"-"`
}

// AgentPolicyPackagePolicies1Inputs0 defines model for .
type AgentPolicyPackagePolicies1Inputs0 = []struct {
	CompiledInput interface{} `json:"compiled_input"`

	// Config Package variable (see integration documentation for more information)
	Config *map[string]struct {
		Frozen *bool       `json:"frozen,omitempty"`
		Type   *string     `json:"type,omitempty"`
		Value  interface{} `json:"value"`
	} `json:"config,omitempty"`
	Enabled        bool    `json:"enabled"`
	Id             *string `json:"id,omitempty"`
	KeepEnabled    *bool   `json:"keep_enabled,omitempty"`
	PolicyTemplate *string `json:"policy_template,omitempty"`
	Streams        []struct {
		CompiledStream interface{} `json:"compiled_stream"`

		// Config Package variable (see integration documentation for more information)
		Config *map[string]struct {
			Frozen *bool       `json:"frozen,omitempty"`
			Type   *string     `json:"type,omitempty"`
			Value  interface{} `json:"value"`
		} `json:"config,omitempty"`
		DataStream struct {
			Dataset       string `json:"dataset"`
			Elasticsearch *struct {
				DynamicDataset   *bool `json:"dynamic_dataset,omitempty"`
				DynamicNamespace *bool `json:"dynamic_namespace,omitempty"`
				Privileges       *struct {
					Indices *[]string `json:"indices,omitempty"`
				} `json:"privileges,omitempty"`
			} `json:"elasticsearch,omitempty"`
			Type string `json:"type"`
		} `json:"data_stream"`
		Enabled     bool                                              `json:"enabled"`
		Id          *string                                           `json:"id,omitempty"`
		KeepEnabled *bool                                             `json:"keep_enabled,omitempty"`
		Release     *AgentPolicyPackagePolicies1Inputs0StreamsRelease `json:"release,omitempty"`

		// Vars Package variable (see integration documentation for more information)
		Vars *map[string]struct {
			Frozen *bool       `json:"frozen,omitempty"`
			Type   *string     `json:"type,omitempty"`
			Value  interface{} `json:"value"`
		} `json:"vars,omitempty"`
	} `json:"streams"`
	Type string `json:"type"`

	// Vars Package variable (see integration documentation for more information)
	Vars *map[string]struct {
		Frozen *bool       `json:"frozen,omitempty"`
		Type   *string     `json:"type,omitempty"`
		Value  interface{} `json:"value"`
	} `json:"vars,omitempty"`
}

// AgentPolicyPackagePolicies1Inputs0StreamsRelease defines model for AgentPolicy.PackagePolicies.1.Inputs.0.Streams.Release.
type AgentPolicyPackagePolicies1Inputs0StreamsRelease string

// AgentPolicyPackagePolicies1Inputs1 Package policy inputs (see integration documentation to know what inputs are available)
type AgentPolicyPackagePolicies1Inputs1 map[string]struct {
	// Enabled enable or disable that input, (default to true)
	Enabled *bool `json:"enabled,omitempty"`

	// Streams Input streams (see integration documentation to know what streams are available)
	Streams *map[string]struct {
		// Enabled enable or disable that stream, (default to true)
		Enabled *bool `json:"enabled,omitempty"`

		// Vars Input/stream level variable (see integration documentation for more information)
		Vars *map[string]*AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties `json:"vars,omitempty"`
	} `json:"streams,omitempty"`

	// Vars Input/stream level variable (see integration documentation for more information)
	Vars *map[string]*AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties `json:"vars,omitempty"`
}

// AgentPolicyPackagePolicies1Inputs1StreamsVars0 defines model for .
type AgentPolicyPackagePolicies1Inputs1StreamsVars0 = bool

// AgentPolicyPackagePolicies1Inputs1StreamsVars1 defines model for .
type AgentPolicyPackagePolicies1Inputs1StreamsVars1 = string

// AgentPolicyPackagePolicies1Inputs1StreamsVars2 defines model for .
type AgentPolicyPackagePolicies1Inputs1StreamsVars2 = float32

// AgentPolicyPackagePolicies1Inputs1StreamsVars3 defines model for .
type AgentPolicyPackagePolicies1Inputs1StreamsVars3 = []string

// AgentPolicyPackagePolicies1Inputs1StreamsVars4 defines model for .
type AgentPolicyPackagePolicies1Inputs1StreamsVars4 = []float32

// AgentPolicyPackagePolicies1Inputs1StreamsVars5 defines model for .
type AgentPolicyPackagePolicies1Inputs1StreamsVars5 struct {
	Id          string `json:"id"`
	IsSecretRef bool   `json:"isSecretRef"`
}

// AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties defines model for AgentPolicy.PackagePolicies.1.Inputs.1.Streams.Vars.AdditionalProperties.
type AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties struct {
	union json.RawMessage
}

// AgentPolicyPackagePolicies1Inputs1Vars0 defines model for .
type AgentPolicyPackagePolicies1Inputs1Vars0 = bool

// AgentPolicyPackagePolicies1Inputs1Vars1 defines model for .
type AgentPolicyPackagePolicies1Inputs1Vars1 = string

// AgentPolicyPackagePolicies1Inputs1Vars2 defines model for .
type AgentPolicyPackagePolicies1Inputs1Vars2 = float32

// AgentPolicyPackagePolicies1Inputs1Vars3 defines model for .
type AgentPolicyPackagePolicies1Inputs1Vars3 = []string

// AgentPolicyPackagePolicies1Inputs1Vars4 defines model for .
type AgentPolicyPackagePolicies1Inputs1Vars4 = []float32

// AgentPolicyPackagePolicies1Inputs1Vars5 defines model for .
type AgentPolicyPackagePolicies1Inputs1Vars5 struct {
	Id          string `json:"id"`
	IsSecretRef bool   `json:"isSecretRef"`
}

// AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties defines model for AgentPolicy.PackagePolicies.1.Inputs.1.Vars.AdditionalProperties.
type AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties struct {
	union json.RawMessage
}

// AgentPolicy_PackagePolicies_1_Inputs defines model for AgentPolicy.PackagePolicies.1.Inputs.
type AgentPolicy_PackagePolicies_1_Inputs struct {
	union json.RawMessage
}

// AgentPolicyPackagePolicies1Vars0 Package variable (see integration documentation for more information)
type AgentPolicyPackagePolicies1Vars0 map[string]struct {
	Frozen *bool       `json:"frozen,omitempty"`
	Type   *string     `json:"type,omitempty"`
	Value  interface{} `json:"value"`
}

// AgentPolicyPackagePolicies1Vars1 Input/stream level variable (see integration documentation for more information)
type AgentPolicyPackagePolicies1Vars1 map[string]*AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties

// AgentPolicyPackagePolicies1Vars10 defines model for .
type AgentPolicyPackagePolicies1Vars10 = bool

// AgentPolicyPackagePolicies1Vars11 defines model for .
type AgentPolicyPackagePolicies1Vars11 = string

// AgentPolicyPackagePolicies1Vars12 defines model for .
type AgentPolicyPackagePolicies1Vars12 = float32

// AgentPolicyPackagePolicies1Vars13 defines model for .
type AgentPolicyPackagePolicies1Vars13 = []string

// AgentPolicyPackagePolicies1Vars14 defines model for .
type AgentPolicyPackagePolicies1Vars14 = []float32

// AgentPolicyPackagePolicies1Vars15 defines model for .
type AgentPolicyPackagePolicies1Vars15 struct {
	Id          string `json:"id"`
	IsSecretRef bool   `json:"isSecretRef"`
}

// AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties defines model for AgentPolicy.PackagePolicies.1.Vars.1.AdditionalProperties.
type AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties struct {
	union json.RawMessage
}

// AgentPolicy_PackagePolicies_1_Vars defines model for AgentPolicy.PackagePolicies.1.Vars.
type AgentPolicy_PackagePolicies_1_Vars struct {
	union json.RawMessage
}

// AgentPolicy_PackagePolicies defines model for AgentPolicy.PackagePolicies.
type AgentPolicy_PackagePolicies struct {
	union json.RawMessage
}

// AgentPolicyStatus defines model for AgentPolicy.Status.
type AgentPolicyStatus string

// AgentPolicyGlobalDataTagsItem defines model for agent_policy_global_data_tags_item.
type AgentPolicyGlobalDataTagsItem struct {
	Name  string                              `json:"name"`
	Value AgentPolicyGlobalDataTagsItem_Value `json:"value"`
}

// AgentPolicyGlobalDataTagsItemValue0 defines model for .
type AgentPolicyGlobalDataTagsItemValue0 = string

// AgentPolicyGlobalDataTagsItemValue1 defines model for .
type AgentPolicyGlobalDataTagsItemValue1 = float32

// AgentPolicyGlobalDataTagsItem_Value defines model for AgentPolicyGlobalDataTagsItem.Value.
type AgentPolicyGlobalDataTagsItem_Value struct {
	union json.RawMessage
}

// AuthType The type of authentication to use: basic, SSL, or none.
type AuthType string

// BedrockConfig Defines properties for connectors when type is `.bedrock`.
type BedrockConfig struct {
	// ApiUrl The Amazon Bedrock request URL.
	ApiUrl string `json:"apiUrl"`

	// DefaultModel The generative artificial intelligence model for Amazon Bedrock to use. Current support is for the Anthropic Claude models.
	DefaultModel *string `json:"defaultModel,omitempty"`
}

// BedrockSecrets Defines secrets for connectors when type is `.bedrock`.
type BedrockSecrets struct {
	// AccessKey The AWS access key for authentication.
	AccessKey string `json:"accessKey"`

	// Secret The AWS secret for authentication.
	Secret string `json:"secret"`
}

// Ca A base64 encoded version of the certificate authority file that the connector can trust to sign and validate certificates. This option is available for all authentication types.
type Ca = string

// CasesWebhookConfig Defines properties for connectors when type is `.cases-webhook`.
type CasesWebhookConfig struct {
	// AuthType The type of authentication to use: basic, SSL, or none.
	AuthType *AuthType `json:"authType,omitempty"`

	// Ca A base64 encoded version of the certificate authority file that the connector can trust to sign and validate certificates. This option is available for all authentication types.
	Ca *Ca `json:"ca,omitempty"`

	// CertType If the `authType` is `webhook-authentication-ssl`, specifies whether the certificate authentication data is in a CRT and key file format or a PFX file format.
	CertType *CertType `json:"certType,omitempty"`

	// CreateCommentJson A JSON payload sent to the create comment URL to create a case comment. You can use variables to add Kibana Cases data to the payload. The required variable is `case.comment`. Due to Mustache template variables (the text enclosed in triple braces, for example, `{{{case.title}}}`), the JSON is not validated when you create the connector. The JSON is validated once the Mustache variables have been placed when the REST method runs. Manually ensure that the JSON is valid, disregarding the Mustache variables, so the later validation will pass.
	CreateCommentJson *string `json:"createCommentJson,omitempty"`

	// CreateCommentMethod The REST API HTTP request method to create a case comment in the third-party system. Valid values are `patch`, `post`, and `put`.
	CreateCommentMethod *CasesWebhookConfigCreateCommentMethod `json:"createCommentMethod,omitempty"`

	// CreateCommentUrl The REST API URL to create a case comment by ID in the third-party system. You can use a variable to add the external system ID to the URL. If you are using the `xpack.actions.allowedHosts setting`, add the hostname to the allowed hosts.
	CreateCommentUrl *string `json:"createCommentUrl,omitempty"`

	// CreateIncidentJson A JSON payload sent to the create case URL to create a case. You can use variables to add case data to the payload. Required variables are `case.title` and `case.description`. Due to Mustache template variables (which is the text enclosed in triple braces, for example, `{{{case.title}}}`), the JSON is not validated when you create the connector. The JSON is validated after the Mustache variables have been placed when REST method runs. Manually ensure that the JSON is valid to avoid future validation errors; disregard Mustache variables during your review.
	CreateIncidentJson string `json:"createIncidentJson"`

	// CreateIncidentMethod The REST API HTTP request method to create a case in the third-party system. Valid values are `patch`, `post`, and `put`.
	CreateIncidentMethod *CasesWebhookConfigCreateIncidentMethod `json:"createIncidentMethod,omitempty"`

	// CreateIncidentResponseKey The JSON key in the create external case response that contains the case ID.
	CreateIncidentResponseKey string `json:"createIncidentResponseKey"`

	// CreateIncidentUrl The REST API URL to create a case in the third-party system. If you are using the `xpack.actions.allowedHosts` setting, add the hostname to the allowed hosts.
	CreateIncidentUrl string `json:"createIncidentUrl"`

	// GetIncidentResponseExternalTitleKey The JSON key in get external case response that contains the case title.
	GetIncidentResponseExternalTitleKey string `json:"getIncidentResponseExternalTitleKey"`

	// GetIncidentUrl The REST API URL to get the case by ID from the third-party system. If you are using the `xpack.actions.allowedHosts` setting, add the hostname to the allowed hosts. You can use a variable to add the external system ID to the URL. Due to Mustache template variables (the text enclosed in triple braces, for example, `{{{case.title}}}`), the JSON is not validated when you create the connector. The JSON is validated after the Mustache variables have been placed when REST method runs. Manually ensure that the JSON is valid, disregarding the Mustache variables, so the later validation will pass.
	GetIncidentUrl string `json:"getIncidentUrl"`

	// HasAuth If true, a username and password for login type authentication must be provided.
	HasAuth *HasAuth `json:"hasAuth,omitempty"`

	// Headers A set of key-value pairs sent as headers with the request URLs for the create case, update case, get case, and create comment methods.
	Headers *string `json:"headers,omitempty"`

	// UpdateIncidentJson The JSON payload sent to the update case URL to update the case. You can use variables to add Kibana Cases data to the payload. Required variables are `case.title` and `case.description`. Due to Mustache template variables (which is the text enclosed in triple braces, for example, `{{{case.title}}}`), the JSON is not validated when you create the connector. The JSON is validated after the Mustache variables have been placed when REST method runs. Manually ensure that the JSON is valid to avoid future validation errors; disregard Mustache variables during your review.
	UpdateIncidentJson string `json:"updateIncidentJson"`

	// UpdateIncidentMethod The REST API HTTP request method to update the case in the third-party system. Valid values are `patch`, `post`, and `put`.
	UpdateIncidentMethod *CasesWebhookConfigUpdateIncidentMethod `json:"updateIncidentMethod,omitempty"`

	// UpdateIncidentUrl The REST API URL to update the case by ID in the third-party system. You can use a variable to add the external system ID to the URL. If you are using the `xpack.actions.allowedHosts` setting, add the hostname to the allowed hosts.
	UpdateIncidentUrl string `json:"updateIncidentUrl"`

	// VerificationMode Controls the verification of certificates. Use `full` to validate that the certificate has an issue date within the `not_before` and `not_after` dates, chains to a trusted certificate authority (CA), and has a hostname or IP address that matches the names within the certificate. Use `certificate` to validate the certificate and verify that it is signed by a trusted authority; this option does not check the certificate hostname. Use `none` to skip certificate validation.
	VerificationMode *VerificationMode `json:"verificationMode,omitempty"`

	// ViewIncidentUrl The URL to view the case in the external system. You can use variables to add the external system ID or external system title to the URL.
	ViewIncidentUrl string `json:"viewIncidentUrl"`
}

// CasesWebhookConfigCreateCommentMethod The REST API HTTP request method to create a case comment in the third-party system. Valid values are `patch`, `post`, and `put`.
type CasesWebhookConfigCreateCommentMethod string

// CasesWebhookConfigCreateIncidentMethod The REST API HTTP request method to create a case in the third-party system. Valid values are `patch`, `post`, and `put`.
type CasesWebhookConfigCreateIncidentMethod string

// CasesWebhookConfigUpdateIncidentMethod The REST API HTTP request method to update the case in the third-party system. Valid values are `patch`, `post`, and `put`.
type CasesWebhookConfigUpdateIncidentMethod string

// CasesWebhookSecrets defines model for cases_webhook_secrets.
type CasesWebhookSecrets struct {
	// Crt If `authType` is `webhook-authentication-ssl` and `certType` is `ssl-crt-key`, it is a base64 encoded version of the CRT or CERT file.
	Crt *Crt `json:"crt,omitempty"`

	// Key If `authType` is `webhook-authentication-ssl` and `certType` is `ssl-crt-key`, it is a base64 encoded version of the KEY file.
	Key *Key `json:"key,omitempty"`

	// Password The password for HTTP basic authentication. If `hasAuth` is set to `true` and and `authType` is `webhook-authentication-basic`, this property is required.
	Password *string `json:"password,omitempty"`

	// Pfx If `authType` is `webhook-authentication-ssl` and `certType` is `ssl-pfx`, it is a base64 encoded version of the PFX or P12 file.
	Pfx *Pfx `json:"pfx,omitempty"`

	// User The username for HTTP basic authentication. If `hasAuth` is set to `true` and `authType` is `webhook-authentication-basic`, this property is required.
	User *string `json:"user,omitempty"`
}

// CertType If the `authType` is `webhook-authentication-ssl`, specifies whether the certificate authentication data is in a CRT and key file format or a PFX file format.
type CertType string

// ConnectorResponse defines model for connector_response.
type ConnectorResponse struct {
	Config *map[string]interface{} `json:"config,omitempty"`

	// ConnectorTypeId The connector type identifier.
	ConnectorTypeId string `json:"connector_type_id"`

	// Id The identifier for the connector.
	Id string `json:"id"`

	// IsDeprecated Indicates whether the connector is deprecated.
	IsDeprecated bool `json:"is_deprecated"`

	// IsMissingSecrets Indicates whether the connector is missing secrets.
	IsMissingSecrets *bool `json:"is_missing_secrets,omitempty"`

	// IsPreconfigured Indicates whether the connector is preconfigured. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
	IsPreconfigured bool `json:"is_preconfigured"`

	// IsSystemAction Indicates whether the connector is used for system actions.
	IsSystemAction bool `json:"is_system_action"`

	// Name  The name of the rule.
	Name string `json:"name"`
}

// CreateConnectorConfig The connector configuration details.
type CreateConnectorConfig struct {
	AdditionalProperties map[string]interface{} `json:"-"`
	union                json.RawMessage
}

// CreateConnectorSecrets defines model for create_connector_secrets.
type CreateConnectorSecrets struct {
	AdditionalProperties map[string]interface{} `json:"-"`
	union                json.RawMessage
}

// CreateParamResponse defines model for create_param_response.
type CreateParamResponse struct {
	union json.RawMessage
}

// CreateParamResponse0 defines model for .
type CreateParamResponse0 = []SyntheticsPostParameterResponse

// CrowdstrikeConfig Defines config properties for connectors when type is `.crowdstrike`.
type CrowdstrikeConfig struct {
	// Url The CrowdStrike tenant URL. If you are using the `xpack.actions.allowedHosts` setting, add the hostname to the allowed hosts.
	Url string `json:"url"`
}

// CrowdstrikeSecrets Defines secrets for connectors when type is `.crowdstrike`.
type CrowdstrikeSecrets struct {
	// ClientId The CrowdStrike API client identifier.
	ClientId string `json:"clientId"`

	// ClientSecret The CrowdStrike API client secret to authenticate the `clientId`.
	ClientSecret string `json:"clientSecret"`
}

// Crt If `authType` is `webhook-authentication-ssl` and `certType` is `ssl-crt-key`, it is a base64 encoded version of the CRT or CERT file.
type Crt = string

// D3securityConfig Defines properties for connectors when type is `.d3security`.
type D3securityConfig struct {
	// Url The D3 Security API request URL. If you are using the `xpack.actions.allowedHosts` setting, add the hostname to the allowed hosts.
	Url string `json:"url"`
}

// D3securitySecrets Defines secrets for connectors when type is `.d3security`.
type D3securitySecrets struct {
	// Token The D3 Security token.
	Token string `json:"token"`
}

// DefenderConfig Defines properties for connectors when type is `.microsoft_defender_endpoint`.
type DefenderConfig struct {
	// ApiUrl The URL of the Microsoft Defender for Endpoint API. If you are using the `xpack.actions.allowedHosts` setting, make sure the hostname is added to the allowed hosts.
	ApiUrl string `json:"apiUrl"`

	// ClientId The application (client) identifier for your app in the Azure portal.
	ClientId *string `json:"clientId,omitempty"`

	// OAuthScope The OAuth scopes or permission sets for the Microsoft Defender for Endpoint API.
	OAuthScope *string `json:"oAuthScope,omitempty"`

	// OAuthServerUrl The OAuth server URL where authentication is sent and received for the Microsoft Defender for Endpoint API.
	OAuthServerUrl *string `json:"oAuthServerUrl,omitempty"`

	// TenantId The tenant identifier for your app in the Azure portal.
	TenantId *string `json:"tenantId,omitempty"`
}

// DefenderSecrets Defines secrets for connectors when type is `..microsoft_defender_endpoint`.
type DefenderSecrets struct {
	// ClientSecret The client secret for your app in the Azure portal.
	ClientSecret string `json:"clientSecret"`
}

// EmailConfig Defines properties for connectors when type is `.email`.
type EmailConfig struct {
	// ClientId The client identifier, which is a part of OAuth 2.0 client credentials authentication, in GUID format. If `service` is `exchange_server`, this property is required.
	ClientId *string `json:"clientId,omitempty"`

	// From The from address for all emails sent by the connector. It must be specified in `user@host-name` format.
	From string `json:"from"`

	// HasAuth Specifies whether a user and password are required inside the secrets configuration.
	HasAuth *bool `json:"hasAuth,omitempty"`

	// Host The host name of the service provider. If the `service` is `elastic_cloud` (for Elastic Cloud notifications) or one of Nodemailer's well-known email service providers, this property is ignored. If `service` is `other`, this property must be defined.
	Host          *string `json:"host,omitempty"`
	OauthTokenUrl *string `json:"oauthTokenUrl,omitempty"`

	// Port The port to connect to on the service provider. If the `service` is `elastic_cloud` (for Elastic Cloud notifications) or one of Nodemailer's well-known email service providers, this property is ignored. If `service` is `other`, this property must be defined.
	Port *int `json:"port,omitempty"`

	// Secure Specifies whether the connection to the service provider will use TLS. If the `service` is `elastic_cloud` (for Elastic Cloud notifications) or one of Nodemailer's well-known email service providers, this property is ignored.
	Secure *bool `json:"secure,omitempty"`

	// Service The name of the email service.
	Service *EmailConfigService `json:"service,omitempty"`

	// TenantId The tenant identifier, which is part of OAuth 2.0 client credentials authentication, in GUID format. If `service` is `exchange_server`, this property is required.
	TenantId *string `json:"tenantId,omitempty"`
}

// EmailConfigService The name of the email service.
type EmailConfigService string

// EmailSecrets Defines secrets for connectors when type is `.email`.
type EmailSecrets struct {
	// ClientSecret The Microsoft Exchange Client secret for OAuth 2.0 client credentials authentication. It must be URL-encoded. If `service` is `exchange_server`, this property is required.
	ClientSecret *string `json:"clientSecret,omitempty"`

	// Password The password for HTTP basic authentication. If `hasAuth` is set to `true`, this property is required.
	Password *string `json:"password,omitempty"`

	// User The username for HTTP basic authentication. If `hasAuth` is set to `true`, this property is required.
	User *string `json:"user,omitempty"`
}

// EnrollmentApiKey defines model for enrollment_api_key.
type EnrollmentApiKey struct {
	// Active When false, the enrollment API key is revoked and cannot be used for enrolling Elastic Agents.
	Active bool `json:"active"`

	// ApiKey The enrollment API key (token) used for enrolling Elastic Agents.
	ApiKey string `json:"api_key"`

	// ApiKeyId The ID of the API key in the Security API.
	ApiKeyId  string `json:"api_key_id"`
	CreatedAt string `json:"created_at"`
	Hidden    *bool  `json:"hidden,omitempty"`
	Id        string `json:"id"`

	// Name The name of the enrollment API key.
	Name *string `json:"name,omitempty"`

	// PolicyId The ID of the agent policy the Elastic Agent will be enrolled in.
	PolicyId *string `json:"policy_id,omitempty"`
}

// GeminiConfig Defines properties for connectors when type is `.gemini`.
type GeminiConfig struct {
	// ApiUrl The Google Gemini request URL.
	ApiUrl string `json:"apiUrl"`

	// DefaultModel The generative artificial intelligence model for Google Gemini to use.
	DefaultModel *string `json:"defaultModel,omitempty"`

	// GcpProjectID The Google ProjectID that has Vertex AI endpoint enabled.
	GcpProjectID string `json:"gcpProjectID"`

	// GcpRegion The GCP region where the Vertex AI endpoint enabled.
	GcpRegion string `json:"gcpRegion"`
}

// GeminiSecrets Defines secrets for connectors when type is `.gemini`.
type GeminiSecrets struct {
	// CredentialsJson The service account credentials JSON file. The service account should have Vertex AI user IAM role assigned to it.
	CredentialsJson string `json:"credentialsJson"`
}

// GenaiAzureConfig Defines properties for connectors when type is `.gen-ai` and the API provider is `Azure OpenAI`.
type GenaiAzureConfig struct {
	// ApiProvider The OpenAI API provider.
	ApiProvider GenaiAzureConfigApiProvider `json:"apiProvider"`

	// ApiUrl The OpenAI API endpoint.
	ApiUrl string `json:"apiUrl"`
}

// GenaiAzureConfigApiProvider The OpenAI API provider.
type GenaiAzureConfigApiProvider string

// GenaiOpenaiConfig Defines properties for connectors when type is `.gen-ai` and the API provider is `OpenAI`.
type GenaiOpenaiConfig struct {
	// ApiProvider The OpenAI API provider.
	ApiProvider GenaiOpenaiConfigApiProvider `json:"apiProvider"`

	// ApiUrl The OpenAI API endpoint.
	ApiUrl string `json:"apiUrl"`

	// DefaultModel The default model to use for requests.
	DefaultModel *string `json:"defaultModel,omitempty"`
}

// GenaiOpenaiConfigApiProvider The OpenAI API provider.
type GenaiOpenaiConfigApiProvider string

// GenaiOpenaiOtherConfig Defines properties for connectors when type is `.gen-ai` and the API provider is `Other` (OpenAI-compatible service), including optional PKI authentication.
type GenaiOpenaiOtherConfig struct {
	// ApiProvider The OpenAI API provider.
	ApiProvider GenaiOpenaiOtherConfigApiProvider `json:"apiProvider"`

	// ApiUrl The OpenAI-compatible API endpoint.
	ApiUrl string `json:"apiUrl"`

	// CaData PEM-encoded CA certificate content.
	CaData *string `json:"caData,omitempty"`

	// CertificateData PEM-encoded certificate content.
	CertificateData *string `json:"certificateData,omitempty"`

	// DefaultModel The default model to use for requests.
	DefaultModel string `json:"defaultModel"`

	// Headers Custom headers to include in requests.
	Headers *map[string]string `json:"headers,omitempty"`

	// PrivateKeyData PEM-encoded private key content.
	PrivateKeyData *string `json:"privateKeyData,omitempty"`

	// VerificationMode SSL verification mode for PKI authentication.
	VerificationMode *GenaiOpenaiOtherConfigVerificationMode `json:"verificationMode,omitempty"`
}

// GenaiOpenaiOtherConfigApiProvider The OpenAI API provider.
type GenaiOpenaiOtherConfigApiProvider string

// GenaiOpenaiOtherConfigVerificationMode SSL verification mode for PKI authentication.
type GenaiOpenaiOtherConfigVerificationMode string

// GenaiSecrets Defines secrets for connectors when type is `.gen-ai`. Supports both API key authentication (OpenAI, Azure OpenAI, and `Other`) and PKI authentication (`Other` provider only). PKI fields must be base64-encoded PEM content.
type GenaiSecrets struct {
	// ApiKey The API key for authentication. For OpenAI and Azure OpenAI providers, it is required. For the `Other` provider, it is required if you do not use PKI authentication. With PKI, you can also optionally include an API key if the OpenAI-compatible service supports or requires one.
	ApiKey *string `json:"apiKey,omitempty"`

	// CaData Base64-encoded PEM CA certificate content for PKI authentication (Other provider only). Optional.
	CaData *string `json:"caData,omitempty"`

	// CertificateData Base64-encoded PEM certificate content for PKI authentication (Other provider only). Required for PKI.
	CertificateData *string `json:"certificateData,omitempty"`

	// PrivateKeyData Base64-encoded PEM private key content for PKI authentication (Other provider only). Required for PKI.
	PrivateKeyData *string `json:"privateKeyData,omitempty"`
}

// GetDataViewsResponseItem defines model for get_data_views_response_item.
type GetDataViewsResponseItem struct {
	Id         *string                 `json:"id,omitempty"`
	Name       *string                 `json:"name,omitempty"`
	Namespaces *[]string               `json:"namespaces,omitempty"`
	Title      *string                 `json:"title,omitempty"`
	TypeMeta   *map[string]interface{} `json:"typeMeta,omitempty"`
}

// HasAuth If true, a username and password for login type authentication must be provided.
type HasAuth = bool

// IndexConfig Defines properties for connectors when type is `.index`.
type IndexConfig struct {
	// ExecutionTimeField A field that indicates when the document was indexed.
	ExecutionTimeField *string `json:"executionTimeField,omitempty"`

	// Index The Elasticsearch index to be written to.
	Index string `json:"index"`

	// Refresh The refresh policy for the write request, which affects when changes are made visible to search. Refer to the refresh setting for Elasticsearch document APIs.
	Refresh *bool `json:"refresh,omitempty"`
}

// JiraConfig Defines properties for connectors when type is `.jira`.
type JiraConfig struct {
	// ApiUrl The Jira instance URL.
	ApiUrl string `json:"apiUrl"`

	// ProjectKey The Jira project key.
	ProjectKey string `json:"projectKey"`
}

// JiraSecrets Defines secrets for connectors when type is `.jira`.
type JiraSecrets struct {
	// ApiToken The Jira API authentication token for HTTP basic authentication.
	ApiToken string `json:"apiToken"`

	// Email The account email for HTTP Basic authentication.
	Email string `json:"email"`
}

// Key If `authType` is `webhook-authentication-ssl` and `certType` is `ssl-crt-key`, it is a base64 encoded version of the KEY file.
type Key = string

// NewOutputElasticsearch defines model for new_output_elasticsearch.
type NewOutputElasticsearch struct {
	AllowEdit            *[]string                     `json:"allow_edit,omitempty"`
	CaSha256             *string                       `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                       `json:"ca_trusted_fingerprint,omitempty"`
	ConfigYaml           *string                       `json:"config_yaml,omitempty"`
	Hosts                []string                      `json:"hosts"`
	Id                   *string                       `json:"id,omitempty"`
	IsDefault            *bool                         `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                         `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                         `json:"is_internal,omitempty"`
	IsPreconfigured      *bool                         `json:"is_preconfigured,omitempty"`
	Name                 string                        `json:"name"`
	Preset               *NewOutputElasticsearchPreset `json:"preset,omitempty"`
	ProxyId              *string                       `json:"proxy_id,omitempty"`
	Secrets              *struct {
		Ssl *struct {
			Key *NewOutputElasticsearch_Secrets_Ssl_Key `json:"key,omitempty"`
		} `json:"ssl,omitempty"`
	} `json:"secrets,omitempty"`
	Shipper            *NewOutputShipper          `json:"shipper,omitempty"`
	Ssl                *NewOutputSsl              `json:"ssl,omitempty"`
	Type               NewOutputElasticsearchType `json:"type"`
	WriteToLogsStreams *bool                      `json:"write_to_logs_streams,omitempty"`
}

// NewOutputElasticsearchPreset defines model for NewOutputElasticsearch.Preset.
type NewOutputElasticsearchPreset string

// NewOutputElasticsearchSecretsSslKey0 defines model for .
type NewOutputElasticsearchSecretsSslKey0 struct {
	Id string `json:"id"`
}

// NewOutputElasticsearchSecretsSslKey1 defines model for .
type NewOutputElasticsearchSecretsSslKey1 = string

// NewOutputElasticsearch_Secrets_Ssl_Key defines model for NewOutputElasticsearch.Secrets.Ssl.Key.
type NewOutputElasticsearch_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// NewOutputElasticsearchType defines model for NewOutputElasticsearch.Type.
type NewOutputElasticsearchType string

// NewOutputKafka defines model for new_output_kafka.
type NewOutputKafka struct {
	AllowEdit            *[]string                  `json:"allow_edit,omitempty"`
	AuthType             NewOutputKafkaAuthType     `json:"auth_type"`
	BrokerTimeout        *float32                   `json:"broker_timeout,omitempty"`
	CaSha256             *string                    `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                    `json:"ca_trusted_fingerprint,omitempty"`
	ClientId             *string                    `json:"client_id,omitempty"`
	Compression          *NewOutputKafkaCompression `json:"compression,omitempty"`
	CompressionLevel     interface{}                `json:"compression_level"`
	ConfigYaml           *string                    `json:"config_yaml,omitempty"`
	ConnectionType       interface{}                `json:"connection_type"`
	Hash                 *struct {
		Hash   *string `json:"hash,omitempty"`
		Random *bool   `json:"random,omitempty"`
	} `json:"hash,omitempty"`
	Headers *[]struct {
		Key   string `json:"key"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Hosts               []string                 `json:"hosts"`
	Id                  *string                  `json:"id,omitempty"`
	IsDefault           *bool                    `json:"is_default,omitempty"`
	IsDefaultMonitoring *bool                    `json:"is_default_monitoring,omitempty"`
	IsInternal          *bool                    `json:"is_internal,omitempty"`
	IsPreconfigured     *bool                    `json:"is_preconfigured,omitempty"`
	Key                 *string                  `json:"key,omitempty"`
	Name                string                   `json:"name"`
	Partition           *NewOutputKafkaPartition `json:"partition,omitempty"`
	Password            interface{}              `json:"password"`
	ProxyId             *string                  `json:"proxy_id,omitempty"`
	Random              *struct {
		GroupEvents *float32 `json:"group_events,omitempty"`
	} `json:"random,omitempty"`
	RequiredAcks *NewOutputKafkaRequiredAcks `json:"required_acks,omitempty"`
	RoundRobin   *struct {
		GroupEvents *float32 `json:"group_events,omitempty"`
	} `json:"round_robin,omitempty"`
	Sasl *struct {
		Mechanism *NewOutputKafkaSaslMechanism `json:"mechanism,omitempty"`
	} `json:"sasl,omitempty"`
	Secrets *struct {
		Password *NewOutputKafka_Secrets_Password `json:"password,omitempty"`
		Ssl      *struct {
			Key NewOutputKafka_Secrets_Ssl_Key `json:"key"`
		} `json:"ssl,omitempty"`
	} `json:"secrets,omitempty"`
	Shipper            *NewOutputShipper  `json:"shipper,omitempty"`
	Ssl                *NewOutputSsl      `json:"ssl,omitempty"`
	Timeout            *float32           `json:"timeout,omitempty"`
	Topic              *string            `json:"topic,omitempty"`
	Type               NewOutputKafkaType `json:"type"`
	Username           interface{}        `json:"username"`
	Version            *string            `json:"version,omitempty"`
	WriteToLogsStreams *bool              `json:"write_to_logs_streams,omitempty"`
}

// NewOutputKafkaAuthType defines model for NewOutputKafka.AuthType.
type NewOutputKafkaAuthType string

// NewOutputKafkaCompression defines model for NewOutputKafka.Compression.
type NewOutputKafkaCompression string

// NewOutputKafkaPartition defines model for NewOutputKafka.Partition.
type NewOutputKafkaPartition string

// NewOutputKafkaRequiredAcks defines model for NewOutputKafka.RequiredAcks.
type NewOutputKafkaRequiredAcks int

// NewOutputKafkaSaslMechanism defines model for NewOutputKafka.Sasl.Mechanism.
type NewOutputKafkaSaslMechanism string

// NewOutputKafkaSecretsPassword0 defines model for .
type NewOutputKafkaSecretsPassword0 struct {
	Id string `json:"id"`
}

// NewOutputKafkaSecretsPassword1 defines model for .
type NewOutputKafkaSecretsPassword1 = string

// NewOutputKafka_Secrets_Password defines model for NewOutputKafka.Secrets.Password.
type NewOutputKafka_Secrets_Password struct {
	union json.RawMessage
}

// NewOutputKafkaSecretsSslKey0 defines model for .
type NewOutputKafkaSecretsSslKey0 struct {
	Id string `json:"id"`
}

// NewOutputKafkaSecretsSslKey1 defines model for .
type NewOutputKafkaSecretsSslKey1 = string

// NewOutputKafka_Secrets_Ssl_Key defines model for NewOutputKafka.Secrets.Ssl.Key.
type NewOutputKafka_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// NewOutputKafkaType defines model for NewOutputKafka.Type.
type NewOutputKafkaType string

// NewOutputLogstash defines model for new_output_logstash.
type NewOutputLogstash struct {
	AllowEdit            *[]string `json:"allow_edit,omitempty"`
	CaSha256             *string   `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string   `json:"ca_trusted_fingerprint,omitempty"`
	ConfigYaml           *string   `json:"config_yaml,omitempty"`
	Hosts                []string  `json:"hosts"`
	Id                   *string   `json:"id,omitempty"`
	IsDefault            *bool     `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool     `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool     `json:"is_internal,omitempty"`
	IsPreconfigured      *bool     `json:"is_preconfigured,omitempty"`
	Name                 string    `json:"name"`
	ProxyId              *string   `json:"proxy_id,omitempty"`
	Secrets              *struct {
		Ssl *struct {
			Key *NewOutputLogstash_Secrets_Ssl_Key `json:"key,omitempty"`
		} `json:"ssl,omitempty"`
	} `json:"secrets,omitempty"`
	Shipper            *NewOutputShipper     `json:"shipper,omitempty"`
	Ssl                *NewOutputSsl         `json:"ssl,omitempty"`
	Type               NewOutputLogstashType `json:"type"`
	WriteToLogsStreams *bool                 `json:"write_to_logs_streams,omitempty"`
}

// NewOutputLogstashSecretsSslKey0 defines model for .
type NewOutputLogstashSecretsSslKey0 struct {
	Id string `json:"id"`
}

// NewOutputLogstashSecretsSslKey1 defines model for .
type NewOutputLogstashSecretsSslKey1 = string

// NewOutputLogstash_Secrets_Ssl_Key defines model for NewOutputLogstash.Secrets.Ssl.Key.
type NewOutputLogstash_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// NewOutputLogstashType defines model for NewOutputLogstash.Type.
type NewOutputLogstashType string

// NewOutputRemoteElasticsearch defines model for new_output_remote_elasticsearch.
type NewOutputRemoteElasticsearch struct {
	AllowEdit            *[]string                           `json:"allow_edit,omitempty"`
	CaSha256             *string                             `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                             `json:"ca_trusted_fingerprint,omitempty"`
	ConfigYaml           *string                             `json:"config_yaml,omitempty"`
	Hosts                []string                            `json:"hosts"`
	Id                   *string                             `json:"id,omitempty"`
	IsDefault            *bool                               `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                               `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                               `json:"is_internal,omitempty"`
	IsPreconfigured      *bool                               `json:"is_preconfigured,omitempty"`
	KibanaApiKey         *string                             `json:"kibana_api_key,omitempty"`
	KibanaUrl            *string                             `json:"kibana_url,omitempty"`
	Name                 string                              `json:"name"`
	Preset               *NewOutputRemoteElasticsearchPreset `json:"preset,omitempty"`
	ProxyId              *string                             `json:"proxy_id,omitempty"`
	Secrets              *struct {
		ServiceToken *NewOutputRemoteElasticsearch_Secrets_ServiceToken `json:"service_token,omitempty"`
		Ssl          *struct {
			Key *NewOutputRemoteElasticsearch_Secrets_Ssl_Key `json:"key,omitempty"`
		} `json:"ssl,omitempty"`
	} `json:"secrets,omitempty"`
	ServiceToken                *string                          `json:"service_token,omitempty"`
	Shipper                     *NewOutputShipper                `json:"shipper,omitempty"`
	Ssl                         *NewOutputSsl                    `json:"ssl,omitempty"`
	SyncIntegrations            *bool                            `json:"sync_integrations,omitempty"`
	SyncUninstalledIntegrations *bool                            `json:"sync_uninstalled_integrations,omitempty"`
	Type                        NewOutputRemoteElasticsearchType `json:"type"`
	WriteToLogsStreams          *bool                            `json:"write_to_logs_streams,omitempty"`
}

// NewOutputRemoteElasticsearchPreset defines model for NewOutputRemoteElasticsearch.Preset.
type NewOutputRemoteElasticsearchPreset string

// NewOutputRemoteElasticsearchSecretsServiceToken0 defines model for .
type NewOutputRemoteElasticsearchSecretsServiceToken0 struct {
	Id string `json:"id"`
}

// NewOutputRemoteElasticsearchSecretsServiceToken1 defines model for .
type NewOutputRemoteElasticsearchSecretsServiceToken1 = string

// NewOutputRemoteElasticsearch_Secrets_ServiceToken defines model for NewOutputRemoteElasticsearch.Secrets.ServiceToken.
type NewOutputRemoteElasticsearch_Secrets_ServiceToken struct {
	union json.RawMessage
}

// NewOutputRemoteElasticsearchSecretsSslKey0 defines model for .
type NewOutputRemoteElasticsearchSecretsSslKey0 struct {
	Id string `json:"id"`
}

// NewOutputRemoteElasticsearchSecretsSslKey1 defines model for .
type NewOutputRemoteElasticsearchSecretsSslKey1 = string

// NewOutputRemoteElasticsearch_Secrets_Ssl_Key defines model for NewOutputRemoteElasticsearch.Secrets.Ssl.Key.
type NewOutputRemoteElasticsearch_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// NewOutputRemoteElasticsearchType defines model for NewOutputRemoteElasticsearch.Type.
type NewOutputRemoteElasticsearchType string

// NewOutputShipper defines model for new_output_shipper.
type NewOutputShipper struct {
	CompressionLevel            *float32 `json:"compression_level,omitempty"`
	DiskQueueCompressionEnabled *bool    `json:"disk_queue_compression_enabled,omitempty"`
	DiskQueueEnabled            *bool    `json:"disk_queue_enabled,omitempty"`
	DiskQueueEncryptionEnabled  *bool    `json:"disk_queue_encryption_enabled,omitempty"`
	DiskQueueMaxSize            *float32 `json:"disk_queue_max_size,omitempty"`
	DiskQueuePath               *string  `json:"disk_queue_path,omitempty"`
	Loadbalance                 *bool    `json:"loadbalance,omitempty"`
	MaxBatchBytes               *float32 `json:"max_batch_bytes,omitempty"`
	MemQueueEvents              *float32 `json:"mem_queue_events,omitempty"`
	QueueFlushTimeout           *float32 `json:"queue_flush_timeout,omitempty"`
}

// NewOutputSsl defines model for new_output_ssl.
type NewOutputSsl struct {
	Certificate            *string                       `json:"certificate,omitempty"`
	CertificateAuthorities *[]string                     `json:"certificate_authorities,omitempty"`
	Key                    *string                       `json:"key,omitempty"`
	VerificationMode       *NewOutputSslVerificationMode `json:"verification_mode,omitempty"`
}

// NewOutputSslVerificationMode defines model for NewOutputSsl.VerificationMode.
type NewOutputSslVerificationMode string

// NewOutputUnion defines model for new_output_union.
type NewOutputUnion struct {
	union json.RawMessage
}

// OpsgenieConfig Defines properties for connectors when type is `.opsgenie`.
type OpsgenieConfig struct {
	// ApiUrl The Opsgenie URL. For example, `https://api.opsgenie.com` or `https://api.eu.opsgenie.com`. If you are using the `xpack.actions.allowedHosts` setting, add the hostname to the allowed hosts.
	ApiUrl string `json:"apiUrl"`
}

// OpsgenieSecrets Defines secrets for connectors when type is `.opsgenie`.
type OpsgenieSecrets struct {
	// ApiKey The Opsgenie API authentication key for HTTP Basic authentication.
	ApiKey string `json:"apiKey"`
}

// OutputElasticsearch defines model for output_elasticsearch.
type OutputElasticsearch struct {
	AllowEdit            *[]string                    `json:"allow_edit,omitempty"`
	CaSha256             *string                      `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                      `json:"ca_trusted_fingerprint,omitempty"`
	ConfigYaml           *string                      `json:"config_yaml,omitempty"`
	Hosts                []string                     `json:"hosts"`
	Id                   *string                      `json:"id,omitempty"`
	IsDefault            *bool                        `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                        `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                        `json:"is_internal,omitempty"`
	IsPreconfigured      *bool                        `json:"is_preconfigured,omitempty"`
	Name                 string                       `json:"name"`
	Preset               *OutputElasticsearchPreset   `json:"preset,omitempty"`
	ProxyId              *string                      `json:"proxy_id,omitempty"`
	Secrets              *OutputElasticsearch_Secrets `json:"secrets,omitempty"`
	Shipper              *OutputShipper               `json:"shipper,omitempty"`
	Ssl                  *OutputSsl                   `json:"ssl,omitempty"`
	Type                 OutputElasticsearchType      `json:"type"`
	WriteToLogsStreams   *bool                        `json:"write_to_logs_streams,omitempty"`
	AdditionalProperties map[string]interface{}       `json:"-"`
}

// OutputElasticsearchPreset defines model for OutputElasticsearch.Preset.
type OutputElasticsearchPreset string

// OutputElasticsearchSecretsSslKey0 defines model for .
type OutputElasticsearchSecretsSslKey0 struct {
	Id                   string                 `json:"id"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputElasticsearchSecretsSslKey1 defines model for .
type OutputElasticsearchSecretsSslKey1 = string

// OutputElasticsearch_Secrets_Ssl_Key defines model for OutputElasticsearch.Secrets.Ssl.Key.
type OutputElasticsearch_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// OutputElasticsearch_Secrets_Ssl defines model for OutputElasticsearch.Secrets.Ssl.
type OutputElasticsearch_Secrets_Ssl struct {
	Key                  *OutputElasticsearch_Secrets_Ssl_Key `json:"key,omitempty"`
	AdditionalProperties map[string]interface{}               `json:"-"`
}

// OutputElasticsearch_Secrets defines model for OutputElasticsearch.Secrets.
type OutputElasticsearch_Secrets struct {
	Ssl                  *OutputElasticsearch_Secrets_Ssl `json:"ssl,omitempty"`
	AdditionalProperties map[string]interface{}           `json:"-"`
}

// OutputElasticsearchType defines model for OutputElasticsearch.Type.
type OutputElasticsearchType string

// OutputKafka defines model for output_kafka.
type OutputKafka struct {
	AllowEdit            *[]string                   `json:"allow_edit,omitempty"`
	AuthType             OutputKafkaAuthType         `json:"auth_type"`
	BrokerTimeout        *float32                    `json:"broker_timeout,omitempty"`
	CaSha256             *string                     `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                     `json:"ca_trusted_fingerprint,omitempty"`
	ClientId             *string                     `json:"client_id,omitempty"`
	Compression          *OutputKafkaCompression     `json:"compression,omitempty"`
	CompressionLevel     interface{}                 `json:"compression_level"`
	ConfigYaml           *string                     `json:"config_yaml,omitempty"`
	ConnectionType       interface{}                 `json:"connection_type"`
	Hash                 *OutputKafka_Hash           `json:"hash,omitempty"`
	Headers              *[]OutputKafka_Headers_Item `json:"headers,omitempty"`
	Hosts                []string                    `json:"hosts"`
	Id                   *string                     `json:"id,omitempty"`
	IsDefault            *bool                       `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                       `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                       `json:"is_internal,omitempty"`
	IsPreconfigured      *bool                       `json:"is_preconfigured,omitempty"`
	Key                  *string                     `json:"key,omitempty"`
	Name                 string                      `json:"name"`
	Partition            *OutputKafkaPartition       `json:"partition,omitempty"`
	Password             interface{}                 `json:"password"`
	ProxyId              *string                     `json:"proxy_id,omitempty"`
	Random               *OutputKafka_Random         `json:"random,omitempty"`
	RequiredAcks         *OutputKafkaRequiredAcks    `json:"required_acks,omitempty"`
	RoundRobin           *OutputKafka_RoundRobin     `json:"round_robin,omitempty"`
	Sasl                 *OutputKafka_Sasl           `json:"sasl,omitempty"`
	Secrets              *OutputKafka_Secrets        `json:"secrets,omitempty"`
	Shipper              *OutputShipper              `json:"shipper,omitempty"`
	Ssl                  *OutputSsl                  `json:"ssl,omitempty"`
	Timeout              *float32                    `json:"timeout,omitempty"`
	Topic                *string                     `json:"topic,omitempty"`
	Type                 OutputKafkaType             `json:"type"`
	Username             interface{}                 `json:"username"`
	Version              *string                     `json:"version,omitempty"`
	WriteToLogsStreams   *bool                       `json:"write_to_logs_streams,omitempty"`
	AdditionalProperties map[string]interface{}      `json:"-"`
}

// OutputKafkaAuthType defines model for OutputKafka.AuthType.
type OutputKafkaAuthType string

// OutputKafkaCompression defines model for OutputKafka.Compression.
type OutputKafkaCompression string

// OutputKafka_Hash defines model for OutputKafka.Hash.
type OutputKafka_Hash struct {
	Hash                 *string                `json:"hash,omitempty"`
	Random               *bool                  `json:"random,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputKafka_Headers_Item defines model for output_kafka.headers.Item.
type OutputKafka_Headers_Item struct {
	Key                  string                 `json:"key"`
	Value                string                 `json:"value"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputKafkaPartition defines model for OutputKafka.Partition.
type OutputKafkaPartition string

// OutputKafka_Random defines model for OutputKafka.Random.
type OutputKafka_Random struct {
	GroupEvents          *float32               `json:"group_events,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputKafkaRequiredAcks defines model for OutputKafka.RequiredAcks.
type OutputKafkaRequiredAcks int

// OutputKafka_RoundRobin defines model for OutputKafka.RoundRobin.
type OutputKafka_RoundRobin struct {
	GroupEvents          *float32               `json:"group_events,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputKafkaSaslMechanism defines model for OutputKafka.Sasl.Mechanism.
type OutputKafkaSaslMechanism string

// OutputKafka_Sasl defines model for OutputKafka.Sasl.
type OutputKafka_Sasl struct {
	Mechanism            *OutputKafkaSaslMechanism `json:"mechanism,omitempty"`
	AdditionalProperties map[string]interface{}    `json:"-"`
}

// OutputKafkaSecretsPassword0 defines model for .
type OutputKafkaSecretsPassword0 struct {
	Id                   string                 `json:"id"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputKafkaSecretsPassword1 defines model for .
type OutputKafkaSecretsPassword1 = string

// OutputKafka_Secrets_Password defines model for OutputKafka.Secrets.Password.
type OutputKafka_Secrets_Password struct {
	union json.RawMessage
}

// OutputKafkaSecretsSslKey0 defines model for .
type OutputKafkaSecretsSslKey0 struct {
	Id                   string                 `json:"id"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputKafkaSecretsSslKey1 defines model for .
type OutputKafkaSecretsSslKey1 = string

// OutputKafka_Secrets_Ssl_Key defines model for OutputKafka.Secrets.Ssl.Key.
type OutputKafka_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// OutputKafka_Secrets_Ssl defines model for OutputKafka.Secrets.Ssl.
type OutputKafka_Secrets_Ssl struct {
	Key                  OutputKafka_Secrets_Ssl_Key `json:"key"`
	AdditionalProperties map[string]interface{}      `json:"-"`
}

// OutputKafka_Secrets defines model for OutputKafka.Secrets.
type OutputKafka_Secrets struct {
	Password             *OutputKafka_Secrets_Password `json:"password,omitempty"`
	Ssl                  *OutputKafka_Secrets_Ssl      `json:"ssl,omitempty"`
	AdditionalProperties map[string]interface{}        `json:"-"`
}

// OutputKafkaType defines model for OutputKafka.Type.
type OutputKafkaType string

// OutputLogstash defines model for output_logstash.
type OutputLogstash struct {
	AllowEdit            *[]string               `json:"allow_edit,omitempty"`
	CaSha256             *string                 `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                 `json:"ca_trusted_fingerprint,omitempty"`
	ConfigYaml           *string                 `json:"config_yaml,omitempty"`
	Hosts                []string                `json:"hosts"`
	Id                   *string                 `json:"id,omitempty"`
	IsDefault            *bool                   `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                   `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                   `json:"is_internal,omitempty"`
	IsPreconfigured      *bool                   `json:"is_preconfigured,omitempty"`
	Name                 string                  `json:"name"`
	ProxyId              *string                 `json:"proxy_id,omitempty"`
	Secrets              *OutputLogstash_Secrets `json:"secrets,omitempty"`
	Shipper              *OutputShipper          `json:"shipper,omitempty"`
	Ssl                  *OutputSsl              `json:"ssl,omitempty"`
	Type                 OutputLogstashType      `json:"type"`
	WriteToLogsStreams   *bool                   `json:"write_to_logs_streams,omitempty"`
	AdditionalProperties map[string]interface{}  `json:"-"`
}

// OutputLogstashSecretsSslKey0 defines model for .
type OutputLogstashSecretsSslKey0 struct {
	Id                   string                 `json:"id"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputLogstashSecretsSslKey1 defines model for .
type OutputLogstashSecretsSslKey1 = string

// OutputLogstash_Secrets_Ssl_Key defines model for OutputLogstash.Secrets.Ssl.Key.
type OutputLogstash_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// OutputLogstash_Secrets_Ssl defines model for OutputLogstash.Secrets.Ssl.
type OutputLogstash_Secrets_Ssl struct {
	Key                  *OutputLogstash_Secrets_Ssl_Key `json:"key,omitempty"`
	AdditionalProperties map[string]interface{}          `json:"-"`
}

// OutputLogstash_Secrets defines model for OutputLogstash.Secrets.
type OutputLogstash_Secrets struct {
	Ssl                  *OutputLogstash_Secrets_Ssl `json:"ssl,omitempty"`
	AdditionalProperties map[string]interface{}      `json:"-"`
}

// OutputLogstashType defines model for OutputLogstash.Type.
type OutputLogstashType string

// OutputRemoteElasticsearch defines model for output_remote_elasticsearch.
type OutputRemoteElasticsearch struct {
	AllowEdit                   *[]string                          `json:"allow_edit,omitempty"`
	CaSha256                    *string                            `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint        *string                            `json:"ca_trusted_fingerprint,omitempty"`
	ConfigYaml                  *string                            `json:"config_yaml,omitempty"`
	Hosts                       []string                           `json:"hosts"`
	Id                          *string                            `json:"id,omitempty"`
	IsDefault                   *bool                              `json:"is_default,omitempty"`
	IsDefaultMonitoring         *bool                              `json:"is_default_monitoring,omitempty"`
	IsInternal                  *bool                              `json:"is_internal,omitempty"`
	IsPreconfigured             *bool                              `json:"is_preconfigured,omitempty"`
	KibanaApiKey                *string                            `json:"kibana_api_key,omitempty"`
	KibanaUrl                   *string                            `json:"kibana_url,omitempty"`
	Name                        string                             `json:"name"`
	Preset                      *OutputRemoteElasticsearchPreset   `json:"preset,omitempty"`
	ProxyId                     *string                            `json:"proxy_id,omitempty"`
	Secrets                     *OutputRemoteElasticsearch_Secrets `json:"secrets,omitempty"`
	ServiceToken                *string                            `json:"service_token,omitempty"`
	Shipper                     *OutputShipper                     `json:"shipper,omitempty"`
	Ssl                         *OutputSsl                         `json:"ssl,omitempty"`
	SyncIntegrations            *bool                              `json:"sync_integrations,omitempty"`
	SyncUninstalledIntegrations *bool                              `json:"sync_uninstalled_integrations,omitempty"`
	Type                        OutputRemoteElasticsearchType      `json:"type"`
	WriteToLogsStreams          *bool                              `json:"write_to_logs_streams,omitempty"`
	AdditionalProperties        map[string]interface{}             `json:"-"`
}

// OutputRemoteElasticsearchPreset defines model for OutputRemoteElasticsearch.Preset.
type OutputRemoteElasticsearchPreset string

// OutputRemoteElasticsearchSecretsServiceToken0 defines model for .
type OutputRemoteElasticsearchSecretsServiceToken0 struct {
	Id                   string                 `json:"id"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputRemoteElasticsearchSecretsServiceToken1 defines model for .
type OutputRemoteElasticsearchSecretsServiceToken1 = string

// OutputRemoteElasticsearch_Secrets_ServiceToken defines model for OutputRemoteElasticsearch.Secrets.ServiceToken.
type OutputRemoteElasticsearch_Secrets_ServiceToken struct {
	union json.RawMessage
}

// OutputRemoteElasticsearchSecretsSslKey0 defines model for .
type OutputRemoteElasticsearchSecretsSslKey0 struct {
	Id                   string                 `json:"id"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputRemoteElasticsearchSecretsSslKey1 defines model for .
type OutputRemoteElasticsearchSecretsSslKey1 = string

// OutputRemoteElasticsearch_Secrets_Ssl_Key defines model for OutputRemoteElasticsearch.Secrets.Ssl.Key.
type OutputRemoteElasticsearch_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// OutputRemoteElasticsearch_Secrets_Ssl defines model for OutputRemoteElasticsearch.Secrets.Ssl.
type OutputRemoteElasticsearch_Secrets_Ssl struct {
	Key                  *OutputRemoteElasticsearch_Secrets_Ssl_Key `json:"key,omitempty"`
	AdditionalProperties map[string]interface{}                     `json:"-"`
}

// OutputRemoteElasticsearch_Secrets defines model for OutputRemoteElasticsearch.Secrets.
type OutputRemoteElasticsearch_Secrets struct {
	ServiceToken         *OutputRemoteElasticsearch_Secrets_ServiceToken `json:"service_token,omitempty"`
	Ssl                  *OutputRemoteElasticsearch_Secrets_Ssl          `json:"ssl,omitempty"`
	AdditionalProperties map[string]interface{}                          `json:"-"`
}

// OutputRemoteElasticsearchType defines model for OutputRemoteElasticsearch.Type.
type OutputRemoteElasticsearchType string

// OutputShipper defines model for output_shipper.
type OutputShipper struct {
	CompressionLevel            *float32               `json:"compression_level,omitempty"`
	DiskQueueCompressionEnabled *bool                  `json:"disk_queue_compression_enabled,omitempty"`
	DiskQueueEnabled            *bool                  `json:"disk_queue_enabled,omitempty"`
	DiskQueueEncryptionEnabled  *bool                  `json:"disk_queue_encryption_enabled,omitempty"`
	DiskQueueMaxSize            *float32               `json:"disk_queue_max_size,omitempty"`
	DiskQueuePath               *string                `json:"disk_queue_path,omitempty"`
	Loadbalance                 *bool                  `json:"loadbalance,omitempty"`
	MaxBatchBytes               *float32               `json:"max_batch_bytes,omitempty"`
	MemQueueEvents              *float32               `json:"mem_queue_events,omitempty"`
	QueueFlushTimeout           *float32               `json:"queue_flush_timeout,omitempty"`
	AdditionalProperties        map[string]interface{} `json:"-"`
}

// OutputSsl defines model for output_ssl.
type OutputSsl struct {
	Certificate            *string                    `json:"certificate,omitempty"`
	CertificateAuthorities *[]string                  `json:"certificate_authorities,omitempty"`
	Key                    *string                    `json:"key,omitempty"`
	VerificationMode       *OutputSslVerificationMode `json:"verification_mode,omitempty"`
	AdditionalProperties   map[string]interface{}     `json:"-"`
}

// OutputSslVerificationMode defines model for OutputSsl.VerificationMode.
type OutputSslVerificationMode string

// OutputUnion defines model for output_union.
type OutputUnion struct {
	union json.RawMessage
}

// PackageInfo defines model for package_info.
type PackageInfo struct {
	Agent *struct {
		Privileges *struct {
			Root *bool `json:"root,omitempty"`
		} `json:"privileges,omitempty"`
	} `json:"agent,omitempty"`
	AssetTags *[]struct {
		AssetIds   *[]string `json:"asset_ids,omitempty"`
		AssetTypes *[]string `json:"asset_types,omitempty"`
		Text       string    `json:"text"`
	} `json:"asset_tags,omitempty"`
	Assets               map[string]interface{}        `json:"assets"`
	Categories           *[]string                     `json:"categories,omitempty"`
	Conditions           *PackageInfo_Conditions       `json:"conditions,omitempty"`
	DataStreams          *[]map[string]interface{}     `json:"data_streams,omitempty"`
	Description          *string                       `json:"description,omitempty"`
	Discovery            *PackageInfo_Discovery        `json:"discovery,omitempty"`
	Download             *string                       `json:"download,omitempty"`
	Elasticsearch        *map[string]interface{}       `json:"elasticsearch,omitempty"`
	FormatVersion        *string                       `json:"format_version,omitempty"`
	Icons                *[]PackageInfo_Icons_Item     `json:"icons,omitempty"`
	InstallationInfo     *PackageInfo_InstallationInfo `json:"installationInfo,omitempty"`
	Internal             *bool                         `json:"internal,omitempty"`
	KeepPoliciesUpToDate *bool                         `json:"keepPoliciesUpToDate,omitempty"`
	LatestVersion        *string                       `json:"latestVersion,omitempty"`
	License              *string                       `json:"license,omitempty"`
	LicensePath          *string                       `json:"licensePath,omitempty"`
	Name                 string                        `json:"name"`
	Notice               *string                       `json:"notice,omitempty"`
	Owner                *PackageInfo_Owner            `json:"owner,omitempty"`
	Path                 *string                       `json:"path,omitempty"`
	PolicyTemplates      *[]map[string]interface{}     `json:"policy_templates,omitempty"`
	Readme               *string                       `json:"readme,omitempty"`
	Release              *PackageInfoRelease           `json:"release,omitempty"`
	Screenshots          *[]struct {
		DarkMode *bool   `json:"dark_mode,omitempty"`
		Path     *string `json:"path,omitempty"`
		Size     *string `json:"size,omitempty"`
		Src      string  `json:"src"`
		Title    *string `json:"title,omitempty"`
		Type     *string `json:"type,omitempty"`
	} `json:"screenshots,omitempty"`
	SignaturePath        *string                   `json:"signature_path,omitempty"`
	Source               *PackageInfo_Source       `json:"source,omitempty"`
	Status               *string                   `json:"status,omitempty"`
	Title                string                    `json:"title"`
	Type                 *PackageInfo_Type         `json:"type,omitempty"`
	Vars                 *[]map[string]interface{} `json:"vars,omitempty"`
	Version              string                    `json:"version"`
	AdditionalProperties map[string]interface{}    `json:"-"`
}

// PackageInfo_Conditions_Elastic defines model for PackageInfo.Conditions.Elastic.
type PackageInfo_Conditions_Elastic struct {
	Capabilities         *[]string              `json:"capabilities,omitempty"`
	Subscription         *string                `json:"subscription,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfo_Conditions_Kibana defines model for PackageInfo.Conditions.Kibana.
type PackageInfo_Conditions_Kibana struct {
	Version              *string                `json:"version,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfo_Conditions defines model for PackageInfo.Conditions.
type PackageInfo_Conditions struct {
	Elastic              *PackageInfo_Conditions_Elastic `json:"elastic,omitempty"`
	Kibana               *PackageInfo_Conditions_Kibana  `json:"kibana,omitempty"`
	AdditionalProperties map[string]interface{}          `json:"-"`
}

// PackageInfo_Discovery_Datasets_Item defines model for PackageInfo.Discovery.Datasets.Item.
type PackageInfo_Discovery_Datasets_Item struct {
	Name                 string                 `json:"name"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfo_Discovery_Fields_Item defines model for PackageInfo.Discovery.Fields.Item.
type PackageInfo_Discovery_Fields_Item struct {
	Name                 string                 `json:"name"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfo_Discovery defines model for PackageInfo.Discovery.
type PackageInfo_Discovery struct {
	Datasets             *[]PackageInfo_Discovery_Datasets_Item `json:"datasets,omitempty"`
	Fields               *[]PackageInfo_Discovery_Fields_Item   `json:"fields,omitempty"`
	AdditionalProperties map[string]interface{}                 `json:"-"`
}

// PackageInfo_Icons_Item defines model for package_info.icons.Item.
type PackageInfo_Icons_Item struct {
	DarkMode             *bool                  `json:"dark_mode,omitempty"`
	Path                 *string                `json:"path,omitempty"`
	Size                 *string                `json:"size,omitempty"`
	Src                  string                 `json:"src"`
	Title                *string                `json:"title,omitempty"`
	Type                 *string                `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0 defines model for PackageInfo.InstallationInfo.AdditionalSpacesInstalledKibana.Type.0.
type PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0 string

// PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType1 defines model for .
type PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType1 = string

// PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Type defines model for PackageInfo.InstallationInfo.AdditionalSpacesInstalledKibana.Type.
type PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Type struct {
	union json.RawMessage
}

// PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item defines model for PackageInfo.InstallationInfo.AdditionalSpacesInstalledKibana.Item.
type PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item struct {
	Id                   string                                                            `json:"id"`
	OriginId             *string                                                           `json:"originId,omitempty"`
	Type                 PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Type `json:"type"`
	AdditionalProperties map[string]interface{}                                            `json:"-"`
}

// PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features defines model for PackageInfo.InstallationInfo.ExperimentalDataStreamFeatures.Features.
type PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features struct {
	DocValueOnlyNumeric  *bool                  `json:"doc_value_only_numeric,omitempty"`
	DocValueOnlyOther    *bool                  `json:"doc_value_only_other,omitempty"`
	SyntheticSource      *bool                  `json:"synthetic_source,omitempty"`
	Tsdb                 *bool                  `json:"tsdb,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item defines model for PackageInfo.InstallationInfo.ExperimentalDataStreamFeatures.Item.
type PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item struct {
	DataStream           string                                                               `json:"data_stream"`
	Features             PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features `json:"features"`
	AdditionalProperties map[string]interface{}                                               `json:"-"`
}

// PackageInfoInstallationInfoInstallSource defines model for PackageInfo.InstallationInfo.InstallSource.
type PackageInfoInstallationInfoInstallSource string

// PackageInfoInstallationInfoInstallStatus defines model for PackageInfo.InstallationInfo.InstallStatus.
type PackageInfoInstallationInfoInstallStatus string

// PackageInfoInstallationInfoInstalledEsType defines model for PackageInfo.InstallationInfo.InstalledEs.Type.
type PackageInfoInstallationInfoInstalledEsType string

// PackageInfo_InstallationInfo_InstalledEs_Item defines model for PackageInfo.InstallationInfo.InstalledEs.Item.
type PackageInfo_InstallationInfo_InstalledEs_Item struct {
	Deferred             *bool                                      `json:"deferred,omitempty"`
	Id                   string                                     `json:"id"`
	Type                 PackageInfoInstallationInfoInstalledEsType `json:"type"`
	Version              *string                                    `json:"version,omitempty"`
	AdditionalProperties map[string]interface{}                     `json:"-"`
}

// PackageInfoInstallationInfoInstalledKibanaType0 defines model for PackageInfo.InstallationInfo.InstalledKibana.Type.0.
type PackageInfoInstallationInfoInstalledKibanaType0 string

// PackageInfoInstallationInfoInstalledKibanaType1 defines model for .
type PackageInfoInstallationInfoInstalledKibanaType1 = string

// PackageInfo_InstallationInfo_InstalledKibana_Type defines model for PackageInfo.InstallationInfo.InstalledKibana.Type.
type PackageInfo_InstallationInfo_InstalledKibana_Type struct {
	union json.RawMessage
}

// PackageInfo_InstallationInfo_InstalledKibana_Item defines model for PackageInfo.InstallationInfo.InstalledKibana.Item.
type PackageInfo_InstallationInfo_InstalledKibana_Item struct {
	Id                   string                                            `json:"id"`
	OriginId             *string                                           `json:"originId,omitempty"`
	Type                 PackageInfo_InstallationInfo_InstalledKibana_Type `json:"type"`
	AdditionalProperties map[string]interface{}                            `json:"-"`
}

// PackageInfo_InstallationInfo_LatestExecutedState defines model for PackageInfo.InstallationInfo.LatestExecutedState.
type PackageInfo_InstallationInfo_LatestExecutedState struct {
	Error                *string                `json:"error,omitempty"`
	Name                 *string                `json:"name,omitempty"`
	StartedAt            *string                `json:"started_at,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error defines model for PackageInfo.InstallationInfo.LatestInstallFailedAttempts.Error.
type PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error struct {
	Message              string                 `json:"message"`
	Name                 string                 `json:"name"`
	Stack                *string                `json:"stack,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item defines model for PackageInfo.InstallationInfo.LatestInstallFailedAttempts.Item.
type PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item struct {
	CreatedAt            string                                                         `json:"created_at"`
	Error                PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error `json:"error"`
	TargetVersion        string                                                         `json:"target_version"`
	AdditionalProperties map[string]interface{}                                         `json:"-"`
}

// PackageInfoInstallationInfoVerificationStatus defines model for PackageInfo.InstallationInfo.VerificationStatus.
type PackageInfoInstallationInfoVerificationStatus string

// PackageInfo_InstallationInfo defines model for PackageInfo.InstallationInfo.
type PackageInfo_InstallationInfo struct {
	AdditionalSpacesInstalledKibana *map[string][]PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item `json:"additional_spaces_installed_kibana,omitempty"`
	CreatedAt                       *string                                                                         `json:"created_at,omitempty"`
	ExperimentalDataStreamFeatures  *[]PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item             `json:"experimental_data_stream_features,omitempty"`
	InstallFormatSchemaVersion      *string                                                                         `json:"install_format_schema_version,omitempty"`
	InstallSource                   PackageInfoInstallationInfoInstallSource                                        `json:"install_source"`
	InstallStatus                   PackageInfoInstallationInfoInstallStatus                                        `json:"install_status"`
	InstalledEs                     []PackageInfo_InstallationInfo_InstalledEs_Item                                 `json:"installed_es"`
	InstalledKibana                 []PackageInfo_InstallationInfo_InstalledKibana_Item                             `json:"installed_kibana"`
	InstalledKibanaSpaceId          *string                                                                         `json:"installed_kibana_space_id,omitempty"`
	LatestExecutedState             *PackageInfo_InstallationInfo_LatestExecutedState                               `json:"latest_executed_state,omitempty"`
	LatestInstallFailedAttempts     *[]PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item                `json:"latest_install_failed_attempts,omitempty"`
	Name                            string                                                                          `json:"name"`
	Namespaces                      *[]string                                                                       `json:"namespaces,omitempty"`
	PreviousVersion                 *string                                                                         `json:"previous_version,omitempty"`
	Type                            string                                                                          `json:"type"`
	UpdatedAt                       *string                                                                         `json:"updated_at,omitempty"`
	VerificationKeyId               *string                                                                         `json:"verification_key_id,omitempty"`
	VerificationStatus              PackageInfoInstallationInfoVerificationStatus                                   `json:"verification_status"`
	Version                         string                                                                          `json:"version"`
	AdditionalProperties            map[string]interface{}                                                          `json:"-"`
}

// PackageInfoOwnerType defines model for PackageInfo.Owner.Type.
type PackageInfoOwnerType string

// PackageInfo_Owner defines model for PackageInfo.Owner.
type PackageInfo_Owner struct {
	Github               *string                `json:"github,omitempty"`
	Type                 *PackageInfoOwnerType  `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfoRelease defines model for PackageInfo.Release.
type PackageInfoRelease string

// PackageInfo_Source defines model for PackageInfo.Source.
type PackageInfo_Source struct {
	License              string                 `json:"license"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfoType0 defines model for PackageInfo.Type.0.
type PackageInfoType0 string

// PackageInfoType1 defines model for PackageInfo.Type.1.
type PackageInfoType1 string

// PackageInfoType2 defines model for PackageInfo.Type.2.
type PackageInfoType2 string

// PackageInfoType3 defines model for .
type PackageInfoType3 = string

// PackageInfo_Type defines model for PackageInfo.Type.
type PackageInfo_Type struct {
	union json.RawMessage
}

// PackageListItem defines model for package_list_item.
type PackageListItem struct {
	Categories           *[]string                         `json:"categories,omitempty"`
	Conditions           *PackageListItem_Conditions       `json:"conditions,omitempty"`
	DataStreams          *[]map[string]interface{}         `json:"data_streams,omitempty"`
	Description          *string                           `json:"description,omitempty"`
	Discovery            *PackageListItem_Discovery        `json:"discovery,omitempty"`
	Download             *string                           `json:"download,omitempty"`
	FormatVersion        *string                           `json:"format_version,omitempty"`
	Icons                *[]PackageListItem_Icons_Item     `json:"icons,omitempty"`
	Id                   string                            `json:"id"`
	InstallationInfo     *PackageListItem_InstallationInfo `json:"installationInfo,omitempty"`
	Integration          *string                           `json:"integration,omitempty"`
	Internal             *bool                             `json:"internal,omitempty"`
	LatestVersion        *string                           `json:"latestVersion,omitempty"`
	Name                 string                            `json:"name"`
	Owner                *PackageListItem_Owner            `json:"owner,omitempty"`
	Path                 *string                           `json:"path,omitempty"`
	PolicyTemplates      *[]map[string]interface{}         `json:"policy_templates,omitempty"`
	Readme               *string                           `json:"readme,omitempty"`
	Release              *PackageListItemRelease           `json:"release,omitempty"`
	SignaturePath        *string                           `json:"signature_path,omitempty"`
	Source               *PackageListItem_Source           `json:"source,omitempty"`
	Status               *string                           `json:"status,omitempty"`
	Title                string                            `json:"title"`
	Type                 *PackageListItem_Type             `json:"type,omitempty"`
	Vars                 *[]map[string]interface{}         `json:"vars,omitempty"`
	Version              string                            `json:"version"`
	AdditionalProperties map[string]interface{}            `json:"-"`
}

// PackageListItem_Conditions_Elastic defines model for PackageListItem.Conditions.Elastic.
type PackageListItem_Conditions_Elastic struct {
	Capabilities         *[]string              `json:"capabilities,omitempty"`
	Subscription         *string                `json:"subscription,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageListItem_Conditions_Kibana defines model for PackageListItem.Conditions.Kibana.
type PackageListItem_Conditions_Kibana struct {
	Version              *string                `json:"version,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageListItem_Conditions defines model for PackageListItem.Conditions.
type PackageListItem_Conditions struct {
	Elastic              *PackageListItem_Conditions_Elastic `json:"elastic,omitempty"`
	Kibana               *PackageListItem_Conditions_Kibana  `json:"kibana,omitempty"`
	AdditionalProperties map[string]interface{}              `json:"-"`
}

// PackageListItem_Discovery_Datasets_Item defines model for PackageListItem.Discovery.Datasets.Item.
type PackageListItem_Discovery_Datasets_Item struct {
	Name                 string                 `json:"name"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageListItem_Discovery_Fields_Item defines model for PackageListItem.Discovery.Fields.Item.
type PackageListItem_Discovery_Fields_Item struct {
	Name                 string                 `json:"name"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageListItem_Discovery defines model for PackageListItem.Discovery.
type PackageListItem_Discovery struct {
	Datasets             *[]PackageListItem_Discovery_Datasets_Item `json:"datasets,omitempty"`
	Fields               *[]PackageListItem_Discovery_Fields_Item   `json:"fields,omitempty"`
	AdditionalProperties map[string]interface{}                     `json:"-"`
}

// PackageListItem_Icons_Item defines model for package_list_item.icons.Item.
type PackageListItem_Icons_Item struct {
	DarkMode             *bool                  `json:"dark_mode,omitempty"`
	Path                 *string                `json:"path,omitempty"`
	Size                 *string                `json:"size,omitempty"`
	Src                  string                 `json:"src"`
	Title                *string                `json:"title,omitempty"`
	Type                 *string                `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0 defines model for PackageListItem.InstallationInfo.AdditionalSpacesInstalledKibana.Type.0.
type PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0 string

// PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType1 defines model for .
type PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType1 = string

// PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Type defines model for PackageListItem.InstallationInfo.AdditionalSpacesInstalledKibana.Type.
type PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Type struct {
	union json.RawMessage
}

// PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item defines model for PackageListItem.InstallationInfo.AdditionalSpacesInstalledKibana.Item.
type PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item struct {
	Id                   string                                                                `json:"id"`
	OriginId             *string                                                               `json:"originId,omitempty"`
	Type                 PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Type `json:"type"`
	AdditionalProperties map[string]interface{}                                                `json:"-"`
}

// PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features defines model for PackageListItem.InstallationInfo.ExperimentalDataStreamFeatures.Features.
type PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features struct {
	DocValueOnlyNumeric  *bool                  `json:"doc_value_only_numeric,omitempty"`
	DocValueOnlyOther    *bool                  `json:"doc_value_only_other,omitempty"`
	SyntheticSource      *bool                  `json:"synthetic_source,omitempty"`
	Tsdb                 *bool                  `json:"tsdb,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item defines model for PackageListItem.InstallationInfo.ExperimentalDataStreamFeatures.Item.
type PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item struct {
	DataStream           string                                                                   `json:"data_stream"`
	Features             PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features `json:"features"`
	AdditionalProperties map[string]interface{}                                                   `json:"-"`
}

// PackageListItemInstallationInfoInstallSource defines model for PackageListItem.InstallationInfo.InstallSource.
type PackageListItemInstallationInfoInstallSource string

// PackageListItemInstallationInfoInstallStatus defines model for PackageListItem.InstallationInfo.InstallStatus.
type PackageListItemInstallationInfoInstallStatus string

// PackageListItemInstallationInfoInstalledEsType defines model for PackageListItem.InstallationInfo.InstalledEs.Type.
type PackageListItemInstallationInfoInstalledEsType string

// PackageListItem_InstallationInfo_InstalledEs_Item defines model for PackageListItem.InstallationInfo.InstalledEs.Item.
type PackageListItem_InstallationInfo_InstalledEs_Item struct {
	Deferred             *bool                                          `json:"deferred,omitempty"`
	Id                   string                                         `json:"id"`
	Type                 PackageListItemInstallationInfoInstalledEsType `json:"type"`
	Version              *string                                        `json:"version,omitempty"`
	AdditionalProperties map[string]interface{}                         `json:"-"`
}

// PackageListItemInstallationInfoInstalledKibanaType0 defines model for PackageListItem.InstallationInfo.InstalledKibana.Type.0.
type PackageListItemInstallationInfoInstalledKibanaType0 string

// PackageListItemInstallationInfoInstalledKibanaType1 defines model for .
type PackageListItemInstallationInfoInstalledKibanaType1 = string

// PackageListItem_InstallationInfo_InstalledKibana_Type defines model for PackageListItem.InstallationInfo.InstalledKibana.Type.
type PackageListItem_InstallationInfo_InstalledKibana_Type struct {
	union json.RawMessage
}

// PackageListItem_InstallationInfo_InstalledKibana_Item defines model for PackageListItem.InstallationInfo.InstalledKibana.Item.
type PackageListItem_InstallationInfo_InstalledKibana_Item struct {
	Id                   string                                                `json:"id"`
	OriginId             *string                                               `json:"originId,omitempty"`
	Type                 PackageListItem_InstallationInfo_InstalledKibana_Type `json:"type"`
	AdditionalProperties map[string]interface{}                                `json:"-"`
}

// PackageListItem_InstallationInfo_LatestExecutedState defines model for PackageListItem.InstallationInfo.LatestExecutedState.
type PackageListItem_InstallationInfo_LatestExecutedState struct {
	Error                *string                `json:"error,omitempty"`
	Name                 *string                `json:"name,omitempty"`
	StartedAt            *string                `json:"started_at,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error defines model for PackageListItem.InstallationInfo.LatestInstallFailedAttempts.Error.
type PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error struct {
	Message              string                 `json:"message"`
	Name                 string                 `json:"name"`
	Stack                *string                `json:"stack,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item defines model for PackageListItem.InstallationInfo.LatestInstallFailedAttempts.Item.
type PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item struct {
	CreatedAt            string                                                             `json:"created_at"`
	Error                PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error `json:"error"`
	TargetVersion        string                                                             `json:"target_version"`
	AdditionalProperties map[string]interface{}                                             `json:"-"`
}

// PackageListItemInstallationInfoVerificationStatus defines model for PackageListItem.InstallationInfo.VerificationStatus.
type PackageListItemInstallationInfoVerificationStatus string

// PackageListItem_InstallationInfo defines model for PackageListItem.InstallationInfo.
type PackageListItem_InstallationInfo struct {
	AdditionalSpacesInstalledKibana *map[string][]PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item `json:"additional_spaces_installed_kibana,omitempty"`
	CreatedAt                       *string                                                                             `json:"created_at,omitempty"`
	ExperimentalDataStreamFeatures  *[]PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item             `json:"experimental_data_stream_features,omitempty"`
	InstallFormatSchemaVersion      *string                                                                             `json:"install_format_schema_version,omitempty"`
	InstallSource                   PackageListItemInstallationInfoInstallSource                                        `json:"install_source"`
	InstallStatus                   PackageListItemInstallationInfoInstallStatus                                        `json:"install_status"`
	InstalledEs                     []PackageListItem_InstallationInfo_InstalledEs_Item                                 `json:"installed_es"`
	InstalledKibana                 []PackageListItem_InstallationInfo_InstalledKibana_Item                             `json:"installed_kibana"`
	InstalledKibanaSpaceId          *string                                                                             `json:"installed_kibana_space_id,omitempty"`
	LatestExecutedState             *PackageListItem_InstallationInfo_LatestExecutedState                               `json:"latest_executed_state,omitempty"`
	LatestInstallFailedAttempts     *[]PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item                `json:"latest_install_failed_attempts,omitempty"`
	Name                            string                                                                              `json:"name"`
	Namespaces                      *[]string                                                                           `json:"namespaces,omitempty"`
	PreviousVersion                 *string                                                                             `json:"previous_version,omitempty"`
	Type                            string                                                                              `json:"type"`
	UpdatedAt                       *string                                                                             `json:"updated_at,omitempty"`
	VerificationKeyId               *string                                                                             `json:"verification_key_id,omitempty"`
	VerificationStatus              PackageListItemInstallationInfoVerificationStatus                                   `json:"verification_status"`
	Version                         string                                                                              `json:"version"`
	AdditionalProperties            map[string]interface{}                                                              `json:"-"`
}

// PackageListItemOwnerType defines model for PackageListItem.Owner.Type.
type PackageListItemOwnerType string

// PackageListItem_Owner defines model for PackageListItem.Owner.
type PackageListItem_Owner struct {
	Github               *string                   `json:"github,omitempty"`
	Type                 *PackageListItemOwnerType `json:"type,omitempty"`
	AdditionalProperties map[string]interface{}    `json:"-"`
}

// PackageListItemRelease defines model for PackageListItem.Release.
type PackageListItemRelease string

// PackageListItem_Source defines model for PackageListItem.Source.
type PackageListItem_Source struct {
	License              string                 `json:"license"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageListItemType0 defines model for PackageListItem.Type.0.
type PackageListItemType0 string

// PackageListItemType1 defines model for PackageListItem.Type.1.
type PackageListItemType1 string

// PackageListItemType2 defines model for PackageListItem.Type.2.
type PackageListItemType2 string

// PackageListItemType3 defines model for .
type PackageListItemType3 = string

// PackageListItem_Type defines model for PackageListItem.Type.
type PackageListItem_Type struct {
	union json.RawMessage
}

// PackagePolicy defines model for package_policy.
type PackagePolicy struct {
	// AdditionalDatastreamsPermissions Additional datastream permissions, that will be added to the agent policy.
	AdditionalDatastreamsPermissions *[]string `json:"additional_datastreams_permissions,omitempty"`
	Agents                           *float32  `json:"agents,omitempty"`
	CreatedAt                        string    `json:"created_at"`
	CreatedBy                        string    `json:"created_by"`

	// Description Package policy description
	Description   *string                      `json:"description,omitempty"`
	Elasticsearch *PackagePolicy_Elasticsearch `json:"elasticsearch,omitempty"`
	Enabled       bool                         `json:"enabled"`
	Id            string                       `json:"id"`

	// Inputs Package policy inputs (see integration documentation to know what inputs are available)
	Inputs    map[string]PackagePolicyInput `json:"inputs"`
	IsManaged *bool                         `json:"is_managed,omitempty"`

	// Name Package policy name (should be unique)
	Name string `json:"name"`

	// Namespace The package policy namespace. Leave blank to inherit the agent policy's namespace.
	Namespace *string `json:"namespace,omitempty"`
	OutputId  *string `json:"output_id,omitempty"`

	// Overrides Override settings that are defined in the package policy. The override option should be used only in unusual circumstances and not as a routine procedure.
	Overrides *struct {
		Inputs *map[string]interface{} `json:"inputs,omitempty"`
	} `json:"overrides,omitempty"`
	Package *struct {
		ExperimentalDataStreamFeatures *[]struct {
			DataStream string `json:"data_stream"`
			Features   struct {
				DocValueOnlyNumeric *bool `json:"doc_value_only_numeric,omitempty"`
				DocValueOnlyOther   *bool `json:"doc_value_only_other,omitempty"`
				SyntheticSource     *bool `json:"synthetic_source,omitempty"`
				Tsdb                *bool `json:"tsdb,omitempty"`
			} `json:"features"`
		} `json:"experimental_data_stream_features,omitempty"`

		// Name Package name
		Name         string  `json:"name"`
		RequiresRoot *bool   `json:"requires_root,omitempty"`
		Title        *string `json:"title,omitempty"`

		// Version Package version
		Version string `json:"version"`
	} `json:"package,omitempty"`

	// PolicyId Agent policy ID where that package policy will be added
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	PolicyId         *string                   `json:"policy_id,omitempty"`
	PolicyIds        *[]string                 `json:"policy_ids,omitempty"`
	Revision         float32                   `json:"revision"`
	SecretReferences *[]PackagePolicySecretRef `json:"secret_references,omitempty"`
	SpaceIds         *[]string                 `json:"spaceIds,omitempty"`

	// SupportsAgentless Indicates whether the package policy belongs to an agentless agent policy.
	SupportsAgentless *bool                   `json:"supports_agentless,omitempty"`
	UpdatedAt         string                  `json:"updated_at"`
	UpdatedBy         string                  `json:"updated_by"`
	Vars              *map[string]interface{} `json:"vars,omitempty"`
	Version           *string                 `json:"version,omitempty"`
}

// PackagePolicy_Elasticsearch_Privileges defines model for PackagePolicy.Elasticsearch.Privileges.
type PackagePolicy_Elasticsearch_Privileges struct {
	Cluster              *[]string              `json:"cluster,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackagePolicy_Elasticsearch defines model for PackagePolicy.Elasticsearch.
type PackagePolicy_Elasticsearch struct {
	Privileges           *PackagePolicy_Elasticsearch_Privileges `json:"privileges,omitempty"`
	AdditionalProperties map[string]interface{}                  `json:"-"`
}

// PackagePolicyInput defines model for package_policy_input.
type PackagePolicyInput struct {
	// Enabled enable or disable that input, (default to true)
	Enabled *bool `json:"enabled,omitempty"`

	// Streams Input streams (see integration documentation to know what streams are available)
	Streams *map[string]PackagePolicyInputStream `json:"streams,omitempty"`
	Vars    *map[string]interface{}              `json:"vars,omitempty"`
}

// PackagePolicyInputStream defines model for package_policy_input_stream.
type PackagePolicyInputStream struct {
	// Enabled enable or disable that stream, (default to true)
	Enabled *bool                   `json:"enabled,omitempty"`
	Vars    *map[string]interface{} `json:"vars,omitempty"`
}

// PackagePolicyRequest defines model for package_policy_request.
type PackagePolicyRequest struct {
	// AdditionalDatastreamsPermissions Additional datastream permissions, that will be added to the agent policy.
	AdditionalDatastreamsPermissions *[]string `json:"additional_datastreams_permissions,omitempty"`
	Description                      *string   `json:"description,omitempty"`
	Force                            *bool     `json:"force,omitempty"`
	Id                               *string   `json:"id,omitempty"`

	// Inputs Package policy inputs (see integration documentation to know what inputs are available)
	Inputs    *map[string]PackagePolicyRequestInput `json:"inputs,omitempty"`
	Name      string                                `json:"name"`
	Namespace *string                               `json:"namespace,omitempty"`
	OutputId  *string                               `json:"output_id,omitempty"`
	Package   PackagePolicyRequestPackage           `json:"package"`
	PolicyId  *string                               `json:"policy_id,omitempty"`
	PolicyIds *[]string                             `json:"policy_ids,omitempty"`

	// SupportsAgentless Indicates whether the package policy belongs to an agentless agent policy.
	SupportsAgentless *bool                   `json:"supports_agentless,omitempty"`
	Vars              *map[string]interface{} `json:"vars,omitempty"`
}

// PackagePolicyRequestInput defines model for package_policy_request_input.
type PackagePolicyRequestInput struct {
	// Enabled enable or disable that input, (default to true)
	Enabled *bool `json:"enabled,omitempty"`

	// Streams Input streams (see integration documentation to know what streams are available)
	Streams *map[string]PackagePolicyRequestInputStream `json:"streams,omitempty"`
	Vars    *map[string]interface{}                     `json:"vars,omitempty"`
}

// PackagePolicyRequestInputStream defines model for package_policy_request_input_stream.
type PackagePolicyRequestInputStream struct {
	// Enabled enable or disable that stream, (default to true)
	Enabled *bool                   `json:"enabled,omitempty"`
	Vars    *map[string]interface{} `json:"vars,omitempty"`
}

// PackagePolicyRequestPackage defines model for package_policy_request_package.
type PackagePolicyRequestPackage struct {
	ExperimentalDataStreamFeatures *[]struct {
		DataStream string `json:"data_stream"`
		Features   struct {
			DocValueOnlyNumeric *bool `json:"doc_value_only_numeric,omitempty"`
			DocValueOnlyOther   *bool `json:"doc_value_only_other,omitempty"`
			SyntheticSource     *bool `json:"synthetic_source,omitempty"`
			Tsdb                *bool `json:"tsdb,omitempty"`
		} `json:"features"`
	} `json:"experimental_data_stream_features,omitempty"`

	// Name Package name
	Name         string  `json:"name"`
	RequiresRoot *bool   `json:"requires_root,omitempty"`
	Title        *string `json:"title,omitempty"`

	// Version Package version
	Version string `json:"version"`
}

// PackagePolicySecretRef defines model for package_policy_secret_ref.
type PackagePolicySecretRef struct {
	Id string `json:"id"`
}

// PagerdutyConfig Defines properties for connectors when type is `.pagerduty`.
type PagerdutyConfig struct {
	// ApiUrl The PagerDuty event URL.
	ApiUrl *string `json:"apiUrl,omitempty"`
}

// PagerdutySecrets Defines secrets for connectors when type is `.pagerduty`.
type PagerdutySecrets struct {
	// RoutingKey A 32 character PagerDuty Integration Key for an integration on a service.
	RoutingKey string `json:"routingKey"`
}

// Pfx If `authType` is `webhook-authentication-ssl` and `certType` is `ssl-pfx`, it is a base64 encoded version of the PFX or P12 file.
type Pfx = string

// ResilientConfig Defines properties for connectors when type is `.resilient`.
type ResilientConfig struct {
	// ApiUrl The IBM Resilient instance URL.
	ApiUrl string `json:"apiUrl"`

	// OrgId The IBM Resilient organization ID.
	OrgId string `json:"orgId"`
}

// ResilientSecrets Defines secrets for connectors when type is `.resilient`.
type ResilientSecrets struct {
	// ApiKeyId The authentication key ID for HTTP Basic authentication.
	ApiKeyId string `json:"apiKeyId"`

	// ApiKeySecret The authentication key secret for HTTP Basic authentication.
	ApiKeySecret string `json:"apiKeySecret"`
}

// SentineloneConfig Defines properties for connectors when type is `.sentinelone`.
type SentineloneConfig struct {
	// Url The SentinelOne tenant URL. If you are using the `xpack.actions.allowedHosts` setting, add the hostname to the allowed hosts.
	Url string `json:"url"`
}

// SentineloneSecrets Defines secrets for connectors when type is `.sentinelone`.
type SentineloneSecrets struct {
	// Token The A SentinelOne API token.
	Token string `json:"token"`
}

// ServerHost defines model for server_host.
type ServerHost struct {
	HostUrls        []string `json:"host_urls"`
	Id              string   `json:"id"`
	IsDefault       *bool    `json:"is_default,omitempty"`
	IsInternal      *bool    `json:"is_internal,omitempty"`
	IsPreconfigured *bool    `json:"is_preconfigured,omitempty"`
	Name            string   `json:"name"`
	ProxyId         *string  `json:"proxy_id,omitempty"`
	Secrets         *struct {
		Ssl *struct {
			EsKey *ServerHost_Secrets_Ssl_EsKey `json:"es_key,omitempty"`
			Key   *ServerHost_Secrets_Ssl_Key   `json:"key,omitempty"`
		} `json:"ssl,omitempty"`
	} `json:"secrets,omitempty"`
	Ssl *struct {
		Certificate              *string                  `json:"certificate,omitempty"`
		CertificateAuthorities   *[]string                `json:"certificate_authorities,omitempty"`
		ClientAuth               *ServerHostSslClientAuth `json:"client_auth,omitempty"`
		EsCertificate            *string                  `json:"es_certificate,omitempty"`
		EsCertificateAuthorities *[]string                `json:"es_certificate_authorities,omitempty"`
		EsKey                    *string                  `json:"es_key,omitempty"`
		Key                      *string                  `json:"key,omitempty"`
	} `json:"ssl,omitempty"`
}

// ServerHostSecretsSslEsKey0 defines model for .
type ServerHostSecretsSslEsKey0 struct {
	Id string `json:"id"`
}

// ServerHostSecretsSslEsKey1 defines model for .
type ServerHostSecretsSslEsKey1 = string

// ServerHost_Secrets_Ssl_EsKey defines model for ServerHost.Secrets.Ssl.EsKey.
type ServerHost_Secrets_Ssl_EsKey struct {
	union json.RawMessage
}

// ServerHostSecretsSslKey0 defines model for .
type ServerHostSecretsSslKey0 struct {
	Id string `json:"id"`
}

// ServerHostSecretsSslKey1 defines model for .
type ServerHostSecretsSslKey1 = string

// ServerHost_Secrets_Ssl_Key defines model for ServerHost.Secrets.Ssl.Key.
type ServerHost_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// ServerHostSslClientAuth defines model for ServerHost.Ssl.ClientAuth.
type ServerHostSslClientAuth string

// ServicenowConfig Defines properties for connectors when type is `.servicenow`.
type ServicenowConfig struct {
	// ApiUrl The ServiceNow instance URL.
	ApiUrl string `json:"apiUrl"`

	// ClientId The client ID assigned to your OAuth application. This property is required when `isOAuth` is `true`.
	ClientId *string `json:"clientId,omitempty"`

	// IsOAuth The type of authentication to use. The default value is false, which means basic authentication is used instead of open authorization (OAuth).
	IsOAuth *bool `json:"isOAuth,omitempty"`

	// JwtKeyId The key identifier assigned to the JWT verifier map of your OAuth application. This property is required when `isOAuth` is `true`.
	JwtKeyId *string `json:"jwtKeyId,omitempty"`

	// UserIdentifierValue The identifier to use for OAuth authentication. This identifier should be the user field you selected when you created an OAuth JWT API endpoint for external clients in your ServiceNow instance. For example, if the selected user field is `Email`, the user identifier should be the user's email address. This property is required when `isOAuth` is `true`.
	UserIdentifierValue *string `json:"userIdentifierValue,omitempty"`

	// UsesTableApi Determines whether the connector uses the Table API or the Import Set API. This property is supported only for ServiceNow ITSM and ServiceNow SecOps connectors.  NOTE: If this property is set to `false`, the Elastic application should be installed in ServiceNow.
	UsesTableApi *bool `json:"usesTableApi,omitempty"`
}

// ServicenowItomConfig Defines properties for connectors when type is `.servicenow-itom`.
type ServicenowItomConfig struct {
	// ApiUrl The ServiceNow instance URL.
	ApiUrl string `json:"apiUrl"`

	// ClientId The client ID assigned to your OAuth application. This property is required when `isOAuth` is `true`.
	ClientId *string `json:"clientId,omitempty"`

	// IsOAuth The type of authentication to use. The default value is false, which means basic authentication is used instead of open authorization (OAuth).
	IsOAuth *bool `json:"isOAuth,omitempty"`

	// JwtKeyId The key identifier assigned to the JWT verifier map of your OAuth application. This property is required when `isOAuth` is `true`.
	JwtKeyId *string `json:"jwtKeyId,omitempty"`

	// UserIdentifierValue The identifier to use for OAuth authentication. This identifier should be the user field you selected when you created an OAuth JWT API endpoint for external clients in your ServiceNow instance. For example, if the selected user field is `Email`, the user identifier should be the user's email address. This property is required when `isOAuth` is `true`.
	UserIdentifierValue *string `json:"userIdentifierValue,omitempty"`
}

// ServicenowSecrets Defines secrets for connectors when type is `.servicenow`, `.servicenow-sir`, or `.servicenow-itom`.
type ServicenowSecrets struct {
	// ClientSecret The client secret assigned to your OAuth application. This property is required when `isOAuth` is `true`.
	ClientSecret *string `json:"clientSecret,omitempty"`

	// Password The password for HTTP basic authentication. This property is required when `isOAuth` is `false`.
	Password *string `json:"password,omitempty"`

	// PrivateKey The RSA private key that you created for use in ServiceNow. This property is required when `isOAuth` is `true`.
	PrivateKey *string `json:"privateKey,omitempty"`

	// PrivateKeyPassword The password for the RSA private key. This property is required when `isOAuth` is `true` and you set a password on your private key.
	PrivateKeyPassword *string `json:"privateKeyPassword,omitempty"`

	// Username The username for HTTP basic authentication. This property is required when `isOAuth` is `false`.
	Username *string `json:"username,omitempty"`
}

// SlackApiConfig Defines properties for connectors when type is `.slack_api`.
type SlackApiConfig struct {
	// AllowedChannels A list of valid Slack channels.
	AllowedChannels *[]struct {
		// Id The Slack channel ID.
		Id string `json:"id"`

		// Name The Slack channel name.
		Name string `json:"name"`
	} `json:"allowedChannels,omitempty"`
}

// SlackApiSecrets Defines secrets for connectors when type is `.slack`.
type SlackApiSecrets struct {
	// Token Slack bot user OAuth token.
	Token string `json:"token"`
}

// SwimlaneConfig Defines properties for connectors when type is `.swimlane`.
type SwimlaneConfig struct {
	// ApiUrl The Swimlane instance URL.
	ApiUrl string `json:"apiUrl"`

	// AppId The Swimlane application ID.
	AppId string `json:"appId"`

	// ConnectorType The type of connector. Valid values are `all`, `alerts`, and `cases`.
	ConnectorType SwimlaneConfigConnectorType `json:"connectorType"`

	// Mappings The field mapping.
	Mappings *struct {
		// AlertIdConfig Mapping for the alert ID.
		AlertIdConfig *struct {
			// FieldType The type of field in Swimlane.
			FieldType string `json:"fieldType"`

			// Id The identifier for the field in Swimlane.
			Id string `json:"id"`

			// Key The key for the field in Swimlane.
			Key string `json:"key"`

			// Name The name of the field in Swimlane.
			Name string `json:"name"`
		} `json:"alertIdConfig,omitempty"`

		// CaseIdConfig Mapping for the case ID.
		CaseIdConfig *struct {
			// FieldType The type of field in Swimlane.
			FieldType string `json:"fieldType"`

			// Id The identifier for the field in Swimlane.
			Id string `json:"id"`

			// Key The key for the field in Swimlane.
			Key string `json:"key"`

			// Name The name of the field in Swimlane.
			Name string `json:"name"`
		} `json:"caseIdConfig,omitempty"`

		// CaseNameConfig Mapping for the case name.
		CaseNameConfig *struct {
			// FieldType The type of field in Swimlane.
			FieldType string `json:"fieldType"`

			// Id The identifier for the field in Swimlane.
			Id string `json:"id"`

			// Key The key for the field in Swimlane.
			Key string `json:"key"`

			// Name The name of the field in Swimlane.
			Name string `json:"name"`
		} `json:"caseNameConfig,omitempty"`

		// CommentsConfig Mapping for the case comments.
		CommentsConfig *struct {
			// FieldType The type of field in Swimlane.
			FieldType string `json:"fieldType"`

			// Id The identifier for the field in Swimlane.
			Id string `json:"id"`

			// Key The key for the field in Swimlane.
			Key string `json:"key"`

			// Name The name of the field in Swimlane.
			Name string `json:"name"`
		} `json:"commentsConfig,omitempty"`

		// DescriptionConfig Mapping for the case description.
		DescriptionConfig *struct {
			// FieldType The type of field in Swimlane.
			FieldType string `json:"fieldType"`

			// Id The identifier for the field in Swimlane.
			Id string `json:"id"`

			// Key The key for the field in Swimlane.
			Key string `json:"key"`

			// Name The name of the field in Swimlane.
			Name string `json:"name"`
		} `json:"descriptionConfig,omitempty"`

		// RuleNameConfig Mapping for the name of the alert's rule.
		RuleNameConfig *struct {
			// FieldType The type of field in Swimlane.
			FieldType string `json:"fieldType"`

			// Id The identifier for the field in Swimlane.
			Id string `json:"id"`

			// Key The key for the field in Swimlane.
			Key string `json:"key"`

			// Name The name of the field in Swimlane.
			Name string `json:"name"`
		} `json:"ruleNameConfig,omitempty"`

		// SeverityConfig Mapping for the severity.
		SeverityConfig *struct {
			// FieldType The type of field in Swimlane.
			FieldType string `json:"fieldType"`

			// Id The identifier for the field in Swimlane.
			Id string `json:"id"`

			// Key The key for the field in Swimlane.
			Key string `json:"key"`

			// Name The name of the field in Swimlane.
			Name string `json:"name"`
		} `json:"severityConfig,omitempty"`
	} `json:"mappings,omitempty"`
}

// SwimlaneConfigConnectorType The type of connector. Valid values are `all`, `alerts`, and `cases`.
type SwimlaneConfigConnectorType string

// SwimlaneSecrets Defines secrets for connectors when type is `.swimlane`.
type SwimlaneSecrets struct {
	// ApiToken Swimlane API authentication token.
	ApiToken *string `json:"apiToken,omitempty"`
}

// TeamsSecrets Defines secrets for connectors when type is `.teams`.
type TeamsSecrets struct {
	// WebhookUrl The URL of the incoming webhook. If you are using the `xpack.actions.allowedHosts` setting, add the hostname to the allowed hosts.
	WebhookUrl string `json:"webhookUrl"`
}

// ThehiveConfig Defines configuration properties for connectors when type is `.thehive`.
type ThehiveConfig struct {
	// Organisation The organisation in TheHive that will contain the alerts or cases. By default, the connector uses the default organisation of the user account that created the API key.
	Organisation *string `json:"organisation,omitempty"`

	// Url The instance URL in TheHive. If you are using the `xpack.actions.allowedHosts` setting, add the hostname to the allowed hosts.
	Url string `json:"url"`
}

// ThehiveSecrets Defines secrets for connectors when type is `.thehive`.
type ThehiveSecrets struct {
	// ApiKey The API key for authentication in TheHive.
	ApiKey string `json:"apiKey"`
}

// TinesConfig Defines properties for connectors when type is `.tines`.
type TinesConfig struct {
	// Url The Tines tenant URL. If you are using the `xpack.actions.allowedHosts` setting, make sure this hostname is added to the allowed hosts.
	Url string `json:"url"`
}

// TinesSecrets Defines secrets for connectors when type is `.tines`.
type TinesSecrets struct {
	// Email The email used to sign in to Tines.
	Email string `json:"email"`

	// Token The Tines API token.
	Token string `json:"token"`
}

// TorqConfig Defines properties for connectors when type is `.torq`.
type TorqConfig struct {
	// WebhookIntegrationUrl The endpoint URL of the Elastic Security integration in Torq.
	WebhookIntegrationUrl string `json:"webhookIntegrationUrl"`
}

// TorqSecrets Defines secrets for connectors when type is `.torq`.
type TorqSecrets struct {
	// Token The secret of the webhook authentication header.
	Token string `json:"token"`
}

// UpdateConnectorConfig The connector configuration details.
type UpdateConnectorConfig struct {
	AdditionalProperties map[string]interface{} `json:"-"`
	union                json.RawMessage
}

// UpdateConnectorSecrets defines model for update_connector_secrets.
type UpdateConnectorSecrets struct {
	AdditionalProperties map[string]interface{} `json:"-"`
	union                json.RawMessage
}

// UpdateOutputElasticsearch defines model for update_output_elasticsearch.
type UpdateOutputElasticsearch struct {
	AllowEdit            *[]string                        `json:"allow_edit,omitempty"`
	CaSha256             *string                          `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                          `json:"ca_trusted_fingerprint,omitempty"`
	ConfigYaml           *string                          `json:"config_yaml,omitempty"`
	Hosts                *[]string                        `json:"hosts,omitempty"`
	IsDefault            *bool                            `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                            `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                            `json:"is_internal,omitempty"`
	IsPreconfigured      *bool                            `json:"is_preconfigured,omitempty"`
	Name                 *string                          `json:"name,omitempty"`
	Preset               *UpdateOutputElasticsearchPreset `json:"preset,omitempty"`
	ProxyId              *string                          `json:"proxy_id,omitempty"`
	Secrets              *struct {
		Ssl *struct {
			Key *UpdateOutputElasticsearch_Secrets_Ssl_Key `json:"key,omitempty"`
		} `json:"ssl,omitempty"`
	} `json:"secrets,omitempty"`
	Shipper            *UpdateOutputShipper           `json:"shipper,omitempty"`
	Ssl                *UpdateOutputSsl               `json:"ssl,omitempty"`
	Type               *UpdateOutputElasticsearchType `json:"type,omitempty"`
	WriteToLogsStreams *bool                          `json:"write_to_logs_streams,omitempty"`
}

// UpdateOutputElasticsearchPreset defines model for UpdateOutputElasticsearch.Preset.
type UpdateOutputElasticsearchPreset string

// UpdateOutputElasticsearchSecretsSslKey0 defines model for .
type UpdateOutputElasticsearchSecretsSslKey0 struct {
	Id string `json:"id"`
}

// UpdateOutputElasticsearchSecretsSslKey1 defines model for .
type UpdateOutputElasticsearchSecretsSslKey1 = string

// UpdateOutputElasticsearch_Secrets_Ssl_Key defines model for UpdateOutputElasticsearch.Secrets.Ssl.Key.
type UpdateOutputElasticsearch_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// UpdateOutputElasticsearchType defines model for UpdateOutputElasticsearch.Type.
type UpdateOutputElasticsearchType string

// UpdateOutputKafka defines model for update_output_kafka.
type UpdateOutputKafka struct {
	AllowEdit            *[]string                     `json:"allow_edit,omitempty"`
	AuthType             *UpdateOutputKafkaAuthType    `json:"auth_type,omitempty"`
	BrokerTimeout        *float32                      `json:"broker_timeout,omitempty"`
	CaSha256             *string                       `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                       `json:"ca_trusted_fingerprint,omitempty"`
	ClientId             *string                       `json:"client_id,omitempty"`
	Compression          *UpdateOutputKafkaCompression `json:"compression,omitempty"`
	CompressionLevel     interface{}                   `json:"compression_level"`
	ConfigYaml           *string                       `json:"config_yaml,omitempty"`
	ConnectionType       interface{}                   `json:"connection_type"`
	Hash                 *struct {
		Hash   *string `json:"hash,omitempty"`
		Random *bool   `json:"random,omitempty"`
	} `json:"hash,omitempty"`
	Headers *[]struct {
		Key   string `json:"key"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Hosts               *[]string                   `json:"hosts,omitempty"`
	IsDefault           *bool                       `json:"is_default,omitempty"`
	IsDefaultMonitoring *bool                       `json:"is_default_monitoring,omitempty"`
	IsInternal          *bool                       `json:"is_internal,omitempty"`
	IsPreconfigured     *bool                       `json:"is_preconfigured,omitempty"`
	Key                 *string                     `json:"key,omitempty"`
	Name                string                      `json:"name"`
	Partition           *UpdateOutputKafkaPartition `json:"partition,omitempty"`
	Password            interface{}                 `json:"password"`
	ProxyId             *string                     `json:"proxy_id,omitempty"`
	Random              *struct {
		GroupEvents *float32 `json:"group_events,omitempty"`
	} `json:"random,omitempty"`
	RequiredAcks *UpdateOutputKafkaRequiredAcks `json:"required_acks,omitempty"`
	RoundRobin   *struct {
		GroupEvents *float32 `json:"group_events,omitempty"`
	} `json:"round_robin,omitempty"`
	Sasl *struct {
		Mechanism *UpdateOutputKafkaSaslMechanism `json:"mechanism,omitempty"`
	} `json:"sasl,omitempty"`
	Secrets *struct {
		Password *UpdateOutputKafka_Secrets_Password `json:"password,omitempty"`
		Ssl      *struct {
			Key UpdateOutputKafka_Secrets_Ssl_Key `json:"key"`
		} `json:"ssl,omitempty"`
	} `json:"secrets,omitempty"`
	Shipper            *UpdateOutputShipper   `json:"shipper,omitempty"`
	Ssl                *UpdateOutputSsl       `json:"ssl,omitempty"`
	Timeout            *float32               `json:"timeout,omitempty"`
	Topic              *string                `json:"topic,omitempty"`
	Type               *UpdateOutputKafkaType `json:"type,omitempty"`
	Username           interface{}            `json:"username"`
	Version            *string                `json:"version,omitempty"`
	WriteToLogsStreams *bool                  `json:"write_to_logs_streams,omitempty"`
}

// UpdateOutputKafkaAuthType defines model for UpdateOutputKafka.AuthType.
type UpdateOutputKafkaAuthType string

// UpdateOutputKafkaCompression defines model for UpdateOutputKafka.Compression.
type UpdateOutputKafkaCompression string

// UpdateOutputKafkaPartition defines model for UpdateOutputKafka.Partition.
type UpdateOutputKafkaPartition string

// UpdateOutputKafkaRequiredAcks defines model for UpdateOutputKafka.RequiredAcks.
type UpdateOutputKafkaRequiredAcks int

// UpdateOutputKafkaSaslMechanism defines model for UpdateOutputKafka.Sasl.Mechanism.
type UpdateOutputKafkaSaslMechanism string

// UpdateOutputKafkaSecretsPassword0 defines model for .
type UpdateOutputKafkaSecretsPassword0 struct {
	Id string `json:"id"`
}

// UpdateOutputKafkaSecretsPassword1 defines model for .
type UpdateOutputKafkaSecretsPassword1 = string

// UpdateOutputKafka_Secrets_Password defines model for UpdateOutputKafka.Secrets.Password.
type UpdateOutputKafka_Secrets_Password struct {
	union json.RawMessage
}

// UpdateOutputKafkaSecretsSslKey0 defines model for .
type UpdateOutputKafkaSecretsSslKey0 struct {
	Id string `json:"id"`
}

// UpdateOutputKafkaSecretsSslKey1 defines model for .
type UpdateOutputKafkaSecretsSslKey1 = string

// UpdateOutputKafka_Secrets_Ssl_Key defines model for UpdateOutputKafka.Secrets.Ssl.Key.
type UpdateOutputKafka_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// UpdateOutputKafkaType defines model for UpdateOutputKafka.Type.
type UpdateOutputKafkaType string

// UpdateOutputLogstash defines model for update_output_logstash.
type UpdateOutputLogstash struct {
	AllowEdit            *[]string `json:"allow_edit,omitempty"`
	CaSha256             *string   `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string   `json:"ca_trusted_fingerprint,omitempty"`
	ConfigYaml           *string   `json:"config_yaml,omitempty"`
	Hosts                *[]string `json:"hosts,omitempty"`
	IsDefault            *bool     `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool     `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool     `json:"is_internal,omitempty"`
	IsPreconfigured      *bool     `json:"is_preconfigured,omitempty"`
	Name                 *string   `json:"name,omitempty"`
	ProxyId              *string   `json:"proxy_id,omitempty"`
	Secrets              *struct {
		Ssl *struct {
			Key *UpdateOutputLogstash_Secrets_Ssl_Key `json:"key,omitempty"`
		} `json:"ssl,omitempty"`
	} `json:"secrets,omitempty"`
	Shipper            *UpdateOutputShipper      `json:"shipper,omitempty"`
	Ssl                *UpdateOutputSsl          `json:"ssl,omitempty"`
	Type               *UpdateOutputLogstashType `json:"type,omitempty"`
	WriteToLogsStreams *bool                     `json:"write_to_logs_streams,omitempty"`
}

// UpdateOutputLogstashSecretsSslKey0 defines model for .
type UpdateOutputLogstashSecretsSslKey0 struct {
	Id string `json:"id"`
}

// UpdateOutputLogstashSecretsSslKey1 defines model for .
type UpdateOutputLogstashSecretsSslKey1 = string

// UpdateOutputLogstash_Secrets_Ssl_Key defines model for UpdateOutputLogstash.Secrets.Ssl.Key.
type UpdateOutputLogstash_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// UpdateOutputLogstashType defines model for UpdateOutputLogstash.Type.
type UpdateOutputLogstashType string

// UpdateOutputRemoteElasticsearch defines model for update_output_remote_elasticsearch.
type UpdateOutputRemoteElasticsearch struct {
	AllowEdit            *[]string                              `json:"allow_edit,omitempty"`
	CaSha256             *string                                `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                                `json:"ca_trusted_fingerprint,omitempty"`
	ConfigYaml           *string                                `json:"config_yaml,omitempty"`
	Hosts                *[]string                              `json:"hosts,omitempty"`
	IsDefault            *bool                                  `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                                  `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                                  `json:"is_internal,omitempty"`
	IsPreconfigured      *bool                                  `json:"is_preconfigured,omitempty"`
	KibanaApiKey         *string                                `json:"kibana_api_key,omitempty"`
	KibanaUrl            *string                                `json:"kibana_url,omitempty"`
	Name                 *string                                `json:"name,omitempty"`
	Preset               *UpdateOutputRemoteElasticsearchPreset `json:"preset,omitempty"`
	ProxyId              *string                                `json:"proxy_id,omitempty"`
	Secrets              *struct {
		ServiceToken *UpdateOutputRemoteElasticsearch_Secrets_ServiceToken `json:"service_token,omitempty"`
		Ssl          *struct {
			Key *UpdateOutputRemoteElasticsearch_Secrets_Ssl_Key `json:"key,omitempty"`
		} `json:"ssl,omitempty"`
	} `json:"secrets,omitempty"`
	ServiceToken                *string                              `json:"service_token,omitempty"`
	Shipper                     *UpdateOutputShipper                 `json:"shipper,omitempty"`
	Ssl                         *UpdateOutputSsl                     `json:"ssl,omitempty"`
	SyncIntegrations            *bool                                `json:"sync_integrations,omitempty"`
	SyncUninstalledIntegrations *bool                                `json:"sync_uninstalled_integrations,omitempty"`
	Type                        *UpdateOutputRemoteElasticsearchType `json:"type,omitempty"`
	WriteToLogsStreams          *bool                                `json:"write_to_logs_streams,omitempty"`
}

// UpdateOutputRemoteElasticsearchPreset defines model for UpdateOutputRemoteElasticsearch.Preset.
type UpdateOutputRemoteElasticsearchPreset string

// UpdateOutputRemoteElasticsearchSecretsServiceToken0 defines model for .
type UpdateOutputRemoteElasticsearchSecretsServiceToken0 struct {
	Id string `json:"id"`
}

// UpdateOutputRemoteElasticsearchSecretsServiceToken1 defines model for .
type UpdateOutputRemoteElasticsearchSecretsServiceToken1 = string

// UpdateOutputRemoteElasticsearch_Secrets_ServiceToken defines model for UpdateOutputRemoteElasticsearch.Secrets.ServiceToken.
type UpdateOutputRemoteElasticsearch_Secrets_ServiceToken struct {
	union json.RawMessage
}

// UpdateOutputRemoteElasticsearchSecretsSslKey0 defines model for .
type UpdateOutputRemoteElasticsearchSecretsSslKey0 struct {
	Id string `json:"id"`
}

// UpdateOutputRemoteElasticsearchSecretsSslKey1 defines model for .
type UpdateOutputRemoteElasticsearchSecretsSslKey1 = string

// UpdateOutputRemoteElasticsearch_Secrets_Ssl_Key defines model for UpdateOutputRemoteElasticsearch.Secrets.Ssl.Key.
type UpdateOutputRemoteElasticsearch_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// UpdateOutputRemoteElasticsearchType defines model for UpdateOutputRemoteElasticsearch.Type.
type UpdateOutputRemoteElasticsearchType string

// UpdateOutputShipper defines model for update_output_shipper.
type UpdateOutputShipper struct {
	CompressionLevel            *float32 `json:"compression_level,omitempty"`
	DiskQueueCompressionEnabled *bool    `json:"disk_queue_compression_enabled,omitempty"`
	DiskQueueEnabled            *bool    `json:"disk_queue_enabled,omitempty"`
	DiskQueueEncryptionEnabled  *bool    `json:"disk_queue_encryption_enabled,omitempty"`
	DiskQueueMaxSize            *float32 `json:"disk_queue_max_size,omitempty"`
	DiskQueuePath               *string  `json:"disk_queue_path,omitempty"`
	Loadbalance                 *bool    `json:"loadbalance,omitempty"`
	MaxBatchBytes               *float32 `json:"max_batch_bytes,omitempty"`
	MemQueueEvents              *float32 `json:"mem_queue_events,omitempty"`
	QueueFlushTimeout           *float32 `json:"queue_flush_timeout,omitempty"`
}

// UpdateOutputSsl defines model for update_output_ssl.
type UpdateOutputSsl struct {
	Certificate            *string                          `json:"certificate,omitempty"`
	CertificateAuthorities *[]string                        `json:"certificate_authorities,omitempty"`
	Key                    *string                          `json:"key,omitempty"`
	VerificationMode       *UpdateOutputSslVerificationMode `json:"verification_mode,omitempty"`
}

// UpdateOutputSslVerificationMode defines model for UpdateOutputSsl.VerificationMode.
type UpdateOutputSslVerificationMode string

// UpdateOutputUnion defines model for update_output_union.
type UpdateOutputUnion struct {
	union json.RawMessage
}

// VerificationMode Controls the verification of certificates. Use `full` to validate that the certificate has an issue date within the `not_before` and `not_after` dates, chains to a trusted certificate authority (CA), and has a hostname or IP address that matches the names within the certificate. Use `certificate` to validate the certificate and verify that it is signed by a trusted authority; this option does not check the certificate hostname. Use `none` to skip certificate validation.
type VerificationMode string

// WebhookConfig Defines properties for connectors when type is `.webhook`.
type WebhookConfig struct {
	// AuthType The type of authentication to use: basic, SSL, or none.
	AuthType *AuthType `json:"authType,omitempty"`

	// Ca A base64 encoded version of the certificate authority file that the connector can trust to sign and validate certificates. This option is available for all authentication types.
	Ca *Ca `json:"ca,omitempty"`

	// CertType If the `authType` is `webhook-authentication-ssl`, specifies whether the certificate authentication data is in a CRT and key file format or a PFX file format.
	CertType *CertType `json:"certType,omitempty"`

	// HasAuth If true, a username and password for login type authentication must be provided.
	HasAuth *HasAuth `json:"hasAuth,omitempty"`

	// Headers A set of key-value pairs sent as headers with the request.
	Headers *map[string]interface{} `json:"headers,omitempty"`

	// Method The HTTP request method, either `post` or `put`.
	Method *WebhookConfigMethod `json:"method,omitempty"`

	// Url The request URL. If you are using the `xpack.actions.allowedHosts` setting, add the hostname to the allowed hosts.
	Url *string `json:"url,omitempty"`

	// VerificationMode Controls the verification of certificates. Use `full` to validate that the certificate has an issue date within the `not_before` and `not_after` dates, chains to a trusted certificate authority (CA), and has a hostname or IP address that matches the names within the certificate. Use `certificate` to validate the certificate and verify that it is signed by a trusted authority; this option does not check the certificate hostname. Use `none` to skip certificate validation.
	VerificationMode *VerificationMode `json:"verificationMode,omitempty"`
}

// WebhookConfigMethod The HTTP request method, either `post` or `put`.
type WebhookConfigMethod string

// WebhookSecrets Defines secrets for connectors when type is `.webhook`.
type WebhookSecrets struct {
	// Crt If `authType` is `webhook-authentication-ssl` and `certType` is `ssl-crt-key`, it is a base64 encoded version of the CRT or CERT file.
	Crt *Crt `json:"crt,omitempty"`

	// Key If `authType` is `webhook-authentication-ssl` and `certType` is `ssl-crt-key`, it is a base64 encoded version of the KEY file.
	Key *Key `json:"key,omitempty"`

	// Password The password for HTTP basic authentication or the passphrase for the SSL certificate files. If `hasAuth` is set to `true` and `authType` is `webhook-authentication-basic`, this property is required.
	Password *string `json:"password,omitempty"`

	// Pfx If `authType` is `webhook-authentication-ssl` and `certType` is `ssl-pfx`, it is a base64 encoded version of the PFX or P12 file.
	Pfx *Pfx `json:"pfx,omitempty"`

	// User The username for HTTP basic authentication. If `hasAuth` is set to `true`  and `authType` is `webhook-authentication-basic`, this property is required.
	User *string `json:"user,omitempty"`
}

// XmattersConfig Defines properties for connectors when type is `.xmatters`.
type XmattersConfig struct {
	// ConfigUrl The request URL for the Elastic Alerts trigger in xMatters. It is applicable only when `usesBasic` is `true`.
	ConfigUrl *string `json:"configUrl,omitempty"`

	// UsesBasic Specifies whether the connector uses HTTP basic authentication (`true`) or URL authentication (`false`).
	UsesBasic *bool `json:"usesBasic,omitempty"`
}

// XmattersSecrets Defines secrets for connectors when type is `.xmatters`.
type XmattersSecrets struct {
	// Password A user name for HTTP basic authentication. It is applicable only when `usesBasic` is `true`.
	Password *string `json:"password,omitempty"`

	// SecretsUrl The request URL for the Elastic Alerts trigger in xMatters with the API key included in the URL. It is applicable only when `usesBasic` is `false`.
	SecretsUrl *string `json:"secretsUrl,omitempty"`

	// User A password for HTTP basic authentication. It is applicable only when `usesBasic` is `true`.
	User *string `json:"user,omitempty"`
}

// APMUIElasticApiVersion defines model for APM_UI_elastic_api_version.
type APMUIElasticApiVersion string

// DataViewsViewId defines model for Data_views_view_id.
type DataViewsViewId = string

// SpaceId defines model for spaceId.
type SpaceId = string

// DeleteAgentConfigurationParams defines parameters for DeleteAgentConfiguration.
type DeleteAgentConfigurationParams struct {
	// ElasticApiVersion The version of the API to use
	ElasticApiVersion DeleteAgentConfigurationParamsElasticApiVersion `json:"elastic-api-version"`
}

// DeleteAgentConfigurationParamsElasticApiVersion defines parameters for DeleteAgentConfiguration.
type DeleteAgentConfigurationParamsElasticApiVersion string

// GetAgentConfigurationsParams defines parameters for GetAgentConfigurations.
type GetAgentConfigurationsParams struct {
	// ElasticApiVersion The version of the API to use
	ElasticApiVersion GetAgentConfigurationsParamsElasticApiVersion `json:"elastic-api-version"`
}

// GetAgentConfigurationsParamsElasticApiVersion defines parameters for GetAgentConfigurations.
type GetAgentConfigurationsParamsElasticApiVersion string

// CreateUpdateAgentConfigurationParams defines parameters for CreateUpdateAgentConfiguration.
type CreateUpdateAgentConfigurationParams struct {
	// Overwrite If the config exists ?overwrite=true is required
	Overwrite *bool `form:"overwrite,omitempty" json:"overwrite,omitempty"`

	// ElasticApiVersion The version of the API to use
	ElasticApiVersion CreateUpdateAgentConfigurationParamsElasticApiVersion `json:"elastic-api-version"`
}

// CreateUpdateAgentConfigurationParamsElasticApiVersion defines parameters for CreateUpdateAgentConfiguration.
type CreateUpdateAgentConfigurationParamsElasticApiVersion string

// DeleteRuleParams defines parameters for DeleteRule.
type DeleteRuleParams struct {
	// Id The rule's `id` value.
	Id *SecurityDetectionsAPIRuleObjectId `form:"id,omitempty" json:"id,omitempty"`

	// RuleId The rule's `rule_id` value.
	RuleId *SecurityDetectionsAPIRuleSignatureId `form:"rule_id,omitempty" json:"rule_id,omitempty"`
}

// ReadRuleParams defines parameters for ReadRule.
type ReadRuleParams struct {
	// Id The rule's `id` value.
	Id *SecurityDetectionsAPIRuleObjectId `form:"id,omitempty" json:"id,omitempty"`

	// RuleId The rule's `rule_id` value.
	RuleId *SecurityDetectionsAPIRuleSignatureId `form:"rule_id,omitempty" json:"rule_id,omitempty"`
}

// GetFleetAgentPoliciesParams defines parameters for GetFleetAgentPolicies.
type GetFleetAgentPoliciesParams struct {
	Page            *float32                              `form:"page,omitempty" json:"page,omitempty"`
	PerPage         *float32                              `form:"perPage,omitempty" json:"perPage,omitempty"`
	SortField       *string                               `form:"sortField,omitempty" json:"sortField,omitempty"`
	SortOrder       *GetFleetAgentPoliciesParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`
	ShowUpgradeable *bool                                 `form:"showUpgradeable,omitempty" json:"showUpgradeable,omitempty"`
	Kuery           *string                               `form:"kuery,omitempty" json:"kuery,omitempty"`

	// NoAgentCount use withAgentCount instead
	NoAgentCount *bool `form:"noAgentCount,omitempty" json:"noAgentCount,omitempty"`

	// WithAgentCount get policies with agent count
	WithAgentCount *bool `form:"withAgentCount,omitempty" json:"withAgentCount,omitempty"`

	// Full get full policies with package policies populated
	Full   *bool                              `form:"full,omitempty" json:"full,omitempty"`
	Format *GetFleetAgentPoliciesParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GetFleetAgentPoliciesParamsSortOrder defines parameters for GetFleetAgentPolicies.
type GetFleetAgentPoliciesParamsSortOrder string

// GetFleetAgentPoliciesParamsFormat defines parameters for GetFleetAgentPolicies.
type GetFleetAgentPoliciesParamsFormat string

// PostFleetAgentPoliciesJSONBody defines parameters for PostFleetAgentPolicies.
type PostFleetAgentPoliciesJSONBody struct {
	AdvancedSettings *struct {
		AgentDownloadTargetDirectory       interface{} `json:"agent_download_target_directory,omitempty"`
		AgentDownloadTimeout               interface{} `json:"agent_download_timeout,omitempty"`
		AgentLimitsGoMaxProcs              interface{} `json:"agent_limits_go_max_procs,omitempty"`
		AgentLoggingFilesInterval          interface{} `json:"agent_logging_files_interval,omitempty"`
		AgentLoggingFilesKeepfiles         interface{} `json:"agent_logging_files_keepfiles,omitempty"`
		AgentLoggingFilesRotateeverybytes  interface{} `json:"agent_logging_files_rotateeverybytes,omitempty"`
		AgentLoggingLevel                  interface{} `json:"agent_logging_level,omitempty"`
		AgentLoggingMetricsPeriod          interface{} `json:"agent_logging_metrics_period,omitempty"`
		AgentLoggingToFiles                interface{} `json:"agent_logging_to_files,omitempty"`
		AgentMonitoringRuntimeExperimental interface{} `json:"agent_monitoring_runtime_experimental,omitempty"`
	} `json:"advanced_settings,omitempty"`
	AgentFeatures *[]struct {
		Enabled bool   `json:"enabled"`
		Name    string `json:"name"`
	} `json:"agent_features,omitempty"`
	Agentless *struct {
		CloudConnectors *struct {
			Enabled   bool    `json:"enabled"`
			TargetCsp *string `json:"target_csp,omitempty"`
		} `json:"cloud_connectors,omitempty"`
		Resources *struct {
			Requests *struct {
				Cpu    *string `json:"cpu,omitempty"`
				Memory *string `json:"memory,omitempty"`
			} `json:"requests,omitempty"`
		} `json:"resources,omitempty"`
	} `json:"agentless,omitempty"`
	DataOutputId      *string `json:"data_output_id,omitempty"`
	Description       *string `json:"description,omitempty"`
	DownloadSourceId  *string `json:"download_source_id,omitempty"`
	FleetServerHostId *string `json:"fleet_server_host_id,omitempty"`
	Force             *bool   `json:"force,omitempty"`

	// GlobalDataTags User defined data tags that are added to all of the inputs. The values can be strings or numbers.
	GlobalDataTags       *[]AgentPolicyGlobalDataTagsItem `json:"global_data_tags,omitempty"`
	HasFleetServer       *bool                            `json:"has_fleet_server,omitempty"`
	Id                   *string                          `json:"id,omitempty"`
	InactivityTimeout    *float32                         `json:"inactivity_timeout,omitempty"`
	IsDefault            *bool                            `json:"is_default,omitempty"`
	IsDefaultFleetServer *bool                            `json:"is_default_fleet_server,omitempty"`
	IsManaged            *bool                            `json:"is_managed,omitempty"`
	IsProtected          *bool                            `json:"is_protected,omitempty"`

	// KeepMonitoringAlive When set to true, monitoring will be enabled but logs/metrics collection will be disabled
	KeepMonitoringAlive   *bool `json:"keep_monitoring_alive,omitempty"`
	MonitoringDiagnostics *struct {
		Limit *struct {
			Burst    *float32 `json:"burst,omitempty"`
			Interval *string  `json:"interval,omitempty"`
		} `json:"limit,omitempty"`
		Uploader *struct {
			InitDur    *string  `json:"init_dur,omitempty"`
			MaxDur     *string  `json:"max_dur,omitempty"`
			MaxRetries *float32 `json:"max_retries,omitempty"`
		} `json:"uploader,omitempty"`
	} `json:"monitoring_diagnostics,omitempty"`
	MonitoringEnabled *[]PostFleetAgentPoliciesJSONBodyMonitoringEnabled `json:"monitoring_enabled,omitempty"`
	MonitoringHttp    *struct {
		Buffer *struct {
			Enabled *bool `json:"enabled,omitempty"`
		} `json:"buffer,omitempty"`
		Enabled *bool    `json:"enabled,omitempty"`
		Host    *string  `json:"host,omitempty"`
		Port    *float32 `json:"port,omitempty"`
	} `json:"monitoring_http,omitempty"`
	MonitoringOutputId     *string `json:"monitoring_output_id,omitempty"`
	MonitoringPprofEnabled *bool   `json:"monitoring_pprof_enabled,omitempty"`
	Name                   string  `json:"name"`
	Namespace              string  `json:"namespace"`

	// Overrides Override settings that are defined in the agent policy. Input settings cannot be overridden. The override option should be used only in unusual circumstances and not as a routine procedure.
	Overrides        *map[string]interface{} `json:"overrides,omitempty"`
	RequiredVersions *[]struct {
		// Percentage Target percentage of agents to auto upgrade
		Percentage float32 `json:"percentage"`

		// Version Target version for automatic agent upgrade
		Version string `json:"version"`
	} `json:"required_versions,omitempty"`
	SpaceIds *[]string `json:"space_ids,omitempty"`

	// SupportsAgentless Indicates whether the agent policy supports agentless integrations.
	SupportsAgentless *bool    `json:"supports_agentless,omitempty"`
	UnenrollTimeout   *float32 `json:"unenroll_timeout,omitempty"`
}

// PostFleetAgentPoliciesParams defines parameters for PostFleetAgentPolicies.
type PostFleetAgentPoliciesParams struct {
	SysMonitoring *bool `form:"sys_monitoring,omitempty" json:"sys_monitoring,omitempty"`
}

// PostFleetAgentPoliciesJSONBodyMonitoringEnabled defines parameters for PostFleetAgentPolicies.
type PostFleetAgentPoliciesJSONBodyMonitoringEnabled string

// PostFleetAgentPoliciesDeleteJSONBody defines parameters for PostFleetAgentPoliciesDelete.
type PostFleetAgentPoliciesDeleteJSONBody struct {
	AgentPolicyId string `json:"agentPolicyId"`

	// Force bypass validation checks that can prevent agent policy deletion
	Force *bool `json:"force,omitempty"`
}

// GetFleetAgentPoliciesAgentpolicyidParams defines parameters for GetFleetAgentPoliciesAgentpolicyid.
type GetFleetAgentPoliciesAgentpolicyidParams struct {
	Format *GetFleetAgentPoliciesAgentpolicyidParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GetFleetAgentPoliciesAgentpolicyidParamsFormat defines parameters for GetFleetAgentPoliciesAgentpolicyid.
type GetFleetAgentPoliciesAgentpolicyidParamsFormat string

// PutFleetAgentPoliciesAgentpolicyidJSONBody defines parameters for PutFleetAgentPoliciesAgentpolicyid.
type PutFleetAgentPoliciesAgentpolicyidJSONBody struct {
	AdvancedSettings *struct {
		AgentDownloadTargetDirectory       interface{} `json:"agent_download_target_directory,omitempty"`
		AgentDownloadTimeout               interface{} `json:"agent_download_timeout,omitempty"`
		AgentLimitsGoMaxProcs              interface{} `json:"agent_limits_go_max_procs,omitempty"`
		AgentLoggingFilesInterval          interface{} `json:"agent_logging_files_interval,omitempty"`
		AgentLoggingFilesKeepfiles         interface{} `json:"agent_logging_files_keepfiles,omitempty"`
		AgentLoggingFilesRotateeverybytes  interface{} `json:"agent_logging_files_rotateeverybytes,omitempty"`
		AgentLoggingLevel                  interface{} `json:"agent_logging_level,omitempty"`
		AgentLoggingMetricsPeriod          interface{} `json:"agent_logging_metrics_period,omitempty"`
		AgentLoggingToFiles                interface{} `json:"agent_logging_to_files,omitempty"`
		AgentMonitoringRuntimeExperimental interface{} `json:"agent_monitoring_runtime_experimental,omitempty"`
	} `json:"advanced_settings,omitempty"`
	AgentFeatures *[]struct {
		Enabled bool   `json:"enabled"`
		Name    string `json:"name"`
	} `json:"agent_features,omitempty"`
	Agentless *struct {
		CloudConnectors *struct {
			Enabled   bool    `json:"enabled"`
			TargetCsp *string `json:"target_csp,omitempty"`
		} `json:"cloud_connectors,omitempty"`
		Resources *struct {
			Requests *struct {
				Cpu    *string `json:"cpu,omitempty"`
				Memory *string `json:"memory,omitempty"`
			} `json:"requests,omitempty"`
		} `json:"resources,omitempty"`
	} `json:"agentless,omitempty"`
	BumpRevision      *bool   `json:"bumpRevision,omitempty"`
	DataOutputId      *string `json:"data_output_id,omitempty"`
	Description       *string `json:"description,omitempty"`
	DownloadSourceId  *string `json:"download_source_id,omitempty"`
	FleetServerHostId *string `json:"fleet_server_host_id,omitempty"`
	Force             *bool   `json:"force,omitempty"`

	// GlobalDataTags User defined data tags that are added to all of the inputs. The values can be strings or numbers.
	GlobalDataTags       *[]AgentPolicyGlobalDataTagsItem `json:"global_data_tags,omitempty"`
	HasFleetServer       *bool                            `json:"has_fleet_server,omitempty"`
	Id                   *string                          `json:"id,omitempty"`
	InactivityTimeout    *float32                         `json:"inactivity_timeout,omitempty"`
	IsDefault            *bool                            `json:"is_default,omitempty"`
	IsDefaultFleetServer *bool                            `json:"is_default_fleet_server,omitempty"`
	IsManaged            *bool                            `json:"is_managed,omitempty"`
	IsProtected          *bool                            `json:"is_protected,omitempty"`

	// KeepMonitoringAlive When set to true, monitoring will be enabled but logs/metrics collection will be disabled
	KeepMonitoringAlive   *bool `json:"keep_monitoring_alive,omitempty"`
	MonitoringDiagnostics *struct {
		Limit *struct {
			Burst    *float32 `json:"burst,omitempty"`
			Interval *string  `json:"interval,omitempty"`
		} `json:"limit,omitempty"`
		Uploader *struct {
			InitDur    *string  `json:"init_dur,omitempty"`
			MaxDur     *string  `json:"max_dur,omitempty"`
			MaxRetries *float32 `json:"max_retries,omitempty"`
		} `json:"uploader,omitempty"`
	} `json:"monitoring_diagnostics,omitempty"`
	MonitoringEnabled *[]PutFleetAgentPoliciesAgentpolicyidJSONBodyMonitoringEnabled `json:"monitoring_enabled,omitempty"`
	MonitoringHttp    *struct {
		Buffer *struct {
			Enabled *bool `json:"enabled,omitempty"`
		} `json:"buffer,omitempty"`
		Enabled *bool    `json:"enabled,omitempty"`
		Host    *string  `json:"host,omitempty"`
		Port    *float32 `json:"port,omitempty"`
	} `json:"monitoring_http,omitempty"`
	MonitoringOutputId     *string `json:"monitoring_output_id,omitempty"`
	MonitoringPprofEnabled *bool   `json:"monitoring_pprof_enabled,omitempty"`
	Name                   string  `json:"name"`
	Namespace              string  `json:"namespace"`

	// Overrides Override settings that are defined in the agent policy. Input settings cannot be overridden. The override option should be used only in unusual circumstances and not as a routine procedure.
	Overrides        *map[string]interface{} `json:"overrides,omitempty"`
	RequiredVersions *[]struct {
		// Percentage Target percentage of agents to auto upgrade
		Percentage float32 `json:"percentage"`

		// Version Target version for automatic agent upgrade
		Version string `json:"version"`
	} `json:"required_versions,omitempty"`
	SpaceIds *[]string `json:"space_ids,omitempty"`

	// SupportsAgentless Indicates whether the agent policy supports agentless integrations.
	SupportsAgentless *bool    `json:"supports_agentless,omitempty"`
	UnenrollTimeout   *float32 `json:"unenroll_timeout,omitempty"`
}

// PutFleetAgentPoliciesAgentpolicyidParams defines parameters for PutFleetAgentPoliciesAgentpolicyid.
type PutFleetAgentPoliciesAgentpolicyidParams struct {
	Format *PutFleetAgentPoliciesAgentpolicyidParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// PutFleetAgentPoliciesAgentpolicyidParamsFormat defines parameters for PutFleetAgentPoliciesAgentpolicyid.
type PutFleetAgentPoliciesAgentpolicyidParamsFormat string

// PutFleetAgentPoliciesAgentpolicyidJSONBodyMonitoringEnabled defines parameters for PutFleetAgentPoliciesAgentpolicyid.
type PutFleetAgentPoliciesAgentpolicyidJSONBodyMonitoringEnabled string

// GetFleetEnrollmentApiKeysParams defines parameters for GetFleetEnrollmentApiKeys.
type GetFleetEnrollmentApiKeysParams struct {
	Page    *float32 `form:"page,omitempty" json:"page,omitempty"`
	PerPage *float32 `form:"perPage,omitempty" json:"perPage,omitempty"`
	Kuery   *string  `form:"kuery,omitempty" json:"kuery,omitempty"`
}

// GetFleetEpmPackagesParams defines parameters for GetFleetEpmPackages.
type GetFleetEpmPackagesParams struct {
	Category                 *string `form:"category,omitempty" json:"category,omitempty"`
	Prerelease               *bool   `form:"prerelease,omitempty" json:"prerelease,omitempty"`
	ExcludeInstallStatus     *bool   `form:"excludeInstallStatus,omitempty" json:"excludeInstallStatus,omitempty"`
	WithPackagePoliciesCount *bool   `form:"withPackagePoliciesCount,omitempty" json:"withPackagePoliciesCount,omitempty"`
}

// PostFleetEpmPackagesParams defines parameters for PostFleetEpmPackages.
type PostFleetEpmPackagesParams struct {
	IgnoreMappingUpdateErrors *bool `form:"ignoreMappingUpdateErrors,omitempty" json:"ignoreMappingUpdateErrors,omitempty"`
	SkipDataStreamRollover    *bool `form:"skipDataStreamRollover,omitempty" json:"skipDataStreamRollover,omitempty"`
}

// DeleteFleetEpmPackagesPkgnamePkgversionParams defines parameters for DeleteFleetEpmPackagesPkgnamePkgversion.
type DeleteFleetEpmPackagesPkgnamePkgversionParams struct {
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// GetFleetEpmPackagesPkgnamePkgversionParams defines parameters for GetFleetEpmPackagesPkgnamePkgversion.
type GetFleetEpmPackagesPkgnamePkgversionParams struct {
	IgnoreUnverified *bool `form:"ignoreUnverified,omitempty" json:"ignoreUnverified,omitempty"`
	Prerelease       *bool `form:"prerelease,omitempty" json:"prerelease,omitempty"`
	Full             *bool `form:"full,omitempty" json:"full,omitempty"`
	WithMetadata     *bool `form:"withMetadata,omitempty" json:"withMetadata,omitempty"`
}

// PostFleetEpmPackagesPkgnamePkgversionJSONBody defines parameters for PostFleetEpmPackagesPkgnamePkgversion.
type PostFleetEpmPackagesPkgnamePkgversionJSONBody struct {
	Force             *bool `json:"force,omitempty"`
	IgnoreConstraints *bool `json:"ignore_constraints,omitempty"`
}

// PostFleetEpmPackagesPkgnamePkgversionParams defines parameters for PostFleetEpmPackagesPkgnamePkgversion.
type PostFleetEpmPackagesPkgnamePkgversionParams struct {
	Prerelease                *bool `form:"prerelease,omitempty" json:"prerelease,omitempty"`
	IgnoreMappingUpdateErrors *bool `form:"ignoreMappingUpdateErrors,omitempty" json:"ignoreMappingUpdateErrors,omitempty"`
	SkipDataStreamRollover    *bool `form:"skipDataStreamRollover,omitempty" json:"skipDataStreamRollover,omitempty"`
}

// PostFleetFleetServerHostsJSONBody defines parameters for PostFleetFleetServerHosts.
type PostFleetFleetServerHostsJSONBody struct {
	HostUrls        []string `json:"host_urls"`
	Id              *string  `json:"id,omitempty"`
	IsDefault       *bool    `json:"is_default,omitempty"`
	IsInternal      *bool    `json:"is_internal,omitempty"`
	IsPreconfigured *bool    `json:"is_preconfigured,omitempty"`
	Name            string   `json:"name"`
	ProxyId         *string  `json:"proxy_id,omitempty"`
	Secrets         *struct {
		Ssl *struct {
			EsKey *PostFleetFleetServerHostsJSONBody_Secrets_Ssl_EsKey `json:"es_key,omitempty"`
			Key   *PostFleetFleetServerHostsJSONBody_Secrets_Ssl_Key   `json:"key,omitempty"`
		} `json:"ssl,omitempty"`
	} `json:"secrets,omitempty"`
	Ssl *struct {
		Certificate              *string                                         `json:"certificate,omitempty"`
		CertificateAuthorities   *[]string                                       `json:"certificate_authorities,omitempty"`
		ClientAuth               *PostFleetFleetServerHostsJSONBodySslClientAuth `json:"client_auth,omitempty"`
		EsCertificate            *string                                         `json:"es_certificate,omitempty"`
		EsCertificateAuthorities *[]string                                       `json:"es_certificate_authorities,omitempty"`
		EsKey                    *string                                         `json:"es_key,omitempty"`
		Key                      *string                                         `json:"key,omitempty"`
	} `json:"ssl,omitempty"`
}

// PostFleetFleetServerHostsJSONBodySecretsSslEsKey0 defines parameters for PostFleetFleetServerHosts.
type PostFleetFleetServerHostsJSONBodySecretsSslEsKey0 struct {
	Id string `json:"id"`
}

// PostFleetFleetServerHostsJSONBodySecretsSslEsKey1 defines parameters for PostFleetFleetServerHosts.
type PostFleetFleetServerHostsJSONBodySecretsSslEsKey1 = string

// PostFleetFleetServerHostsJSONBody_Secrets_Ssl_EsKey defines parameters for PostFleetFleetServerHosts.
type PostFleetFleetServerHostsJSONBody_Secrets_Ssl_EsKey struct {
	union json.RawMessage
}

// PostFleetFleetServerHostsJSONBodySecretsSslKey0 defines parameters for PostFleetFleetServerHosts.
type PostFleetFleetServerHostsJSONBodySecretsSslKey0 struct {
	Id string `json:"id"`
}

// PostFleetFleetServerHostsJSONBodySecretsSslKey1 defines parameters for PostFleetFleetServerHosts.
type PostFleetFleetServerHostsJSONBodySecretsSslKey1 = string

// PostFleetFleetServerHostsJSONBody_Secrets_Ssl_Key defines parameters for PostFleetFleetServerHosts.
type PostFleetFleetServerHostsJSONBody_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// PostFleetFleetServerHostsJSONBodySslClientAuth defines parameters for PostFleetFleetServerHosts.
type PostFleetFleetServerHostsJSONBodySslClientAuth string

// PutFleetFleetServerHostsItemidJSONBody defines parameters for PutFleetFleetServerHostsItemid.
type PutFleetFleetServerHostsItemidJSONBody struct {
	HostUrls   *[]string `json:"host_urls,omitempty"`
	IsDefault  *bool     `json:"is_default,omitempty"`
	IsInternal *bool     `json:"is_internal,omitempty"`
	Name       *string   `json:"name,omitempty"`
	ProxyId    *string   `json:"proxy_id,omitempty"`
	Secrets    *struct {
		Ssl *struct {
			EsKey *PutFleetFleetServerHostsItemidJSONBody_Secrets_Ssl_EsKey `json:"es_key,omitempty"`
			Key   *PutFleetFleetServerHostsItemidJSONBody_Secrets_Ssl_Key   `json:"key,omitempty"`
		} `json:"ssl,omitempty"`
	} `json:"secrets,omitempty"`
	Ssl *struct {
		Certificate              *string                                              `json:"certificate,omitempty"`
		CertificateAuthorities   *[]string                                            `json:"certificate_authorities,omitempty"`
		ClientAuth               *PutFleetFleetServerHostsItemidJSONBodySslClientAuth `json:"client_auth,omitempty"`
		EsCertificate            *string                                              `json:"es_certificate,omitempty"`
		EsCertificateAuthorities *[]string                                            `json:"es_certificate_authorities,omitempty"`
		EsKey                    *string                                              `json:"es_key,omitempty"`
		Key                      *string                                              `json:"key,omitempty"`
	} `json:"ssl,omitempty"`
}

// PutFleetFleetServerHostsItemidJSONBodySecretsSslEsKey0 defines parameters for PutFleetFleetServerHostsItemid.
type PutFleetFleetServerHostsItemidJSONBodySecretsSslEsKey0 struct {
	Id string `json:"id"`
}

// PutFleetFleetServerHostsItemidJSONBodySecretsSslEsKey1 defines parameters for PutFleetFleetServerHostsItemid.
type PutFleetFleetServerHostsItemidJSONBodySecretsSslEsKey1 = string

// PutFleetFleetServerHostsItemidJSONBody_Secrets_Ssl_EsKey defines parameters for PutFleetFleetServerHostsItemid.
type PutFleetFleetServerHostsItemidJSONBody_Secrets_Ssl_EsKey struct {
	union json.RawMessage
}

// PutFleetFleetServerHostsItemidJSONBodySecretsSslKey0 defines parameters for PutFleetFleetServerHostsItemid.
type PutFleetFleetServerHostsItemidJSONBodySecretsSslKey0 struct {
	Id string `json:"id"`
}

// PutFleetFleetServerHostsItemidJSONBodySecretsSslKey1 defines parameters for PutFleetFleetServerHostsItemid.
type PutFleetFleetServerHostsItemidJSONBodySecretsSslKey1 = string

// PutFleetFleetServerHostsItemidJSONBody_Secrets_Ssl_Key defines parameters for PutFleetFleetServerHostsItemid.
type PutFleetFleetServerHostsItemidJSONBody_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// PutFleetFleetServerHostsItemidJSONBodySslClientAuth defines parameters for PutFleetFleetServerHostsItemid.
type PutFleetFleetServerHostsItemidJSONBodySslClientAuth string

// GetFleetPackagePoliciesParams defines parameters for GetFleetPackagePolicies.
type GetFleetPackagePoliciesParams struct {
	Page            *float32                                `form:"page,omitempty" json:"page,omitempty"`
	PerPage         *float32                                `form:"perPage,omitempty" json:"perPage,omitempty"`
	SortField       *string                                 `form:"sortField,omitempty" json:"sortField,omitempty"`
	SortOrder       *GetFleetPackagePoliciesParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`
	ShowUpgradeable *bool                                   `form:"showUpgradeable,omitempty" json:"showUpgradeable,omitempty"`
	Kuery           *string                                 `form:"kuery,omitempty" json:"kuery,omitempty"`
	Format          *GetFleetPackagePoliciesParamsFormat    `form:"format,omitempty" json:"format,omitempty"`
	WithAgentCount  *bool                                   `form:"withAgentCount,omitempty" json:"withAgentCount,omitempty"`
}

// GetFleetPackagePoliciesParamsSortOrder defines parameters for GetFleetPackagePolicies.
type GetFleetPackagePoliciesParamsSortOrder string

// GetFleetPackagePoliciesParamsFormat defines parameters for GetFleetPackagePolicies.
type GetFleetPackagePoliciesParamsFormat string

// PostFleetPackagePoliciesParams defines parameters for PostFleetPackagePolicies.
type PostFleetPackagePoliciesParams struct {
	Format *PostFleetPackagePoliciesParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// PostFleetPackagePoliciesParamsFormat defines parameters for PostFleetPackagePolicies.
type PostFleetPackagePoliciesParamsFormat string

// DeleteFleetPackagePoliciesPackagepolicyidParams defines parameters for DeleteFleetPackagePoliciesPackagepolicyid.
type DeleteFleetPackagePoliciesPackagepolicyidParams struct {
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// GetFleetPackagePoliciesPackagepolicyidParams defines parameters for GetFleetPackagePoliciesPackagepolicyid.
type GetFleetPackagePoliciesPackagepolicyidParams struct {
	Format *GetFleetPackagePoliciesPackagepolicyidParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GetFleetPackagePoliciesPackagepolicyidParamsFormat defines parameters for GetFleetPackagePoliciesPackagepolicyid.
type GetFleetPackagePoliciesPackagepolicyidParamsFormat string

// PutFleetPackagePoliciesPackagepolicyidParams defines parameters for PutFleetPackagePoliciesPackagepolicyid.
type PutFleetPackagePoliciesPackagepolicyidParams struct {
	Format *PutFleetPackagePoliciesPackagepolicyidParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// PutFleetPackagePoliciesPackagepolicyidParamsFormat defines parameters for PutFleetPackagePoliciesPackagepolicyid.
type PutFleetPackagePoliciesPackagepolicyidParamsFormat string

// PostParametersJSONBody defines parameters for PostParameters.
type PostParametersJSONBody struct {
	union json.RawMessage
}

// PostParametersJSONBody0 defines parameters for PostParameters.
type PostParametersJSONBody0 = []SyntheticsParameterRequest

// PutParameterJSONBody defines parameters for PutParameter.
type PutParameterJSONBody struct {
	// Description The updated description of the parameter.
	Description *string `json:"description,omitempty"`

	// Key The key of the parameter.
	Key *string `json:"key,omitempty"`

	// Tags An array of updated tags to categorize the parameter.
	Tags *[]string `json:"tags,omitempty"`

	// Value The updated value associated with the parameter.
	Value *string `json:"value,omitempty"`
}

// PostActionsConnectorIdJSONBody defines parameters for PostActionsConnectorId.
type PostActionsConnectorIdJSONBody struct {
	// Config The connector configuration details.
	Config *CreateConnectorConfig `json:"config,omitempty"`

	// ConnectorTypeId The type of connector.
	ConnectorTypeId string `json:"connector_type_id"`

	// Name The display name for the connector.
	Name    string                  `json:"name"`
	Secrets *CreateConnectorSecrets `json:"secrets,omitempty"`
}

// PutActionsConnectorIdJSONBody defines parameters for PutActionsConnectorId.
type PutActionsConnectorIdJSONBody struct {
	// Config The connector configuration details.
	Config *UpdateConnectorConfig `json:"config,omitempty"`

	// Name The display name for the connector.
	Name    string                  `json:"name"`
	Secrets *UpdateConnectorSecrets `json:"secrets,omitempty"`
}

// DeleteAgentConfigurationJSONRequestBody defines body for DeleteAgentConfiguration for application/json ContentType.
type DeleteAgentConfigurationJSONRequestBody = APMUIDeleteServiceObject

// CreateUpdateAgentConfigurationJSONRequestBody defines body for CreateUpdateAgentConfiguration for application/json ContentType.
type CreateUpdateAgentConfigurationJSONRequestBody = APMUIAgentConfigurationIntakeObject

// CreateRuleJSONRequestBody defines body for CreateRule for application/json ContentType.
type CreateRuleJSONRequestBody = SecurityDetectionsAPIRuleCreateProps

// UpdateRuleJSONRequestBody defines body for UpdateRule for application/json ContentType.
type UpdateRuleJSONRequestBody = SecurityDetectionsAPIRuleUpdateProps

// PostFleetAgentPoliciesJSONRequestBody defines body for PostFleetAgentPolicies for application/json ContentType.
type PostFleetAgentPoliciesJSONRequestBody PostFleetAgentPoliciesJSONBody

// PostFleetAgentPoliciesDeleteJSONRequestBody defines body for PostFleetAgentPoliciesDelete for application/json ContentType.
type PostFleetAgentPoliciesDeleteJSONRequestBody PostFleetAgentPoliciesDeleteJSONBody

// PutFleetAgentPoliciesAgentpolicyidJSONRequestBody defines body for PutFleetAgentPoliciesAgentpolicyid for application/json ContentType.
type PutFleetAgentPoliciesAgentpolicyidJSONRequestBody PutFleetAgentPoliciesAgentpolicyidJSONBody

// PostFleetEpmPackagesPkgnamePkgversionJSONRequestBody defines body for PostFleetEpmPackagesPkgnamePkgversion for application/json ContentType.
type PostFleetEpmPackagesPkgnamePkgversionJSONRequestBody PostFleetEpmPackagesPkgnamePkgversionJSONBody

// PostFleetFleetServerHostsJSONRequestBody defines body for PostFleetFleetServerHosts for application/json ContentType.
type PostFleetFleetServerHostsJSONRequestBody PostFleetFleetServerHostsJSONBody

// PutFleetFleetServerHostsItemidJSONRequestBody defines body for PutFleetFleetServerHostsItemid for application/json ContentType.
type PutFleetFleetServerHostsItemidJSONRequestBody PutFleetFleetServerHostsItemidJSONBody

// PostFleetOutputsJSONRequestBody defines body for PostFleetOutputs for application/json ContentType.
type PostFleetOutputsJSONRequestBody = NewOutputUnion

// PutFleetOutputsOutputidJSONRequestBody defines body for PutFleetOutputsOutputid for application/json ContentType.
type PutFleetOutputsOutputidJSONRequestBody = UpdateOutputUnion

// PostFleetPackagePoliciesJSONRequestBody defines body for PostFleetPackagePolicies for application/json ContentType.
type PostFleetPackagePoliciesJSONRequestBody = PackagePolicyRequest

// PutFleetPackagePoliciesPackagepolicyidJSONRequestBody defines body for PutFleetPackagePoliciesPackagepolicyid for application/json ContentType.
type PutFleetPackagePoliciesPackagepolicyidJSONRequestBody = PackagePolicyRequest

// PostParametersJSONRequestBody defines body for PostParameters for application/json ContentType.
type PostParametersJSONRequestBody PostParametersJSONBody

// PutParameterJSONRequestBody defines body for PutParameter for application/json ContentType.
type PutParameterJSONRequestBody PutParameterJSONBody

// PostActionsConnectorIdJSONRequestBody defines body for PostActionsConnectorId for application/json ContentType.
type PostActionsConnectorIdJSONRequestBody PostActionsConnectorIdJSONBody

// PutActionsConnectorIdJSONRequestBody defines body for PutActionsConnectorId for application/json ContentType.
type PutActionsConnectorIdJSONRequestBody PutActionsConnectorIdJSONBody

// CreateDataViewDefaultwJSONRequestBody defines body for CreateDataViewDefaultw for application/json ContentType.
type CreateDataViewDefaultwJSONRequestBody = DataViewsCreateDataViewRequestObject

// UpdateDataViewDefaultJSONRequestBody defines body for UpdateDataViewDefault for application/json ContentType.
type UpdateDataViewDefaultJSONRequestBody = DataViewsUpdateDataViewRequestObject

// Getter for additional properties for AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges. Returns the specified
// element and whether it was found
func (a AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges
func (a *AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges to handle AdditionalProperties
func (a *AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["cluster"]; found {
		err = json.Unmarshal(raw, &a.Cluster)
		if err != nil {
			return fmt.Errorf("error reading 'cluster': %w", err)
		}
		delete(object, "cluster")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges to handle AdditionalProperties
func (a AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Cluster != nil {
		object["cluster"], err = json.Marshal(a.Cluster)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'cluster': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AgentPolicy_PackagePolicies_1_Elasticsearch. Returns the specified
// element and whether it was found
func (a AgentPolicy_PackagePolicies_1_Elasticsearch) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AgentPolicy_PackagePolicies_1_Elasticsearch
func (a *AgentPolicy_PackagePolicies_1_Elasticsearch) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AgentPolicy_PackagePolicies_1_Elasticsearch to handle AdditionalProperties
func (a *AgentPolicy_PackagePolicies_1_Elasticsearch) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["privileges"]; found {
		err = json.Unmarshal(raw, &a.Privileges)
		if err != nil {
			return fmt.Errorf("error reading 'privileges': %w", err)
		}
		delete(object, "privileges")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AgentPolicy_PackagePolicies_1_Elasticsearch to handle AdditionalProperties
func (a AgentPolicy_PackagePolicies_1_Elasticsearch) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Privileges != nil {
		object["privileges"], err = json.Marshal(a.Privileges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'privileges': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for CreateConnectorConfig. Returns the specified
// element and whether it was found
func (a CreateConnectorConfig) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateConnectorConfig
func (a *CreateConnectorConfig) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Getter for additional properties for CreateConnectorSecrets. Returns the specified
// element and whether it was found
func (a CreateConnectorSecrets) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateConnectorSecrets
func (a *CreateConnectorSecrets) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Getter for additional properties for OutputElasticsearch. Returns the specified
// element and whether it was found
func (a OutputElasticsearch) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputElasticsearch
func (a *OutputElasticsearch) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputElasticsearch to handle AdditionalProperties
func (a *OutputElasticsearch) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["allow_edit"]; found {
		err = json.Unmarshal(raw, &a.AllowEdit)
		if err != nil {
			return fmt.Errorf("error reading 'allow_edit': %w", err)
		}
		delete(object, "allow_edit")
	}

	if raw, found := object["ca_sha256"]; found {
		err = json.Unmarshal(raw, &a.CaSha256)
		if err != nil {
			return fmt.Errorf("error reading 'ca_sha256': %w", err)
		}
		delete(object, "ca_sha256")
	}

	if raw, found := object["ca_trusted_fingerprint"]; found {
		err = json.Unmarshal(raw, &a.CaTrustedFingerprint)
		if err != nil {
			return fmt.Errorf("error reading 'ca_trusted_fingerprint': %w", err)
		}
		delete(object, "ca_trusted_fingerprint")
	}

	if raw, found := object["config_yaml"]; found {
		err = json.Unmarshal(raw, &a.ConfigYaml)
		if err != nil {
			return fmt.Errorf("error reading 'config_yaml': %w", err)
		}
		delete(object, "config_yaml")
	}

	if raw, found := object["hosts"]; found {
		err = json.Unmarshal(raw, &a.Hosts)
		if err != nil {
			return fmt.Errorf("error reading 'hosts': %w", err)
		}
		delete(object, "hosts")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["is_default"]; found {
		err = json.Unmarshal(raw, &a.IsDefault)
		if err != nil {
			return fmt.Errorf("error reading 'is_default': %w", err)
		}
		delete(object, "is_default")
	}

	if raw, found := object["is_default_monitoring"]; found {
		err = json.Unmarshal(raw, &a.IsDefaultMonitoring)
		if err != nil {
			return fmt.Errorf("error reading 'is_default_monitoring': %w", err)
		}
		delete(object, "is_default_monitoring")
	}

	if raw, found := object["is_internal"]; found {
		err = json.Unmarshal(raw, &a.IsInternal)
		if err != nil {
			return fmt.Errorf("error reading 'is_internal': %w", err)
		}
		delete(object, "is_internal")
	}

	if raw, found := object["is_preconfigured"]; found {
		err = json.Unmarshal(raw, &a.IsPreconfigured)
		if err != nil {
			return fmt.Errorf("error reading 'is_preconfigured': %w", err)
		}
		delete(object, "is_preconfigured")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["preset"]; found {
		err = json.Unmarshal(raw, &a.Preset)
		if err != nil {
			return fmt.Errorf("error reading 'preset': %w", err)
		}
		delete(object, "preset")
	}

	if raw, found := object["proxy_id"]; found {
		err = json.Unmarshal(raw, &a.ProxyId)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_id': %w", err)
		}
		delete(object, "proxy_id")
	}

	if raw, found := object["secrets"]; found {
		err = json.Unmarshal(raw, &a.Secrets)
		if err != nil {
			return fmt.Errorf("error reading 'secrets': %w", err)
		}
		delete(object, "secrets")
	}

	if raw, found := object["shipper"]; found {
		err = json.Unmarshal(raw, &a.Shipper)
		if err != nil {
			return fmt.Errorf("error reading 'shipper': %w", err)
		}
		delete(object, "shipper")
	}

	if raw, found := object["ssl"]; found {
		err = json.Unmarshal(raw, &a.Ssl)
		if err != nil {
			return fmt.Errorf("error reading 'ssl': %w", err)
		}
		delete(object, "ssl")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["write_to_logs_streams"]; found {
		err = json.Unmarshal(raw, &a.WriteToLogsStreams)
		if err != nil {
			return fmt.Errorf("error reading 'write_to_logs_streams': %w", err)
		}
		delete(object, "write_to_logs_streams")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputElasticsearch to handle AdditionalProperties
func (a OutputElasticsearch) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AllowEdit != nil {
		object["allow_edit"], err = json.Marshal(a.AllowEdit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allow_edit': %w", err)
		}
	}

	if a.CaSha256 != nil {
		object["ca_sha256"], err = json.Marshal(a.CaSha256)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ca_sha256': %w", err)
		}
	}

	if a.CaTrustedFingerprint != nil {
		object["ca_trusted_fingerprint"], err = json.Marshal(a.CaTrustedFingerprint)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ca_trusted_fingerprint': %w", err)
		}
	}

	if a.ConfigYaml != nil {
		object["config_yaml"], err = json.Marshal(a.ConfigYaml)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'config_yaml': %w", err)
		}
	}

	object["hosts"], err = json.Marshal(a.Hosts)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'hosts': %w", err)
	}

	if a.Id != nil {
		object["id"], err = json.Marshal(a.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if a.IsDefault != nil {
		object["is_default"], err = json.Marshal(a.IsDefault)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_default': %w", err)
		}
	}

	if a.IsDefaultMonitoring != nil {
		object["is_default_monitoring"], err = json.Marshal(a.IsDefaultMonitoring)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_default_monitoring': %w", err)
		}
	}

	if a.IsInternal != nil {
		object["is_internal"], err = json.Marshal(a.IsInternal)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_internal': %w", err)
		}
	}

	if a.IsPreconfigured != nil {
		object["is_preconfigured"], err = json.Marshal(a.IsPreconfigured)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_preconfigured': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Preset != nil {
		object["preset"], err = json.Marshal(a.Preset)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'preset': %w", err)
		}
	}

	if a.ProxyId != nil {
		object["proxy_id"], err = json.Marshal(a.ProxyId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_id': %w", err)
		}
	}

	if a.Secrets != nil {
		object["secrets"], err = json.Marshal(a.Secrets)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secrets': %w", err)
		}
	}

	if a.Shipper != nil {
		object["shipper"], err = json.Marshal(a.Shipper)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'shipper': %w", err)
		}
	}

	if a.Ssl != nil {
		object["ssl"], err = json.Marshal(a.Ssl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	if a.WriteToLogsStreams != nil {
		object["write_to_logs_streams"], err = json.Marshal(a.WriteToLogsStreams)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'write_to_logs_streams': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputElasticsearchSecretsSslKey0. Returns the specified
// element and whether it was found
func (a OutputElasticsearchSecretsSslKey0) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputElasticsearchSecretsSslKey0
func (a *OutputElasticsearchSecretsSslKey0) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputElasticsearchSecretsSslKey0 to handle AdditionalProperties
func (a *OutputElasticsearchSecretsSslKey0) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputElasticsearchSecretsSslKey0 to handle AdditionalProperties
func (a OutputElasticsearchSecretsSslKey0) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputElasticsearch_Secrets_Ssl. Returns the specified
// element and whether it was found
func (a OutputElasticsearch_Secrets_Ssl) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputElasticsearch_Secrets_Ssl
func (a *OutputElasticsearch_Secrets_Ssl) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputElasticsearch_Secrets_Ssl to handle AdditionalProperties
func (a *OutputElasticsearch_Secrets_Ssl) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["key"]; found {
		err = json.Unmarshal(raw, &a.Key)
		if err != nil {
			return fmt.Errorf("error reading 'key': %w", err)
		}
		delete(object, "key")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputElasticsearch_Secrets_Ssl to handle AdditionalProperties
func (a OutputElasticsearch_Secrets_Ssl) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Key != nil {
		object["key"], err = json.Marshal(a.Key)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'key': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputElasticsearch_Secrets. Returns the specified
// element and whether it was found
func (a OutputElasticsearch_Secrets) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputElasticsearch_Secrets
func (a *OutputElasticsearch_Secrets) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputElasticsearch_Secrets to handle AdditionalProperties
func (a *OutputElasticsearch_Secrets) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["ssl"]; found {
		err = json.Unmarshal(raw, &a.Ssl)
		if err != nil {
			return fmt.Errorf("error reading 'ssl': %w", err)
		}
		delete(object, "ssl")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputElasticsearch_Secrets to handle AdditionalProperties
func (a OutputElasticsearch_Secrets) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Ssl != nil {
		object["ssl"], err = json.Marshal(a.Ssl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka. Returns the specified
// element and whether it was found
func (a OutputKafka) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka
func (a *OutputKafka) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka to handle AdditionalProperties
func (a *OutputKafka) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["allow_edit"]; found {
		err = json.Unmarshal(raw, &a.AllowEdit)
		if err != nil {
			return fmt.Errorf("error reading 'allow_edit': %w", err)
		}
		delete(object, "allow_edit")
	}

	if raw, found := object["auth_type"]; found {
		err = json.Unmarshal(raw, &a.AuthType)
		if err != nil {
			return fmt.Errorf("error reading 'auth_type': %w", err)
		}
		delete(object, "auth_type")
	}

	if raw, found := object["broker_timeout"]; found {
		err = json.Unmarshal(raw, &a.BrokerTimeout)
		if err != nil {
			return fmt.Errorf("error reading 'broker_timeout': %w", err)
		}
		delete(object, "broker_timeout")
	}

	if raw, found := object["ca_sha256"]; found {
		err = json.Unmarshal(raw, &a.CaSha256)
		if err != nil {
			return fmt.Errorf("error reading 'ca_sha256': %w", err)
		}
		delete(object, "ca_sha256")
	}

	if raw, found := object["ca_trusted_fingerprint"]; found {
		err = json.Unmarshal(raw, &a.CaTrustedFingerprint)
		if err != nil {
			return fmt.Errorf("error reading 'ca_trusted_fingerprint': %w", err)
		}
		delete(object, "ca_trusted_fingerprint")
	}

	if raw, found := object["client_id"]; found {
		err = json.Unmarshal(raw, &a.ClientId)
		if err != nil {
			return fmt.Errorf("error reading 'client_id': %w", err)
		}
		delete(object, "client_id")
	}

	if raw, found := object["compression"]; found {
		err = json.Unmarshal(raw, &a.Compression)
		if err != nil {
			return fmt.Errorf("error reading 'compression': %w", err)
		}
		delete(object, "compression")
	}

	if raw, found := object["compression_level"]; found {
		err = json.Unmarshal(raw, &a.CompressionLevel)
		if err != nil {
			return fmt.Errorf("error reading 'compression_level': %w", err)
		}
		delete(object, "compression_level")
	}

	if raw, found := object["config_yaml"]; found {
		err = json.Unmarshal(raw, &a.ConfigYaml)
		if err != nil {
			return fmt.Errorf("error reading 'config_yaml': %w", err)
		}
		delete(object, "config_yaml")
	}

	if raw, found := object["connection_type"]; found {
		err = json.Unmarshal(raw, &a.ConnectionType)
		if err != nil {
			return fmt.Errorf("error reading 'connection_type': %w", err)
		}
		delete(object, "connection_type")
	}

	if raw, found := object["hash"]; found {
		err = json.Unmarshal(raw, &a.Hash)
		if err != nil {
			return fmt.Errorf("error reading 'hash': %w", err)
		}
		delete(object, "hash")
	}

	if raw, found := object["headers"]; found {
		err = json.Unmarshal(raw, &a.Headers)
		if err != nil {
			return fmt.Errorf("error reading 'headers': %w", err)
		}
		delete(object, "headers")
	}

	if raw, found := object["hosts"]; found {
		err = json.Unmarshal(raw, &a.Hosts)
		if err != nil {
			return fmt.Errorf("error reading 'hosts': %w", err)
		}
		delete(object, "hosts")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["is_default"]; found {
		err = json.Unmarshal(raw, &a.IsDefault)
		if err != nil {
			return fmt.Errorf("error reading 'is_default': %w", err)
		}
		delete(object, "is_default")
	}

	if raw, found := object["is_default_monitoring"]; found {
		err = json.Unmarshal(raw, &a.IsDefaultMonitoring)
		if err != nil {
			return fmt.Errorf("error reading 'is_default_monitoring': %w", err)
		}
		delete(object, "is_default_monitoring")
	}

	if raw, found := object["is_internal"]; found {
		err = json.Unmarshal(raw, &a.IsInternal)
		if err != nil {
			return fmt.Errorf("error reading 'is_internal': %w", err)
		}
		delete(object, "is_internal")
	}

	if raw, found := object["is_preconfigured"]; found {
		err = json.Unmarshal(raw, &a.IsPreconfigured)
		if err != nil {
			return fmt.Errorf("error reading 'is_preconfigured': %w", err)
		}
		delete(object, "is_preconfigured")
	}

	if raw, found := object["key"]; found {
		err = json.Unmarshal(raw, &a.Key)
		if err != nil {
			return fmt.Errorf("error reading 'key': %w", err)
		}
		delete(object, "key")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["partition"]; found {
		err = json.Unmarshal(raw, &a.Partition)
		if err != nil {
			return fmt.Errorf("error reading 'partition': %w", err)
		}
		delete(object, "partition")
	}

	if raw, found := object["password"]; found {
		err = json.Unmarshal(raw, &a.Password)
		if err != nil {
			return fmt.Errorf("error reading 'password': %w", err)
		}
		delete(object, "password")
	}

	if raw, found := object["proxy_id"]; found {
		err = json.Unmarshal(raw, &a.ProxyId)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_id': %w", err)
		}
		delete(object, "proxy_id")
	}

	if raw, found := object["random"]; found {
		err = json.Unmarshal(raw, &a.Random)
		if err != nil {
			return fmt.Errorf("error reading 'random': %w", err)
		}
		delete(object, "random")
	}

	if raw, found := object["required_acks"]; found {
		err = json.Unmarshal(raw, &a.RequiredAcks)
		if err != nil {
			return fmt.Errorf("error reading 'required_acks': %w", err)
		}
		delete(object, "required_acks")
	}

	if raw, found := object["round_robin"]; found {
		err = json.Unmarshal(raw, &a.RoundRobin)
		if err != nil {
			return fmt.Errorf("error reading 'round_robin': %w", err)
		}
		delete(object, "round_robin")
	}

	if raw, found := object["sasl"]; found {
		err = json.Unmarshal(raw, &a.Sasl)
		if err != nil {
			return fmt.Errorf("error reading 'sasl': %w", err)
		}
		delete(object, "sasl")
	}

	if raw, found := object["secrets"]; found {
		err = json.Unmarshal(raw, &a.Secrets)
		if err != nil {
			return fmt.Errorf("error reading 'secrets': %w", err)
		}
		delete(object, "secrets")
	}

	if raw, found := object["shipper"]; found {
		err = json.Unmarshal(raw, &a.Shipper)
		if err != nil {
			return fmt.Errorf("error reading 'shipper': %w", err)
		}
		delete(object, "shipper")
	}

	if raw, found := object["ssl"]; found {
		err = json.Unmarshal(raw, &a.Ssl)
		if err != nil {
			return fmt.Errorf("error reading 'ssl': %w", err)
		}
		delete(object, "ssl")
	}

	if raw, found := object["timeout"]; found {
		err = json.Unmarshal(raw, &a.Timeout)
		if err != nil {
			return fmt.Errorf("error reading 'timeout': %w", err)
		}
		delete(object, "timeout")
	}

	if raw, found := object["topic"]; found {
		err = json.Unmarshal(raw, &a.Topic)
		if err != nil {
			return fmt.Errorf("error reading 'topic': %w", err)
		}
		delete(object, "topic")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["username"]; found {
		err = json.Unmarshal(raw, &a.Username)
		if err != nil {
			return fmt.Errorf("error reading 'username': %w", err)
		}
		delete(object, "username")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if raw, found := object["write_to_logs_streams"]; found {
		err = json.Unmarshal(raw, &a.WriteToLogsStreams)
		if err != nil {
			return fmt.Errorf("error reading 'write_to_logs_streams': %w", err)
		}
		delete(object, "write_to_logs_streams")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka to handle AdditionalProperties
func (a OutputKafka) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AllowEdit != nil {
		object["allow_edit"], err = json.Marshal(a.AllowEdit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allow_edit': %w", err)
		}
	}

	object["auth_type"], err = json.Marshal(a.AuthType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'auth_type': %w", err)
	}

	if a.BrokerTimeout != nil {
		object["broker_timeout"], err = json.Marshal(a.BrokerTimeout)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'broker_timeout': %w", err)
		}
	}

	if a.CaSha256 != nil {
		object["ca_sha256"], err = json.Marshal(a.CaSha256)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ca_sha256': %w", err)
		}
	}

	if a.CaTrustedFingerprint != nil {
		object["ca_trusted_fingerprint"], err = json.Marshal(a.CaTrustedFingerprint)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ca_trusted_fingerprint': %w", err)
		}
	}

	if a.ClientId != nil {
		object["client_id"], err = json.Marshal(a.ClientId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'client_id': %w", err)
		}
	}

	if a.Compression != nil {
		object["compression"], err = json.Marshal(a.Compression)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'compression': %w", err)
		}
	}

	object["compression_level"], err = json.Marshal(a.CompressionLevel)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'compression_level': %w", err)
	}

	if a.ConfigYaml != nil {
		object["config_yaml"], err = json.Marshal(a.ConfigYaml)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'config_yaml': %w", err)
		}
	}

	object["connection_type"], err = json.Marshal(a.ConnectionType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'connection_type': %w", err)
	}

	if a.Hash != nil {
		object["hash"], err = json.Marshal(a.Hash)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'hash': %w", err)
		}
	}

	if a.Headers != nil {
		object["headers"], err = json.Marshal(a.Headers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'headers': %w", err)
		}
	}

	object["hosts"], err = json.Marshal(a.Hosts)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'hosts': %w", err)
	}

	if a.Id != nil {
		object["id"], err = json.Marshal(a.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if a.IsDefault != nil {
		object["is_default"], err = json.Marshal(a.IsDefault)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_default': %w", err)
		}
	}

	if a.IsDefaultMonitoring != nil {
		object["is_default_monitoring"], err = json.Marshal(a.IsDefaultMonitoring)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_default_monitoring': %w", err)
		}
	}

	if a.IsInternal != nil {
		object["is_internal"], err = json.Marshal(a.IsInternal)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_internal': %w", err)
		}
	}

	if a.IsPreconfigured != nil {
		object["is_preconfigured"], err = json.Marshal(a.IsPreconfigured)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_preconfigured': %w", err)
		}
	}

	if a.Key != nil {
		object["key"], err = json.Marshal(a.Key)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'key': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Partition != nil {
		object["partition"], err = json.Marshal(a.Partition)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'partition': %w", err)
		}
	}

	object["password"], err = json.Marshal(a.Password)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'password': %w", err)
	}

	if a.ProxyId != nil {
		object["proxy_id"], err = json.Marshal(a.ProxyId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_id': %w", err)
		}
	}

	if a.Random != nil {
		object["random"], err = json.Marshal(a.Random)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'random': %w", err)
		}
	}

	if a.RequiredAcks != nil {
		object["required_acks"], err = json.Marshal(a.RequiredAcks)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'required_acks': %w", err)
		}
	}

	if a.RoundRobin != nil {
		object["round_robin"], err = json.Marshal(a.RoundRobin)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'round_robin': %w", err)
		}
	}

	if a.Sasl != nil {
		object["sasl"], err = json.Marshal(a.Sasl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sasl': %w", err)
		}
	}

	if a.Secrets != nil {
		object["secrets"], err = json.Marshal(a.Secrets)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secrets': %w", err)
		}
	}

	if a.Shipper != nil {
		object["shipper"], err = json.Marshal(a.Shipper)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'shipper': %w", err)
		}
	}

	if a.Ssl != nil {
		object["ssl"], err = json.Marshal(a.Ssl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl': %w", err)
		}
	}

	if a.Timeout != nil {
		object["timeout"], err = json.Marshal(a.Timeout)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'timeout': %w", err)
		}
	}

	if a.Topic != nil {
		object["topic"], err = json.Marshal(a.Topic)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'topic': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	object["username"], err = json.Marshal(a.Username)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'username': %w", err)
	}

	if a.Version != nil {
		object["version"], err = json.Marshal(a.Version)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'version': %w", err)
		}
	}

	if a.WriteToLogsStreams != nil {
		object["write_to_logs_streams"], err = json.Marshal(a.WriteToLogsStreams)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'write_to_logs_streams': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka_Hash. Returns the specified
// element and whether it was found
func (a OutputKafka_Hash) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka_Hash
func (a *OutputKafka_Hash) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka_Hash to handle AdditionalProperties
func (a *OutputKafka_Hash) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["hash"]; found {
		err = json.Unmarshal(raw, &a.Hash)
		if err != nil {
			return fmt.Errorf("error reading 'hash': %w", err)
		}
		delete(object, "hash")
	}

	if raw, found := object["random"]; found {
		err = json.Unmarshal(raw, &a.Random)
		if err != nil {
			return fmt.Errorf("error reading 'random': %w", err)
		}
		delete(object, "random")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka_Hash to handle AdditionalProperties
func (a OutputKafka_Hash) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Hash != nil {
		object["hash"], err = json.Marshal(a.Hash)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'hash': %w", err)
		}
	}

	if a.Random != nil {
		object["random"], err = json.Marshal(a.Random)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'random': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka_Headers_Item. Returns the specified
// element and whether it was found
func (a OutputKafka_Headers_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka_Headers_Item
func (a *OutputKafka_Headers_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka_Headers_Item to handle AdditionalProperties
func (a *OutputKafka_Headers_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["key"]; found {
		err = json.Unmarshal(raw, &a.Key)
		if err != nil {
			return fmt.Errorf("error reading 'key': %w", err)
		}
		delete(object, "key")
	}

	if raw, found := object["value"]; found {
		err = json.Unmarshal(raw, &a.Value)
		if err != nil {
			return fmt.Errorf("error reading 'value': %w", err)
		}
		delete(object, "value")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka_Headers_Item to handle AdditionalProperties
func (a OutputKafka_Headers_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["key"], err = json.Marshal(a.Key)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'key': %w", err)
	}

	object["value"], err = json.Marshal(a.Value)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'value': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka_Random. Returns the specified
// element and whether it was found
func (a OutputKafka_Random) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka_Random
func (a *OutputKafka_Random) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka_Random to handle AdditionalProperties
func (a *OutputKafka_Random) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["group_events"]; found {
		err = json.Unmarshal(raw, &a.GroupEvents)
		if err != nil {
			return fmt.Errorf("error reading 'group_events': %w", err)
		}
		delete(object, "group_events")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka_Random to handle AdditionalProperties
func (a OutputKafka_Random) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.GroupEvents != nil {
		object["group_events"], err = json.Marshal(a.GroupEvents)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'group_events': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka_RoundRobin. Returns the specified
// element and whether it was found
func (a OutputKafka_RoundRobin) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka_RoundRobin
func (a *OutputKafka_RoundRobin) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka_RoundRobin to handle AdditionalProperties
func (a *OutputKafka_RoundRobin) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["group_events"]; found {
		err = json.Unmarshal(raw, &a.GroupEvents)
		if err != nil {
			return fmt.Errorf("error reading 'group_events': %w", err)
		}
		delete(object, "group_events")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka_RoundRobin to handle AdditionalProperties
func (a OutputKafka_RoundRobin) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.GroupEvents != nil {
		object["group_events"], err = json.Marshal(a.GroupEvents)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'group_events': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka_Sasl. Returns the specified
// element and whether it was found
func (a OutputKafka_Sasl) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka_Sasl
func (a *OutputKafka_Sasl) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka_Sasl to handle AdditionalProperties
func (a *OutputKafka_Sasl) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["mechanism"]; found {
		err = json.Unmarshal(raw, &a.Mechanism)
		if err != nil {
			return fmt.Errorf("error reading 'mechanism': %w", err)
		}
		delete(object, "mechanism")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka_Sasl to handle AdditionalProperties
func (a OutputKafka_Sasl) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Mechanism != nil {
		object["mechanism"], err = json.Marshal(a.Mechanism)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mechanism': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafkaSecretsPassword0. Returns the specified
// element and whether it was found
func (a OutputKafkaSecretsPassword0) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafkaSecretsPassword0
func (a *OutputKafkaSecretsPassword0) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafkaSecretsPassword0 to handle AdditionalProperties
func (a *OutputKafkaSecretsPassword0) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafkaSecretsPassword0 to handle AdditionalProperties
func (a OutputKafkaSecretsPassword0) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafkaSecretsSslKey0. Returns the specified
// element and whether it was found
func (a OutputKafkaSecretsSslKey0) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafkaSecretsSslKey0
func (a *OutputKafkaSecretsSslKey0) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafkaSecretsSslKey0 to handle AdditionalProperties
func (a *OutputKafkaSecretsSslKey0) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafkaSecretsSslKey0 to handle AdditionalProperties
func (a OutputKafkaSecretsSslKey0) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka_Secrets_Ssl. Returns the specified
// element and whether it was found
func (a OutputKafka_Secrets_Ssl) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka_Secrets_Ssl
func (a *OutputKafka_Secrets_Ssl) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka_Secrets_Ssl to handle AdditionalProperties
func (a *OutputKafka_Secrets_Ssl) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["key"]; found {
		err = json.Unmarshal(raw, &a.Key)
		if err != nil {
			return fmt.Errorf("error reading 'key': %w", err)
		}
		delete(object, "key")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka_Secrets_Ssl to handle AdditionalProperties
func (a OutputKafka_Secrets_Ssl) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["key"], err = json.Marshal(a.Key)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'key': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka_Secrets. Returns the specified
// element and whether it was found
func (a OutputKafka_Secrets) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka_Secrets
func (a *OutputKafka_Secrets) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka_Secrets to handle AdditionalProperties
func (a *OutputKafka_Secrets) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["password"]; found {
		err = json.Unmarshal(raw, &a.Password)
		if err != nil {
			return fmt.Errorf("error reading 'password': %w", err)
		}
		delete(object, "password")
	}

	if raw, found := object["ssl"]; found {
		err = json.Unmarshal(raw, &a.Ssl)
		if err != nil {
			return fmt.Errorf("error reading 'ssl': %w", err)
		}
		delete(object, "ssl")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka_Secrets to handle AdditionalProperties
func (a OutputKafka_Secrets) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Password != nil {
		object["password"], err = json.Marshal(a.Password)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'password': %w", err)
		}
	}

	if a.Ssl != nil {
		object["ssl"], err = json.Marshal(a.Ssl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputLogstash. Returns the specified
// element and whether it was found
func (a OutputLogstash) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputLogstash
func (a *OutputLogstash) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputLogstash to handle AdditionalProperties
func (a *OutputLogstash) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["allow_edit"]; found {
		err = json.Unmarshal(raw, &a.AllowEdit)
		if err != nil {
			return fmt.Errorf("error reading 'allow_edit': %w", err)
		}
		delete(object, "allow_edit")
	}

	if raw, found := object["ca_sha256"]; found {
		err = json.Unmarshal(raw, &a.CaSha256)
		if err != nil {
			return fmt.Errorf("error reading 'ca_sha256': %w", err)
		}
		delete(object, "ca_sha256")
	}

	if raw, found := object["ca_trusted_fingerprint"]; found {
		err = json.Unmarshal(raw, &a.CaTrustedFingerprint)
		if err != nil {
			return fmt.Errorf("error reading 'ca_trusted_fingerprint': %w", err)
		}
		delete(object, "ca_trusted_fingerprint")
	}

	if raw, found := object["config_yaml"]; found {
		err = json.Unmarshal(raw, &a.ConfigYaml)
		if err != nil {
			return fmt.Errorf("error reading 'config_yaml': %w", err)
		}
		delete(object, "config_yaml")
	}

	if raw, found := object["hosts"]; found {
		err = json.Unmarshal(raw, &a.Hosts)
		if err != nil {
			return fmt.Errorf("error reading 'hosts': %w", err)
		}
		delete(object, "hosts")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["is_default"]; found {
		err = json.Unmarshal(raw, &a.IsDefault)
		if err != nil {
			return fmt.Errorf("error reading 'is_default': %w", err)
		}
		delete(object, "is_default")
	}

	if raw, found := object["is_default_monitoring"]; found {
		err = json.Unmarshal(raw, &a.IsDefaultMonitoring)
		if err != nil {
			return fmt.Errorf("error reading 'is_default_monitoring': %w", err)
		}
		delete(object, "is_default_monitoring")
	}

	if raw, found := object["is_internal"]; found {
		err = json.Unmarshal(raw, &a.IsInternal)
		if err != nil {
			return fmt.Errorf("error reading 'is_internal': %w", err)
		}
		delete(object, "is_internal")
	}

	if raw, found := object["is_preconfigured"]; found {
		err = json.Unmarshal(raw, &a.IsPreconfigured)
		if err != nil {
			return fmt.Errorf("error reading 'is_preconfigured': %w", err)
		}
		delete(object, "is_preconfigured")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["proxy_id"]; found {
		err = json.Unmarshal(raw, &a.ProxyId)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_id': %w", err)
		}
		delete(object, "proxy_id")
	}

	if raw, found := object["secrets"]; found {
		err = json.Unmarshal(raw, &a.Secrets)
		if err != nil {
			return fmt.Errorf("error reading 'secrets': %w", err)
		}
		delete(object, "secrets")
	}

	if raw, found := object["shipper"]; found {
		err = json.Unmarshal(raw, &a.Shipper)
		if err != nil {
			return fmt.Errorf("error reading 'shipper': %w", err)
		}
		delete(object, "shipper")
	}

	if raw, found := object["ssl"]; found {
		err = json.Unmarshal(raw, &a.Ssl)
		if err != nil {
			return fmt.Errorf("error reading 'ssl': %w", err)
		}
		delete(object, "ssl")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["write_to_logs_streams"]; found {
		err = json.Unmarshal(raw, &a.WriteToLogsStreams)
		if err != nil {
			return fmt.Errorf("error reading 'write_to_logs_streams': %w", err)
		}
		delete(object, "write_to_logs_streams")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputLogstash to handle AdditionalProperties
func (a OutputLogstash) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AllowEdit != nil {
		object["allow_edit"], err = json.Marshal(a.AllowEdit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allow_edit': %w", err)
		}
	}

	if a.CaSha256 != nil {
		object["ca_sha256"], err = json.Marshal(a.CaSha256)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ca_sha256': %w", err)
		}
	}

	if a.CaTrustedFingerprint != nil {
		object["ca_trusted_fingerprint"], err = json.Marshal(a.CaTrustedFingerprint)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ca_trusted_fingerprint': %w", err)
		}
	}

	if a.ConfigYaml != nil {
		object["config_yaml"], err = json.Marshal(a.ConfigYaml)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'config_yaml': %w", err)
		}
	}

	object["hosts"], err = json.Marshal(a.Hosts)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'hosts': %w", err)
	}

	if a.Id != nil {
		object["id"], err = json.Marshal(a.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if a.IsDefault != nil {
		object["is_default"], err = json.Marshal(a.IsDefault)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_default': %w", err)
		}
	}

	if a.IsDefaultMonitoring != nil {
		object["is_default_monitoring"], err = json.Marshal(a.IsDefaultMonitoring)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_default_monitoring': %w", err)
		}
	}

	if a.IsInternal != nil {
		object["is_internal"], err = json.Marshal(a.IsInternal)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_internal': %w", err)
		}
	}

	if a.IsPreconfigured != nil {
		object["is_preconfigured"], err = json.Marshal(a.IsPreconfigured)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_preconfigured': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.ProxyId != nil {
		object["proxy_id"], err = json.Marshal(a.ProxyId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_id': %w", err)
		}
	}

	if a.Secrets != nil {
		object["secrets"], err = json.Marshal(a.Secrets)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secrets': %w", err)
		}
	}

	if a.Shipper != nil {
		object["shipper"], err = json.Marshal(a.Shipper)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'shipper': %w", err)
		}
	}

	if a.Ssl != nil {
		object["ssl"], err = json.Marshal(a.Ssl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	if a.WriteToLogsStreams != nil {
		object["write_to_logs_streams"], err = json.Marshal(a.WriteToLogsStreams)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'write_to_logs_streams': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputLogstashSecretsSslKey0. Returns the specified
// element and whether it was found
func (a OutputLogstashSecretsSslKey0) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputLogstashSecretsSslKey0
func (a *OutputLogstashSecretsSslKey0) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputLogstashSecretsSslKey0 to handle AdditionalProperties
func (a *OutputLogstashSecretsSslKey0) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputLogstashSecretsSslKey0 to handle AdditionalProperties
func (a OutputLogstashSecretsSslKey0) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputLogstash_Secrets_Ssl. Returns the specified
// element and whether it was found
func (a OutputLogstash_Secrets_Ssl) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputLogstash_Secrets_Ssl
func (a *OutputLogstash_Secrets_Ssl) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputLogstash_Secrets_Ssl to handle AdditionalProperties
func (a *OutputLogstash_Secrets_Ssl) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["key"]; found {
		err = json.Unmarshal(raw, &a.Key)
		if err != nil {
			return fmt.Errorf("error reading 'key': %w", err)
		}
		delete(object, "key")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputLogstash_Secrets_Ssl to handle AdditionalProperties
func (a OutputLogstash_Secrets_Ssl) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Key != nil {
		object["key"], err = json.Marshal(a.Key)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'key': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputLogstash_Secrets. Returns the specified
// element and whether it was found
func (a OutputLogstash_Secrets) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputLogstash_Secrets
func (a *OutputLogstash_Secrets) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputLogstash_Secrets to handle AdditionalProperties
func (a *OutputLogstash_Secrets) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["ssl"]; found {
		err = json.Unmarshal(raw, &a.Ssl)
		if err != nil {
			return fmt.Errorf("error reading 'ssl': %w", err)
		}
		delete(object, "ssl")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputLogstash_Secrets to handle AdditionalProperties
func (a OutputLogstash_Secrets) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Ssl != nil {
		object["ssl"], err = json.Marshal(a.Ssl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputRemoteElasticsearch. Returns the specified
// element and whether it was found
func (a OutputRemoteElasticsearch) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputRemoteElasticsearch
func (a *OutputRemoteElasticsearch) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputRemoteElasticsearch to handle AdditionalProperties
func (a *OutputRemoteElasticsearch) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["allow_edit"]; found {
		err = json.Unmarshal(raw, &a.AllowEdit)
		if err != nil {
			return fmt.Errorf("error reading 'allow_edit': %w", err)
		}
		delete(object, "allow_edit")
	}

	if raw, found := object["ca_sha256"]; found {
		err = json.Unmarshal(raw, &a.CaSha256)
		if err != nil {
			return fmt.Errorf("error reading 'ca_sha256': %w", err)
		}
		delete(object, "ca_sha256")
	}

	if raw, found := object["ca_trusted_fingerprint"]; found {
		err = json.Unmarshal(raw, &a.CaTrustedFingerprint)
		if err != nil {
			return fmt.Errorf("error reading 'ca_trusted_fingerprint': %w", err)
		}
		delete(object, "ca_trusted_fingerprint")
	}

	if raw, found := object["config_yaml"]; found {
		err = json.Unmarshal(raw, &a.ConfigYaml)
		if err != nil {
			return fmt.Errorf("error reading 'config_yaml': %w", err)
		}
		delete(object, "config_yaml")
	}

	if raw, found := object["hosts"]; found {
		err = json.Unmarshal(raw, &a.Hosts)
		if err != nil {
			return fmt.Errorf("error reading 'hosts': %w", err)
		}
		delete(object, "hosts")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["is_default"]; found {
		err = json.Unmarshal(raw, &a.IsDefault)
		if err != nil {
			return fmt.Errorf("error reading 'is_default': %w", err)
		}
		delete(object, "is_default")
	}

	if raw, found := object["is_default_monitoring"]; found {
		err = json.Unmarshal(raw, &a.IsDefaultMonitoring)
		if err != nil {
			return fmt.Errorf("error reading 'is_default_monitoring': %w", err)
		}
		delete(object, "is_default_monitoring")
	}

	if raw, found := object["is_internal"]; found {
		err = json.Unmarshal(raw, &a.IsInternal)
		if err != nil {
			return fmt.Errorf("error reading 'is_internal': %w", err)
		}
		delete(object, "is_internal")
	}

	if raw, found := object["is_preconfigured"]; found {
		err = json.Unmarshal(raw, &a.IsPreconfigured)
		if err != nil {
			return fmt.Errorf("error reading 'is_preconfigured': %w", err)
		}
		delete(object, "is_preconfigured")
	}

	if raw, found := object["kibana_api_key"]; found {
		err = json.Unmarshal(raw, &a.KibanaApiKey)
		if err != nil {
			return fmt.Errorf("error reading 'kibana_api_key': %w", err)
		}
		delete(object, "kibana_api_key")
	}

	if raw, found := object["kibana_url"]; found {
		err = json.Unmarshal(raw, &a.KibanaUrl)
		if err != nil {
			return fmt.Errorf("error reading 'kibana_url': %w", err)
		}
		delete(object, "kibana_url")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["preset"]; found {
		err = json.Unmarshal(raw, &a.Preset)
		if err != nil {
			return fmt.Errorf("error reading 'preset': %w", err)
		}
		delete(object, "preset")
	}

	if raw, found := object["proxy_id"]; found {
		err = json.Unmarshal(raw, &a.ProxyId)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_id': %w", err)
		}
		delete(object, "proxy_id")
	}

	if raw, found := object["secrets"]; found {
		err = json.Unmarshal(raw, &a.Secrets)
		if err != nil {
			return fmt.Errorf("error reading 'secrets': %w", err)
		}
		delete(object, "secrets")
	}

	if raw, found := object["service_token"]; found {
		err = json.Unmarshal(raw, &a.ServiceToken)
		if err != nil {
			return fmt.Errorf("error reading 'service_token': %w", err)
		}
		delete(object, "service_token")
	}

	if raw, found := object["shipper"]; found {
		err = json.Unmarshal(raw, &a.Shipper)
		if err != nil {
			return fmt.Errorf("error reading 'shipper': %w", err)
		}
		delete(object, "shipper")
	}

	if raw, found := object["ssl"]; found {
		err = json.Unmarshal(raw, &a.Ssl)
		if err != nil {
			return fmt.Errorf("error reading 'ssl': %w", err)
		}
		delete(object, "ssl")
	}

	if raw, found := object["sync_integrations"]; found {
		err = json.Unmarshal(raw, &a.SyncIntegrations)
		if err != nil {
			return fmt.Errorf("error reading 'sync_integrations': %w", err)
		}
		delete(object, "sync_integrations")
	}

	if raw, found := object["sync_uninstalled_integrations"]; found {
		err = json.Unmarshal(raw, &a.SyncUninstalledIntegrations)
		if err != nil {
			return fmt.Errorf("error reading 'sync_uninstalled_integrations': %w", err)
		}
		delete(object, "sync_uninstalled_integrations")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["write_to_logs_streams"]; found {
		err = json.Unmarshal(raw, &a.WriteToLogsStreams)
		if err != nil {
			return fmt.Errorf("error reading 'write_to_logs_streams': %w", err)
		}
		delete(object, "write_to_logs_streams")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputRemoteElasticsearch to handle AdditionalProperties
func (a OutputRemoteElasticsearch) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AllowEdit != nil {
		object["allow_edit"], err = json.Marshal(a.AllowEdit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allow_edit': %w", err)
		}
	}

	if a.CaSha256 != nil {
		object["ca_sha256"], err = json.Marshal(a.CaSha256)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ca_sha256': %w", err)
		}
	}

	if a.CaTrustedFingerprint != nil {
		object["ca_trusted_fingerprint"], err = json.Marshal(a.CaTrustedFingerprint)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ca_trusted_fingerprint': %w", err)
		}
	}

	if a.ConfigYaml != nil {
		object["config_yaml"], err = json.Marshal(a.ConfigYaml)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'config_yaml': %w", err)
		}
	}

	object["hosts"], err = json.Marshal(a.Hosts)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'hosts': %w", err)
	}

	if a.Id != nil {
		object["id"], err = json.Marshal(a.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if a.IsDefault != nil {
		object["is_default"], err = json.Marshal(a.IsDefault)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_default': %w", err)
		}
	}

	if a.IsDefaultMonitoring != nil {
		object["is_default_monitoring"], err = json.Marshal(a.IsDefaultMonitoring)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_default_monitoring': %w", err)
		}
	}

	if a.IsInternal != nil {
		object["is_internal"], err = json.Marshal(a.IsInternal)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_internal': %w", err)
		}
	}

	if a.IsPreconfigured != nil {
		object["is_preconfigured"], err = json.Marshal(a.IsPreconfigured)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_preconfigured': %w", err)
		}
	}

	if a.KibanaApiKey != nil {
		object["kibana_api_key"], err = json.Marshal(a.KibanaApiKey)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'kibana_api_key': %w", err)
		}
	}

	if a.KibanaUrl != nil {
		object["kibana_url"], err = json.Marshal(a.KibanaUrl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'kibana_url': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Preset != nil {
		object["preset"], err = json.Marshal(a.Preset)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'preset': %w", err)
		}
	}

	if a.ProxyId != nil {
		object["proxy_id"], err = json.Marshal(a.ProxyId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_id': %w", err)
		}
	}

	if a.Secrets != nil {
		object["secrets"], err = json.Marshal(a.Secrets)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secrets': %w", err)
		}
	}

	if a.ServiceToken != nil {
		object["service_token"], err = json.Marshal(a.ServiceToken)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'service_token': %w", err)
		}
	}

	if a.Shipper != nil {
		object["shipper"], err = json.Marshal(a.Shipper)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'shipper': %w", err)
		}
	}

	if a.Ssl != nil {
		object["ssl"], err = json.Marshal(a.Ssl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl': %w", err)
		}
	}

	if a.SyncIntegrations != nil {
		object["sync_integrations"], err = json.Marshal(a.SyncIntegrations)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sync_integrations': %w", err)
		}
	}

	if a.SyncUninstalledIntegrations != nil {
		object["sync_uninstalled_integrations"], err = json.Marshal(a.SyncUninstalledIntegrations)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sync_uninstalled_integrations': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	if a.WriteToLogsStreams != nil {
		object["write_to_logs_streams"], err = json.Marshal(a.WriteToLogsStreams)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'write_to_logs_streams': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputRemoteElasticsearchSecretsServiceToken0. Returns the specified
// element and whether it was found
func (a OutputRemoteElasticsearchSecretsServiceToken0) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputRemoteElasticsearchSecretsServiceToken0
func (a *OutputRemoteElasticsearchSecretsServiceToken0) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputRemoteElasticsearchSecretsServiceToken0 to handle AdditionalProperties
func (a *OutputRemoteElasticsearchSecretsServiceToken0) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputRemoteElasticsearchSecretsServiceToken0 to handle AdditionalProperties
func (a OutputRemoteElasticsearchSecretsServiceToken0) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputRemoteElasticsearchSecretsSslKey0. Returns the specified
// element and whether it was found
func (a OutputRemoteElasticsearchSecretsSslKey0) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputRemoteElasticsearchSecretsSslKey0
func (a *OutputRemoteElasticsearchSecretsSslKey0) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputRemoteElasticsearchSecretsSslKey0 to handle AdditionalProperties
func (a *OutputRemoteElasticsearchSecretsSslKey0) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputRemoteElasticsearchSecretsSslKey0 to handle AdditionalProperties
func (a OutputRemoteElasticsearchSecretsSslKey0) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputRemoteElasticsearch_Secrets_Ssl. Returns the specified
// element and whether it was found
func (a OutputRemoteElasticsearch_Secrets_Ssl) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputRemoteElasticsearch_Secrets_Ssl
func (a *OutputRemoteElasticsearch_Secrets_Ssl) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputRemoteElasticsearch_Secrets_Ssl to handle AdditionalProperties
func (a *OutputRemoteElasticsearch_Secrets_Ssl) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["key"]; found {
		err = json.Unmarshal(raw, &a.Key)
		if err != nil {
			return fmt.Errorf("error reading 'key': %w", err)
		}
		delete(object, "key")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputRemoteElasticsearch_Secrets_Ssl to handle AdditionalProperties
func (a OutputRemoteElasticsearch_Secrets_Ssl) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Key != nil {
		object["key"], err = json.Marshal(a.Key)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'key': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputRemoteElasticsearch_Secrets. Returns the specified
// element and whether it was found
func (a OutputRemoteElasticsearch_Secrets) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputRemoteElasticsearch_Secrets
func (a *OutputRemoteElasticsearch_Secrets) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputRemoteElasticsearch_Secrets to handle AdditionalProperties
func (a *OutputRemoteElasticsearch_Secrets) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["service_token"]; found {
		err = json.Unmarshal(raw, &a.ServiceToken)
		if err != nil {
			return fmt.Errorf("error reading 'service_token': %w", err)
		}
		delete(object, "service_token")
	}

	if raw, found := object["ssl"]; found {
		err = json.Unmarshal(raw, &a.Ssl)
		if err != nil {
			return fmt.Errorf("error reading 'ssl': %w", err)
		}
		delete(object, "ssl")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputRemoteElasticsearch_Secrets to handle AdditionalProperties
func (a OutputRemoteElasticsearch_Secrets) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.ServiceToken != nil {
		object["service_token"], err = json.Marshal(a.ServiceToken)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'service_token': %w", err)
		}
	}

	if a.Ssl != nil {
		object["ssl"], err = json.Marshal(a.Ssl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputShipper. Returns the specified
// element and whether it was found
func (a OutputShipper) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputShipper
func (a *OutputShipper) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputShipper to handle AdditionalProperties
func (a *OutputShipper) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["compression_level"]; found {
		err = json.Unmarshal(raw, &a.CompressionLevel)
		if err != nil {
			return fmt.Errorf("error reading 'compression_level': %w", err)
		}
		delete(object, "compression_level")
	}

	if raw, found := object["disk_queue_compression_enabled"]; found {
		err = json.Unmarshal(raw, &a.DiskQueueCompressionEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'disk_queue_compression_enabled': %w", err)
		}
		delete(object, "disk_queue_compression_enabled")
	}

	if raw, found := object["disk_queue_enabled"]; found {
		err = json.Unmarshal(raw, &a.DiskQueueEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'disk_queue_enabled': %w", err)
		}
		delete(object, "disk_queue_enabled")
	}

	if raw, found := object["disk_queue_encryption_enabled"]; found {
		err = json.Unmarshal(raw, &a.DiskQueueEncryptionEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'disk_queue_encryption_enabled': %w", err)
		}
		delete(object, "disk_queue_encryption_enabled")
	}

	if raw, found := object["disk_queue_max_size"]; found {
		err = json.Unmarshal(raw, &a.DiskQueueMaxSize)
		if err != nil {
			return fmt.Errorf("error reading 'disk_queue_max_size': %w", err)
		}
		delete(object, "disk_queue_max_size")
	}

	if raw, found := object["disk_queue_path"]; found {
		err = json.Unmarshal(raw, &a.DiskQueuePath)
		if err != nil {
			return fmt.Errorf("error reading 'disk_queue_path': %w", err)
		}
		delete(object, "disk_queue_path")
	}

	if raw, found := object["loadbalance"]; found {
		err = json.Unmarshal(raw, &a.Loadbalance)
		if err != nil {
			return fmt.Errorf("error reading 'loadbalance': %w", err)
		}
		delete(object, "loadbalance")
	}

	if raw, found := object["max_batch_bytes"]; found {
		err = json.Unmarshal(raw, &a.MaxBatchBytes)
		if err != nil {
			return fmt.Errorf("error reading 'max_batch_bytes': %w", err)
		}
		delete(object, "max_batch_bytes")
	}

	if raw, found := object["mem_queue_events"]; found {
		err = json.Unmarshal(raw, &a.MemQueueEvents)
		if err != nil {
			return fmt.Errorf("error reading 'mem_queue_events': %w", err)
		}
		delete(object, "mem_queue_events")
	}

	if raw, found := object["queue_flush_timeout"]; found {
		err = json.Unmarshal(raw, &a.QueueFlushTimeout)
		if err != nil {
			return fmt.Errorf("error reading 'queue_flush_timeout': %w", err)
		}
		delete(object, "queue_flush_timeout")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputShipper to handle AdditionalProperties
func (a OutputShipper) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["compression_level"], err = json.Marshal(a.CompressionLevel)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'compression_level': %w", err)
	}

	object["disk_queue_compression_enabled"], err = json.Marshal(a.DiskQueueCompressionEnabled)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'disk_queue_compression_enabled': %w", err)
	}

	if a.DiskQueueEnabled != nil {
		object["disk_queue_enabled"], err = json.Marshal(a.DiskQueueEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'disk_queue_enabled': %w", err)
		}
	}

	object["disk_queue_encryption_enabled"], err = json.Marshal(a.DiskQueueEncryptionEnabled)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'disk_queue_encryption_enabled': %w", err)
	}

	object["disk_queue_max_size"], err = json.Marshal(a.DiskQueueMaxSize)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'disk_queue_max_size': %w", err)
	}

	object["disk_queue_path"], err = json.Marshal(a.DiskQueuePath)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'disk_queue_path': %w", err)
	}

	object["loadbalance"], err = json.Marshal(a.Loadbalance)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'loadbalance': %w", err)
	}

	object["max_batch_bytes"], err = json.Marshal(a.MaxBatchBytes)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'max_batch_bytes': %w", err)
	}

	object["mem_queue_events"], err = json.Marshal(a.MemQueueEvents)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'mem_queue_events': %w", err)
	}

	object["queue_flush_timeout"], err = json.Marshal(a.QueueFlushTimeout)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'queue_flush_timeout': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputSsl. Returns the specified
// element and whether it was found
func (a OutputSsl) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputSsl
func (a *OutputSsl) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputSsl to handle AdditionalProperties
func (a *OutputSsl) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["certificate"]; found {
		err = json.Unmarshal(raw, &a.Certificate)
		if err != nil {
			return fmt.Errorf("error reading 'certificate': %w", err)
		}
		delete(object, "certificate")
	}

	if raw, found := object["certificate_authorities"]; found {
		err = json.Unmarshal(raw, &a.CertificateAuthorities)
		if err != nil {
			return fmt.Errorf("error reading 'certificate_authorities': %w", err)
		}
		delete(object, "certificate_authorities")
	}

	if raw, found := object["key"]; found {
		err = json.Unmarshal(raw, &a.Key)
		if err != nil {
			return fmt.Errorf("error reading 'key': %w", err)
		}
		delete(object, "key")
	}

	if raw, found := object["verification_mode"]; found {
		err = json.Unmarshal(raw, &a.VerificationMode)
		if err != nil {
			return fmt.Errorf("error reading 'verification_mode': %w", err)
		}
		delete(object, "verification_mode")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputSsl to handle AdditionalProperties
func (a OutputSsl) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Certificate != nil {
		object["certificate"], err = json.Marshal(a.Certificate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'certificate': %w", err)
		}
	}

	if a.CertificateAuthorities != nil {
		object["certificate_authorities"], err = json.Marshal(a.CertificateAuthorities)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'certificate_authorities': %w", err)
		}
	}

	if a.Key != nil {
		object["key"], err = json.Marshal(a.Key)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'key': %w", err)
		}
	}

	if a.VerificationMode != nil {
		object["verification_mode"], err = json.Marshal(a.VerificationMode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'verification_mode': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo. Returns the specified
// element and whether it was found
func (a PackageInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo
func (a *PackageInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo to handle AdditionalProperties
func (a *PackageInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["agent"]; found {
		err = json.Unmarshal(raw, &a.Agent)
		if err != nil {
			return fmt.Errorf("error reading 'agent': %w", err)
		}
		delete(object, "agent")
	}

	if raw, found := object["asset_tags"]; found {
		err = json.Unmarshal(raw, &a.AssetTags)
		if err != nil {
			return fmt.Errorf("error reading 'asset_tags': %w", err)
		}
		delete(object, "asset_tags")
	}

	if raw, found := object["assets"]; found {
		err = json.Unmarshal(raw, &a.Assets)
		if err != nil {
			return fmt.Errorf("error reading 'assets': %w", err)
		}
		delete(object, "assets")
	}

	if raw, found := object["categories"]; found {
		err = json.Unmarshal(raw, &a.Categories)
		if err != nil {
			return fmt.Errorf("error reading 'categories': %w", err)
		}
		delete(object, "categories")
	}

	if raw, found := object["conditions"]; found {
		err = json.Unmarshal(raw, &a.Conditions)
		if err != nil {
			return fmt.Errorf("error reading 'conditions': %w", err)
		}
		delete(object, "conditions")
	}

	if raw, found := object["data_streams"]; found {
		err = json.Unmarshal(raw, &a.DataStreams)
		if err != nil {
			return fmt.Errorf("error reading 'data_streams': %w", err)
		}
		delete(object, "data_streams")
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["discovery"]; found {
		err = json.Unmarshal(raw, &a.Discovery)
		if err != nil {
			return fmt.Errorf("error reading 'discovery': %w", err)
		}
		delete(object, "discovery")
	}

	if raw, found := object["download"]; found {
		err = json.Unmarshal(raw, &a.Download)
		if err != nil {
			return fmt.Errorf("error reading 'download': %w", err)
		}
		delete(object, "download")
	}

	if raw, found := object["elasticsearch"]; found {
		err = json.Unmarshal(raw, &a.Elasticsearch)
		if err != nil {
			return fmt.Errorf("error reading 'elasticsearch': %w", err)
		}
		delete(object, "elasticsearch")
	}

	if raw, found := object["format_version"]; found {
		err = json.Unmarshal(raw, &a.FormatVersion)
		if err != nil {
			return fmt.Errorf("error reading 'format_version': %w", err)
		}
		delete(object, "format_version")
	}

	if raw, found := object["icons"]; found {
		err = json.Unmarshal(raw, &a.Icons)
		if err != nil {
			return fmt.Errorf("error reading 'icons': %w", err)
		}
		delete(object, "icons")
	}

	if raw, found := object["installationInfo"]; found {
		err = json.Unmarshal(raw, &a.InstallationInfo)
		if err != nil {
			return fmt.Errorf("error reading 'installationInfo': %w", err)
		}
		delete(object, "installationInfo")
	}

	if raw, found := object["internal"]; found {
		err = json.Unmarshal(raw, &a.Internal)
		if err != nil {
			return fmt.Errorf("error reading 'internal': %w", err)
		}
		delete(object, "internal")
	}

	if raw, found := object["keepPoliciesUpToDate"]; found {
		err = json.Unmarshal(raw, &a.KeepPoliciesUpToDate)
		if err != nil {
			return fmt.Errorf("error reading 'keepPoliciesUpToDate': %w", err)
		}
		delete(object, "keepPoliciesUpToDate")
	}

	if raw, found := object["latestVersion"]; found {
		err = json.Unmarshal(raw, &a.LatestVersion)
		if err != nil {
			return fmt.Errorf("error reading 'latestVersion': %w", err)
		}
		delete(object, "latestVersion")
	}

	if raw, found := object["license"]; found {
		err = json.Unmarshal(raw, &a.License)
		if err != nil {
			return fmt.Errorf("error reading 'license': %w", err)
		}
		delete(object, "license")
	}

	if raw, found := object["licensePath"]; found {
		err = json.Unmarshal(raw, &a.LicensePath)
		if err != nil {
			return fmt.Errorf("error reading 'licensePath': %w", err)
		}
		delete(object, "licensePath")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["notice"]; found {
		err = json.Unmarshal(raw, &a.Notice)
		if err != nil {
			return fmt.Errorf("error reading 'notice': %w", err)
		}
		delete(object, "notice")
	}

	if raw, found := object["owner"]; found {
		err = json.Unmarshal(raw, &a.Owner)
		if err != nil {
			return fmt.Errorf("error reading 'owner': %w", err)
		}
		delete(object, "owner")
	}

	if raw, found := object["path"]; found {
		err = json.Unmarshal(raw, &a.Path)
		if err != nil {
			return fmt.Errorf("error reading 'path': %w", err)
		}
		delete(object, "path")
	}

	if raw, found := object["policy_templates"]; found {
		err = json.Unmarshal(raw, &a.PolicyTemplates)
		if err != nil {
			return fmt.Errorf("error reading 'policy_templates': %w", err)
		}
		delete(object, "policy_templates")
	}

	if raw, found := object["readme"]; found {
		err = json.Unmarshal(raw, &a.Readme)
		if err != nil {
			return fmt.Errorf("error reading 'readme': %w", err)
		}
		delete(object, "readme")
	}

	if raw, found := object["release"]; found {
		err = json.Unmarshal(raw, &a.Release)
		if err != nil {
			return fmt.Errorf("error reading 'release': %w", err)
		}
		delete(object, "release")
	}

	if raw, found := object["screenshots"]; found {
		err = json.Unmarshal(raw, &a.Screenshots)
		if err != nil {
			return fmt.Errorf("error reading 'screenshots': %w", err)
		}
		delete(object, "screenshots")
	}

	if raw, found := object["signature_path"]; found {
		err = json.Unmarshal(raw, &a.SignaturePath)
		if err != nil {
			return fmt.Errorf("error reading 'signature_path': %w", err)
		}
		delete(object, "signature_path")
	}

	if raw, found := object["source"]; found {
		err = json.Unmarshal(raw, &a.Source)
		if err != nil {
			return fmt.Errorf("error reading 'source': %w", err)
		}
		delete(object, "source")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
		delete(object, "title")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["vars"]; found {
		err = json.Unmarshal(raw, &a.Vars)
		if err != nil {
			return fmt.Errorf("error reading 'vars': %w", err)
		}
		delete(object, "vars")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo to handle AdditionalProperties
func (a PackageInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Agent != nil {
		object["agent"], err = json.Marshal(a.Agent)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'agent': %w", err)
		}
	}

	if a.AssetTags != nil {
		object["asset_tags"], err = json.Marshal(a.AssetTags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'asset_tags': %w", err)
		}
	}

	object["assets"], err = json.Marshal(a.Assets)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'assets': %w", err)
	}

	if a.Categories != nil {
		object["categories"], err = json.Marshal(a.Categories)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'categories': %w", err)
		}
	}

	if a.Conditions != nil {
		object["conditions"], err = json.Marshal(a.Conditions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'conditions': %w", err)
		}
	}

	if a.DataStreams != nil {
		object["data_streams"], err = json.Marshal(a.DataStreams)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'data_streams': %w", err)
		}
	}

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.Discovery != nil {
		object["discovery"], err = json.Marshal(a.Discovery)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'discovery': %w", err)
		}
	}

	if a.Download != nil {
		object["download"], err = json.Marshal(a.Download)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'download': %w", err)
		}
	}

	if a.Elasticsearch != nil {
		object["elasticsearch"], err = json.Marshal(a.Elasticsearch)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'elasticsearch': %w", err)
		}
	}

	if a.FormatVersion != nil {
		object["format_version"], err = json.Marshal(a.FormatVersion)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'format_version': %w", err)
		}
	}

	if a.Icons != nil {
		object["icons"], err = json.Marshal(a.Icons)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'icons': %w", err)
		}
	}

	if a.InstallationInfo != nil {
		object["installationInfo"], err = json.Marshal(a.InstallationInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'installationInfo': %w", err)
		}
	}

	if a.Internal != nil {
		object["internal"], err = json.Marshal(a.Internal)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'internal': %w", err)
		}
	}

	if a.KeepPoliciesUpToDate != nil {
		object["keepPoliciesUpToDate"], err = json.Marshal(a.KeepPoliciesUpToDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'keepPoliciesUpToDate': %w", err)
		}
	}

	if a.LatestVersion != nil {
		object["latestVersion"], err = json.Marshal(a.LatestVersion)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'latestVersion': %w", err)
		}
	}

	if a.License != nil {
		object["license"], err = json.Marshal(a.License)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'license': %w", err)
		}
	}

	if a.LicensePath != nil {
		object["licensePath"], err = json.Marshal(a.LicensePath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'licensePath': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Notice != nil {
		object["notice"], err = json.Marshal(a.Notice)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'notice': %w", err)
		}
	}

	if a.Owner != nil {
		object["owner"], err = json.Marshal(a.Owner)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'owner': %w", err)
		}
	}

	if a.Path != nil {
		object["path"], err = json.Marshal(a.Path)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'path': %w", err)
		}
	}

	if a.PolicyTemplates != nil {
		object["policy_templates"], err = json.Marshal(a.PolicyTemplates)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'policy_templates': %w", err)
		}
	}

	if a.Readme != nil {
		object["readme"], err = json.Marshal(a.Readme)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'readme': %w", err)
		}
	}

	if a.Release != nil {
		object["release"], err = json.Marshal(a.Release)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'release': %w", err)
		}
	}

	if a.Screenshots != nil {
		object["screenshots"], err = json.Marshal(a.Screenshots)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'screenshots': %w", err)
		}
	}

	if a.SignaturePath != nil {
		object["signature_path"], err = json.Marshal(a.SignaturePath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'signature_path': %w", err)
		}
	}

	if a.Source != nil {
		object["source"], err = json.Marshal(a.Source)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'source': %w", err)
		}
	}

	if a.Status != nil {
		object["status"], err = json.Marshal(a.Status)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status': %w", err)
		}
	}

	object["title"], err = json.Marshal(a.Title)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'title': %w", err)
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	if a.Vars != nil {
		object["vars"], err = json.Marshal(a.Vars)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'vars': %w", err)
		}
	}

	object["version"], err = json.Marshal(a.Version)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'version': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_Conditions_Elastic. Returns the specified
// element and whether it was found
func (a PackageInfo_Conditions_Elastic) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_Conditions_Elastic
func (a *PackageInfo_Conditions_Elastic) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_Conditions_Elastic to handle AdditionalProperties
func (a *PackageInfo_Conditions_Elastic) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["capabilities"]; found {
		err = json.Unmarshal(raw, &a.Capabilities)
		if err != nil {
			return fmt.Errorf("error reading 'capabilities': %w", err)
		}
		delete(object, "capabilities")
	}

	if raw, found := object["subscription"]; found {
		err = json.Unmarshal(raw, &a.Subscription)
		if err != nil {
			return fmt.Errorf("error reading 'subscription': %w", err)
		}
		delete(object, "subscription")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_Conditions_Elastic to handle AdditionalProperties
func (a PackageInfo_Conditions_Elastic) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Capabilities != nil {
		object["capabilities"], err = json.Marshal(a.Capabilities)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'capabilities': %w", err)
		}
	}

	if a.Subscription != nil {
		object["subscription"], err = json.Marshal(a.Subscription)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subscription': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_Conditions_Kibana. Returns the specified
// element and whether it was found
func (a PackageInfo_Conditions_Kibana) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_Conditions_Kibana
func (a *PackageInfo_Conditions_Kibana) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_Conditions_Kibana to handle AdditionalProperties
func (a *PackageInfo_Conditions_Kibana) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_Conditions_Kibana to handle AdditionalProperties
func (a PackageInfo_Conditions_Kibana) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Version != nil {
		object["version"], err = json.Marshal(a.Version)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'version': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_Conditions. Returns the specified
// element and whether it was found
func (a PackageInfo_Conditions) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_Conditions
func (a *PackageInfo_Conditions) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_Conditions to handle AdditionalProperties
func (a *PackageInfo_Conditions) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["elastic"]; found {
		err = json.Unmarshal(raw, &a.Elastic)
		if err != nil {
			return fmt.Errorf("error reading 'elastic': %w", err)
		}
		delete(object, "elastic")
	}

	if raw, found := object["kibana"]; found {
		err = json.Unmarshal(raw, &a.Kibana)
		if err != nil {
			return fmt.Errorf("error reading 'kibana': %w", err)
		}
		delete(object, "kibana")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_Conditions to handle AdditionalProperties
func (a PackageInfo_Conditions) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Elastic != nil {
		object["elastic"], err = json.Marshal(a.Elastic)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'elastic': %w", err)
		}
	}

	if a.Kibana != nil {
		object["kibana"], err = json.Marshal(a.Kibana)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'kibana': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_Discovery_Datasets_Item. Returns the specified
// element and whether it was found
func (a PackageInfo_Discovery_Datasets_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_Discovery_Datasets_Item
func (a *PackageInfo_Discovery_Datasets_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_Discovery_Datasets_Item to handle AdditionalProperties
func (a *PackageInfo_Discovery_Datasets_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_Discovery_Datasets_Item to handle AdditionalProperties
func (a PackageInfo_Discovery_Datasets_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_Discovery_Fields_Item. Returns the specified
// element and whether it was found
func (a PackageInfo_Discovery_Fields_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_Discovery_Fields_Item
func (a *PackageInfo_Discovery_Fields_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_Discovery_Fields_Item to handle AdditionalProperties
func (a *PackageInfo_Discovery_Fields_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_Discovery_Fields_Item to handle AdditionalProperties
func (a PackageInfo_Discovery_Fields_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_Discovery. Returns the specified
// element and whether it was found
func (a PackageInfo_Discovery) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_Discovery
func (a *PackageInfo_Discovery) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_Discovery to handle AdditionalProperties
func (a *PackageInfo_Discovery) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["datasets"]; found {
		err = json.Unmarshal(raw, &a.Datasets)
		if err != nil {
			return fmt.Errorf("error reading 'datasets': %w", err)
		}
		delete(object, "datasets")
	}

	if raw, found := object["fields"]; found {
		err = json.Unmarshal(raw, &a.Fields)
		if err != nil {
			return fmt.Errorf("error reading 'fields': %w", err)
		}
		delete(object, "fields")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_Discovery to handle AdditionalProperties
func (a PackageInfo_Discovery) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Datasets != nil {
		object["datasets"], err = json.Marshal(a.Datasets)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'datasets': %w", err)
		}
	}

	if a.Fields != nil {
		object["fields"], err = json.Marshal(a.Fields)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fields': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_Icons_Item. Returns the specified
// element and whether it was found
func (a PackageInfo_Icons_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_Icons_Item
func (a *PackageInfo_Icons_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_Icons_Item to handle AdditionalProperties
func (a *PackageInfo_Icons_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["dark_mode"]; found {
		err = json.Unmarshal(raw, &a.DarkMode)
		if err != nil {
			return fmt.Errorf("error reading 'dark_mode': %w", err)
		}
		delete(object, "dark_mode")
	}

	if raw, found := object["path"]; found {
		err = json.Unmarshal(raw, &a.Path)
		if err != nil {
			return fmt.Errorf("error reading 'path': %w", err)
		}
		delete(object, "path")
	}

	if raw, found := object["size"]; found {
		err = json.Unmarshal(raw, &a.Size)
		if err != nil {
			return fmt.Errorf("error reading 'size': %w", err)
		}
		delete(object, "size")
	}

	if raw, found := object["src"]; found {
		err = json.Unmarshal(raw, &a.Src)
		if err != nil {
			return fmt.Errorf("error reading 'src': %w", err)
		}
		delete(object, "src")
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
		delete(object, "title")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_Icons_Item to handle AdditionalProperties
func (a PackageInfo_Icons_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.DarkMode != nil {
		object["dark_mode"], err = json.Marshal(a.DarkMode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dark_mode': %w", err)
		}
	}

	if a.Path != nil {
		object["path"], err = json.Marshal(a.Path)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'path': %w", err)
		}
	}

	if a.Size != nil {
		object["size"], err = json.Marshal(a.Size)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'size': %w", err)
		}
	}

	object["src"], err = json.Marshal(a.Src)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'src': %w", err)
	}

	if a.Title != nil {
		object["title"], err = json.Marshal(a.Title)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'title': %w", err)
		}
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item
func (a *PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["originId"]; found {
		err = json.Unmarshal(raw, &a.OriginId)
		if err != nil {
			return fmt.Errorf("error reading 'originId': %w", err)
		}
		delete(object, "originId")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item to handle AdditionalProperties
func (a PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if a.OriginId != nil {
		object["originId"], err = json.Marshal(a.OriginId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'originId': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features
func (a *PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["doc_value_only_numeric"]; found {
		err = json.Unmarshal(raw, &a.DocValueOnlyNumeric)
		if err != nil {
			return fmt.Errorf("error reading 'doc_value_only_numeric': %w", err)
		}
		delete(object, "doc_value_only_numeric")
	}

	if raw, found := object["doc_value_only_other"]; found {
		err = json.Unmarshal(raw, &a.DocValueOnlyOther)
		if err != nil {
			return fmt.Errorf("error reading 'doc_value_only_other': %w", err)
		}
		delete(object, "doc_value_only_other")
	}

	if raw, found := object["synthetic_source"]; found {
		err = json.Unmarshal(raw, &a.SyntheticSource)
		if err != nil {
			return fmt.Errorf("error reading 'synthetic_source': %w", err)
		}
		delete(object, "synthetic_source")
	}

	if raw, found := object["tsdb"]; found {
		err = json.Unmarshal(raw, &a.Tsdb)
		if err != nil {
			return fmt.Errorf("error reading 'tsdb': %w", err)
		}
		delete(object, "tsdb")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features to handle AdditionalProperties
func (a PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.DocValueOnlyNumeric != nil {
		object["doc_value_only_numeric"], err = json.Marshal(a.DocValueOnlyNumeric)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'doc_value_only_numeric': %w", err)
		}
	}

	if a.DocValueOnlyOther != nil {
		object["doc_value_only_other"], err = json.Marshal(a.DocValueOnlyOther)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'doc_value_only_other': %w", err)
		}
	}

	if a.SyntheticSource != nil {
		object["synthetic_source"], err = json.Marshal(a.SyntheticSource)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'synthetic_source': %w", err)
		}
	}

	if a.Tsdb != nil {
		object["tsdb"], err = json.Marshal(a.Tsdb)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tsdb': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item
func (a *PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["data_stream"]; found {
		err = json.Unmarshal(raw, &a.DataStream)
		if err != nil {
			return fmt.Errorf("error reading 'data_stream': %w", err)
		}
		delete(object, "data_stream")
	}

	if raw, found := object["features"]; found {
		err = json.Unmarshal(raw, &a.Features)
		if err != nil {
			return fmt.Errorf("error reading 'features': %w", err)
		}
		delete(object, "features")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item to handle AdditionalProperties
func (a PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["data_stream"], err = json.Marshal(a.DataStream)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'data_stream': %w", err)
	}

	object["features"], err = json.Marshal(a.Features)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'features': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo_InstalledEs_Item. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo_InstalledEs_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo_InstalledEs_Item
func (a *PackageInfo_InstallationInfo_InstalledEs_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo_InstalledEs_Item to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo_InstalledEs_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["deferred"]; found {
		err = json.Unmarshal(raw, &a.Deferred)
		if err != nil {
			return fmt.Errorf("error reading 'deferred': %w", err)
		}
		delete(object, "deferred")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo_InstalledEs_Item to handle AdditionalProperties
func (a PackageInfo_InstallationInfo_InstalledEs_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Deferred != nil {
		object["deferred"], err = json.Marshal(a.Deferred)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'deferred': %w", err)
		}
	}

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	if a.Version != nil {
		object["version"], err = json.Marshal(a.Version)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'version': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo_InstalledKibana_Item. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo_InstalledKibana_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo_InstalledKibana_Item
func (a *PackageInfo_InstallationInfo_InstalledKibana_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo_InstalledKibana_Item to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo_InstalledKibana_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["originId"]; found {
		err = json.Unmarshal(raw, &a.OriginId)
		if err != nil {
			return fmt.Errorf("error reading 'originId': %w", err)
		}
		delete(object, "originId")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo_InstalledKibana_Item to handle AdditionalProperties
func (a PackageInfo_InstallationInfo_InstalledKibana_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if a.OriginId != nil {
		object["originId"], err = json.Marshal(a.OriginId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'originId': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo_LatestExecutedState. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo_LatestExecutedState) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo_LatestExecutedState
func (a *PackageInfo_InstallationInfo_LatestExecutedState) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo_LatestExecutedState to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo_LatestExecutedState) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["error"]; found {
		err = json.Unmarshal(raw, &a.Error)
		if err != nil {
			return fmt.Errorf("error reading 'error': %w", err)
		}
		delete(object, "error")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["started_at"]; found {
		err = json.Unmarshal(raw, &a.StartedAt)
		if err != nil {
			return fmt.Errorf("error reading 'started_at': %w", err)
		}
		delete(object, "started_at")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo_LatestExecutedState to handle AdditionalProperties
func (a PackageInfo_InstallationInfo_LatestExecutedState) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Error != nil {
		object["error"], err = json.Marshal(a.Error)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'error': %w", err)
		}
	}

	if a.Name != nil {
		object["name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	if a.StartedAt != nil {
		object["started_at"], err = json.Marshal(a.StartedAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'started_at': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error
func (a *PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &a.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
		delete(object, "message")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["stack"]; found {
		err = json.Unmarshal(raw, &a.Stack)
		if err != nil {
			return fmt.Errorf("error reading 'stack': %w", err)
		}
		delete(object, "stack")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error to handle AdditionalProperties
func (a PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["message"], err = json.Marshal(a.Message)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'message': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Stack != nil {
		object["stack"], err = json.Marshal(a.Stack)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stack': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item
func (a *PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["created_at"]; found {
		err = json.Unmarshal(raw, &a.CreatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'created_at': %w", err)
		}
		delete(object, "created_at")
	}

	if raw, found := object["error"]; found {
		err = json.Unmarshal(raw, &a.Error)
		if err != nil {
			return fmt.Errorf("error reading 'error': %w", err)
		}
		delete(object, "error")
	}

	if raw, found := object["target_version"]; found {
		err = json.Unmarshal(raw, &a.TargetVersion)
		if err != nil {
			return fmt.Errorf("error reading 'target_version': %w", err)
		}
		delete(object, "target_version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item to handle AdditionalProperties
func (a PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["created_at"], err = json.Marshal(a.CreatedAt)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'created_at': %w", err)
	}

	object["error"], err = json.Marshal(a.Error)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'error': %w", err)
	}

	object["target_version"], err = json.Marshal(a.TargetVersion)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'target_version': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo
func (a *PackageInfo_InstallationInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["additional_spaces_installed_kibana"]; found {
		err = json.Unmarshal(raw, &a.AdditionalSpacesInstalledKibana)
		if err != nil {
			return fmt.Errorf("error reading 'additional_spaces_installed_kibana': %w", err)
		}
		delete(object, "additional_spaces_installed_kibana")
	}

	if raw, found := object["created_at"]; found {
		err = json.Unmarshal(raw, &a.CreatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'created_at': %w", err)
		}
		delete(object, "created_at")
	}

	if raw, found := object["experimental_data_stream_features"]; found {
		err = json.Unmarshal(raw, &a.ExperimentalDataStreamFeatures)
		if err != nil {
			return fmt.Errorf("error reading 'experimental_data_stream_features': %w", err)
		}
		delete(object, "experimental_data_stream_features")
	}

	if raw, found := object["install_format_schema_version"]; found {
		err = json.Unmarshal(raw, &a.InstallFormatSchemaVersion)
		if err != nil {
			return fmt.Errorf("error reading 'install_format_schema_version': %w", err)
		}
		delete(object, "install_format_schema_version")
	}

	if raw, found := object["install_source"]; found {
		err = json.Unmarshal(raw, &a.InstallSource)
		if err != nil {
			return fmt.Errorf("error reading 'install_source': %w", err)
		}
		delete(object, "install_source")
	}

	if raw, found := object["install_status"]; found {
		err = json.Unmarshal(raw, &a.InstallStatus)
		if err != nil {
			return fmt.Errorf("error reading 'install_status': %w", err)
		}
		delete(object, "install_status")
	}

	if raw, found := object["installed_es"]; found {
		err = json.Unmarshal(raw, &a.InstalledEs)
		if err != nil {
			return fmt.Errorf("error reading 'installed_es': %w", err)
		}
		delete(object, "installed_es")
	}

	if raw, found := object["installed_kibana"]; found {
		err = json.Unmarshal(raw, &a.InstalledKibana)
		if err != nil {
			return fmt.Errorf("error reading 'installed_kibana': %w", err)
		}
		delete(object, "installed_kibana")
	}

	if raw, found := object["installed_kibana_space_id"]; found {
		err = json.Unmarshal(raw, &a.InstalledKibanaSpaceId)
		if err != nil {
			return fmt.Errorf("error reading 'installed_kibana_space_id': %w", err)
		}
		delete(object, "installed_kibana_space_id")
	}

	if raw, found := object["latest_executed_state"]; found {
		err = json.Unmarshal(raw, &a.LatestExecutedState)
		if err != nil {
			return fmt.Errorf("error reading 'latest_executed_state': %w", err)
		}
		delete(object, "latest_executed_state")
	}

	if raw, found := object["latest_install_failed_attempts"]; found {
		err = json.Unmarshal(raw, &a.LatestInstallFailedAttempts)
		if err != nil {
			return fmt.Errorf("error reading 'latest_install_failed_attempts': %w", err)
		}
		delete(object, "latest_install_failed_attempts")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["namespaces"]; found {
		err = json.Unmarshal(raw, &a.Namespaces)
		if err != nil {
			return fmt.Errorf("error reading 'namespaces': %w", err)
		}
		delete(object, "namespaces")
	}

	if raw, found := object["previous_version"]; found {
		err = json.Unmarshal(raw, &a.PreviousVersion)
		if err != nil {
			return fmt.Errorf("error reading 'previous_version': %w", err)
		}
		delete(object, "previous_version")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["updated_at"]; found {
		err = json.Unmarshal(raw, &a.UpdatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'updated_at': %w", err)
		}
		delete(object, "updated_at")
	}

	if raw, found := object["verification_key_id"]; found {
		err = json.Unmarshal(raw, &a.VerificationKeyId)
		if err != nil {
			return fmt.Errorf("error reading 'verification_key_id': %w", err)
		}
		delete(object, "verification_key_id")
	}

	if raw, found := object["verification_status"]; found {
		err = json.Unmarshal(raw, &a.VerificationStatus)
		if err != nil {
			return fmt.Errorf("error reading 'verification_status': %w", err)
		}
		delete(object, "verification_status")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo to handle AdditionalProperties
func (a PackageInfo_InstallationInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AdditionalSpacesInstalledKibana != nil {
		object["additional_spaces_installed_kibana"], err = json.Marshal(a.AdditionalSpacesInstalledKibana)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'additional_spaces_installed_kibana': %w", err)
		}
	}

	if a.CreatedAt != nil {
		object["created_at"], err = json.Marshal(a.CreatedAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'created_at': %w", err)
		}
	}

	if a.ExperimentalDataStreamFeatures != nil {
		object["experimental_data_stream_features"], err = json.Marshal(a.ExperimentalDataStreamFeatures)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'experimental_data_stream_features': %w", err)
		}
	}

	if a.InstallFormatSchemaVersion != nil {
		object["install_format_schema_version"], err = json.Marshal(a.InstallFormatSchemaVersion)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'install_format_schema_version': %w", err)
		}
	}

	object["install_source"], err = json.Marshal(a.InstallSource)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'install_source': %w", err)
	}

	object["install_status"], err = json.Marshal(a.InstallStatus)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'install_status': %w", err)
	}

	object["installed_es"], err = json.Marshal(a.InstalledEs)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'installed_es': %w", err)
	}

	object["installed_kibana"], err = json.Marshal(a.InstalledKibana)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'installed_kibana': %w", err)
	}

	if a.InstalledKibanaSpaceId != nil {
		object["installed_kibana_space_id"], err = json.Marshal(a.InstalledKibanaSpaceId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'installed_kibana_space_id': %w", err)
		}
	}

	if a.LatestExecutedState != nil {
		object["latest_executed_state"], err = json.Marshal(a.LatestExecutedState)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'latest_executed_state': %w", err)
		}
	}

	if a.LatestInstallFailedAttempts != nil {
		object["latest_install_failed_attempts"], err = json.Marshal(a.LatestInstallFailedAttempts)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'latest_install_failed_attempts': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Namespaces != nil {
		object["namespaces"], err = json.Marshal(a.Namespaces)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'namespaces': %w", err)
		}
	}

	if a.PreviousVersion != nil {
		object["previous_version"], err = json.Marshal(a.PreviousVersion)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'previous_version': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	if a.UpdatedAt != nil {
		object["updated_at"], err = json.Marshal(a.UpdatedAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'updated_at': %w", err)
		}
	}

	if a.VerificationKeyId != nil {
		object["verification_key_id"], err = json.Marshal(a.VerificationKeyId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'verification_key_id': %w", err)
		}
	}

	object["verification_status"], err = json.Marshal(a.VerificationStatus)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'verification_status': %w", err)
	}

	object["version"], err = json.Marshal(a.Version)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'version': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_Owner. Returns the specified
// element and whether it was found
func (a PackageInfo_Owner) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_Owner
func (a *PackageInfo_Owner) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_Owner to handle AdditionalProperties
func (a *PackageInfo_Owner) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["github"]; found {
		err = json.Unmarshal(raw, &a.Github)
		if err != nil {
			return fmt.Errorf("error reading 'github': %w", err)
		}
		delete(object, "github")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_Owner to handle AdditionalProperties
func (a PackageInfo_Owner) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Github != nil {
		object["github"], err = json.Marshal(a.Github)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'github': %w", err)
		}
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_Source. Returns the specified
// element and whether it was found
func (a PackageInfo_Source) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_Source
func (a *PackageInfo_Source) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_Source to handle AdditionalProperties
func (a *PackageInfo_Source) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["license"]; found {
		err = json.Unmarshal(raw, &a.License)
		if err != nil {
			return fmt.Errorf("error reading 'license': %w", err)
		}
		delete(object, "license")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_Source to handle AdditionalProperties
func (a PackageInfo_Source) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["license"], err = json.Marshal(a.License)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'license': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem. Returns the specified
// element and whether it was found
func (a PackageListItem) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem
func (a *PackageListItem) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem to handle AdditionalProperties
func (a *PackageListItem) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["categories"]; found {
		err = json.Unmarshal(raw, &a.Categories)
		if err != nil {
			return fmt.Errorf("error reading 'categories': %w", err)
		}
		delete(object, "categories")
	}

	if raw, found := object["conditions"]; found {
		err = json.Unmarshal(raw, &a.Conditions)
		if err != nil {
			return fmt.Errorf("error reading 'conditions': %w", err)
		}
		delete(object, "conditions")
	}

	if raw, found := object["data_streams"]; found {
		err = json.Unmarshal(raw, &a.DataStreams)
		if err != nil {
			return fmt.Errorf("error reading 'data_streams': %w", err)
		}
		delete(object, "data_streams")
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["discovery"]; found {
		err = json.Unmarshal(raw, &a.Discovery)
		if err != nil {
			return fmt.Errorf("error reading 'discovery': %w", err)
		}
		delete(object, "discovery")
	}

	if raw, found := object["download"]; found {
		err = json.Unmarshal(raw, &a.Download)
		if err != nil {
			return fmt.Errorf("error reading 'download': %w", err)
		}
		delete(object, "download")
	}

	if raw, found := object["format_version"]; found {
		err = json.Unmarshal(raw, &a.FormatVersion)
		if err != nil {
			return fmt.Errorf("error reading 'format_version': %w", err)
		}
		delete(object, "format_version")
	}

	if raw, found := object["icons"]; found {
		err = json.Unmarshal(raw, &a.Icons)
		if err != nil {
			return fmt.Errorf("error reading 'icons': %w", err)
		}
		delete(object, "icons")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["installationInfo"]; found {
		err = json.Unmarshal(raw, &a.InstallationInfo)
		if err != nil {
			return fmt.Errorf("error reading 'installationInfo': %w", err)
		}
		delete(object, "installationInfo")
	}

	if raw, found := object["integration"]; found {
		err = json.Unmarshal(raw, &a.Integration)
		if err != nil {
			return fmt.Errorf("error reading 'integration': %w", err)
		}
		delete(object, "integration")
	}

	if raw, found := object["internal"]; found {
		err = json.Unmarshal(raw, &a.Internal)
		if err != nil {
			return fmt.Errorf("error reading 'internal': %w", err)
		}
		delete(object, "internal")
	}

	if raw, found := object["latestVersion"]; found {
		err = json.Unmarshal(raw, &a.LatestVersion)
		if err != nil {
			return fmt.Errorf("error reading 'latestVersion': %w", err)
		}
		delete(object, "latestVersion")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["owner"]; found {
		err = json.Unmarshal(raw, &a.Owner)
		if err != nil {
			return fmt.Errorf("error reading 'owner': %w", err)
		}
		delete(object, "owner")
	}

	if raw, found := object["path"]; found {
		err = json.Unmarshal(raw, &a.Path)
		if err != nil {
			return fmt.Errorf("error reading 'path': %w", err)
		}
		delete(object, "path")
	}

	if raw, found := object["policy_templates"]; found {
		err = json.Unmarshal(raw, &a.PolicyTemplates)
		if err != nil {
			return fmt.Errorf("error reading 'policy_templates': %w", err)
		}
		delete(object, "policy_templates")
	}

	if raw, found := object["readme"]; found {
		err = json.Unmarshal(raw, &a.Readme)
		if err != nil {
			return fmt.Errorf("error reading 'readme': %w", err)
		}
		delete(object, "readme")
	}

	if raw, found := object["release"]; found {
		err = json.Unmarshal(raw, &a.Release)
		if err != nil {
			return fmt.Errorf("error reading 'release': %w", err)
		}
		delete(object, "release")
	}

	if raw, found := object["signature_path"]; found {
		err = json.Unmarshal(raw, &a.SignaturePath)
		if err != nil {
			return fmt.Errorf("error reading 'signature_path': %w", err)
		}
		delete(object, "signature_path")
	}

	if raw, found := object["source"]; found {
		err = json.Unmarshal(raw, &a.Source)
		if err != nil {
			return fmt.Errorf("error reading 'source': %w", err)
		}
		delete(object, "source")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
		delete(object, "title")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["vars"]; found {
		err = json.Unmarshal(raw, &a.Vars)
		if err != nil {
			return fmt.Errorf("error reading 'vars': %w", err)
		}
		delete(object, "vars")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem to handle AdditionalProperties
func (a PackageListItem) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Categories != nil {
		object["categories"], err = json.Marshal(a.Categories)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'categories': %w", err)
		}
	}

	if a.Conditions != nil {
		object["conditions"], err = json.Marshal(a.Conditions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'conditions': %w", err)
		}
	}

	if a.DataStreams != nil {
		object["data_streams"], err = json.Marshal(a.DataStreams)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'data_streams': %w", err)
		}
	}

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.Discovery != nil {
		object["discovery"], err = json.Marshal(a.Discovery)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'discovery': %w", err)
		}
	}

	if a.Download != nil {
		object["download"], err = json.Marshal(a.Download)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'download': %w", err)
		}
	}

	if a.FormatVersion != nil {
		object["format_version"], err = json.Marshal(a.FormatVersion)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'format_version': %w", err)
		}
	}

	if a.Icons != nil {
		object["icons"], err = json.Marshal(a.Icons)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'icons': %w", err)
		}
	}

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if a.InstallationInfo != nil {
		object["installationInfo"], err = json.Marshal(a.InstallationInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'installationInfo': %w", err)
		}
	}

	if a.Integration != nil {
		object["integration"], err = json.Marshal(a.Integration)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'integration': %w", err)
		}
	}

	if a.Internal != nil {
		object["internal"], err = json.Marshal(a.Internal)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'internal': %w", err)
		}
	}

	if a.LatestVersion != nil {
		object["latestVersion"], err = json.Marshal(a.LatestVersion)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'latestVersion': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Owner != nil {
		object["owner"], err = json.Marshal(a.Owner)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'owner': %w", err)
		}
	}

	if a.Path != nil {
		object["path"], err = json.Marshal(a.Path)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'path': %w", err)
		}
	}

	if a.PolicyTemplates != nil {
		object["policy_templates"], err = json.Marshal(a.PolicyTemplates)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'policy_templates': %w", err)
		}
	}

	if a.Readme != nil {
		object["readme"], err = json.Marshal(a.Readme)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'readme': %w", err)
		}
	}

	if a.Release != nil {
		object["release"], err = json.Marshal(a.Release)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'release': %w", err)
		}
	}

	if a.SignaturePath != nil {
		object["signature_path"], err = json.Marshal(a.SignaturePath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'signature_path': %w", err)
		}
	}

	if a.Source != nil {
		object["source"], err = json.Marshal(a.Source)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'source': %w", err)
		}
	}

	if a.Status != nil {
		object["status"], err = json.Marshal(a.Status)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status': %w", err)
		}
	}

	object["title"], err = json.Marshal(a.Title)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'title': %w", err)
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	if a.Vars != nil {
		object["vars"], err = json.Marshal(a.Vars)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'vars': %w", err)
		}
	}

	object["version"], err = json.Marshal(a.Version)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'version': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_Conditions_Elastic. Returns the specified
// element and whether it was found
func (a PackageListItem_Conditions_Elastic) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_Conditions_Elastic
func (a *PackageListItem_Conditions_Elastic) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_Conditions_Elastic to handle AdditionalProperties
func (a *PackageListItem_Conditions_Elastic) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["capabilities"]; found {
		err = json.Unmarshal(raw, &a.Capabilities)
		if err != nil {
			return fmt.Errorf("error reading 'capabilities': %w", err)
		}
		delete(object, "capabilities")
	}

	if raw, found := object["subscription"]; found {
		err = json.Unmarshal(raw, &a.Subscription)
		if err != nil {
			return fmt.Errorf("error reading 'subscription': %w", err)
		}
		delete(object, "subscription")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_Conditions_Elastic to handle AdditionalProperties
func (a PackageListItem_Conditions_Elastic) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Capabilities != nil {
		object["capabilities"], err = json.Marshal(a.Capabilities)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'capabilities': %w", err)
		}
	}

	if a.Subscription != nil {
		object["subscription"], err = json.Marshal(a.Subscription)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subscription': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_Conditions_Kibana. Returns the specified
// element and whether it was found
func (a PackageListItem_Conditions_Kibana) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_Conditions_Kibana
func (a *PackageListItem_Conditions_Kibana) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_Conditions_Kibana to handle AdditionalProperties
func (a *PackageListItem_Conditions_Kibana) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_Conditions_Kibana to handle AdditionalProperties
func (a PackageListItem_Conditions_Kibana) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Version != nil {
		object["version"], err = json.Marshal(a.Version)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'version': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_Conditions. Returns the specified
// element and whether it was found
func (a PackageListItem_Conditions) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_Conditions
func (a *PackageListItem_Conditions) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_Conditions to handle AdditionalProperties
func (a *PackageListItem_Conditions) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["elastic"]; found {
		err = json.Unmarshal(raw, &a.Elastic)
		if err != nil {
			return fmt.Errorf("error reading 'elastic': %w", err)
		}
		delete(object, "elastic")
	}

	if raw, found := object["kibana"]; found {
		err = json.Unmarshal(raw, &a.Kibana)
		if err != nil {
			return fmt.Errorf("error reading 'kibana': %w", err)
		}
		delete(object, "kibana")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_Conditions to handle AdditionalProperties
func (a PackageListItem_Conditions) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Elastic != nil {
		object["elastic"], err = json.Marshal(a.Elastic)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'elastic': %w", err)
		}
	}

	if a.Kibana != nil {
		object["kibana"], err = json.Marshal(a.Kibana)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'kibana': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_Discovery_Datasets_Item. Returns the specified
// element and whether it was found
func (a PackageListItem_Discovery_Datasets_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_Discovery_Datasets_Item
func (a *PackageListItem_Discovery_Datasets_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_Discovery_Datasets_Item to handle AdditionalProperties
func (a *PackageListItem_Discovery_Datasets_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_Discovery_Datasets_Item to handle AdditionalProperties
func (a PackageListItem_Discovery_Datasets_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_Discovery_Fields_Item. Returns the specified
// element and whether it was found
func (a PackageListItem_Discovery_Fields_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_Discovery_Fields_Item
func (a *PackageListItem_Discovery_Fields_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_Discovery_Fields_Item to handle AdditionalProperties
func (a *PackageListItem_Discovery_Fields_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_Discovery_Fields_Item to handle AdditionalProperties
func (a PackageListItem_Discovery_Fields_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_Discovery. Returns the specified
// element and whether it was found
func (a PackageListItem_Discovery) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_Discovery
func (a *PackageListItem_Discovery) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_Discovery to handle AdditionalProperties
func (a *PackageListItem_Discovery) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["datasets"]; found {
		err = json.Unmarshal(raw, &a.Datasets)
		if err != nil {
			return fmt.Errorf("error reading 'datasets': %w", err)
		}
		delete(object, "datasets")
	}

	if raw, found := object["fields"]; found {
		err = json.Unmarshal(raw, &a.Fields)
		if err != nil {
			return fmt.Errorf("error reading 'fields': %w", err)
		}
		delete(object, "fields")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_Discovery to handle AdditionalProperties
func (a PackageListItem_Discovery) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Datasets != nil {
		object["datasets"], err = json.Marshal(a.Datasets)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'datasets': %w", err)
		}
	}

	if a.Fields != nil {
		object["fields"], err = json.Marshal(a.Fields)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fields': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_Icons_Item. Returns the specified
// element and whether it was found
func (a PackageListItem_Icons_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_Icons_Item
func (a *PackageListItem_Icons_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_Icons_Item to handle AdditionalProperties
func (a *PackageListItem_Icons_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["dark_mode"]; found {
		err = json.Unmarshal(raw, &a.DarkMode)
		if err != nil {
			return fmt.Errorf("error reading 'dark_mode': %w", err)
		}
		delete(object, "dark_mode")
	}

	if raw, found := object["path"]; found {
		err = json.Unmarshal(raw, &a.Path)
		if err != nil {
			return fmt.Errorf("error reading 'path': %w", err)
		}
		delete(object, "path")
	}

	if raw, found := object["size"]; found {
		err = json.Unmarshal(raw, &a.Size)
		if err != nil {
			return fmt.Errorf("error reading 'size': %w", err)
		}
		delete(object, "size")
	}

	if raw, found := object["src"]; found {
		err = json.Unmarshal(raw, &a.Src)
		if err != nil {
			return fmt.Errorf("error reading 'src': %w", err)
		}
		delete(object, "src")
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
		delete(object, "title")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_Icons_Item to handle AdditionalProperties
func (a PackageListItem_Icons_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.DarkMode != nil {
		object["dark_mode"], err = json.Marshal(a.DarkMode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dark_mode': %w", err)
		}
	}

	if a.Path != nil {
		object["path"], err = json.Marshal(a.Path)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'path': %w", err)
		}
	}

	if a.Size != nil {
		object["size"], err = json.Marshal(a.Size)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'size': %w", err)
		}
	}

	object["src"], err = json.Marshal(a.Src)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'src': %w", err)
	}

	if a.Title != nil {
		object["title"], err = json.Marshal(a.Title)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'title': %w", err)
		}
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item
func (a *PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["originId"]; found {
		err = json.Unmarshal(raw, &a.OriginId)
		if err != nil {
			return fmt.Errorf("error reading 'originId': %w", err)
		}
		delete(object, "originId")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item to handle AdditionalProperties
func (a PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if a.OriginId != nil {
		object["originId"], err = json.Marshal(a.OriginId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'originId': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features
func (a *PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["doc_value_only_numeric"]; found {
		err = json.Unmarshal(raw, &a.DocValueOnlyNumeric)
		if err != nil {
			return fmt.Errorf("error reading 'doc_value_only_numeric': %w", err)
		}
		delete(object, "doc_value_only_numeric")
	}

	if raw, found := object["doc_value_only_other"]; found {
		err = json.Unmarshal(raw, &a.DocValueOnlyOther)
		if err != nil {
			return fmt.Errorf("error reading 'doc_value_only_other': %w", err)
		}
		delete(object, "doc_value_only_other")
	}

	if raw, found := object["synthetic_source"]; found {
		err = json.Unmarshal(raw, &a.SyntheticSource)
		if err != nil {
			return fmt.Errorf("error reading 'synthetic_source': %w", err)
		}
		delete(object, "synthetic_source")
	}

	if raw, found := object["tsdb"]; found {
		err = json.Unmarshal(raw, &a.Tsdb)
		if err != nil {
			return fmt.Errorf("error reading 'tsdb': %w", err)
		}
		delete(object, "tsdb")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features to handle AdditionalProperties
func (a PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.DocValueOnlyNumeric != nil {
		object["doc_value_only_numeric"], err = json.Marshal(a.DocValueOnlyNumeric)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'doc_value_only_numeric': %w", err)
		}
	}

	if a.DocValueOnlyOther != nil {
		object["doc_value_only_other"], err = json.Marshal(a.DocValueOnlyOther)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'doc_value_only_other': %w", err)
		}
	}

	if a.SyntheticSource != nil {
		object["synthetic_source"], err = json.Marshal(a.SyntheticSource)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'synthetic_source': %w", err)
		}
	}

	if a.Tsdb != nil {
		object["tsdb"], err = json.Marshal(a.Tsdb)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tsdb': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item
func (a *PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["data_stream"]; found {
		err = json.Unmarshal(raw, &a.DataStream)
		if err != nil {
			return fmt.Errorf("error reading 'data_stream': %w", err)
		}
		delete(object, "data_stream")
	}

	if raw, found := object["features"]; found {
		err = json.Unmarshal(raw, &a.Features)
		if err != nil {
			return fmt.Errorf("error reading 'features': %w", err)
		}
		delete(object, "features")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item to handle AdditionalProperties
func (a PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["data_stream"], err = json.Marshal(a.DataStream)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'data_stream': %w", err)
	}

	object["features"], err = json.Marshal(a.Features)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'features': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo_InstalledEs_Item. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo_InstalledEs_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo_InstalledEs_Item
func (a *PackageListItem_InstallationInfo_InstalledEs_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo_InstalledEs_Item to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo_InstalledEs_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["deferred"]; found {
		err = json.Unmarshal(raw, &a.Deferred)
		if err != nil {
			return fmt.Errorf("error reading 'deferred': %w", err)
		}
		delete(object, "deferred")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo_InstalledEs_Item to handle AdditionalProperties
func (a PackageListItem_InstallationInfo_InstalledEs_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Deferred != nil {
		object["deferred"], err = json.Marshal(a.Deferred)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'deferred': %w", err)
		}
	}

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	if a.Version != nil {
		object["version"], err = json.Marshal(a.Version)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'version': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo_InstalledKibana_Item. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo_InstalledKibana_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo_InstalledKibana_Item
func (a *PackageListItem_InstallationInfo_InstalledKibana_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo_InstalledKibana_Item to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo_InstalledKibana_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["originId"]; found {
		err = json.Unmarshal(raw, &a.OriginId)
		if err != nil {
			return fmt.Errorf("error reading 'originId': %w", err)
		}
		delete(object, "originId")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo_InstalledKibana_Item to handle AdditionalProperties
func (a PackageListItem_InstallationInfo_InstalledKibana_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if a.OriginId != nil {
		object["originId"], err = json.Marshal(a.OriginId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'originId': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo_LatestExecutedState. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo_LatestExecutedState) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo_LatestExecutedState
func (a *PackageListItem_InstallationInfo_LatestExecutedState) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo_LatestExecutedState to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo_LatestExecutedState) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["error"]; found {
		err = json.Unmarshal(raw, &a.Error)
		if err != nil {
			return fmt.Errorf("error reading 'error': %w", err)
		}
		delete(object, "error")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["started_at"]; found {
		err = json.Unmarshal(raw, &a.StartedAt)
		if err != nil {
			return fmt.Errorf("error reading 'started_at': %w", err)
		}
		delete(object, "started_at")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo_LatestExecutedState to handle AdditionalProperties
func (a PackageListItem_InstallationInfo_LatestExecutedState) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Error != nil {
		object["error"], err = json.Marshal(a.Error)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'error': %w", err)
		}
	}

	if a.Name != nil {
		object["name"], err = json.Marshal(a.Name)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'name': %w", err)
		}
	}

	if a.StartedAt != nil {
		object["started_at"], err = json.Marshal(a.StartedAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'started_at': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error
func (a *PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &a.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
		delete(object, "message")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["stack"]; found {
		err = json.Unmarshal(raw, &a.Stack)
		if err != nil {
			return fmt.Errorf("error reading 'stack': %w", err)
		}
		delete(object, "stack")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error to handle AdditionalProperties
func (a PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["message"], err = json.Marshal(a.Message)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'message': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Stack != nil {
		object["stack"], err = json.Marshal(a.Stack)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stack': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item
func (a *PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["created_at"]; found {
		err = json.Unmarshal(raw, &a.CreatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'created_at': %w", err)
		}
		delete(object, "created_at")
	}

	if raw, found := object["error"]; found {
		err = json.Unmarshal(raw, &a.Error)
		if err != nil {
			return fmt.Errorf("error reading 'error': %w", err)
		}
		delete(object, "error")
	}

	if raw, found := object["target_version"]; found {
		err = json.Unmarshal(raw, &a.TargetVersion)
		if err != nil {
			return fmt.Errorf("error reading 'target_version': %w", err)
		}
		delete(object, "target_version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item to handle AdditionalProperties
func (a PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["created_at"], err = json.Marshal(a.CreatedAt)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'created_at': %w", err)
	}

	object["error"], err = json.Marshal(a.Error)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'error': %w", err)
	}

	object["target_version"], err = json.Marshal(a.TargetVersion)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'target_version': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo
func (a *PackageListItem_InstallationInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["additional_spaces_installed_kibana"]; found {
		err = json.Unmarshal(raw, &a.AdditionalSpacesInstalledKibana)
		if err != nil {
			return fmt.Errorf("error reading 'additional_spaces_installed_kibana': %w", err)
		}
		delete(object, "additional_spaces_installed_kibana")
	}

	if raw, found := object["created_at"]; found {
		err = json.Unmarshal(raw, &a.CreatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'created_at': %w", err)
		}
		delete(object, "created_at")
	}

	if raw, found := object["experimental_data_stream_features"]; found {
		err = json.Unmarshal(raw, &a.ExperimentalDataStreamFeatures)
		if err != nil {
			return fmt.Errorf("error reading 'experimental_data_stream_features': %w", err)
		}
		delete(object, "experimental_data_stream_features")
	}

	if raw, found := object["install_format_schema_version"]; found {
		err = json.Unmarshal(raw, &a.InstallFormatSchemaVersion)
		if err != nil {
			return fmt.Errorf("error reading 'install_format_schema_version': %w", err)
		}
		delete(object, "install_format_schema_version")
	}

	if raw, found := object["install_source"]; found {
		err = json.Unmarshal(raw, &a.InstallSource)
		if err != nil {
			return fmt.Errorf("error reading 'install_source': %w", err)
		}
		delete(object, "install_source")
	}

	if raw, found := object["install_status"]; found {
		err = json.Unmarshal(raw, &a.InstallStatus)
		if err != nil {
			return fmt.Errorf("error reading 'install_status': %w", err)
		}
		delete(object, "install_status")
	}

	if raw, found := object["installed_es"]; found {
		err = json.Unmarshal(raw, &a.InstalledEs)
		if err != nil {
			return fmt.Errorf("error reading 'installed_es': %w", err)
		}
		delete(object, "installed_es")
	}

	if raw, found := object["installed_kibana"]; found {
		err = json.Unmarshal(raw, &a.InstalledKibana)
		if err != nil {
			return fmt.Errorf("error reading 'installed_kibana': %w", err)
		}
		delete(object, "installed_kibana")
	}

	if raw, found := object["installed_kibana_space_id"]; found {
		err = json.Unmarshal(raw, &a.InstalledKibanaSpaceId)
		if err != nil {
			return fmt.Errorf("error reading 'installed_kibana_space_id': %w", err)
		}
		delete(object, "installed_kibana_space_id")
	}

	if raw, found := object["latest_executed_state"]; found {
		err = json.Unmarshal(raw, &a.LatestExecutedState)
		if err != nil {
			return fmt.Errorf("error reading 'latest_executed_state': %w", err)
		}
		delete(object, "latest_executed_state")
	}

	if raw, found := object["latest_install_failed_attempts"]; found {
		err = json.Unmarshal(raw, &a.LatestInstallFailedAttempts)
		if err != nil {
			return fmt.Errorf("error reading 'latest_install_failed_attempts': %w", err)
		}
		delete(object, "latest_install_failed_attempts")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["namespaces"]; found {
		err = json.Unmarshal(raw, &a.Namespaces)
		if err != nil {
			return fmt.Errorf("error reading 'namespaces': %w", err)
		}
		delete(object, "namespaces")
	}

	if raw, found := object["previous_version"]; found {
		err = json.Unmarshal(raw, &a.PreviousVersion)
		if err != nil {
			return fmt.Errorf("error reading 'previous_version': %w", err)
		}
		delete(object, "previous_version")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["updated_at"]; found {
		err = json.Unmarshal(raw, &a.UpdatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'updated_at': %w", err)
		}
		delete(object, "updated_at")
	}

	if raw, found := object["verification_key_id"]; found {
		err = json.Unmarshal(raw, &a.VerificationKeyId)
		if err != nil {
			return fmt.Errorf("error reading 'verification_key_id': %w", err)
		}
		delete(object, "verification_key_id")
	}

	if raw, found := object["verification_status"]; found {
		err = json.Unmarshal(raw, &a.VerificationStatus)
		if err != nil {
			return fmt.Errorf("error reading 'verification_status': %w", err)
		}
		delete(object, "verification_status")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo to handle AdditionalProperties
func (a PackageListItem_InstallationInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AdditionalSpacesInstalledKibana != nil {
		object["additional_spaces_installed_kibana"], err = json.Marshal(a.AdditionalSpacesInstalledKibana)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'additional_spaces_installed_kibana': %w", err)
		}
	}

	if a.CreatedAt != nil {
		object["created_at"], err = json.Marshal(a.CreatedAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'created_at': %w", err)
		}
	}

	if a.ExperimentalDataStreamFeatures != nil {
		object["experimental_data_stream_features"], err = json.Marshal(a.ExperimentalDataStreamFeatures)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'experimental_data_stream_features': %w", err)
		}
	}

	if a.InstallFormatSchemaVersion != nil {
		object["install_format_schema_version"], err = json.Marshal(a.InstallFormatSchemaVersion)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'install_format_schema_version': %w", err)
		}
	}

	object["install_source"], err = json.Marshal(a.InstallSource)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'install_source': %w", err)
	}

	object["install_status"], err = json.Marshal(a.InstallStatus)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'install_status': %w", err)
	}

	object["installed_es"], err = json.Marshal(a.InstalledEs)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'installed_es': %w", err)
	}

	object["installed_kibana"], err = json.Marshal(a.InstalledKibana)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'installed_kibana': %w", err)
	}

	if a.InstalledKibanaSpaceId != nil {
		object["installed_kibana_space_id"], err = json.Marshal(a.InstalledKibanaSpaceId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'installed_kibana_space_id': %w", err)
		}
	}

	if a.LatestExecutedState != nil {
		object["latest_executed_state"], err = json.Marshal(a.LatestExecutedState)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'latest_executed_state': %w", err)
		}
	}

	if a.LatestInstallFailedAttempts != nil {
		object["latest_install_failed_attempts"], err = json.Marshal(a.LatestInstallFailedAttempts)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'latest_install_failed_attempts': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Namespaces != nil {
		object["namespaces"], err = json.Marshal(a.Namespaces)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'namespaces': %w", err)
		}
	}

	if a.PreviousVersion != nil {
		object["previous_version"], err = json.Marshal(a.PreviousVersion)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'previous_version': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	if a.UpdatedAt != nil {
		object["updated_at"], err = json.Marshal(a.UpdatedAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'updated_at': %w", err)
		}
	}

	if a.VerificationKeyId != nil {
		object["verification_key_id"], err = json.Marshal(a.VerificationKeyId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'verification_key_id': %w", err)
		}
	}

	object["verification_status"], err = json.Marshal(a.VerificationStatus)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'verification_status': %w", err)
	}

	object["version"], err = json.Marshal(a.Version)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'version': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_Owner. Returns the specified
// element and whether it was found
func (a PackageListItem_Owner) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_Owner
func (a *PackageListItem_Owner) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_Owner to handle AdditionalProperties
func (a *PackageListItem_Owner) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["github"]; found {
		err = json.Unmarshal(raw, &a.Github)
		if err != nil {
			return fmt.Errorf("error reading 'github': %w", err)
		}
		delete(object, "github")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_Owner to handle AdditionalProperties
func (a PackageListItem_Owner) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Github != nil {
		object["github"], err = json.Marshal(a.Github)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'github': %w", err)
		}
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_Source. Returns the specified
// element and whether it was found
func (a PackageListItem_Source) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_Source
func (a *PackageListItem_Source) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_Source to handle AdditionalProperties
func (a *PackageListItem_Source) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["license"]; found {
		err = json.Unmarshal(raw, &a.License)
		if err != nil {
			return fmt.Errorf("error reading 'license': %w", err)
		}
		delete(object, "license")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_Source to handle AdditionalProperties
func (a PackageListItem_Source) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["license"], err = json.Marshal(a.License)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'license': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackagePolicy_Elasticsearch_Privileges. Returns the specified
// element and whether it was found
func (a PackagePolicy_Elasticsearch_Privileges) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackagePolicy_Elasticsearch_Privileges
func (a *PackagePolicy_Elasticsearch_Privileges) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackagePolicy_Elasticsearch_Privileges to handle AdditionalProperties
func (a *PackagePolicy_Elasticsearch_Privileges) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["cluster"]; found {
		err = json.Unmarshal(raw, &a.Cluster)
		if err != nil {
			return fmt.Errorf("error reading 'cluster': %w", err)
		}
		delete(object, "cluster")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackagePolicy_Elasticsearch_Privileges to handle AdditionalProperties
func (a PackagePolicy_Elasticsearch_Privileges) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Cluster != nil {
		object["cluster"], err = json.Marshal(a.Cluster)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'cluster': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackagePolicy_Elasticsearch. Returns the specified
// element and whether it was found
func (a PackagePolicy_Elasticsearch) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackagePolicy_Elasticsearch
func (a *PackagePolicy_Elasticsearch) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackagePolicy_Elasticsearch to handle AdditionalProperties
func (a *PackagePolicy_Elasticsearch) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["privileges"]; found {
		err = json.Unmarshal(raw, &a.Privileges)
		if err != nil {
			return fmt.Errorf("error reading 'privileges': %w", err)
		}
		delete(object, "privileges")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackagePolicy_Elasticsearch to handle AdditionalProperties
func (a PackagePolicy_Elasticsearch) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Privileges != nil {
		object["privileges"], err = json.Marshal(a.Privileges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'privileges': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateConnectorConfig. Returns the specified
// element and whether it was found
func (a UpdateConnectorConfig) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateConnectorConfig
func (a *UpdateConnectorConfig) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Getter for additional properties for UpdateConnectorSecrets. Returns the specified
// element and whether it was found
func (a UpdateConnectorSecrets) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateConnectorSecrets
func (a *UpdateConnectorSecrets) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// AsSecurityDetectionsAPIEcsMappingValue0 returns the union data inside the SecurityDetectionsAPIEcsMapping_Value as a SecurityDetectionsAPIEcsMappingValue0
func (t SecurityDetectionsAPIEcsMapping_Value) AsSecurityDetectionsAPIEcsMappingValue0() (SecurityDetectionsAPIEcsMappingValue0, error) {
	var body SecurityDetectionsAPIEcsMappingValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIEcsMappingValue0 overwrites any union data inside the SecurityDetectionsAPIEcsMapping_Value as the provided SecurityDetectionsAPIEcsMappingValue0
func (t *SecurityDetectionsAPIEcsMapping_Value) FromSecurityDetectionsAPIEcsMappingValue0(v SecurityDetectionsAPIEcsMappingValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIEcsMappingValue0 performs a merge with any union data inside the SecurityDetectionsAPIEcsMapping_Value, using the provided SecurityDetectionsAPIEcsMappingValue0
func (t *SecurityDetectionsAPIEcsMapping_Value) MergeSecurityDetectionsAPIEcsMappingValue0(v SecurityDetectionsAPIEcsMappingValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPIEcsMappingValue1 returns the union data inside the SecurityDetectionsAPIEcsMapping_Value as a SecurityDetectionsAPIEcsMappingValue1
func (t SecurityDetectionsAPIEcsMapping_Value) AsSecurityDetectionsAPIEcsMappingValue1() (SecurityDetectionsAPIEcsMappingValue1, error) {
	var body SecurityDetectionsAPIEcsMappingValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIEcsMappingValue1 overwrites any union data inside the SecurityDetectionsAPIEcsMapping_Value as the provided SecurityDetectionsAPIEcsMappingValue1
func (t *SecurityDetectionsAPIEcsMapping_Value) FromSecurityDetectionsAPIEcsMappingValue1(v SecurityDetectionsAPIEcsMappingValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIEcsMappingValue1 performs a merge with any union data inside the SecurityDetectionsAPIEcsMapping_Value, using the provided SecurityDetectionsAPIEcsMappingValue1
func (t *SecurityDetectionsAPIEcsMapping_Value) MergeSecurityDetectionsAPIEcsMappingValue1(v SecurityDetectionsAPIEcsMappingValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SecurityDetectionsAPIEcsMapping_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SecurityDetectionsAPIEcsMapping_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSecurityDetectionsAPIDefaultParams returns the union data inside the SecurityDetectionsAPIEndpointResponseAction_Params as a SecurityDetectionsAPIDefaultParams
func (t SecurityDetectionsAPIEndpointResponseAction_Params) AsSecurityDetectionsAPIDefaultParams() (SecurityDetectionsAPIDefaultParams, error) {
	var body SecurityDetectionsAPIDefaultParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIDefaultParams overwrites any union data inside the SecurityDetectionsAPIEndpointResponseAction_Params as the provided SecurityDetectionsAPIDefaultParams
func (t *SecurityDetectionsAPIEndpointResponseAction_Params) FromSecurityDetectionsAPIDefaultParams(v SecurityDetectionsAPIDefaultParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIDefaultParams performs a merge with any union data inside the SecurityDetectionsAPIEndpointResponseAction_Params, using the provided SecurityDetectionsAPIDefaultParams
func (t *SecurityDetectionsAPIEndpointResponseAction_Params) MergeSecurityDetectionsAPIDefaultParams(v SecurityDetectionsAPIDefaultParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPIProcessesParams returns the union data inside the SecurityDetectionsAPIEndpointResponseAction_Params as a SecurityDetectionsAPIProcessesParams
func (t SecurityDetectionsAPIEndpointResponseAction_Params) AsSecurityDetectionsAPIProcessesParams() (SecurityDetectionsAPIProcessesParams, error) {
	var body SecurityDetectionsAPIProcessesParams
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIProcessesParams overwrites any union data inside the SecurityDetectionsAPIEndpointResponseAction_Params as the provided SecurityDetectionsAPIProcessesParams
func (t *SecurityDetectionsAPIEndpointResponseAction_Params) FromSecurityDetectionsAPIProcessesParams(v SecurityDetectionsAPIProcessesParams) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIProcessesParams performs a merge with any union data inside the SecurityDetectionsAPIEndpointResponseAction_Params, using the provided SecurityDetectionsAPIProcessesParams
func (t *SecurityDetectionsAPIEndpointResponseAction_Params) MergeSecurityDetectionsAPIProcessesParams(v SecurityDetectionsAPIProcessesParams) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SecurityDetectionsAPIEndpointResponseAction_Params) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SecurityDetectionsAPIEndpointResponseAction_Params) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSecurityDetectionsAPIMachineLearningJobId0 returns the union data inside the SecurityDetectionsAPIMachineLearningJobId as a SecurityDetectionsAPIMachineLearningJobId0
func (t SecurityDetectionsAPIMachineLearningJobId) AsSecurityDetectionsAPIMachineLearningJobId0() (SecurityDetectionsAPIMachineLearningJobId0, error) {
	var body SecurityDetectionsAPIMachineLearningJobId0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIMachineLearningJobId0 overwrites any union data inside the SecurityDetectionsAPIMachineLearningJobId as the provided SecurityDetectionsAPIMachineLearningJobId0
func (t *SecurityDetectionsAPIMachineLearningJobId) FromSecurityDetectionsAPIMachineLearningJobId0(v SecurityDetectionsAPIMachineLearningJobId0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIMachineLearningJobId0 performs a merge with any union data inside the SecurityDetectionsAPIMachineLearningJobId, using the provided SecurityDetectionsAPIMachineLearningJobId0
func (t *SecurityDetectionsAPIMachineLearningJobId) MergeSecurityDetectionsAPIMachineLearningJobId0(v SecurityDetectionsAPIMachineLearningJobId0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPIMachineLearningJobId1 returns the union data inside the SecurityDetectionsAPIMachineLearningJobId as a SecurityDetectionsAPIMachineLearningJobId1
func (t SecurityDetectionsAPIMachineLearningJobId) AsSecurityDetectionsAPIMachineLearningJobId1() (SecurityDetectionsAPIMachineLearningJobId1, error) {
	var body SecurityDetectionsAPIMachineLearningJobId1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIMachineLearningJobId1 overwrites any union data inside the SecurityDetectionsAPIMachineLearningJobId as the provided SecurityDetectionsAPIMachineLearningJobId1
func (t *SecurityDetectionsAPIMachineLearningJobId) FromSecurityDetectionsAPIMachineLearningJobId1(v SecurityDetectionsAPIMachineLearningJobId1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIMachineLearningJobId1 performs a merge with any union data inside the SecurityDetectionsAPIMachineLearningJobId, using the provided SecurityDetectionsAPIMachineLearningJobId1
func (t *SecurityDetectionsAPIMachineLearningJobId) MergeSecurityDetectionsAPIMachineLearningJobId1(v SecurityDetectionsAPIMachineLearningJobId1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SecurityDetectionsAPIMachineLearningJobId) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SecurityDetectionsAPIMachineLearningJobId) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSecurityDetectionsAPIOsqueryResponseAction returns the union data inside the SecurityDetectionsAPIResponseAction as a SecurityDetectionsAPIOsqueryResponseAction
func (t SecurityDetectionsAPIResponseAction) AsSecurityDetectionsAPIOsqueryResponseAction() (SecurityDetectionsAPIOsqueryResponseAction, error) {
	var body SecurityDetectionsAPIOsqueryResponseAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIOsqueryResponseAction overwrites any union data inside the SecurityDetectionsAPIResponseAction as the provided SecurityDetectionsAPIOsqueryResponseAction
func (t *SecurityDetectionsAPIResponseAction) FromSecurityDetectionsAPIOsqueryResponseAction(v SecurityDetectionsAPIOsqueryResponseAction) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIOsqueryResponseAction performs a merge with any union data inside the SecurityDetectionsAPIResponseAction, using the provided SecurityDetectionsAPIOsqueryResponseAction
func (t *SecurityDetectionsAPIResponseAction) MergeSecurityDetectionsAPIOsqueryResponseAction(v SecurityDetectionsAPIOsqueryResponseAction) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPIEndpointResponseAction returns the union data inside the SecurityDetectionsAPIResponseAction as a SecurityDetectionsAPIEndpointResponseAction
func (t SecurityDetectionsAPIResponseAction) AsSecurityDetectionsAPIEndpointResponseAction() (SecurityDetectionsAPIEndpointResponseAction, error) {
	var body SecurityDetectionsAPIEndpointResponseAction
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIEndpointResponseAction overwrites any union data inside the SecurityDetectionsAPIResponseAction as the provided SecurityDetectionsAPIEndpointResponseAction
func (t *SecurityDetectionsAPIResponseAction) FromSecurityDetectionsAPIEndpointResponseAction(v SecurityDetectionsAPIEndpointResponseAction) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIEndpointResponseAction performs a merge with any union data inside the SecurityDetectionsAPIResponseAction, using the provided SecurityDetectionsAPIEndpointResponseAction
func (t *SecurityDetectionsAPIResponseAction) MergeSecurityDetectionsAPIEndpointResponseAction(v SecurityDetectionsAPIEndpointResponseAction) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SecurityDetectionsAPIResponseAction) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SecurityDetectionsAPIResponseAction) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSecurityDetectionsAPIRuleActionThrottle0 returns the union data inside the SecurityDetectionsAPIRuleActionThrottle as a SecurityDetectionsAPIRuleActionThrottle0
func (t SecurityDetectionsAPIRuleActionThrottle) AsSecurityDetectionsAPIRuleActionThrottle0() (SecurityDetectionsAPIRuleActionThrottle0, error) {
	var body SecurityDetectionsAPIRuleActionThrottle0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIRuleActionThrottle0 overwrites any union data inside the SecurityDetectionsAPIRuleActionThrottle as the provided SecurityDetectionsAPIRuleActionThrottle0
func (t *SecurityDetectionsAPIRuleActionThrottle) FromSecurityDetectionsAPIRuleActionThrottle0(v SecurityDetectionsAPIRuleActionThrottle0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIRuleActionThrottle0 performs a merge with any union data inside the SecurityDetectionsAPIRuleActionThrottle, using the provided SecurityDetectionsAPIRuleActionThrottle0
func (t *SecurityDetectionsAPIRuleActionThrottle) MergeSecurityDetectionsAPIRuleActionThrottle0(v SecurityDetectionsAPIRuleActionThrottle0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPIRuleActionThrottle1 returns the union data inside the SecurityDetectionsAPIRuleActionThrottle as a SecurityDetectionsAPIRuleActionThrottle1
func (t SecurityDetectionsAPIRuleActionThrottle) AsSecurityDetectionsAPIRuleActionThrottle1() (SecurityDetectionsAPIRuleActionThrottle1, error) {
	var body SecurityDetectionsAPIRuleActionThrottle1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIRuleActionThrottle1 overwrites any union data inside the SecurityDetectionsAPIRuleActionThrottle as the provided SecurityDetectionsAPIRuleActionThrottle1
func (t *SecurityDetectionsAPIRuleActionThrottle) FromSecurityDetectionsAPIRuleActionThrottle1(v SecurityDetectionsAPIRuleActionThrottle1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIRuleActionThrottle1 performs a merge with any union data inside the SecurityDetectionsAPIRuleActionThrottle, using the provided SecurityDetectionsAPIRuleActionThrottle1
func (t *SecurityDetectionsAPIRuleActionThrottle) MergeSecurityDetectionsAPIRuleActionThrottle1(v SecurityDetectionsAPIRuleActionThrottle1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SecurityDetectionsAPIRuleActionThrottle) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SecurityDetectionsAPIRuleActionThrottle) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSecurityDetectionsAPIEqlRuleCreateProps returns the union data inside the SecurityDetectionsAPIRuleCreateProps as a SecurityDetectionsAPIEqlRuleCreateProps
func (t SecurityDetectionsAPIRuleCreateProps) AsSecurityDetectionsAPIEqlRuleCreateProps() (SecurityDetectionsAPIEqlRuleCreateProps, error) {
	var body SecurityDetectionsAPIEqlRuleCreateProps
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIEqlRuleCreateProps overwrites any union data inside the SecurityDetectionsAPIRuleCreateProps as the provided SecurityDetectionsAPIEqlRuleCreateProps
func (t *SecurityDetectionsAPIRuleCreateProps) FromSecurityDetectionsAPIEqlRuleCreateProps(v SecurityDetectionsAPIEqlRuleCreateProps) error {
	v.Type = "Security_Detections_API_EqlRuleCreateProps"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIEqlRuleCreateProps performs a merge with any union data inside the SecurityDetectionsAPIRuleCreateProps, using the provided SecurityDetectionsAPIEqlRuleCreateProps
func (t *SecurityDetectionsAPIRuleCreateProps) MergeSecurityDetectionsAPIEqlRuleCreateProps(v SecurityDetectionsAPIEqlRuleCreateProps) error {
	v.Type = "Security_Detections_API_EqlRuleCreateProps"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPIQueryRuleCreateProps returns the union data inside the SecurityDetectionsAPIRuleCreateProps as a SecurityDetectionsAPIQueryRuleCreateProps
func (t SecurityDetectionsAPIRuleCreateProps) AsSecurityDetectionsAPIQueryRuleCreateProps() (SecurityDetectionsAPIQueryRuleCreateProps, error) {
	var body SecurityDetectionsAPIQueryRuleCreateProps
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIQueryRuleCreateProps overwrites any union data inside the SecurityDetectionsAPIRuleCreateProps as the provided SecurityDetectionsAPIQueryRuleCreateProps
func (t *SecurityDetectionsAPIRuleCreateProps) FromSecurityDetectionsAPIQueryRuleCreateProps(v SecurityDetectionsAPIQueryRuleCreateProps) error {
	v.Type = "Security_Detections_API_QueryRuleCreateProps"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIQueryRuleCreateProps performs a merge with any union data inside the SecurityDetectionsAPIRuleCreateProps, using the provided SecurityDetectionsAPIQueryRuleCreateProps
func (t *SecurityDetectionsAPIRuleCreateProps) MergeSecurityDetectionsAPIQueryRuleCreateProps(v SecurityDetectionsAPIQueryRuleCreateProps) error {
	v.Type = "Security_Detections_API_QueryRuleCreateProps"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPISavedQueryRuleCreateProps returns the union data inside the SecurityDetectionsAPIRuleCreateProps as a SecurityDetectionsAPISavedQueryRuleCreateProps
func (t SecurityDetectionsAPIRuleCreateProps) AsSecurityDetectionsAPISavedQueryRuleCreateProps() (SecurityDetectionsAPISavedQueryRuleCreateProps, error) {
	var body SecurityDetectionsAPISavedQueryRuleCreateProps
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPISavedQueryRuleCreateProps overwrites any union data inside the SecurityDetectionsAPIRuleCreateProps as the provided SecurityDetectionsAPISavedQueryRuleCreateProps
func (t *SecurityDetectionsAPIRuleCreateProps) FromSecurityDetectionsAPISavedQueryRuleCreateProps(v SecurityDetectionsAPISavedQueryRuleCreateProps) error {
	v.Type = "Security_Detections_API_SavedQueryRuleCreateProps"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPISavedQueryRuleCreateProps performs a merge with any union data inside the SecurityDetectionsAPIRuleCreateProps, using the provided SecurityDetectionsAPISavedQueryRuleCreateProps
func (t *SecurityDetectionsAPIRuleCreateProps) MergeSecurityDetectionsAPISavedQueryRuleCreateProps(v SecurityDetectionsAPISavedQueryRuleCreateProps) error {
	v.Type = "Security_Detections_API_SavedQueryRuleCreateProps"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPIThresholdRuleCreateProps returns the union data inside the SecurityDetectionsAPIRuleCreateProps as a SecurityDetectionsAPIThresholdRuleCreateProps
func (t SecurityDetectionsAPIRuleCreateProps) AsSecurityDetectionsAPIThresholdRuleCreateProps() (SecurityDetectionsAPIThresholdRuleCreateProps, error) {
	var body SecurityDetectionsAPIThresholdRuleCreateProps
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIThresholdRuleCreateProps overwrites any union data inside the SecurityDetectionsAPIRuleCreateProps as the provided SecurityDetectionsAPIThresholdRuleCreateProps
func (t *SecurityDetectionsAPIRuleCreateProps) FromSecurityDetectionsAPIThresholdRuleCreateProps(v SecurityDetectionsAPIThresholdRuleCreateProps) error {
	v.Type = "Security_Detections_API_ThresholdRuleCreateProps"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIThresholdRuleCreateProps performs a merge with any union data inside the SecurityDetectionsAPIRuleCreateProps, using the provided SecurityDetectionsAPIThresholdRuleCreateProps
func (t *SecurityDetectionsAPIRuleCreateProps) MergeSecurityDetectionsAPIThresholdRuleCreateProps(v SecurityDetectionsAPIThresholdRuleCreateProps) error {
	v.Type = "Security_Detections_API_ThresholdRuleCreateProps"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPIThreatMatchRuleCreateProps returns the union data inside the SecurityDetectionsAPIRuleCreateProps as a SecurityDetectionsAPIThreatMatchRuleCreateProps
func (t SecurityDetectionsAPIRuleCreateProps) AsSecurityDetectionsAPIThreatMatchRuleCreateProps() (SecurityDetectionsAPIThreatMatchRuleCreateProps, error) {
	var body SecurityDetectionsAPIThreatMatchRuleCreateProps
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIThreatMatchRuleCreateProps overwrites any union data inside the SecurityDetectionsAPIRuleCreateProps as the provided SecurityDetectionsAPIThreatMatchRuleCreateProps
func (t *SecurityDetectionsAPIRuleCreateProps) FromSecurityDetectionsAPIThreatMatchRuleCreateProps(v SecurityDetectionsAPIThreatMatchRuleCreateProps) error {
	v.Type = "Security_Detections_API_ThreatMatchRuleCreateProps"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIThreatMatchRuleCreateProps performs a merge with any union data inside the SecurityDetectionsAPIRuleCreateProps, using the provided SecurityDetectionsAPIThreatMatchRuleCreateProps
func (t *SecurityDetectionsAPIRuleCreateProps) MergeSecurityDetectionsAPIThreatMatchRuleCreateProps(v SecurityDetectionsAPIThreatMatchRuleCreateProps) error {
	v.Type = "Security_Detections_API_ThreatMatchRuleCreateProps"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPIMachineLearningRuleCreateProps returns the union data inside the SecurityDetectionsAPIRuleCreateProps as a SecurityDetectionsAPIMachineLearningRuleCreateProps
func (t SecurityDetectionsAPIRuleCreateProps) AsSecurityDetectionsAPIMachineLearningRuleCreateProps() (SecurityDetectionsAPIMachineLearningRuleCreateProps, error) {
	var body SecurityDetectionsAPIMachineLearningRuleCreateProps
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIMachineLearningRuleCreateProps overwrites any union data inside the SecurityDetectionsAPIRuleCreateProps as the provided SecurityDetectionsAPIMachineLearningRuleCreateProps
func (t *SecurityDetectionsAPIRuleCreateProps) FromSecurityDetectionsAPIMachineLearningRuleCreateProps(v SecurityDetectionsAPIMachineLearningRuleCreateProps) error {
	v.Type = "Security_Detections_API_MachineLearningRuleCreateProps"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIMachineLearningRuleCreateProps performs a merge with any union data inside the SecurityDetectionsAPIRuleCreateProps, using the provided SecurityDetectionsAPIMachineLearningRuleCreateProps
func (t *SecurityDetectionsAPIRuleCreateProps) MergeSecurityDetectionsAPIMachineLearningRuleCreateProps(v SecurityDetectionsAPIMachineLearningRuleCreateProps) error {
	v.Type = "Security_Detections_API_MachineLearningRuleCreateProps"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPINewTermsRuleCreateProps returns the union data inside the SecurityDetectionsAPIRuleCreateProps as a SecurityDetectionsAPINewTermsRuleCreateProps
func (t SecurityDetectionsAPIRuleCreateProps) AsSecurityDetectionsAPINewTermsRuleCreateProps() (SecurityDetectionsAPINewTermsRuleCreateProps, error) {
	var body SecurityDetectionsAPINewTermsRuleCreateProps
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPINewTermsRuleCreateProps overwrites any union data inside the SecurityDetectionsAPIRuleCreateProps as the provided SecurityDetectionsAPINewTermsRuleCreateProps
func (t *SecurityDetectionsAPIRuleCreateProps) FromSecurityDetectionsAPINewTermsRuleCreateProps(v SecurityDetectionsAPINewTermsRuleCreateProps) error {
	v.Type = "Security_Detections_API_NewTermsRuleCreateProps"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPINewTermsRuleCreateProps performs a merge with any union data inside the SecurityDetectionsAPIRuleCreateProps, using the provided SecurityDetectionsAPINewTermsRuleCreateProps
func (t *SecurityDetectionsAPIRuleCreateProps) MergeSecurityDetectionsAPINewTermsRuleCreateProps(v SecurityDetectionsAPINewTermsRuleCreateProps) error {
	v.Type = "Security_Detections_API_NewTermsRuleCreateProps"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPIEsqlRuleCreateProps returns the union data inside the SecurityDetectionsAPIRuleCreateProps as a SecurityDetectionsAPIEsqlRuleCreateProps
func (t SecurityDetectionsAPIRuleCreateProps) AsSecurityDetectionsAPIEsqlRuleCreateProps() (SecurityDetectionsAPIEsqlRuleCreateProps, error) {
	var body SecurityDetectionsAPIEsqlRuleCreateProps
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIEsqlRuleCreateProps overwrites any union data inside the SecurityDetectionsAPIRuleCreateProps as the provided SecurityDetectionsAPIEsqlRuleCreateProps
func (t *SecurityDetectionsAPIRuleCreateProps) FromSecurityDetectionsAPIEsqlRuleCreateProps(v SecurityDetectionsAPIEsqlRuleCreateProps) error {
	v.Type = "Security_Detections_API_EsqlRuleCreateProps"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIEsqlRuleCreateProps performs a merge with any union data inside the SecurityDetectionsAPIRuleCreateProps, using the provided SecurityDetectionsAPIEsqlRuleCreateProps
func (t *SecurityDetectionsAPIRuleCreateProps) MergeSecurityDetectionsAPIEsqlRuleCreateProps(v SecurityDetectionsAPIEsqlRuleCreateProps) error {
	v.Type = "Security_Detections_API_EsqlRuleCreateProps"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SecurityDetectionsAPIRuleCreateProps) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SecurityDetectionsAPIRuleCreateProps) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "Security_Detections_API_EqlRuleCreateProps":
		return t.AsSecurityDetectionsAPIEqlRuleCreateProps()
	case "Security_Detections_API_EsqlRuleCreateProps":
		return t.AsSecurityDetectionsAPIEsqlRuleCreateProps()
	case "Security_Detections_API_MachineLearningRuleCreateProps":
		return t.AsSecurityDetectionsAPIMachineLearningRuleCreateProps()
	case "Security_Detections_API_NewTermsRuleCreateProps":
		return t.AsSecurityDetectionsAPINewTermsRuleCreateProps()
	case "Security_Detections_API_QueryRuleCreateProps":
		return t.AsSecurityDetectionsAPIQueryRuleCreateProps()
	case "Security_Detections_API_SavedQueryRuleCreateProps":
		return t.AsSecurityDetectionsAPISavedQueryRuleCreateProps()
	case "Security_Detections_API_ThreatMatchRuleCreateProps":
		return t.AsSecurityDetectionsAPIThreatMatchRuleCreateProps()
	case "Security_Detections_API_ThresholdRuleCreateProps":
		return t.AsSecurityDetectionsAPIThresholdRuleCreateProps()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SecurityDetectionsAPIRuleCreateProps) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SecurityDetectionsAPIRuleCreateProps) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSecurityDetectionsAPIEqlRule returns the union data inside the SecurityDetectionsAPIRuleResponse as a SecurityDetectionsAPIEqlRule
func (t SecurityDetectionsAPIRuleResponse) AsSecurityDetectionsAPIEqlRule() (SecurityDetectionsAPIEqlRule, error) {
	var body SecurityDetectionsAPIEqlRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIEqlRule overwrites any union data inside the SecurityDetectionsAPIRuleResponse as the provided SecurityDetectionsAPIEqlRule
func (t *SecurityDetectionsAPIRuleResponse) FromSecurityDetectionsAPIEqlRule(v SecurityDetectionsAPIEqlRule) error {
	v.Type = "Security_Detections_API_EqlRule"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIEqlRule performs a merge with any union data inside the SecurityDetectionsAPIRuleResponse, using the provided SecurityDetectionsAPIEqlRule
func (t *SecurityDetectionsAPIRuleResponse) MergeSecurityDetectionsAPIEqlRule(v SecurityDetectionsAPIEqlRule) error {
	v.Type = "Security_Detections_API_EqlRule"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPIQueryRule returns the union data inside the SecurityDetectionsAPIRuleResponse as a SecurityDetectionsAPIQueryRule
func (t SecurityDetectionsAPIRuleResponse) AsSecurityDetectionsAPIQueryRule() (SecurityDetectionsAPIQueryRule, error) {
	var body SecurityDetectionsAPIQueryRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIQueryRule overwrites any union data inside the SecurityDetectionsAPIRuleResponse as the provided SecurityDetectionsAPIQueryRule
func (t *SecurityDetectionsAPIRuleResponse) FromSecurityDetectionsAPIQueryRule(v SecurityDetectionsAPIQueryRule) error {
	v.Type = "Security_Detections_API_QueryRule"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIQueryRule performs a merge with any union data inside the SecurityDetectionsAPIRuleResponse, using the provided SecurityDetectionsAPIQueryRule
func (t *SecurityDetectionsAPIRuleResponse) MergeSecurityDetectionsAPIQueryRule(v SecurityDetectionsAPIQueryRule) error {
	v.Type = "Security_Detections_API_QueryRule"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPISavedQueryRule returns the union data inside the SecurityDetectionsAPIRuleResponse as a SecurityDetectionsAPISavedQueryRule
func (t SecurityDetectionsAPIRuleResponse) AsSecurityDetectionsAPISavedQueryRule() (SecurityDetectionsAPISavedQueryRule, error) {
	var body SecurityDetectionsAPISavedQueryRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPISavedQueryRule overwrites any union data inside the SecurityDetectionsAPIRuleResponse as the provided SecurityDetectionsAPISavedQueryRule
func (t *SecurityDetectionsAPIRuleResponse) FromSecurityDetectionsAPISavedQueryRule(v SecurityDetectionsAPISavedQueryRule) error {
	v.Type = "Security_Detections_API_SavedQueryRule"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPISavedQueryRule performs a merge with any union data inside the SecurityDetectionsAPIRuleResponse, using the provided SecurityDetectionsAPISavedQueryRule
func (t *SecurityDetectionsAPIRuleResponse) MergeSecurityDetectionsAPISavedQueryRule(v SecurityDetectionsAPISavedQueryRule) error {
	v.Type = "Security_Detections_API_SavedQueryRule"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPIThresholdRule returns the union data inside the SecurityDetectionsAPIRuleResponse as a SecurityDetectionsAPIThresholdRule
func (t SecurityDetectionsAPIRuleResponse) AsSecurityDetectionsAPIThresholdRule() (SecurityDetectionsAPIThresholdRule, error) {
	var body SecurityDetectionsAPIThresholdRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIThresholdRule overwrites any union data inside the SecurityDetectionsAPIRuleResponse as the provided SecurityDetectionsAPIThresholdRule
func (t *SecurityDetectionsAPIRuleResponse) FromSecurityDetectionsAPIThresholdRule(v SecurityDetectionsAPIThresholdRule) error {
	v.Type = "Security_Detections_API_ThresholdRule"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIThresholdRule performs a merge with any union data inside the SecurityDetectionsAPIRuleResponse, using the provided SecurityDetectionsAPIThresholdRule
func (t *SecurityDetectionsAPIRuleResponse) MergeSecurityDetectionsAPIThresholdRule(v SecurityDetectionsAPIThresholdRule) error {
	v.Type = "Security_Detections_API_ThresholdRule"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPIThreatMatchRule returns the union data inside the SecurityDetectionsAPIRuleResponse as a SecurityDetectionsAPIThreatMatchRule
func (t SecurityDetectionsAPIRuleResponse) AsSecurityDetectionsAPIThreatMatchRule() (SecurityDetectionsAPIThreatMatchRule, error) {
	var body SecurityDetectionsAPIThreatMatchRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIThreatMatchRule overwrites any union data inside the SecurityDetectionsAPIRuleResponse as the provided SecurityDetectionsAPIThreatMatchRule
func (t *SecurityDetectionsAPIRuleResponse) FromSecurityDetectionsAPIThreatMatchRule(v SecurityDetectionsAPIThreatMatchRule) error {
	v.Type = "Security_Detections_API_ThreatMatchRule"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIThreatMatchRule performs a merge with any union data inside the SecurityDetectionsAPIRuleResponse, using the provided SecurityDetectionsAPIThreatMatchRule
func (t *SecurityDetectionsAPIRuleResponse) MergeSecurityDetectionsAPIThreatMatchRule(v SecurityDetectionsAPIThreatMatchRule) error {
	v.Type = "Security_Detections_API_ThreatMatchRule"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPIMachineLearningRule returns the union data inside the SecurityDetectionsAPIRuleResponse as a SecurityDetectionsAPIMachineLearningRule
func (t SecurityDetectionsAPIRuleResponse) AsSecurityDetectionsAPIMachineLearningRule() (SecurityDetectionsAPIMachineLearningRule, error) {
	var body SecurityDetectionsAPIMachineLearningRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIMachineLearningRule overwrites any union data inside the SecurityDetectionsAPIRuleResponse as the provided SecurityDetectionsAPIMachineLearningRule
func (t *SecurityDetectionsAPIRuleResponse) FromSecurityDetectionsAPIMachineLearningRule(v SecurityDetectionsAPIMachineLearningRule) error {
	v.Type = "Security_Detections_API_MachineLearningRule"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIMachineLearningRule performs a merge with any union data inside the SecurityDetectionsAPIRuleResponse, using the provided SecurityDetectionsAPIMachineLearningRule
func (t *SecurityDetectionsAPIRuleResponse) MergeSecurityDetectionsAPIMachineLearningRule(v SecurityDetectionsAPIMachineLearningRule) error {
	v.Type = "Security_Detections_API_MachineLearningRule"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPINewTermsRule returns the union data inside the SecurityDetectionsAPIRuleResponse as a SecurityDetectionsAPINewTermsRule
func (t SecurityDetectionsAPIRuleResponse) AsSecurityDetectionsAPINewTermsRule() (SecurityDetectionsAPINewTermsRule, error) {
	var body SecurityDetectionsAPINewTermsRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPINewTermsRule overwrites any union data inside the SecurityDetectionsAPIRuleResponse as the provided SecurityDetectionsAPINewTermsRule
func (t *SecurityDetectionsAPIRuleResponse) FromSecurityDetectionsAPINewTermsRule(v SecurityDetectionsAPINewTermsRule) error {
	v.Type = "Security_Detections_API_NewTermsRule"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPINewTermsRule performs a merge with any union data inside the SecurityDetectionsAPIRuleResponse, using the provided SecurityDetectionsAPINewTermsRule
func (t *SecurityDetectionsAPIRuleResponse) MergeSecurityDetectionsAPINewTermsRule(v SecurityDetectionsAPINewTermsRule) error {
	v.Type = "Security_Detections_API_NewTermsRule"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPIEsqlRule returns the union data inside the SecurityDetectionsAPIRuleResponse as a SecurityDetectionsAPIEsqlRule
func (t SecurityDetectionsAPIRuleResponse) AsSecurityDetectionsAPIEsqlRule() (SecurityDetectionsAPIEsqlRule, error) {
	var body SecurityDetectionsAPIEsqlRule
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIEsqlRule overwrites any union data inside the SecurityDetectionsAPIRuleResponse as the provided SecurityDetectionsAPIEsqlRule
func (t *SecurityDetectionsAPIRuleResponse) FromSecurityDetectionsAPIEsqlRule(v SecurityDetectionsAPIEsqlRule) error {
	v.Type = "Security_Detections_API_EsqlRule"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIEsqlRule performs a merge with any union data inside the SecurityDetectionsAPIRuleResponse, using the provided SecurityDetectionsAPIEsqlRule
func (t *SecurityDetectionsAPIRuleResponse) MergeSecurityDetectionsAPIEsqlRule(v SecurityDetectionsAPIEsqlRule) error {
	v.Type = "Security_Detections_API_EsqlRule"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SecurityDetectionsAPIRuleResponse) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SecurityDetectionsAPIRuleResponse) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "Security_Detections_API_EqlRule":
		return t.AsSecurityDetectionsAPIEqlRule()
	case "Security_Detections_API_EsqlRule":
		return t.AsSecurityDetectionsAPIEsqlRule()
	case "Security_Detections_API_MachineLearningRule":
		return t.AsSecurityDetectionsAPIMachineLearningRule()
	case "Security_Detections_API_NewTermsRule":
		return t.AsSecurityDetectionsAPINewTermsRule()
	case "Security_Detections_API_QueryRule":
		return t.AsSecurityDetectionsAPIQueryRule()
	case "Security_Detections_API_SavedQueryRule":
		return t.AsSecurityDetectionsAPISavedQueryRule()
	case "Security_Detections_API_ThreatMatchRule":
		return t.AsSecurityDetectionsAPIThreatMatchRule()
	case "Security_Detections_API_ThresholdRule":
		return t.AsSecurityDetectionsAPIThresholdRule()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SecurityDetectionsAPIRuleResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SecurityDetectionsAPIRuleResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSecurityDetectionsAPIExternalRuleSource returns the union data inside the SecurityDetectionsAPIRuleSource as a SecurityDetectionsAPIExternalRuleSource
func (t SecurityDetectionsAPIRuleSource) AsSecurityDetectionsAPIExternalRuleSource() (SecurityDetectionsAPIExternalRuleSource, error) {
	var body SecurityDetectionsAPIExternalRuleSource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIExternalRuleSource overwrites any union data inside the SecurityDetectionsAPIRuleSource as the provided SecurityDetectionsAPIExternalRuleSource
func (t *SecurityDetectionsAPIRuleSource) FromSecurityDetectionsAPIExternalRuleSource(v SecurityDetectionsAPIExternalRuleSource) error {
	v.Type = "Security_Detections_API_ExternalRuleSource"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIExternalRuleSource performs a merge with any union data inside the SecurityDetectionsAPIRuleSource, using the provided SecurityDetectionsAPIExternalRuleSource
func (t *SecurityDetectionsAPIRuleSource) MergeSecurityDetectionsAPIExternalRuleSource(v SecurityDetectionsAPIExternalRuleSource) error {
	v.Type = "Security_Detections_API_ExternalRuleSource"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPIInternalRuleSource returns the union data inside the SecurityDetectionsAPIRuleSource as a SecurityDetectionsAPIInternalRuleSource
func (t SecurityDetectionsAPIRuleSource) AsSecurityDetectionsAPIInternalRuleSource() (SecurityDetectionsAPIInternalRuleSource, error) {
	var body SecurityDetectionsAPIInternalRuleSource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIInternalRuleSource overwrites any union data inside the SecurityDetectionsAPIRuleSource as the provided SecurityDetectionsAPIInternalRuleSource
func (t *SecurityDetectionsAPIRuleSource) FromSecurityDetectionsAPIInternalRuleSource(v SecurityDetectionsAPIInternalRuleSource) error {
	v.Type = "Security_Detections_API_InternalRuleSource"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIInternalRuleSource performs a merge with any union data inside the SecurityDetectionsAPIRuleSource, using the provided SecurityDetectionsAPIInternalRuleSource
func (t *SecurityDetectionsAPIRuleSource) MergeSecurityDetectionsAPIInternalRuleSource(v SecurityDetectionsAPIInternalRuleSource) error {
	v.Type = "Security_Detections_API_InternalRuleSource"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SecurityDetectionsAPIRuleSource) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SecurityDetectionsAPIRuleSource) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "Security_Detections_API_ExternalRuleSource":
		return t.AsSecurityDetectionsAPIExternalRuleSource()
	case "Security_Detections_API_InternalRuleSource":
		return t.AsSecurityDetectionsAPIInternalRuleSource()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SecurityDetectionsAPIRuleSource) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SecurityDetectionsAPIRuleSource) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSecurityDetectionsAPIEqlRuleUpdateProps returns the union data inside the SecurityDetectionsAPIRuleUpdateProps as a SecurityDetectionsAPIEqlRuleUpdateProps
func (t SecurityDetectionsAPIRuleUpdateProps) AsSecurityDetectionsAPIEqlRuleUpdateProps() (SecurityDetectionsAPIEqlRuleUpdateProps, error) {
	var body SecurityDetectionsAPIEqlRuleUpdateProps
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIEqlRuleUpdateProps overwrites any union data inside the SecurityDetectionsAPIRuleUpdateProps as the provided SecurityDetectionsAPIEqlRuleUpdateProps
func (t *SecurityDetectionsAPIRuleUpdateProps) FromSecurityDetectionsAPIEqlRuleUpdateProps(v SecurityDetectionsAPIEqlRuleUpdateProps) error {
	v.Type = "Security_Detections_API_EqlRuleUpdateProps"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIEqlRuleUpdateProps performs a merge with any union data inside the SecurityDetectionsAPIRuleUpdateProps, using the provided SecurityDetectionsAPIEqlRuleUpdateProps
func (t *SecurityDetectionsAPIRuleUpdateProps) MergeSecurityDetectionsAPIEqlRuleUpdateProps(v SecurityDetectionsAPIEqlRuleUpdateProps) error {
	v.Type = "Security_Detections_API_EqlRuleUpdateProps"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPIQueryRuleUpdateProps returns the union data inside the SecurityDetectionsAPIRuleUpdateProps as a SecurityDetectionsAPIQueryRuleUpdateProps
func (t SecurityDetectionsAPIRuleUpdateProps) AsSecurityDetectionsAPIQueryRuleUpdateProps() (SecurityDetectionsAPIQueryRuleUpdateProps, error) {
	var body SecurityDetectionsAPIQueryRuleUpdateProps
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIQueryRuleUpdateProps overwrites any union data inside the SecurityDetectionsAPIRuleUpdateProps as the provided SecurityDetectionsAPIQueryRuleUpdateProps
func (t *SecurityDetectionsAPIRuleUpdateProps) FromSecurityDetectionsAPIQueryRuleUpdateProps(v SecurityDetectionsAPIQueryRuleUpdateProps) error {
	v.Type = "Security_Detections_API_QueryRuleUpdateProps"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIQueryRuleUpdateProps performs a merge with any union data inside the SecurityDetectionsAPIRuleUpdateProps, using the provided SecurityDetectionsAPIQueryRuleUpdateProps
func (t *SecurityDetectionsAPIRuleUpdateProps) MergeSecurityDetectionsAPIQueryRuleUpdateProps(v SecurityDetectionsAPIQueryRuleUpdateProps) error {
	v.Type = "Security_Detections_API_QueryRuleUpdateProps"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPISavedQueryRuleUpdateProps returns the union data inside the SecurityDetectionsAPIRuleUpdateProps as a SecurityDetectionsAPISavedQueryRuleUpdateProps
func (t SecurityDetectionsAPIRuleUpdateProps) AsSecurityDetectionsAPISavedQueryRuleUpdateProps() (SecurityDetectionsAPISavedQueryRuleUpdateProps, error) {
	var body SecurityDetectionsAPISavedQueryRuleUpdateProps
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPISavedQueryRuleUpdateProps overwrites any union data inside the SecurityDetectionsAPIRuleUpdateProps as the provided SecurityDetectionsAPISavedQueryRuleUpdateProps
func (t *SecurityDetectionsAPIRuleUpdateProps) FromSecurityDetectionsAPISavedQueryRuleUpdateProps(v SecurityDetectionsAPISavedQueryRuleUpdateProps) error {
	v.Type = "Security_Detections_API_SavedQueryRuleUpdateProps"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPISavedQueryRuleUpdateProps performs a merge with any union data inside the SecurityDetectionsAPIRuleUpdateProps, using the provided SecurityDetectionsAPISavedQueryRuleUpdateProps
func (t *SecurityDetectionsAPIRuleUpdateProps) MergeSecurityDetectionsAPISavedQueryRuleUpdateProps(v SecurityDetectionsAPISavedQueryRuleUpdateProps) error {
	v.Type = "Security_Detections_API_SavedQueryRuleUpdateProps"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPIThresholdRuleUpdateProps returns the union data inside the SecurityDetectionsAPIRuleUpdateProps as a SecurityDetectionsAPIThresholdRuleUpdateProps
func (t SecurityDetectionsAPIRuleUpdateProps) AsSecurityDetectionsAPIThresholdRuleUpdateProps() (SecurityDetectionsAPIThresholdRuleUpdateProps, error) {
	var body SecurityDetectionsAPIThresholdRuleUpdateProps
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIThresholdRuleUpdateProps overwrites any union data inside the SecurityDetectionsAPIRuleUpdateProps as the provided SecurityDetectionsAPIThresholdRuleUpdateProps
func (t *SecurityDetectionsAPIRuleUpdateProps) FromSecurityDetectionsAPIThresholdRuleUpdateProps(v SecurityDetectionsAPIThresholdRuleUpdateProps) error {
	v.Type = "Security_Detections_API_ThresholdRuleUpdateProps"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIThresholdRuleUpdateProps performs a merge with any union data inside the SecurityDetectionsAPIRuleUpdateProps, using the provided SecurityDetectionsAPIThresholdRuleUpdateProps
func (t *SecurityDetectionsAPIRuleUpdateProps) MergeSecurityDetectionsAPIThresholdRuleUpdateProps(v SecurityDetectionsAPIThresholdRuleUpdateProps) error {
	v.Type = "Security_Detections_API_ThresholdRuleUpdateProps"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPIThreatMatchRuleUpdateProps returns the union data inside the SecurityDetectionsAPIRuleUpdateProps as a SecurityDetectionsAPIThreatMatchRuleUpdateProps
func (t SecurityDetectionsAPIRuleUpdateProps) AsSecurityDetectionsAPIThreatMatchRuleUpdateProps() (SecurityDetectionsAPIThreatMatchRuleUpdateProps, error) {
	var body SecurityDetectionsAPIThreatMatchRuleUpdateProps
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIThreatMatchRuleUpdateProps overwrites any union data inside the SecurityDetectionsAPIRuleUpdateProps as the provided SecurityDetectionsAPIThreatMatchRuleUpdateProps
func (t *SecurityDetectionsAPIRuleUpdateProps) FromSecurityDetectionsAPIThreatMatchRuleUpdateProps(v SecurityDetectionsAPIThreatMatchRuleUpdateProps) error {
	v.Type = "Security_Detections_API_ThreatMatchRuleUpdateProps"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIThreatMatchRuleUpdateProps performs a merge with any union data inside the SecurityDetectionsAPIRuleUpdateProps, using the provided SecurityDetectionsAPIThreatMatchRuleUpdateProps
func (t *SecurityDetectionsAPIRuleUpdateProps) MergeSecurityDetectionsAPIThreatMatchRuleUpdateProps(v SecurityDetectionsAPIThreatMatchRuleUpdateProps) error {
	v.Type = "Security_Detections_API_ThreatMatchRuleUpdateProps"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPIMachineLearningRuleUpdateProps returns the union data inside the SecurityDetectionsAPIRuleUpdateProps as a SecurityDetectionsAPIMachineLearningRuleUpdateProps
func (t SecurityDetectionsAPIRuleUpdateProps) AsSecurityDetectionsAPIMachineLearningRuleUpdateProps() (SecurityDetectionsAPIMachineLearningRuleUpdateProps, error) {
	var body SecurityDetectionsAPIMachineLearningRuleUpdateProps
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIMachineLearningRuleUpdateProps overwrites any union data inside the SecurityDetectionsAPIRuleUpdateProps as the provided SecurityDetectionsAPIMachineLearningRuleUpdateProps
func (t *SecurityDetectionsAPIRuleUpdateProps) FromSecurityDetectionsAPIMachineLearningRuleUpdateProps(v SecurityDetectionsAPIMachineLearningRuleUpdateProps) error {
	v.Type = "Security_Detections_API_MachineLearningRuleUpdateProps"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIMachineLearningRuleUpdateProps performs a merge with any union data inside the SecurityDetectionsAPIRuleUpdateProps, using the provided SecurityDetectionsAPIMachineLearningRuleUpdateProps
func (t *SecurityDetectionsAPIRuleUpdateProps) MergeSecurityDetectionsAPIMachineLearningRuleUpdateProps(v SecurityDetectionsAPIMachineLearningRuleUpdateProps) error {
	v.Type = "Security_Detections_API_MachineLearningRuleUpdateProps"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPINewTermsRuleUpdateProps returns the union data inside the SecurityDetectionsAPIRuleUpdateProps as a SecurityDetectionsAPINewTermsRuleUpdateProps
func (t SecurityDetectionsAPIRuleUpdateProps) AsSecurityDetectionsAPINewTermsRuleUpdateProps() (SecurityDetectionsAPINewTermsRuleUpdateProps, error) {
	var body SecurityDetectionsAPINewTermsRuleUpdateProps
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPINewTermsRuleUpdateProps overwrites any union data inside the SecurityDetectionsAPIRuleUpdateProps as the provided SecurityDetectionsAPINewTermsRuleUpdateProps
func (t *SecurityDetectionsAPIRuleUpdateProps) FromSecurityDetectionsAPINewTermsRuleUpdateProps(v SecurityDetectionsAPINewTermsRuleUpdateProps) error {
	v.Type = "Security_Detections_API_NewTermsRuleUpdateProps"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPINewTermsRuleUpdateProps performs a merge with any union data inside the SecurityDetectionsAPIRuleUpdateProps, using the provided SecurityDetectionsAPINewTermsRuleUpdateProps
func (t *SecurityDetectionsAPIRuleUpdateProps) MergeSecurityDetectionsAPINewTermsRuleUpdateProps(v SecurityDetectionsAPINewTermsRuleUpdateProps) error {
	v.Type = "Security_Detections_API_NewTermsRuleUpdateProps"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPIEsqlRuleUpdateProps returns the union data inside the SecurityDetectionsAPIRuleUpdateProps as a SecurityDetectionsAPIEsqlRuleUpdateProps
func (t SecurityDetectionsAPIRuleUpdateProps) AsSecurityDetectionsAPIEsqlRuleUpdateProps() (SecurityDetectionsAPIEsqlRuleUpdateProps, error) {
	var body SecurityDetectionsAPIEsqlRuleUpdateProps
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIEsqlRuleUpdateProps overwrites any union data inside the SecurityDetectionsAPIRuleUpdateProps as the provided SecurityDetectionsAPIEsqlRuleUpdateProps
func (t *SecurityDetectionsAPIRuleUpdateProps) FromSecurityDetectionsAPIEsqlRuleUpdateProps(v SecurityDetectionsAPIEsqlRuleUpdateProps) error {
	v.Type = "Security_Detections_API_EsqlRuleUpdateProps"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIEsqlRuleUpdateProps performs a merge with any union data inside the SecurityDetectionsAPIRuleUpdateProps, using the provided SecurityDetectionsAPIEsqlRuleUpdateProps
func (t *SecurityDetectionsAPIRuleUpdateProps) MergeSecurityDetectionsAPIEsqlRuleUpdateProps(v SecurityDetectionsAPIEsqlRuleUpdateProps) error {
	v.Type = "Security_Detections_API_EsqlRuleUpdateProps"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SecurityDetectionsAPIRuleUpdateProps) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t SecurityDetectionsAPIRuleUpdateProps) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "Security_Detections_API_EqlRuleUpdateProps":
		return t.AsSecurityDetectionsAPIEqlRuleUpdateProps()
	case "Security_Detections_API_EsqlRuleUpdateProps":
		return t.AsSecurityDetectionsAPIEsqlRuleUpdateProps()
	case "Security_Detections_API_MachineLearningRuleUpdateProps":
		return t.AsSecurityDetectionsAPIMachineLearningRuleUpdateProps()
	case "Security_Detections_API_NewTermsRuleUpdateProps":
		return t.AsSecurityDetectionsAPINewTermsRuleUpdateProps()
	case "Security_Detections_API_QueryRuleUpdateProps":
		return t.AsSecurityDetectionsAPIQueryRuleUpdateProps()
	case "Security_Detections_API_SavedQueryRuleUpdateProps":
		return t.AsSecurityDetectionsAPISavedQueryRuleUpdateProps()
	case "Security_Detections_API_ThreatMatchRuleUpdateProps":
		return t.AsSecurityDetectionsAPIThreatMatchRuleUpdateProps()
	case "Security_Detections_API_ThresholdRuleUpdateProps":
		return t.AsSecurityDetectionsAPIThresholdRuleUpdateProps()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t SecurityDetectionsAPIRuleUpdateProps) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SecurityDetectionsAPIRuleUpdateProps) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsSecurityDetectionsAPIThresholdField0 returns the union data inside the SecurityDetectionsAPIThresholdField as a SecurityDetectionsAPIThresholdField0
func (t SecurityDetectionsAPIThresholdField) AsSecurityDetectionsAPIThresholdField0() (SecurityDetectionsAPIThresholdField0, error) {
	var body SecurityDetectionsAPIThresholdField0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIThresholdField0 overwrites any union data inside the SecurityDetectionsAPIThresholdField as the provided SecurityDetectionsAPIThresholdField0
func (t *SecurityDetectionsAPIThresholdField) FromSecurityDetectionsAPIThresholdField0(v SecurityDetectionsAPIThresholdField0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIThresholdField0 performs a merge with any union data inside the SecurityDetectionsAPIThresholdField, using the provided SecurityDetectionsAPIThresholdField0
func (t *SecurityDetectionsAPIThresholdField) MergeSecurityDetectionsAPIThresholdField0(v SecurityDetectionsAPIThresholdField0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSecurityDetectionsAPIThresholdField1 returns the union data inside the SecurityDetectionsAPIThresholdField as a SecurityDetectionsAPIThresholdField1
func (t SecurityDetectionsAPIThresholdField) AsSecurityDetectionsAPIThresholdField1() (SecurityDetectionsAPIThresholdField1, error) {
	var body SecurityDetectionsAPIThresholdField1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSecurityDetectionsAPIThresholdField1 overwrites any union data inside the SecurityDetectionsAPIThresholdField as the provided SecurityDetectionsAPIThresholdField1
func (t *SecurityDetectionsAPIThresholdField) FromSecurityDetectionsAPIThresholdField1(v SecurityDetectionsAPIThresholdField1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSecurityDetectionsAPIThresholdField1 performs a merge with any union data inside the SecurityDetectionsAPIThresholdField, using the provided SecurityDetectionsAPIThresholdField1
func (t *SecurityDetectionsAPIThresholdField) MergeSecurityDetectionsAPIThresholdField1(v SecurityDetectionsAPIThresholdField1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SecurityDetectionsAPIThresholdField) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SecurityDetectionsAPIThresholdField) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAgentPolicyPackagePolicies1Inputs1StreamsVars0 returns the union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties as a AgentPolicyPackagePolicies1Inputs1StreamsVars0
func (t AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties) AsAgentPolicyPackagePolicies1Inputs1StreamsVars0() (AgentPolicyPackagePolicies1Inputs1StreamsVars0, error) {
	var body AgentPolicyPackagePolicies1Inputs1StreamsVars0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies1Inputs1StreamsVars0 overwrites any union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties as the provided AgentPolicyPackagePolicies1Inputs1StreamsVars0
func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties) FromAgentPolicyPackagePolicies1Inputs1StreamsVars0(v AgentPolicyPackagePolicies1Inputs1StreamsVars0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies1Inputs1StreamsVars0 performs a merge with any union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties, using the provided AgentPolicyPackagePolicies1Inputs1StreamsVars0
func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties) MergeAgentPolicyPackagePolicies1Inputs1StreamsVars0(v AgentPolicyPackagePolicies1Inputs1StreamsVars0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyPackagePolicies1Inputs1StreamsVars1 returns the union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties as a AgentPolicyPackagePolicies1Inputs1StreamsVars1
func (t AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties) AsAgentPolicyPackagePolicies1Inputs1StreamsVars1() (AgentPolicyPackagePolicies1Inputs1StreamsVars1, error) {
	var body AgentPolicyPackagePolicies1Inputs1StreamsVars1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies1Inputs1StreamsVars1 overwrites any union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties as the provided AgentPolicyPackagePolicies1Inputs1StreamsVars1
func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties) FromAgentPolicyPackagePolicies1Inputs1StreamsVars1(v AgentPolicyPackagePolicies1Inputs1StreamsVars1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies1Inputs1StreamsVars1 performs a merge with any union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties, using the provided AgentPolicyPackagePolicies1Inputs1StreamsVars1
func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties) MergeAgentPolicyPackagePolicies1Inputs1StreamsVars1(v AgentPolicyPackagePolicies1Inputs1StreamsVars1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyPackagePolicies1Inputs1StreamsVars2 returns the union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties as a AgentPolicyPackagePolicies1Inputs1StreamsVars2
func (t AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties) AsAgentPolicyPackagePolicies1Inputs1StreamsVars2() (AgentPolicyPackagePolicies1Inputs1StreamsVars2, error) {
	var body AgentPolicyPackagePolicies1Inputs1StreamsVars2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies1Inputs1StreamsVars2 overwrites any union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties as the provided AgentPolicyPackagePolicies1Inputs1StreamsVars2
func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties) FromAgentPolicyPackagePolicies1Inputs1StreamsVars2(v AgentPolicyPackagePolicies1Inputs1StreamsVars2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies1Inputs1StreamsVars2 performs a merge with any union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties, using the provided AgentPolicyPackagePolicies1Inputs1StreamsVars2
func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties) MergeAgentPolicyPackagePolicies1Inputs1StreamsVars2(v AgentPolicyPackagePolicies1Inputs1StreamsVars2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyPackagePolicies1Inputs1StreamsVars3 returns the union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties as a AgentPolicyPackagePolicies1Inputs1StreamsVars3
func (t AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties) AsAgentPolicyPackagePolicies1Inputs1StreamsVars3() (AgentPolicyPackagePolicies1Inputs1StreamsVars3, error) {
	var body AgentPolicyPackagePolicies1Inputs1StreamsVars3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies1Inputs1StreamsVars3 overwrites any union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties as the provided AgentPolicyPackagePolicies1Inputs1StreamsVars3
func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties) FromAgentPolicyPackagePolicies1Inputs1StreamsVars3(v AgentPolicyPackagePolicies1Inputs1StreamsVars3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies1Inputs1StreamsVars3 performs a merge with any union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties, using the provided AgentPolicyPackagePolicies1Inputs1StreamsVars3
func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties) MergeAgentPolicyPackagePolicies1Inputs1StreamsVars3(v AgentPolicyPackagePolicies1Inputs1StreamsVars3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyPackagePolicies1Inputs1StreamsVars4 returns the union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties as a AgentPolicyPackagePolicies1Inputs1StreamsVars4
func (t AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties) AsAgentPolicyPackagePolicies1Inputs1StreamsVars4() (AgentPolicyPackagePolicies1Inputs1StreamsVars4, error) {
	var body AgentPolicyPackagePolicies1Inputs1StreamsVars4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies1Inputs1StreamsVars4 overwrites any union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties as the provided AgentPolicyPackagePolicies1Inputs1StreamsVars4
func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties) FromAgentPolicyPackagePolicies1Inputs1StreamsVars4(v AgentPolicyPackagePolicies1Inputs1StreamsVars4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies1Inputs1StreamsVars4 performs a merge with any union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties, using the provided AgentPolicyPackagePolicies1Inputs1StreamsVars4
func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties) MergeAgentPolicyPackagePolicies1Inputs1StreamsVars4(v AgentPolicyPackagePolicies1Inputs1StreamsVars4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyPackagePolicies1Inputs1StreamsVars5 returns the union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties as a AgentPolicyPackagePolicies1Inputs1StreamsVars5
func (t AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties) AsAgentPolicyPackagePolicies1Inputs1StreamsVars5() (AgentPolicyPackagePolicies1Inputs1StreamsVars5, error) {
	var body AgentPolicyPackagePolicies1Inputs1StreamsVars5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies1Inputs1StreamsVars5 overwrites any union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties as the provided AgentPolicyPackagePolicies1Inputs1StreamsVars5
func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties) FromAgentPolicyPackagePolicies1Inputs1StreamsVars5(v AgentPolicyPackagePolicies1Inputs1StreamsVars5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies1Inputs1StreamsVars5 performs a merge with any union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties, using the provided AgentPolicyPackagePolicies1Inputs1StreamsVars5
func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties) MergeAgentPolicyPackagePolicies1Inputs1StreamsVars5(v AgentPolicyPackagePolicies1Inputs1StreamsVars5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Streams_Vars_AdditionalProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAgentPolicyPackagePolicies1Inputs1Vars0 returns the union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties as a AgentPolicyPackagePolicies1Inputs1Vars0
func (t AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties) AsAgentPolicyPackagePolicies1Inputs1Vars0() (AgentPolicyPackagePolicies1Inputs1Vars0, error) {
	var body AgentPolicyPackagePolicies1Inputs1Vars0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies1Inputs1Vars0 overwrites any union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties as the provided AgentPolicyPackagePolicies1Inputs1Vars0
func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties) FromAgentPolicyPackagePolicies1Inputs1Vars0(v AgentPolicyPackagePolicies1Inputs1Vars0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies1Inputs1Vars0 performs a merge with any union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties, using the provided AgentPolicyPackagePolicies1Inputs1Vars0
func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties) MergeAgentPolicyPackagePolicies1Inputs1Vars0(v AgentPolicyPackagePolicies1Inputs1Vars0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyPackagePolicies1Inputs1Vars1 returns the union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties as a AgentPolicyPackagePolicies1Inputs1Vars1
func (t AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties) AsAgentPolicyPackagePolicies1Inputs1Vars1() (AgentPolicyPackagePolicies1Inputs1Vars1, error) {
	var body AgentPolicyPackagePolicies1Inputs1Vars1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies1Inputs1Vars1 overwrites any union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties as the provided AgentPolicyPackagePolicies1Inputs1Vars1
func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties) FromAgentPolicyPackagePolicies1Inputs1Vars1(v AgentPolicyPackagePolicies1Inputs1Vars1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies1Inputs1Vars1 performs a merge with any union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties, using the provided AgentPolicyPackagePolicies1Inputs1Vars1
func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties) MergeAgentPolicyPackagePolicies1Inputs1Vars1(v AgentPolicyPackagePolicies1Inputs1Vars1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyPackagePolicies1Inputs1Vars2 returns the union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties as a AgentPolicyPackagePolicies1Inputs1Vars2
func (t AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties) AsAgentPolicyPackagePolicies1Inputs1Vars2() (AgentPolicyPackagePolicies1Inputs1Vars2, error) {
	var body AgentPolicyPackagePolicies1Inputs1Vars2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies1Inputs1Vars2 overwrites any union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties as the provided AgentPolicyPackagePolicies1Inputs1Vars2
func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties) FromAgentPolicyPackagePolicies1Inputs1Vars2(v AgentPolicyPackagePolicies1Inputs1Vars2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies1Inputs1Vars2 performs a merge with any union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties, using the provided AgentPolicyPackagePolicies1Inputs1Vars2
func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties) MergeAgentPolicyPackagePolicies1Inputs1Vars2(v AgentPolicyPackagePolicies1Inputs1Vars2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyPackagePolicies1Inputs1Vars3 returns the union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties as a AgentPolicyPackagePolicies1Inputs1Vars3
func (t AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties) AsAgentPolicyPackagePolicies1Inputs1Vars3() (AgentPolicyPackagePolicies1Inputs1Vars3, error) {
	var body AgentPolicyPackagePolicies1Inputs1Vars3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies1Inputs1Vars3 overwrites any union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties as the provided AgentPolicyPackagePolicies1Inputs1Vars3
func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties) FromAgentPolicyPackagePolicies1Inputs1Vars3(v AgentPolicyPackagePolicies1Inputs1Vars3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies1Inputs1Vars3 performs a merge with any union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties, using the provided AgentPolicyPackagePolicies1Inputs1Vars3
func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties) MergeAgentPolicyPackagePolicies1Inputs1Vars3(v AgentPolicyPackagePolicies1Inputs1Vars3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyPackagePolicies1Inputs1Vars4 returns the union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties as a AgentPolicyPackagePolicies1Inputs1Vars4
func (t AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties) AsAgentPolicyPackagePolicies1Inputs1Vars4() (AgentPolicyPackagePolicies1Inputs1Vars4, error) {
	var body AgentPolicyPackagePolicies1Inputs1Vars4
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies1Inputs1Vars4 overwrites any union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties as the provided AgentPolicyPackagePolicies1Inputs1Vars4
func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties) FromAgentPolicyPackagePolicies1Inputs1Vars4(v AgentPolicyPackagePolicies1Inputs1Vars4) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies1Inputs1Vars4 performs a merge with any union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties, using the provided AgentPolicyPackagePolicies1Inputs1Vars4
func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties) MergeAgentPolicyPackagePolicies1Inputs1Vars4(v AgentPolicyPackagePolicies1Inputs1Vars4) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyPackagePolicies1Inputs1Vars5 returns the union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties as a AgentPolicyPackagePolicies1Inputs1Vars5
func (t AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties) AsAgentPolicyPackagePolicies1Inputs1Vars5() (AgentPolicyPackagePolicies1Inputs1Vars5, error) {
	var body AgentPolicyPackagePolicies1Inputs1Vars5
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies1Inputs1Vars5 overwrites any union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties as the provided AgentPolicyPackagePolicies1Inputs1Vars5
func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties) FromAgentPolicyPackagePolicies1Inputs1Vars5(v AgentPolicyPackagePolicies1Inputs1Vars5) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies1Inputs1Vars5 performs a merge with any union data inside the AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties, using the provided AgentPolicyPackagePolicies1Inputs1Vars5
func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties) MergeAgentPolicyPackagePolicies1Inputs1Vars5(v AgentPolicyPackagePolicies1Inputs1Vars5) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AgentPolicy_PackagePolicies_1_Inputs_1_Vars_AdditionalProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAgentPolicyPackagePolicies1Inputs0 returns the union data inside the AgentPolicy_PackagePolicies_1_Inputs as a AgentPolicyPackagePolicies1Inputs0
func (t AgentPolicy_PackagePolicies_1_Inputs) AsAgentPolicyPackagePolicies1Inputs0() (AgentPolicyPackagePolicies1Inputs0, error) {
	var body AgentPolicyPackagePolicies1Inputs0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies1Inputs0 overwrites any union data inside the AgentPolicy_PackagePolicies_1_Inputs as the provided AgentPolicyPackagePolicies1Inputs0
func (t *AgentPolicy_PackagePolicies_1_Inputs) FromAgentPolicyPackagePolicies1Inputs0(v AgentPolicyPackagePolicies1Inputs0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies1Inputs0 performs a merge with any union data inside the AgentPolicy_PackagePolicies_1_Inputs, using the provided AgentPolicyPackagePolicies1Inputs0
func (t *AgentPolicy_PackagePolicies_1_Inputs) MergeAgentPolicyPackagePolicies1Inputs0(v AgentPolicyPackagePolicies1Inputs0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyPackagePolicies1Inputs1 returns the union data inside the AgentPolicy_PackagePolicies_1_Inputs as a AgentPolicyPackagePolicies1Inputs1
func (t AgentPolicy_PackagePolicies_1_Inputs) AsAgentPolicyPackagePolicies1Inputs1() (AgentPolicyPackagePolicies1Inputs1, error) {
	var body AgentPolicyPackagePolicies1Inputs1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies1Inputs1 overwrites any union data inside the AgentPolicy_PackagePolicies_1_Inputs as the provided AgentPolicyPackagePolicies1Inputs1
func (t *AgentPolicy_PackagePolicies_1_Inputs) FromAgentPolicyPackagePolicies1Inputs1(v AgentPolicyPackagePolicies1Inputs1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies1Inputs1 performs a merge with any union data inside the AgentPolicy_PackagePolicies_1_Inputs, using the provided AgentPolicyPackagePolicies1Inputs1
func (t *AgentPolicy_PackagePolicies_1_Inputs) MergeAgentPolicyPackagePolicies1Inputs1(v AgentPolicyPackagePolicies1Inputs1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AgentPolicy_PackagePolicies_1_Inputs) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AgentPolicy_PackagePolicies_1_Inputs) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAgentPolicyPackagePolicies1Vars10 returns the union data inside the AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties as a AgentPolicyPackagePolicies1Vars10
func (t AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties) AsAgentPolicyPackagePolicies1Vars10() (AgentPolicyPackagePolicies1Vars10, error) {
	var body AgentPolicyPackagePolicies1Vars10
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies1Vars10 overwrites any union data inside the AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties as the provided AgentPolicyPackagePolicies1Vars10
func (t *AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties) FromAgentPolicyPackagePolicies1Vars10(v AgentPolicyPackagePolicies1Vars10) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies1Vars10 performs a merge with any union data inside the AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties, using the provided AgentPolicyPackagePolicies1Vars10
func (t *AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties) MergeAgentPolicyPackagePolicies1Vars10(v AgentPolicyPackagePolicies1Vars10) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyPackagePolicies1Vars11 returns the union data inside the AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties as a AgentPolicyPackagePolicies1Vars11
func (t AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties) AsAgentPolicyPackagePolicies1Vars11() (AgentPolicyPackagePolicies1Vars11, error) {
	var body AgentPolicyPackagePolicies1Vars11
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies1Vars11 overwrites any union data inside the AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties as the provided AgentPolicyPackagePolicies1Vars11
func (t *AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties) FromAgentPolicyPackagePolicies1Vars11(v AgentPolicyPackagePolicies1Vars11) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies1Vars11 performs a merge with any union data inside the AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties, using the provided AgentPolicyPackagePolicies1Vars11
func (t *AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties) MergeAgentPolicyPackagePolicies1Vars11(v AgentPolicyPackagePolicies1Vars11) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyPackagePolicies1Vars12 returns the union data inside the AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties as a AgentPolicyPackagePolicies1Vars12
func (t AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties) AsAgentPolicyPackagePolicies1Vars12() (AgentPolicyPackagePolicies1Vars12, error) {
	var body AgentPolicyPackagePolicies1Vars12
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies1Vars12 overwrites any union data inside the AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties as the provided AgentPolicyPackagePolicies1Vars12
func (t *AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties) FromAgentPolicyPackagePolicies1Vars12(v AgentPolicyPackagePolicies1Vars12) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies1Vars12 performs a merge with any union data inside the AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties, using the provided AgentPolicyPackagePolicies1Vars12
func (t *AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties) MergeAgentPolicyPackagePolicies1Vars12(v AgentPolicyPackagePolicies1Vars12) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyPackagePolicies1Vars13 returns the union data inside the AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties as a AgentPolicyPackagePolicies1Vars13
func (t AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties) AsAgentPolicyPackagePolicies1Vars13() (AgentPolicyPackagePolicies1Vars13, error) {
	var body AgentPolicyPackagePolicies1Vars13
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies1Vars13 overwrites any union data inside the AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties as the provided AgentPolicyPackagePolicies1Vars13
func (t *AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties) FromAgentPolicyPackagePolicies1Vars13(v AgentPolicyPackagePolicies1Vars13) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies1Vars13 performs a merge with any union data inside the AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties, using the provided AgentPolicyPackagePolicies1Vars13
func (t *AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties) MergeAgentPolicyPackagePolicies1Vars13(v AgentPolicyPackagePolicies1Vars13) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyPackagePolicies1Vars14 returns the union data inside the AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties as a AgentPolicyPackagePolicies1Vars14
func (t AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties) AsAgentPolicyPackagePolicies1Vars14() (AgentPolicyPackagePolicies1Vars14, error) {
	var body AgentPolicyPackagePolicies1Vars14
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies1Vars14 overwrites any union data inside the AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties as the provided AgentPolicyPackagePolicies1Vars14
func (t *AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties) FromAgentPolicyPackagePolicies1Vars14(v AgentPolicyPackagePolicies1Vars14) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies1Vars14 performs a merge with any union data inside the AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties, using the provided AgentPolicyPackagePolicies1Vars14
func (t *AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties) MergeAgentPolicyPackagePolicies1Vars14(v AgentPolicyPackagePolicies1Vars14) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyPackagePolicies1Vars15 returns the union data inside the AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties as a AgentPolicyPackagePolicies1Vars15
func (t AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties) AsAgentPolicyPackagePolicies1Vars15() (AgentPolicyPackagePolicies1Vars15, error) {
	var body AgentPolicyPackagePolicies1Vars15
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies1Vars15 overwrites any union data inside the AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties as the provided AgentPolicyPackagePolicies1Vars15
func (t *AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties) FromAgentPolicyPackagePolicies1Vars15(v AgentPolicyPackagePolicies1Vars15) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies1Vars15 performs a merge with any union data inside the AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties, using the provided AgentPolicyPackagePolicies1Vars15
func (t *AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties) MergeAgentPolicyPackagePolicies1Vars15(v AgentPolicyPackagePolicies1Vars15) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AgentPolicy_PackagePolicies_1_Vars_1_AdditionalProperties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAgentPolicyPackagePolicies1Vars0 returns the union data inside the AgentPolicy_PackagePolicies_1_Vars as a AgentPolicyPackagePolicies1Vars0
func (t AgentPolicy_PackagePolicies_1_Vars) AsAgentPolicyPackagePolicies1Vars0() (AgentPolicyPackagePolicies1Vars0, error) {
	var body AgentPolicyPackagePolicies1Vars0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies1Vars0 overwrites any union data inside the AgentPolicy_PackagePolicies_1_Vars as the provided AgentPolicyPackagePolicies1Vars0
func (t *AgentPolicy_PackagePolicies_1_Vars) FromAgentPolicyPackagePolicies1Vars0(v AgentPolicyPackagePolicies1Vars0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies1Vars0 performs a merge with any union data inside the AgentPolicy_PackagePolicies_1_Vars, using the provided AgentPolicyPackagePolicies1Vars0
func (t *AgentPolicy_PackagePolicies_1_Vars) MergeAgentPolicyPackagePolicies1Vars0(v AgentPolicyPackagePolicies1Vars0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyPackagePolicies1Vars1 returns the union data inside the AgentPolicy_PackagePolicies_1_Vars as a AgentPolicyPackagePolicies1Vars1
func (t AgentPolicy_PackagePolicies_1_Vars) AsAgentPolicyPackagePolicies1Vars1() (AgentPolicyPackagePolicies1Vars1, error) {
	var body AgentPolicyPackagePolicies1Vars1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies1Vars1 overwrites any union data inside the AgentPolicy_PackagePolicies_1_Vars as the provided AgentPolicyPackagePolicies1Vars1
func (t *AgentPolicy_PackagePolicies_1_Vars) FromAgentPolicyPackagePolicies1Vars1(v AgentPolicyPackagePolicies1Vars1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies1Vars1 performs a merge with any union data inside the AgentPolicy_PackagePolicies_1_Vars, using the provided AgentPolicyPackagePolicies1Vars1
func (t *AgentPolicy_PackagePolicies_1_Vars) MergeAgentPolicyPackagePolicies1Vars1(v AgentPolicyPackagePolicies1Vars1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AgentPolicy_PackagePolicies_1_Vars) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AgentPolicy_PackagePolicies_1_Vars) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAgentPolicyPackagePolicies0 returns the union data inside the AgentPolicy_PackagePolicies as a AgentPolicyPackagePolicies0
func (t AgentPolicy_PackagePolicies) AsAgentPolicyPackagePolicies0() (AgentPolicyPackagePolicies0, error) {
	var body AgentPolicyPackagePolicies0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies0 overwrites any union data inside the AgentPolicy_PackagePolicies as the provided AgentPolicyPackagePolicies0
func (t *AgentPolicy_PackagePolicies) FromAgentPolicyPackagePolicies0(v AgentPolicyPackagePolicies0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies0 performs a merge with any union data inside the AgentPolicy_PackagePolicies, using the provided AgentPolicyPackagePolicies0
func (t *AgentPolicy_PackagePolicies) MergeAgentPolicyPackagePolicies0(v AgentPolicyPackagePolicies0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyPackagePolicies1 returns the union data inside the AgentPolicy_PackagePolicies as a AgentPolicyPackagePolicies1
func (t AgentPolicy_PackagePolicies) AsAgentPolicyPackagePolicies1() (AgentPolicyPackagePolicies1, error) {
	var body AgentPolicyPackagePolicies1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies1 overwrites any union data inside the AgentPolicy_PackagePolicies as the provided AgentPolicyPackagePolicies1
func (t *AgentPolicy_PackagePolicies) FromAgentPolicyPackagePolicies1(v AgentPolicyPackagePolicies1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies1 performs a merge with any union data inside the AgentPolicy_PackagePolicies, using the provided AgentPolicyPackagePolicies1
func (t *AgentPolicy_PackagePolicies) MergeAgentPolicyPackagePolicies1(v AgentPolicyPackagePolicies1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AgentPolicy_PackagePolicies) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AgentPolicy_PackagePolicies) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAgentPolicyGlobalDataTagsItemValue0 returns the union data inside the AgentPolicyGlobalDataTagsItem_Value as a AgentPolicyGlobalDataTagsItemValue0
func (t AgentPolicyGlobalDataTagsItem_Value) AsAgentPolicyGlobalDataTagsItemValue0() (AgentPolicyGlobalDataTagsItemValue0, error) {
	var body AgentPolicyGlobalDataTagsItemValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyGlobalDataTagsItemValue0 overwrites any union data inside the AgentPolicyGlobalDataTagsItem_Value as the provided AgentPolicyGlobalDataTagsItemValue0
func (t *AgentPolicyGlobalDataTagsItem_Value) FromAgentPolicyGlobalDataTagsItemValue0(v AgentPolicyGlobalDataTagsItemValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyGlobalDataTagsItemValue0 performs a merge with any union data inside the AgentPolicyGlobalDataTagsItem_Value, using the provided AgentPolicyGlobalDataTagsItemValue0
func (t *AgentPolicyGlobalDataTagsItem_Value) MergeAgentPolicyGlobalDataTagsItemValue0(v AgentPolicyGlobalDataTagsItemValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyGlobalDataTagsItemValue1 returns the union data inside the AgentPolicyGlobalDataTagsItem_Value as a AgentPolicyGlobalDataTagsItemValue1
func (t AgentPolicyGlobalDataTagsItem_Value) AsAgentPolicyGlobalDataTagsItemValue1() (AgentPolicyGlobalDataTagsItemValue1, error) {
	var body AgentPolicyGlobalDataTagsItemValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyGlobalDataTagsItemValue1 overwrites any union data inside the AgentPolicyGlobalDataTagsItem_Value as the provided AgentPolicyGlobalDataTagsItemValue1
func (t *AgentPolicyGlobalDataTagsItem_Value) FromAgentPolicyGlobalDataTagsItemValue1(v AgentPolicyGlobalDataTagsItemValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyGlobalDataTagsItemValue1 performs a merge with any union data inside the AgentPolicyGlobalDataTagsItem_Value, using the provided AgentPolicyGlobalDataTagsItemValue1
func (t *AgentPolicyGlobalDataTagsItem_Value) MergeAgentPolicyGlobalDataTagsItemValue1(v AgentPolicyGlobalDataTagsItemValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AgentPolicyGlobalDataTagsItem_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AgentPolicyGlobalDataTagsItem_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBedrockConfig returns the union data inside the CreateConnectorConfig as a BedrockConfig
func (t CreateConnectorConfig) AsBedrockConfig() (BedrockConfig, error) {
	var body BedrockConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBedrockConfig overwrites any union data inside the CreateConnectorConfig as the provided BedrockConfig
func (t *CreateConnectorConfig) FromBedrockConfig(v BedrockConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBedrockConfig performs a merge with any union data inside the CreateConnectorConfig, using the provided BedrockConfig
func (t *CreateConnectorConfig) MergeBedrockConfig(v BedrockConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCrowdstrikeConfig returns the union data inside the CreateConnectorConfig as a CrowdstrikeConfig
func (t CreateConnectorConfig) AsCrowdstrikeConfig() (CrowdstrikeConfig, error) {
	var body CrowdstrikeConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCrowdstrikeConfig overwrites any union data inside the CreateConnectorConfig as the provided CrowdstrikeConfig
func (t *CreateConnectorConfig) FromCrowdstrikeConfig(v CrowdstrikeConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCrowdstrikeConfig performs a merge with any union data inside the CreateConnectorConfig, using the provided CrowdstrikeConfig
func (t *CreateConnectorConfig) MergeCrowdstrikeConfig(v CrowdstrikeConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsD3securityConfig returns the union data inside the CreateConnectorConfig as a D3securityConfig
func (t CreateConnectorConfig) AsD3securityConfig() (D3securityConfig, error) {
	var body D3securityConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromD3securityConfig overwrites any union data inside the CreateConnectorConfig as the provided D3securityConfig
func (t *CreateConnectorConfig) FromD3securityConfig(v D3securityConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeD3securityConfig performs a merge with any union data inside the CreateConnectorConfig, using the provided D3securityConfig
func (t *CreateConnectorConfig) MergeD3securityConfig(v D3securityConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmailConfig returns the union data inside the CreateConnectorConfig as a EmailConfig
func (t CreateConnectorConfig) AsEmailConfig() (EmailConfig, error) {
	var body EmailConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmailConfig overwrites any union data inside the CreateConnectorConfig as the provided EmailConfig
func (t *CreateConnectorConfig) FromEmailConfig(v EmailConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmailConfig performs a merge with any union data inside the CreateConnectorConfig, using the provided EmailConfig
func (t *CreateConnectorConfig) MergeEmailConfig(v EmailConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGeminiConfig returns the union data inside the CreateConnectorConfig as a GeminiConfig
func (t CreateConnectorConfig) AsGeminiConfig() (GeminiConfig, error) {
	var body GeminiConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeminiConfig overwrites any union data inside the CreateConnectorConfig as the provided GeminiConfig
func (t *CreateConnectorConfig) FromGeminiConfig(v GeminiConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeminiConfig performs a merge with any union data inside the CreateConnectorConfig, using the provided GeminiConfig
func (t *CreateConnectorConfig) MergeGeminiConfig(v GeminiConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResilientConfig returns the union data inside the CreateConnectorConfig as a ResilientConfig
func (t CreateConnectorConfig) AsResilientConfig() (ResilientConfig, error) {
	var body ResilientConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResilientConfig overwrites any union data inside the CreateConnectorConfig as the provided ResilientConfig
func (t *CreateConnectorConfig) FromResilientConfig(v ResilientConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResilientConfig performs a merge with any union data inside the CreateConnectorConfig, using the provided ResilientConfig
func (t *CreateConnectorConfig) MergeResilientConfig(v ResilientConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndexConfig returns the union data inside the CreateConnectorConfig as a IndexConfig
func (t CreateConnectorConfig) AsIndexConfig() (IndexConfig, error) {
	var body IndexConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndexConfig overwrites any union data inside the CreateConnectorConfig as the provided IndexConfig
func (t *CreateConnectorConfig) FromIndexConfig(v IndexConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndexConfig performs a merge with any union data inside the CreateConnectorConfig, using the provided IndexConfig
func (t *CreateConnectorConfig) MergeIndexConfig(v IndexConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJiraConfig returns the union data inside the CreateConnectorConfig as a JiraConfig
func (t CreateConnectorConfig) AsJiraConfig() (JiraConfig, error) {
	var body JiraConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJiraConfig overwrites any union data inside the CreateConnectorConfig as the provided JiraConfig
func (t *CreateConnectorConfig) FromJiraConfig(v JiraConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJiraConfig performs a merge with any union data inside the CreateConnectorConfig, using the provided JiraConfig
func (t *CreateConnectorConfig) MergeJiraConfig(v JiraConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGenaiAzureConfig returns the union data inside the CreateConnectorConfig as a GenaiAzureConfig
func (t CreateConnectorConfig) AsGenaiAzureConfig() (GenaiAzureConfig, error) {
	var body GenaiAzureConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGenaiAzureConfig overwrites any union data inside the CreateConnectorConfig as the provided GenaiAzureConfig
func (t *CreateConnectorConfig) FromGenaiAzureConfig(v GenaiAzureConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGenaiAzureConfig performs a merge with any union data inside the CreateConnectorConfig, using the provided GenaiAzureConfig
func (t *CreateConnectorConfig) MergeGenaiAzureConfig(v GenaiAzureConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGenaiOpenaiConfig returns the union data inside the CreateConnectorConfig as a GenaiOpenaiConfig
func (t CreateConnectorConfig) AsGenaiOpenaiConfig() (GenaiOpenaiConfig, error) {
	var body GenaiOpenaiConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGenaiOpenaiConfig overwrites any union data inside the CreateConnectorConfig as the provided GenaiOpenaiConfig
func (t *CreateConnectorConfig) FromGenaiOpenaiConfig(v GenaiOpenaiConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGenaiOpenaiConfig performs a merge with any union data inside the CreateConnectorConfig, using the provided GenaiOpenaiConfig
func (t *CreateConnectorConfig) MergeGenaiOpenaiConfig(v GenaiOpenaiConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGenaiOpenaiOtherConfig returns the union data inside the CreateConnectorConfig as a GenaiOpenaiOtherConfig
func (t CreateConnectorConfig) AsGenaiOpenaiOtherConfig() (GenaiOpenaiOtherConfig, error) {
	var body GenaiOpenaiOtherConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGenaiOpenaiOtherConfig overwrites any union data inside the CreateConnectorConfig as the provided GenaiOpenaiOtherConfig
func (t *CreateConnectorConfig) FromGenaiOpenaiOtherConfig(v GenaiOpenaiOtherConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGenaiOpenaiOtherConfig performs a merge with any union data inside the CreateConnectorConfig, using the provided GenaiOpenaiOtherConfig
func (t *CreateConnectorConfig) MergeGenaiOpenaiOtherConfig(v GenaiOpenaiOtherConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpsgenieConfig returns the union data inside the CreateConnectorConfig as a OpsgenieConfig
func (t CreateConnectorConfig) AsOpsgenieConfig() (OpsgenieConfig, error) {
	var body OpsgenieConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpsgenieConfig overwrites any union data inside the CreateConnectorConfig as the provided OpsgenieConfig
func (t *CreateConnectorConfig) FromOpsgenieConfig(v OpsgenieConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpsgenieConfig performs a merge with any union data inside the CreateConnectorConfig, using the provided OpsgenieConfig
func (t *CreateConnectorConfig) MergeOpsgenieConfig(v OpsgenieConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPagerdutyConfig returns the union data inside the CreateConnectorConfig as a PagerdutyConfig
func (t CreateConnectorConfig) AsPagerdutyConfig() (PagerdutyConfig, error) {
	var body PagerdutyConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPagerdutyConfig overwrites any union data inside the CreateConnectorConfig as the provided PagerdutyConfig
func (t *CreateConnectorConfig) FromPagerdutyConfig(v PagerdutyConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePagerdutyConfig performs a merge with any union data inside the CreateConnectorConfig, using the provided PagerdutyConfig
func (t *CreateConnectorConfig) MergePagerdutyConfig(v PagerdutyConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSentineloneConfig returns the union data inside the CreateConnectorConfig as a SentineloneConfig
func (t CreateConnectorConfig) AsSentineloneConfig() (SentineloneConfig, error) {
	var body SentineloneConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSentineloneConfig overwrites any union data inside the CreateConnectorConfig as the provided SentineloneConfig
func (t *CreateConnectorConfig) FromSentineloneConfig(v SentineloneConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSentineloneConfig performs a merge with any union data inside the CreateConnectorConfig, using the provided SentineloneConfig
func (t *CreateConnectorConfig) MergeSentineloneConfig(v SentineloneConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsServicenowConfig returns the union data inside the CreateConnectorConfig as a ServicenowConfig
func (t CreateConnectorConfig) AsServicenowConfig() (ServicenowConfig, error) {
	var body ServicenowConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServicenowConfig overwrites any union data inside the CreateConnectorConfig as the provided ServicenowConfig
func (t *CreateConnectorConfig) FromServicenowConfig(v ServicenowConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServicenowConfig performs a merge with any union data inside the CreateConnectorConfig, using the provided ServicenowConfig
func (t *CreateConnectorConfig) MergeServicenowConfig(v ServicenowConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsServicenowItomConfig returns the union data inside the CreateConnectorConfig as a ServicenowItomConfig
func (t CreateConnectorConfig) AsServicenowItomConfig() (ServicenowItomConfig, error) {
	var body ServicenowItomConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServicenowItomConfig overwrites any union data inside the CreateConnectorConfig as the provided ServicenowItomConfig
func (t *CreateConnectorConfig) FromServicenowItomConfig(v ServicenowItomConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServicenowItomConfig performs a merge with any union data inside the CreateConnectorConfig, using the provided ServicenowItomConfig
func (t *CreateConnectorConfig) MergeServicenowItomConfig(v ServicenowItomConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSlackApiConfig returns the union data inside the CreateConnectorConfig as a SlackApiConfig
func (t CreateConnectorConfig) AsSlackApiConfig() (SlackApiConfig, error) {
	var body SlackApiConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSlackApiConfig overwrites any union data inside the CreateConnectorConfig as the provided SlackApiConfig
func (t *CreateConnectorConfig) FromSlackApiConfig(v SlackApiConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSlackApiConfig performs a merge with any union data inside the CreateConnectorConfig, using the provided SlackApiConfig
func (t *CreateConnectorConfig) MergeSlackApiConfig(v SlackApiConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSwimlaneConfig returns the union data inside the CreateConnectorConfig as a SwimlaneConfig
func (t CreateConnectorConfig) AsSwimlaneConfig() (SwimlaneConfig, error) {
	var body SwimlaneConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSwimlaneConfig overwrites any union data inside the CreateConnectorConfig as the provided SwimlaneConfig
func (t *CreateConnectorConfig) FromSwimlaneConfig(v SwimlaneConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSwimlaneConfig performs a merge with any union data inside the CreateConnectorConfig, using the provided SwimlaneConfig
func (t *CreateConnectorConfig) MergeSwimlaneConfig(v SwimlaneConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsThehiveConfig returns the union data inside the CreateConnectorConfig as a ThehiveConfig
func (t CreateConnectorConfig) AsThehiveConfig() (ThehiveConfig, error) {
	var body ThehiveConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromThehiveConfig overwrites any union data inside the CreateConnectorConfig as the provided ThehiveConfig
func (t *CreateConnectorConfig) FromThehiveConfig(v ThehiveConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeThehiveConfig performs a merge with any union data inside the CreateConnectorConfig, using the provided ThehiveConfig
func (t *CreateConnectorConfig) MergeThehiveConfig(v ThehiveConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTinesConfig returns the union data inside the CreateConnectorConfig as a TinesConfig
func (t CreateConnectorConfig) AsTinesConfig() (TinesConfig, error) {
	var body TinesConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTinesConfig overwrites any union data inside the CreateConnectorConfig as the provided TinesConfig
func (t *CreateConnectorConfig) FromTinesConfig(v TinesConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTinesConfig performs a merge with any union data inside the CreateConnectorConfig, using the provided TinesConfig
func (t *CreateConnectorConfig) MergeTinesConfig(v TinesConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTorqConfig returns the union data inside the CreateConnectorConfig as a TorqConfig
func (t CreateConnectorConfig) AsTorqConfig() (TorqConfig, error) {
	var body TorqConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTorqConfig overwrites any union data inside the CreateConnectorConfig as the provided TorqConfig
func (t *CreateConnectorConfig) FromTorqConfig(v TorqConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTorqConfig performs a merge with any union data inside the CreateConnectorConfig, using the provided TorqConfig
func (t *CreateConnectorConfig) MergeTorqConfig(v TorqConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWebhookConfig returns the union data inside the CreateConnectorConfig as a WebhookConfig
func (t CreateConnectorConfig) AsWebhookConfig() (WebhookConfig, error) {
	var body WebhookConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWebhookConfig overwrites any union data inside the CreateConnectorConfig as the provided WebhookConfig
func (t *CreateConnectorConfig) FromWebhookConfig(v WebhookConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWebhookConfig performs a merge with any union data inside the CreateConnectorConfig, using the provided WebhookConfig
func (t *CreateConnectorConfig) MergeWebhookConfig(v WebhookConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCasesWebhookConfig returns the union data inside the CreateConnectorConfig as a CasesWebhookConfig
func (t CreateConnectorConfig) AsCasesWebhookConfig() (CasesWebhookConfig, error) {
	var body CasesWebhookConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCasesWebhookConfig overwrites any union data inside the CreateConnectorConfig as the provided CasesWebhookConfig
func (t *CreateConnectorConfig) FromCasesWebhookConfig(v CasesWebhookConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCasesWebhookConfig performs a merge with any union data inside the CreateConnectorConfig, using the provided CasesWebhookConfig
func (t *CreateConnectorConfig) MergeCasesWebhookConfig(v CasesWebhookConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsXmattersConfig returns the union data inside the CreateConnectorConfig as a XmattersConfig
func (t CreateConnectorConfig) AsXmattersConfig() (XmattersConfig, error) {
	var body XmattersConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromXmattersConfig overwrites any union data inside the CreateConnectorConfig as the provided XmattersConfig
func (t *CreateConnectorConfig) FromXmattersConfig(v XmattersConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeXmattersConfig performs a merge with any union data inside the CreateConnectorConfig, using the provided XmattersConfig
func (t *CreateConnectorConfig) MergeXmattersConfig(v XmattersConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBedrockSecrets returns the union data inside the CreateConnectorSecrets as a BedrockSecrets
func (t CreateConnectorSecrets) AsBedrockSecrets() (BedrockSecrets, error) {
	var body BedrockSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBedrockSecrets overwrites any union data inside the CreateConnectorSecrets as the provided BedrockSecrets
func (t *CreateConnectorSecrets) FromBedrockSecrets(v BedrockSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBedrockSecrets performs a merge with any union data inside the CreateConnectorSecrets, using the provided BedrockSecrets
func (t *CreateConnectorSecrets) MergeBedrockSecrets(v BedrockSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCrowdstrikeSecrets returns the union data inside the CreateConnectorSecrets as a CrowdstrikeSecrets
func (t CreateConnectorSecrets) AsCrowdstrikeSecrets() (CrowdstrikeSecrets, error) {
	var body CrowdstrikeSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCrowdstrikeSecrets overwrites any union data inside the CreateConnectorSecrets as the provided CrowdstrikeSecrets
func (t *CreateConnectorSecrets) FromCrowdstrikeSecrets(v CrowdstrikeSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCrowdstrikeSecrets performs a merge with any union data inside the CreateConnectorSecrets, using the provided CrowdstrikeSecrets
func (t *CreateConnectorSecrets) MergeCrowdstrikeSecrets(v CrowdstrikeSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsD3securitySecrets returns the union data inside the CreateConnectorSecrets as a D3securitySecrets
func (t CreateConnectorSecrets) AsD3securitySecrets() (D3securitySecrets, error) {
	var body D3securitySecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromD3securitySecrets overwrites any union data inside the CreateConnectorSecrets as the provided D3securitySecrets
func (t *CreateConnectorSecrets) FromD3securitySecrets(v D3securitySecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeD3securitySecrets performs a merge with any union data inside the CreateConnectorSecrets, using the provided D3securitySecrets
func (t *CreateConnectorSecrets) MergeD3securitySecrets(v D3securitySecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmailSecrets returns the union data inside the CreateConnectorSecrets as a EmailSecrets
func (t CreateConnectorSecrets) AsEmailSecrets() (EmailSecrets, error) {
	var body EmailSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmailSecrets overwrites any union data inside the CreateConnectorSecrets as the provided EmailSecrets
func (t *CreateConnectorSecrets) FromEmailSecrets(v EmailSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmailSecrets performs a merge with any union data inside the CreateConnectorSecrets, using the provided EmailSecrets
func (t *CreateConnectorSecrets) MergeEmailSecrets(v EmailSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGeminiSecrets returns the union data inside the CreateConnectorSecrets as a GeminiSecrets
func (t CreateConnectorSecrets) AsGeminiSecrets() (GeminiSecrets, error) {
	var body GeminiSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeminiSecrets overwrites any union data inside the CreateConnectorSecrets as the provided GeminiSecrets
func (t *CreateConnectorSecrets) FromGeminiSecrets(v GeminiSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeminiSecrets performs a merge with any union data inside the CreateConnectorSecrets, using the provided GeminiSecrets
func (t *CreateConnectorSecrets) MergeGeminiSecrets(v GeminiSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResilientSecrets returns the union data inside the CreateConnectorSecrets as a ResilientSecrets
func (t CreateConnectorSecrets) AsResilientSecrets() (ResilientSecrets, error) {
	var body ResilientSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResilientSecrets overwrites any union data inside the CreateConnectorSecrets as the provided ResilientSecrets
func (t *CreateConnectorSecrets) FromResilientSecrets(v ResilientSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResilientSecrets performs a merge with any union data inside the CreateConnectorSecrets, using the provided ResilientSecrets
func (t *CreateConnectorSecrets) MergeResilientSecrets(v ResilientSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJiraSecrets returns the union data inside the CreateConnectorSecrets as a JiraSecrets
func (t CreateConnectorSecrets) AsJiraSecrets() (JiraSecrets, error) {
	var body JiraSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJiraSecrets overwrites any union data inside the CreateConnectorSecrets as the provided JiraSecrets
func (t *CreateConnectorSecrets) FromJiraSecrets(v JiraSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJiraSecrets performs a merge with any union data inside the CreateConnectorSecrets, using the provided JiraSecrets
func (t *CreateConnectorSecrets) MergeJiraSecrets(v JiraSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDefenderSecrets returns the union data inside the CreateConnectorSecrets as a DefenderSecrets
func (t CreateConnectorSecrets) AsDefenderSecrets() (DefenderSecrets, error) {
	var body DefenderSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDefenderSecrets overwrites any union data inside the CreateConnectorSecrets as the provided DefenderSecrets
func (t *CreateConnectorSecrets) FromDefenderSecrets(v DefenderSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDefenderSecrets performs a merge with any union data inside the CreateConnectorSecrets, using the provided DefenderSecrets
func (t *CreateConnectorSecrets) MergeDefenderSecrets(v DefenderSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTeamsSecrets returns the union data inside the CreateConnectorSecrets as a TeamsSecrets
func (t CreateConnectorSecrets) AsTeamsSecrets() (TeamsSecrets, error) {
	var body TeamsSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTeamsSecrets overwrites any union data inside the CreateConnectorSecrets as the provided TeamsSecrets
func (t *CreateConnectorSecrets) FromTeamsSecrets(v TeamsSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTeamsSecrets performs a merge with any union data inside the CreateConnectorSecrets, using the provided TeamsSecrets
func (t *CreateConnectorSecrets) MergeTeamsSecrets(v TeamsSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGenaiSecrets returns the union data inside the CreateConnectorSecrets as a GenaiSecrets
func (t CreateConnectorSecrets) AsGenaiSecrets() (GenaiSecrets, error) {
	var body GenaiSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGenaiSecrets overwrites any union data inside the CreateConnectorSecrets as the provided GenaiSecrets
func (t *CreateConnectorSecrets) FromGenaiSecrets(v GenaiSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGenaiSecrets performs a merge with any union data inside the CreateConnectorSecrets, using the provided GenaiSecrets
func (t *CreateConnectorSecrets) MergeGenaiSecrets(v GenaiSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpsgenieSecrets returns the union data inside the CreateConnectorSecrets as a OpsgenieSecrets
func (t CreateConnectorSecrets) AsOpsgenieSecrets() (OpsgenieSecrets, error) {
	var body OpsgenieSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpsgenieSecrets overwrites any union data inside the CreateConnectorSecrets as the provided OpsgenieSecrets
func (t *CreateConnectorSecrets) FromOpsgenieSecrets(v OpsgenieSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpsgenieSecrets performs a merge with any union data inside the CreateConnectorSecrets, using the provided OpsgenieSecrets
func (t *CreateConnectorSecrets) MergeOpsgenieSecrets(v OpsgenieSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPagerdutySecrets returns the union data inside the CreateConnectorSecrets as a PagerdutySecrets
func (t CreateConnectorSecrets) AsPagerdutySecrets() (PagerdutySecrets, error) {
	var body PagerdutySecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPagerdutySecrets overwrites any union data inside the CreateConnectorSecrets as the provided PagerdutySecrets
func (t *CreateConnectorSecrets) FromPagerdutySecrets(v PagerdutySecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePagerdutySecrets performs a merge with any union data inside the CreateConnectorSecrets, using the provided PagerdutySecrets
func (t *CreateConnectorSecrets) MergePagerdutySecrets(v PagerdutySecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSentineloneSecrets returns the union data inside the CreateConnectorSecrets as a SentineloneSecrets
func (t CreateConnectorSecrets) AsSentineloneSecrets() (SentineloneSecrets, error) {
	var body SentineloneSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSentineloneSecrets overwrites any union data inside the CreateConnectorSecrets as the provided SentineloneSecrets
func (t *CreateConnectorSecrets) FromSentineloneSecrets(v SentineloneSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSentineloneSecrets performs a merge with any union data inside the CreateConnectorSecrets, using the provided SentineloneSecrets
func (t *CreateConnectorSecrets) MergeSentineloneSecrets(v SentineloneSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsServicenowSecrets returns the union data inside the CreateConnectorSecrets as a ServicenowSecrets
func (t CreateConnectorSecrets) AsServicenowSecrets() (ServicenowSecrets, error) {
	var body ServicenowSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServicenowSecrets overwrites any union data inside the CreateConnectorSecrets as the provided ServicenowSecrets
func (t *CreateConnectorSecrets) FromServicenowSecrets(v ServicenowSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServicenowSecrets performs a merge with any union data inside the CreateConnectorSecrets, using the provided ServicenowSecrets
func (t *CreateConnectorSecrets) MergeServicenowSecrets(v ServicenowSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSlackApiSecrets returns the union data inside the CreateConnectorSecrets as a SlackApiSecrets
func (t CreateConnectorSecrets) AsSlackApiSecrets() (SlackApiSecrets, error) {
	var body SlackApiSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSlackApiSecrets overwrites any union data inside the CreateConnectorSecrets as the provided SlackApiSecrets
func (t *CreateConnectorSecrets) FromSlackApiSecrets(v SlackApiSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSlackApiSecrets performs a merge with any union data inside the CreateConnectorSecrets, using the provided SlackApiSecrets
func (t *CreateConnectorSecrets) MergeSlackApiSecrets(v SlackApiSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSwimlaneSecrets returns the union data inside the CreateConnectorSecrets as a SwimlaneSecrets
func (t CreateConnectorSecrets) AsSwimlaneSecrets() (SwimlaneSecrets, error) {
	var body SwimlaneSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSwimlaneSecrets overwrites any union data inside the CreateConnectorSecrets as the provided SwimlaneSecrets
func (t *CreateConnectorSecrets) FromSwimlaneSecrets(v SwimlaneSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSwimlaneSecrets performs a merge with any union data inside the CreateConnectorSecrets, using the provided SwimlaneSecrets
func (t *CreateConnectorSecrets) MergeSwimlaneSecrets(v SwimlaneSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsThehiveSecrets returns the union data inside the CreateConnectorSecrets as a ThehiveSecrets
func (t CreateConnectorSecrets) AsThehiveSecrets() (ThehiveSecrets, error) {
	var body ThehiveSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromThehiveSecrets overwrites any union data inside the CreateConnectorSecrets as the provided ThehiveSecrets
func (t *CreateConnectorSecrets) FromThehiveSecrets(v ThehiveSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeThehiveSecrets performs a merge with any union data inside the CreateConnectorSecrets, using the provided ThehiveSecrets
func (t *CreateConnectorSecrets) MergeThehiveSecrets(v ThehiveSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTinesSecrets returns the union data inside the CreateConnectorSecrets as a TinesSecrets
func (t CreateConnectorSecrets) AsTinesSecrets() (TinesSecrets, error) {
	var body TinesSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTinesSecrets overwrites any union data inside the CreateConnectorSecrets as the provided TinesSecrets
func (t *CreateConnectorSecrets) FromTinesSecrets(v TinesSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTinesSecrets performs a merge with any union data inside the CreateConnectorSecrets, using the provided TinesSecrets
func (t *CreateConnectorSecrets) MergeTinesSecrets(v TinesSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTorqSecrets returns the union data inside the CreateConnectorSecrets as a TorqSecrets
func (t CreateConnectorSecrets) AsTorqSecrets() (TorqSecrets, error) {
	var body TorqSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTorqSecrets overwrites any union data inside the CreateConnectorSecrets as the provided TorqSecrets
func (t *CreateConnectorSecrets) FromTorqSecrets(v TorqSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTorqSecrets performs a merge with any union data inside the CreateConnectorSecrets, using the provided TorqSecrets
func (t *CreateConnectorSecrets) MergeTorqSecrets(v TorqSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWebhookSecrets returns the union data inside the CreateConnectorSecrets as a WebhookSecrets
func (t CreateConnectorSecrets) AsWebhookSecrets() (WebhookSecrets, error) {
	var body WebhookSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWebhookSecrets overwrites any union data inside the CreateConnectorSecrets as the provided WebhookSecrets
func (t *CreateConnectorSecrets) FromWebhookSecrets(v WebhookSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWebhookSecrets performs a merge with any union data inside the CreateConnectorSecrets, using the provided WebhookSecrets
func (t *CreateConnectorSecrets) MergeWebhookSecrets(v WebhookSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCasesWebhookSecrets returns the union data inside the CreateConnectorSecrets as a CasesWebhookSecrets
func (t CreateConnectorSecrets) AsCasesWebhookSecrets() (CasesWebhookSecrets, error) {
	var body CasesWebhookSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCasesWebhookSecrets overwrites any union data inside the CreateConnectorSecrets as the provided CasesWebhookSecrets
func (t *CreateConnectorSecrets) FromCasesWebhookSecrets(v CasesWebhookSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCasesWebhookSecrets performs a merge with any union data inside the CreateConnectorSecrets, using the provided CasesWebhookSecrets
func (t *CreateConnectorSecrets) MergeCasesWebhookSecrets(v CasesWebhookSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsXmattersSecrets returns the union data inside the CreateConnectorSecrets as a XmattersSecrets
func (t CreateConnectorSecrets) AsXmattersSecrets() (XmattersSecrets, error) {
	var body XmattersSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromXmattersSecrets overwrites any union data inside the CreateConnectorSecrets as the provided XmattersSecrets
func (t *CreateConnectorSecrets) FromXmattersSecrets(v XmattersSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeXmattersSecrets performs a merge with any union data inside the CreateConnectorSecrets, using the provided XmattersSecrets
func (t *CreateConnectorSecrets) MergeXmattersSecrets(v XmattersSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCreateParamResponse0 returns the union data inside the CreateParamResponse as a CreateParamResponse0
func (t CreateParamResponse) AsCreateParamResponse0() (CreateParamResponse0, error) {
	var body CreateParamResponse0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCreateParamResponse0 overwrites any union data inside the CreateParamResponse as the provided CreateParamResponse0
func (t *CreateParamResponse) FromCreateParamResponse0(v CreateParamResponse0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCreateParamResponse0 performs a merge with any union data inside the CreateParamResponse, using the provided CreateParamResponse0
func (t *CreateParamResponse) MergeCreateParamResponse0(v CreateParamResponse0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSyntheticsPostParameterResponse returns the union data inside the CreateParamResponse as a SyntheticsPostParameterResponse
func (t CreateParamResponse) AsSyntheticsPostParameterResponse() (SyntheticsPostParameterResponse, error) {
	var body SyntheticsPostParameterResponse
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSyntheticsPostParameterResponse overwrites any union data inside the CreateParamResponse as the provided SyntheticsPostParameterResponse
func (t *CreateParamResponse) FromSyntheticsPostParameterResponse(v SyntheticsPostParameterResponse) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSyntheticsPostParameterResponse performs a merge with any union data inside the CreateParamResponse, using the provided SyntheticsPostParameterResponse
func (t *CreateParamResponse) MergeSyntheticsPostParameterResponse(v SyntheticsPostParameterResponse) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t CreateParamResponse) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *CreateParamResponse) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNewOutputElasticsearchSecretsSslKey0 returns the union data inside the NewOutputElasticsearch_Secrets_Ssl_Key as a NewOutputElasticsearchSecretsSslKey0
func (t NewOutputElasticsearch_Secrets_Ssl_Key) AsNewOutputElasticsearchSecretsSslKey0() (NewOutputElasticsearchSecretsSslKey0, error) {
	var body NewOutputElasticsearchSecretsSslKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputElasticsearchSecretsSslKey0 overwrites any union data inside the NewOutputElasticsearch_Secrets_Ssl_Key as the provided NewOutputElasticsearchSecretsSslKey0
func (t *NewOutputElasticsearch_Secrets_Ssl_Key) FromNewOutputElasticsearchSecretsSslKey0(v NewOutputElasticsearchSecretsSslKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputElasticsearchSecretsSslKey0 performs a merge with any union data inside the NewOutputElasticsearch_Secrets_Ssl_Key, using the provided NewOutputElasticsearchSecretsSslKey0
func (t *NewOutputElasticsearch_Secrets_Ssl_Key) MergeNewOutputElasticsearchSecretsSslKey0(v NewOutputElasticsearchSecretsSslKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNewOutputElasticsearchSecretsSslKey1 returns the union data inside the NewOutputElasticsearch_Secrets_Ssl_Key as a NewOutputElasticsearchSecretsSslKey1
func (t NewOutputElasticsearch_Secrets_Ssl_Key) AsNewOutputElasticsearchSecretsSslKey1() (NewOutputElasticsearchSecretsSslKey1, error) {
	var body NewOutputElasticsearchSecretsSslKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputElasticsearchSecretsSslKey1 overwrites any union data inside the NewOutputElasticsearch_Secrets_Ssl_Key as the provided NewOutputElasticsearchSecretsSslKey1
func (t *NewOutputElasticsearch_Secrets_Ssl_Key) FromNewOutputElasticsearchSecretsSslKey1(v NewOutputElasticsearchSecretsSslKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputElasticsearchSecretsSslKey1 performs a merge with any union data inside the NewOutputElasticsearch_Secrets_Ssl_Key, using the provided NewOutputElasticsearchSecretsSslKey1
func (t *NewOutputElasticsearch_Secrets_Ssl_Key) MergeNewOutputElasticsearchSecretsSslKey1(v NewOutputElasticsearchSecretsSslKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NewOutputElasticsearch_Secrets_Ssl_Key) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NewOutputElasticsearch_Secrets_Ssl_Key) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNewOutputKafkaSecretsPassword0 returns the union data inside the NewOutputKafka_Secrets_Password as a NewOutputKafkaSecretsPassword0
func (t NewOutputKafka_Secrets_Password) AsNewOutputKafkaSecretsPassword0() (NewOutputKafkaSecretsPassword0, error) {
	var body NewOutputKafkaSecretsPassword0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputKafkaSecretsPassword0 overwrites any union data inside the NewOutputKafka_Secrets_Password as the provided NewOutputKafkaSecretsPassword0
func (t *NewOutputKafka_Secrets_Password) FromNewOutputKafkaSecretsPassword0(v NewOutputKafkaSecretsPassword0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputKafkaSecretsPassword0 performs a merge with any union data inside the NewOutputKafka_Secrets_Password, using the provided NewOutputKafkaSecretsPassword0
func (t *NewOutputKafka_Secrets_Password) MergeNewOutputKafkaSecretsPassword0(v NewOutputKafkaSecretsPassword0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNewOutputKafkaSecretsPassword1 returns the union data inside the NewOutputKafka_Secrets_Password as a NewOutputKafkaSecretsPassword1
func (t NewOutputKafka_Secrets_Password) AsNewOutputKafkaSecretsPassword1() (NewOutputKafkaSecretsPassword1, error) {
	var body NewOutputKafkaSecretsPassword1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputKafkaSecretsPassword1 overwrites any union data inside the NewOutputKafka_Secrets_Password as the provided NewOutputKafkaSecretsPassword1
func (t *NewOutputKafka_Secrets_Password) FromNewOutputKafkaSecretsPassword1(v NewOutputKafkaSecretsPassword1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputKafkaSecretsPassword1 performs a merge with any union data inside the NewOutputKafka_Secrets_Password, using the provided NewOutputKafkaSecretsPassword1
func (t *NewOutputKafka_Secrets_Password) MergeNewOutputKafkaSecretsPassword1(v NewOutputKafkaSecretsPassword1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NewOutputKafka_Secrets_Password) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NewOutputKafka_Secrets_Password) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNewOutputKafkaSecretsSslKey0 returns the union data inside the NewOutputKafka_Secrets_Ssl_Key as a NewOutputKafkaSecretsSslKey0
func (t NewOutputKafka_Secrets_Ssl_Key) AsNewOutputKafkaSecretsSslKey0() (NewOutputKafkaSecretsSslKey0, error) {
	var body NewOutputKafkaSecretsSslKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputKafkaSecretsSslKey0 overwrites any union data inside the NewOutputKafka_Secrets_Ssl_Key as the provided NewOutputKafkaSecretsSslKey0
func (t *NewOutputKafka_Secrets_Ssl_Key) FromNewOutputKafkaSecretsSslKey0(v NewOutputKafkaSecretsSslKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputKafkaSecretsSslKey0 performs a merge with any union data inside the NewOutputKafka_Secrets_Ssl_Key, using the provided NewOutputKafkaSecretsSslKey0
func (t *NewOutputKafka_Secrets_Ssl_Key) MergeNewOutputKafkaSecretsSslKey0(v NewOutputKafkaSecretsSslKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNewOutputKafkaSecretsSslKey1 returns the union data inside the NewOutputKafka_Secrets_Ssl_Key as a NewOutputKafkaSecretsSslKey1
func (t NewOutputKafka_Secrets_Ssl_Key) AsNewOutputKafkaSecretsSslKey1() (NewOutputKafkaSecretsSslKey1, error) {
	var body NewOutputKafkaSecretsSslKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputKafkaSecretsSslKey1 overwrites any union data inside the NewOutputKafka_Secrets_Ssl_Key as the provided NewOutputKafkaSecretsSslKey1
func (t *NewOutputKafka_Secrets_Ssl_Key) FromNewOutputKafkaSecretsSslKey1(v NewOutputKafkaSecretsSslKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputKafkaSecretsSslKey1 performs a merge with any union data inside the NewOutputKafka_Secrets_Ssl_Key, using the provided NewOutputKafkaSecretsSslKey1
func (t *NewOutputKafka_Secrets_Ssl_Key) MergeNewOutputKafkaSecretsSslKey1(v NewOutputKafkaSecretsSslKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NewOutputKafka_Secrets_Ssl_Key) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NewOutputKafka_Secrets_Ssl_Key) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNewOutputLogstashSecretsSslKey0 returns the union data inside the NewOutputLogstash_Secrets_Ssl_Key as a NewOutputLogstashSecretsSslKey0
func (t NewOutputLogstash_Secrets_Ssl_Key) AsNewOutputLogstashSecretsSslKey0() (NewOutputLogstashSecretsSslKey0, error) {
	var body NewOutputLogstashSecretsSslKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputLogstashSecretsSslKey0 overwrites any union data inside the NewOutputLogstash_Secrets_Ssl_Key as the provided NewOutputLogstashSecretsSslKey0
func (t *NewOutputLogstash_Secrets_Ssl_Key) FromNewOutputLogstashSecretsSslKey0(v NewOutputLogstashSecretsSslKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputLogstashSecretsSslKey0 performs a merge with any union data inside the NewOutputLogstash_Secrets_Ssl_Key, using the provided NewOutputLogstashSecretsSslKey0
func (t *NewOutputLogstash_Secrets_Ssl_Key) MergeNewOutputLogstashSecretsSslKey0(v NewOutputLogstashSecretsSslKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNewOutputLogstashSecretsSslKey1 returns the union data inside the NewOutputLogstash_Secrets_Ssl_Key as a NewOutputLogstashSecretsSslKey1
func (t NewOutputLogstash_Secrets_Ssl_Key) AsNewOutputLogstashSecretsSslKey1() (NewOutputLogstashSecretsSslKey1, error) {
	var body NewOutputLogstashSecretsSslKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputLogstashSecretsSslKey1 overwrites any union data inside the NewOutputLogstash_Secrets_Ssl_Key as the provided NewOutputLogstashSecretsSslKey1
func (t *NewOutputLogstash_Secrets_Ssl_Key) FromNewOutputLogstashSecretsSslKey1(v NewOutputLogstashSecretsSslKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputLogstashSecretsSslKey1 performs a merge with any union data inside the NewOutputLogstash_Secrets_Ssl_Key, using the provided NewOutputLogstashSecretsSslKey1
func (t *NewOutputLogstash_Secrets_Ssl_Key) MergeNewOutputLogstashSecretsSslKey1(v NewOutputLogstashSecretsSslKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NewOutputLogstash_Secrets_Ssl_Key) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NewOutputLogstash_Secrets_Ssl_Key) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNewOutputRemoteElasticsearchSecretsServiceToken0 returns the union data inside the NewOutputRemoteElasticsearch_Secrets_ServiceToken as a NewOutputRemoteElasticsearchSecretsServiceToken0
func (t NewOutputRemoteElasticsearch_Secrets_ServiceToken) AsNewOutputRemoteElasticsearchSecretsServiceToken0() (NewOutputRemoteElasticsearchSecretsServiceToken0, error) {
	var body NewOutputRemoteElasticsearchSecretsServiceToken0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputRemoteElasticsearchSecretsServiceToken0 overwrites any union data inside the NewOutputRemoteElasticsearch_Secrets_ServiceToken as the provided NewOutputRemoteElasticsearchSecretsServiceToken0
func (t *NewOutputRemoteElasticsearch_Secrets_ServiceToken) FromNewOutputRemoteElasticsearchSecretsServiceToken0(v NewOutputRemoteElasticsearchSecretsServiceToken0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputRemoteElasticsearchSecretsServiceToken0 performs a merge with any union data inside the NewOutputRemoteElasticsearch_Secrets_ServiceToken, using the provided NewOutputRemoteElasticsearchSecretsServiceToken0
func (t *NewOutputRemoteElasticsearch_Secrets_ServiceToken) MergeNewOutputRemoteElasticsearchSecretsServiceToken0(v NewOutputRemoteElasticsearchSecretsServiceToken0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNewOutputRemoteElasticsearchSecretsServiceToken1 returns the union data inside the NewOutputRemoteElasticsearch_Secrets_ServiceToken as a NewOutputRemoteElasticsearchSecretsServiceToken1
func (t NewOutputRemoteElasticsearch_Secrets_ServiceToken) AsNewOutputRemoteElasticsearchSecretsServiceToken1() (NewOutputRemoteElasticsearchSecretsServiceToken1, error) {
	var body NewOutputRemoteElasticsearchSecretsServiceToken1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputRemoteElasticsearchSecretsServiceToken1 overwrites any union data inside the NewOutputRemoteElasticsearch_Secrets_ServiceToken as the provided NewOutputRemoteElasticsearchSecretsServiceToken1
func (t *NewOutputRemoteElasticsearch_Secrets_ServiceToken) FromNewOutputRemoteElasticsearchSecretsServiceToken1(v NewOutputRemoteElasticsearchSecretsServiceToken1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputRemoteElasticsearchSecretsServiceToken1 performs a merge with any union data inside the NewOutputRemoteElasticsearch_Secrets_ServiceToken, using the provided NewOutputRemoteElasticsearchSecretsServiceToken1
func (t *NewOutputRemoteElasticsearch_Secrets_ServiceToken) MergeNewOutputRemoteElasticsearchSecretsServiceToken1(v NewOutputRemoteElasticsearchSecretsServiceToken1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NewOutputRemoteElasticsearch_Secrets_ServiceToken) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NewOutputRemoteElasticsearch_Secrets_ServiceToken) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNewOutputRemoteElasticsearchSecretsSslKey0 returns the union data inside the NewOutputRemoteElasticsearch_Secrets_Ssl_Key as a NewOutputRemoteElasticsearchSecretsSslKey0
func (t NewOutputRemoteElasticsearch_Secrets_Ssl_Key) AsNewOutputRemoteElasticsearchSecretsSslKey0() (NewOutputRemoteElasticsearchSecretsSslKey0, error) {
	var body NewOutputRemoteElasticsearchSecretsSslKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputRemoteElasticsearchSecretsSslKey0 overwrites any union data inside the NewOutputRemoteElasticsearch_Secrets_Ssl_Key as the provided NewOutputRemoteElasticsearchSecretsSslKey0
func (t *NewOutputRemoteElasticsearch_Secrets_Ssl_Key) FromNewOutputRemoteElasticsearchSecretsSslKey0(v NewOutputRemoteElasticsearchSecretsSslKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputRemoteElasticsearchSecretsSslKey0 performs a merge with any union data inside the NewOutputRemoteElasticsearch_Secrets_Ssl_Key, using the provided NewOutputRemoteElasticsearchSecretsSslKey0
func (t *NewOutputRemoteElasticsearch_Secrets_Ssl_Key) MergeNewOutputRemoteElasticsearchSecretsSslKey0(v NewOutputRemoteElasticsearchSecretsSslKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNewOutputRemoteElasticsearchSecretsSslKey1 returns the union data inside the NewOutputRemoteElasticsearch_Secrets_Ssl_Key as a NewOutputRemoteElasticsearchSecretsSslKey1
func (t NewOutputRemoteElasticsearch_Secrets_Ssl_Key) AsNewOutputRemoteElasticsearchSecretsSslKey1() (NewOutputRemoteElasticsearchSecretsSslKey1, error) {
	var body NewOutputRemoteElasticsearchSecretsSslKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputRemoteElasticsearchSecretsSslKey1 overwrites any union data inside the NewOutputRemoteElasticsearch_Secrets_Ssl_Key as the provided NewOutputRemoteElasticsearchSecretsSslKey1
func (t *NewOutputRemoteElasticsearch_Secrets_Ssl_Key) FromNewOutputRemoteElasticsearchSecretsSslKey1(v NewOutputRemoteElasticsearchSecretsSslKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputRemoteElasticsearchSecretsSslKey1 performs a merge with any union data inside the NewOutputRemoteElasticsearch_Secrets_Ssl_Key, using the provided NewOutputRemoteElasticsearchSecretsSslKey1
func (t *NewOutputRemoteElasticsearch_Secrets_Ssl_Key) MergeNewOutputRemoteElasticsearchSecretsSslKey1(v NewOutputRemoteElasticsearchSecretsSslKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NewOutputRemoteElasticsearch_Secrets_Ssl_Key) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NewOutputRemoteElasticsearch_Secrets_Ssl_Key) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNewOutputElasticsearch returns the union data inside the NewOutputUnion as a NewOutputElasticsearch
func (t NewOutputUnion) AsNewOutputElasticsearch() (NewOutputElasticsearch, error) {
	var body NewOutputElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputElasticsearch overwrites any union data inside the NewOutputUnion as the provided NewOutputElasticsearch
func (t *NewOutputUnion) FromNewOutputElasticsearch(v NewOutputElasticsearch) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputElasticsearch performs a merge with any union data inside the NewOutputUnion, using the provided NewOutputElasticsearch
func (t *NewOutputUnion) MergeNewOutputElasticsearch(v NewOutputElasticsearch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNewOutputRemoteElasticsearch returns the union data inside the NewOutputUnion as a NewOutputRemoteElasticsearch
func (t NewOutputUnion) AsNewOutputRemoteElasticsearch() (NewOutputRemoteElasticsearch, error) {
	var body NewOutputRemoteElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputRemoteElasticsearch overwrites any union data inside the NewOutputUnion as the provided NewOutputRemoteElasticsearch
func (t *NewOutputUnion) FromNewOutputRemoteElasticsearch(v NewOutputRemoteElasticsearch) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputRemoteElasticsearch performs a merge with any union data inside the NewOutputUnion, using the provided NewOutputRemoteElasticsearch
func (t *NewOutputUnion) MergeNewOutputRemoteElasticsearch(v NewOutputRemoteElasticsearch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNewOutputLogstash returns the union data inside the NewOutputUnion as a NewOutputLogstash
func (t NewOutputUnion) AsNewOutputLogstash() (NewOutputLogstash, error) {
	var body NewOutputLogstash
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputLogstash overwrites any union data inside the NewOutputUnion as the provided NewOutputLogstash
func (t *NewOutputUnion) FromNewOutputLogstash(v NewOutputLogstash) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputLogstash performs a merge with any union data inside the NewOutputUnion, using the provided NewOutputLogstash
func (t *NewOutputUnion) MergeNewOutputLogstash(v NewOutputLogstash) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNewOutputKafka returns the union data inside the NewOutputUnion as a NewOutputKafka
func (t NewOutputUnion) AsNewOutputKafka() (NewOutputKafka, error) {
	var body NewOutputKafka
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputKafka overwrites any union data inside the NewOutputUnion as the provided NewOutputKafka
func (t *NewOutputUnion) FromNewOutputKafka(v NewOutputKafka) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputKafka performs a merge with any union data inside the NewOutputUnion, using the provided NewOutputKafka
func (t *NewOutputUnion) MergeNewOutputKafka(v NewOutputKafka) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NewOutputUnion) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NewOutputUnion) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOutputElasticsearchSecretsSslKey0 returns the union data inside the OutputElasticsearch_Secrets_Ssl_Key as a OutputElasticsearchSecretsSslKey0
func (t OutputElasticsearch_Secrets_Ssl_Key) AsOutputElasticsearchSecretsSslKey0() (OutputElasticsearchSecretsSslKey0, error) {
	var body OutputElasticsearchSecretsSslKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputElasticsearchSecretsSslKey0 overwrites any union data inside the OutputElasticsearch_Secrets_Ssl_Key as the provided OutputElasticsearchSecretsSslKey0
func (t *OutputElasticsearch_Secrets_Ssl_Key) FromOutputElasticsearchSecretsSslKey0(v OutputElasticsearchSecretsSslKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputElasticsearchSecretsSslKey0 performs a merge with any union data inside the OutputElasticsearch_Secrets_Ssl_Key, using the provided OutputElasticsearchSecretsSslKey0
func (t *OutputElasticsearch_Secrets_Ssl_Key) MergeOutputElasticsearchSecretsSslKey0(v OutputElasticsearchSecretsSslKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputElasticsearchSecretsSslKey1 returns the union data inside the OutputElasticsearch_Secrets_Ssl_Key as a OutputElasticsearchSecretsSslKey1
func (t OutputElasticsearch_Secrets_Ssl_Key) AsOutputElasticsearchSecretsSslKey1() (OutputElasticsearchSecretsSslKey1, error) {
	var body OutputElasticsearchSecretsSslKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputElasticsearchSecretsSslKey1 overwrites any union data inside the OutputElasticsearch_Secrets_Ssl_Key as the provided OutputElasticsearchSecretsSslKey1
func (t *OutputElasticsearch_Secrets_Ssl_Key) FromOutputElasticsearchSecretsSslKey1(v OutputElasticsearchSecretsSslKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputElasticsearchSecretsSslKey1 performs a merge with any union data inside the OutputElasticsearch_Secrets_Ssl_Key, using the provided OutputElasticsearchSecretsSslKey1
func (t *OutputElasticsearch_Secrets_Ssl_Key) MergeOutputElasticsearchSecretsSslKey1(v OutputElasticsearchSecretsSslKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OutputElasticsearch_Secrets_Ssl_Key) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OutputElasticsearch_Secrets_Ssl_Key) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOutputKafkaSecretsPassword0 returns the union data inside the OutputKafka_Secrets_Password as a OutputKafkaSecretsPassword0
func (t OutputKafka_Secrets_Password) AsOutputKafkaSecretsPassword0() (OutputKafkaSecretsPassword0, error) {
	var body OutputKafkaSecretsPassword0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputKafkaSecretsPassword0 overwrites any union data inside the OutputKafka_Secrets_Password as the provided OutputKafkaSecretsPassword0
func (t *OutputKafka_Secrets_Password) FromOutputKafkaSecretsPassword0(v OutputKafkaSecretsPassword0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputKafkaSecretsPassword0 performs a merge with any union data inside the OutputKafka_Secrets_Password, using the provided OutputKafkaSecretsPassword0
func (t *OutputKafka_Secrets_Password) MergeOutputKafkaSecretsPassword0(v OutputKafkaSecretsPassword0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputKafkaSecretsPassword1 returns the union data inside the OutputKafka_Secrets_Password as a OutputKafkaSecretsPassword1
func (t OutputKafka_Secrets_Password) AsOutputKafkaSecretsPassword1() (OutputKafkaSecretsPassword1, error) {
	var body OutputKafkaSecretsPassword1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputKafkaSecretsPassword1 overwrites any union data inside the OutputKafka_Secrets_Password as the provided OutputKafkaSecretsPassword1
func (t *OutputKafka_Secrets_Password) FromOutputKafkaSecretsPassword1(v OutputKafkaSecretsPassword1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputKafkaSecretsPassword1 performs a merge with any union data inside the OutputKafka_Secrets_Password, using the provided OutputKafkaSecretsPassword1
func (t *OutputKafka_Secrets_Password) MergeOutputKafkaSecretsPassword1(v OutputKafkaSecretsPassword1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OutputKafka_Secrets_Password) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OutputKafka_Secrets_Password) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOutputKafkaSecretsSslKey0 returns the union data inside the OutputKafka_Secrets_Ssl_Key as a OutputKafkaSecretsSslKey0
func (t OutputKafka_Secrets_Ssl_Key) AsOutputKafkaSecretsSslKey0() (OutputKafkaSecretsSslKey0, error) {
	var body OutputKafkaSecretsSslKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputKafkaSecretsSslKey0 overwrites any union data inside the OutputKafka_Secrets_Ssl_Key as the provided OutputKafkaSecretsSslKey0
func (t *OutputKafka_Secrets_Ssl_Key) FromOutputKafkaSecretsSslKey0(v OutputKafkaSecretsSslKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputKafkaSecretsSslKey0 performs a merge with any union data inside the OutputKafka_Secrets_Ssl_Key, using the provided OutputKafkaSecretsSslKey0
func (t *OutputKafka_Secrets_Ssl_Key) MergeOutputKafkaSecretsSslKey0(v OutputKafkaSecretsSslKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputKafkaSecretsSslKey1 returns the union data inside the OutputKafka_Secrets_Ssl_Key as a OutputKafkaSecretsSslKey1
func (t OutputKafka_Secrets_Ssl_Key) AsOutputKafkaSecretsSslKey1() (OutputKafkaSecretsSslKey1, error) {
	var body OutputKafkaSecretsSslKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputKafkaSecretsSslKey1 overwrites any union data inside the OutputKafka_Secrets_Ssl_Key as the provided OutputKafkaSecretsSslKey1
func (t *OutputKafka_Secrets_Ssl_Key) FromOutputKafkaSecretsSslKey1(v OutputKafkaSecretsSslKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputKafkaSecretsSslKey1 performs a merge with any union data inside the OutputKafka_Secrets_Ssl_Key, using the provided OutputKafkaSecretsSslKey1
func (t *OutputKafka_Secrets_Ssl_Key) MergeOutputKafkaSecretsSslKey1(v OutputKafkaSecretsSslKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OutputKafka_Secrets_Ssl_Key) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OutputKafka_Secrets_Ssl_Key) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOutputLogstashSecretsSslKey0 returns the union data inside the OutputLogstash_Secrets_Ssl_Key as a OutputLogstashSecretsSslKey0
func (t OutputLogstash_Secrets_Ssl_Key) AsOutputLogstashSecretsSslKey0() (OutputLogstashSecretsSslKey0, error) {
	var body OutputLogstashSecretsSslKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputLogstashSecretsSslKey0 overwrites any union data inside the OutputLogstash_Secrets_Ssl_Key as the provided OutputLogstashSecretsSslKey0
func (t *OutputLogstash_Secrets_Ssl_Key) FromOutputLogstashSecretsSslKey0(v OutputLogstashSecretsSslKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputLogstashSecretsSslKey0 performs a merge with any union data inside the OutputLogstash_Secrets_Ssl_Key, using the provided OutputLogstashSecretsSslKey0
func (t *OutputLogstash_Secrets_Ssl_Key) MergeOutputLogstashSecretsSslKey0(v OutputLogstashSecretsSslKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputLogstashSecretsSslKey1 returns the union data inside the OutputLogstash_Secrets_Ssl_Key as a OutputLogstashSecretsSslKey1
func (t OutputLogstash_Secrets_Ssl_Key) AsOutputLogstashSecretsSslKey1() (OutputLogstashSecretsSslKey1, error) {
	var body OutputLogstashSecretsSslKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputLogstashSecretsSslKey1 overwrites any union data inside the OutputLogstash_Secrets_Ssl_Key as the provided OutputLogstashSecretsSslKey1
func (t *OutputLogstash_Secrets_Ssl_Key) FromOutputLogstashSecretsSslKey1(v OutputLogstashSecretsSslKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputLogstashSecretsSslKey1 performs a merge with any union data inside the OutputLogstash_Secrets_Ssl_Key, using the provided OutputLogstashSecretsSslKey1
func (t *OutputLogstash_Secrets_Ssl_Key) MergeOutputLogstashSecretsSslKey1(v OutputLogstashSecretsSslKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OutputLogstash_Secrets_Ssl_Key) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OutputLogstash_Secrets_Ssl_Key) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOutputRemoteElasticsearchSecretsServiceToken0 returns the union data inside the OutputRemoteElasticsearch_Secrets_ServiceToken as a OutputRemoteElasticsearchSecretsServiceToken0
func (t OutputRemoteElasticsearch_Secrets_ServiceToken) AsOutputRemoteElasticsearchSecretsServiceToken0() (OutputRemoteElasticsearchSecretsServiceToken0, error) {
	var body OutputRemoteElasticsearchSecretsServiceToken0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputRemoteElasticsearchSecretsServiceToken0 overwrites any union data inside the OutputRemoteElasticsearch_Secrets_ServiceToken as the provided OutputRemoteElasticsearchSecretsServiceToken0
func (t *OutputRemoteElasticsearch_Secrets_ServiceToken) FromOutputRemoteElasticsearchSecretsServiceToken0(v OutputRemoteElasticsearchSecretsServiceToken0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputRemoteElasticsearchSecretsServiceToken0 performs a merge with any union data inside the OutputRemoteElasticsearch_Secrets_ServiceToken, using the provided OutputRemoteElasticsearchSecretsServiceToken0
func (t *OutputRemoteElasticsearch_Secrets_ServiceToken) MergeOutputRemoteElasticsearchSecretsServiceToken0(v OutputRemoteElasticsearchSecretsServiceToken0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputRemoteElasticsearchSecretsServiceToken1 returns the union data inside the OutputRemoteElasticsearch_Secrets_ServiceToken as a OutputRemoteElasticsearchSecretsServiceToken1
func (t OutputRemoteElasticsearch_Secrets_ServiceToken) AsOutputRemoteElasticsearchSecretsServiceToken1() (OutputRemoteElasticsearchSecretsServiceToken1, error) {
	var body OutputRemoteElasticsearchSecretsServiceToken1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputRemoteElasticsearchSecretsServiceToken1 overwrites any union data inside the OutputRemoteElasticsearch_Secrets_ServiceToken as the provided OutputRemoteElasticsearchSecretsServiceToken1
func (t *OutputRemoteElasticsearch_Secrets_ServiceToken) FromOutputRemoteElasticsearchSecretsServiceToken1(v OutputRemoteElasticsearchSecretsServiceToken1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputRemoteElasticsearchSecretsServiceToken1 performs a merge with any union data inside the OutputRemoteElasticsearch_Secrets_ServiceToken, using the provided OutputRemoteElasticsearchSecretsServiceToken1
func (t *OutputRemoteElasticsearch_Secrets_ServiceToken) MergeOutputRemoteElasticsearchSecretsServiceToken1(v OutputRemoteElasticsearchSecretsServiceToken1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OutputRemoteElasticsearch_Secrets_ServiceToken) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OutputRemoteElasticsearch_Secrets_ServiceToken) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOutputRemoteElasticsearchSecretsSslKey0 returns the union data inside the OutputRemoteElasticsearch_Secrets_Ssl_Key as a OutputRemoteElasticsearchSecretsSslKey0
func (t OutputRemoteElasticsearch_Secrets_Ssl_Key) AsOutputRemoteElasticsearchSecretsSslKey0() (OutputRemoteElasticsearchSecretsSslKey0, error) {
	var body OutputRemoteElasticsearchSecretsSslKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputRemoteElasticsearchSecretsSslKey0 overwrites any union data inside the OutputRemoteElasticsearch_Secrets_Ssl_Key as the provided OutputRemoteElasticsearchSecretsSslKey0
func (t *OutputRemoteElasticsearch_Secrets_Ssl_Key) FromOutputRemoteElasticsearchSecretsSslKey0(v OutputRemoteElasticsearchSecretsSslKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputRemoteElasticsearchSecretsSslKey0 performs a merge with any union data inside the OutputRemoteElasticsearch_Secrets_Ssl_Key, using the provided OutputRemoteElasticsearchSecretsSslKey0
func (t *OutputRemoteElasticsearch_Secrets_Ssl_Key) MergeOutputRemoteElasticsearchSecretsSslKey0(v OutputRemoteElasticsearchSecretsSslKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputRemoteElasticsearchSecretsSslKey1 returns the union data inside the OutputRemoteElasticsearch_Secrets_Ssl_Key as a OutputRemoteElasticsearchSecretsSslKey1
func (t OutputRemoteElasticsearch_Secrets_Ssl_Key) AsOutputRemoteElasticsearchSecretsSslKey1() (OutputRemoteElasticsearchSecretsSslKey1, error) {
	var body OutputRemoteElasticsearchSecretsSslKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputRemoteElasticsearchSecretsSslKey1 overwrites any union data inside the OutputRemoteElasticsearch_Secrets_Ssl_Key as the provided OutputRemoteElasticsearchSecretsSslKey1
func (t *OutputRemoteElasticsearch_Secrets_Ssl_Key) FromOutputRemoteElasticsearchSecretsSslKey1(v OutputRemoteElasticsearchSecretsSslKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputRemoteElasticsearchSecretsSslKey1 performs a merge with any union data inside the OutputRemoteElasticsearch_Secrets_Ssl_Key, using the provided OutputRemoteElasticsearchSecretsSslKey1
func (t *OutputRemoteElasticsearch_Secrets_Ssl_Key) MergeOutputRemoteElasticsearchSecretsSslKey1(v OutputRemoteElasticsearchSecretsSslKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OutputRemoteElasticsearch_Secrets_Ssl_Key) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OutputRemoteElasticsearch_Secrets_Ssl_Key) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOutputElasticsearch returns the union data inside the OutputUnion as a OutputElasticsearch
func (t OutputUnion) AsOutputElasticsearch() (OutputElasticsearch, error) {
	var body OutputElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputElasticsearch overwrites any union data inside the OutputUnion as the provided OutputElasticsearch
func (t *OutputUnion) FromOutputElasticsearch(v OutputElasticsearch) error {
	v.Type = "elasticsearch"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputElasticsearch performs a merge with any union data inside the OutputUnion, using the provided OutputElasticsearch
func (t *OutputUnion) MergeOutputElasticsearch(v OutputElasticsearch) error {
	v.Type = "elasticsearch"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputRemoteElasticsearch returns the union data inside the OutputUnion as a OutputRemoteElasticsearch
func (t OutputUnion) AsOutputRemoteElasticsearch() (OutputRemoteElasticsearch, error) {
	var body OutputRemoteElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputRemoteElasticsearch overwrites any union data inside the OutputUnion as the provided OutputRemoteElasticsearch
func (t *OutputUnion) FromOutputRemoteElasticsearch(v OutputRemoteElasticsearch) error {
	v.Type = "remote_elasticsearch"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputRemoteElasticsearch performs a merge with any union data inside the OutputUnion, using the provided OutputRemoteElasticsearch
func (t *OutputUnion) MergeOutputRemoteElasticsearch(v OutputRemoteElasticsearch) error {
	v.Type = "remote_elasticsearch"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputLogstash returns the union data inside the OutputUnion as a OutputLogstash
func (t OutputUnion) AsOutputLogstash() (OutputLogstash, error) {
	var body OutputLogstash
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputLogstash overwrites any union data inside the OutputUnion as the provided OutputLogstash
func (t *OutputUnion) FromOutputLogstash(v OutputLogstash) error {
	v.Type = "logstash"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputLogstash performs a merge with any union data inside the OutputUnion, using the provided OutputLogstash
func (t *OutputUnion) MergeOutputLogstash(v OutputLogstash) error {
	v.Type = "logstash"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputKafka returns the union data inside the OutputUnion as a OutputKafka
func (t OutputUnion) AsOutputKafka() (OutputKafka, error) {
	var body OutputKafka
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputKafka overwrites any union data inside the OutputUnion as the provided OutputKafka
func (t *OutputUnion) FromOutputKafka(v OutputKafka) error {
	v.Type = "kafka"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputKafka performs a merge with any union data inside the OutputUnion, using the provided OutputKafka
func (t *OutputUnion) MergeOutputKafka(v OutputKafka) error {
	v.Type = "kafka"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OutputUnion) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t OutputUnion) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "elasticsearch":
		return t.AsOutputElasticsearch()
	case "kafka":
		return t.AsOutputKafka()
	case "logstash":
		return t.AsOutputLogstash()
	case "remote_elasticsearch":
		return t.AsOutputRemoteElasticsearch()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t OutputUnion) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OutputUnion) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0 returns the union data inside the PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Type as a PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0
func (t PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Type) AsPackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0() (PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0, error) {
	var body PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0 overwrites any union data inside the PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Type as the provided PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0
func (t *PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Type) FromPackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0(v PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0 performs a merge with any union data inside the PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Type, using the provided PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0
func (t *PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Type) MergePackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0(v PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType1 returns the union data inside the PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Type as a PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType1
func (t PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Type) AsPackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType1() (PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType1, error) {
	var body PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType1 overwrites any union data inside the PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Type as the provided PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType1
func (t *PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Type) FromPackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType1(v PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType1 performs a merge with any union data inside the PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Type, using the provided PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType1
func (t *PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Type) MergePackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType1(v PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Type) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Type) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPackageInfoInstallationInfoInstalledKibanaType0 returns the union data inside the PackageInfo_InstallationInfo_InstalledKibana_Type as a PackageInfoInstallationInfoInstalledKibanaType0
func (t PackageInfo_InstallationInfo_InstalledKibana_Type) AsPackageInfoInstallationInfoInstalledKibanaType0() (PackageInfoInstallationInfoInstalledKibanaType0, error) {
	var body PackageInfoInstallationInfoInstalledKibanaType0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageInfoInstallationInfoInstalledKibanaType0 overwrites any union data inside the PackageInfo_InstallationInfo_InstalledKibana_Type as the provided PackageInfoInstallationInfoInstalledKibanaType0
func (t *PackageInfo_InstallationInfo_InstalledKibana_Type) FromPackageInfoInstallationInfoInstalledKibanaType0(v PackageInfoInstallationInfoInstalledKibanaType0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageInfoInstallationInfoInstalledKibanaType0 performs a merge with any union data inside the PackageInfo_InstallationInfo_InstalledKibana_Type, using the provided PackageInfoInstallationInfoInstalledKibanaType0
func (t *PackageInfo_InstallationInfo_InstalledKibana_Type) MergePackageInfoInstallationInfoInstalledKibanaType0(v PackageInfoInstallationInfoInstalledKibanaType0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPackageInfoInstallationInfoInstalledKibanaType1 returns the union data inside the PackageInfo_InstallationInfo_InstalledKibana_Type as a PackageInfoInstallationInfoInstalledKibanaType1
func (t PackageInfo_InstallationInfo_InstalledKibana_Type) AsPackageInfoInstallationInfoInstalledKibanaType1() (PackageInfoInstallationInfoInstalledKibanaType1, error) {
	var body PackageInfoInstallationInfoInstalledKibanaType1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageInfoInstallationInfoInstalledKibanaType1 overwrites any union data inside the PackageInfo_InstallationInfo_InstalledKibana_Type as the provided PackageInfoInstallationInfoInstalledKibanaType1
func (t *PackageInfo_InstallationInfo_InstalledKibana_Type) FromPackageInfoInstallationInfoInstalledKibanaType1(v PackageInfoInstallationInfoInstalledKibanaType1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageInfoInstallationInfoInstalledKibanaType1 performs a merge with any union data inside the PackageInfo_InstallationInfo_InstalledKibana_Type, using the provided PackageInfoInstallationInfoInstalledKibanaType1
func (t *PackageInfo_InstallationInfo_InstalledKibana_Type) MergePackageInfoInstallationInfoInstalledKibanaType1(v PackageInfoInstallationInfoInstalledKibanaType1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PackageInfo_InstallationInfo_InstalledKibana_Type) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PackageInfo_InstallationInfo_InstalledKibana_Type) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPackageInfoType0 returns the union data inside the PackageInfo_Type as a PackageInfoType0
func (t PackageInfo_Type) AsPackageInfoType0() (PackageInfoType0, error) {
	var body PackageInfoType0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageInfoType0 overwrites any union data inside the PackageInfo_Type as the provided PackageInfoType0
func (t *PackageInfo_Type) FromPackageInfoType0(v PackageInfoType0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageInfoType0 performs a merge with any union data inside the PackageInfo_Type, using the provided PackageInfoType0
func (t *PackageInfo_Type) MergePackageInfoType0(v PackageInfoType0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPackageInfoType1 returns the union data inside the PackageInfo_Type as a PackageInfoType1
func (t PackageInfo_Type) AsPackageInfoType1() (PackageInfoType1, error) {
	var body PackageInfoType1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageInfoType1 overwrites any union data inside the PackageInfo_Type as the provided PackageInfoType1
func (t *PackageInfo_Type) FromPackageInfoType1(v PackageInfoType1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageInfoType1 performs a merge with any union data inside the PackageInfo_Type, using the provided PackageInfoType1
func (t *PackageInfo_Type) MergePackageInfoType1(v PackageInfoType1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPackageInfoType2 returns the union data inside the PackageInfo_Type as a PackageInfoType2
func (t PackageInfo_Type) AsPackageInfoType2() (PackageInfoType2, error) {
	var body PackageInfoType2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageInfoType2 overwrites any union data inside the PackageInfo_Type as the provided PackageInfoType2
func (t *PackageInfo_Type) FromPackageInfoType2(v PackageInfoType2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageInfoType2 performs a merge with any union data inside the PackageInfo_Type, using the provided PackageInfoType2
func (t *PackageInfo_Type) MergePackageInfoType2(v PackageInfoType2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPackageInfoType3 returns the union data inside the PackageInfo_Type as a PackageInfoType3
func (t PackageInfo_Type) AsPackageInfoType3() (PackageInfoType3, error) {
	var body PackageInfoType3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageInfoType3 overwrites any union data inside the PackageInfo_Type as the provided PackageInfoType3
func (t *PackageInfo_Type) FromPackageInfoType3(v PackageInfoType3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageInfoType3 performs a merge with any union data inside the PackageInfo_Type, using the provided PackageInfoType3
func (t *PackageInfo_Type) MergePackageInfoType3(v PackageInfoType3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PackageInfo_Type) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PackageInfo_Type) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0 returns the union data inside the PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Type as a PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0
func (t PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Type) AsPackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0() (PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0, error) {
	var body PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0 overwrites any union data inside the PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Type as the provided PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0
func (t *PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Type) FromPackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0(v PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0 performs a merge with any union data inside the PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Type, using the provided PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0
func (t *PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Type) MergePackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0(v PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType1 returns the union data inside the PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Type as a PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType1
func (t PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Type) AsPackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType1() (PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType1, error) {
	var body PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType1 overwrites any union data inside the PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Type as the provided PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType1
func (t *PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Type) FromPackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType1(v PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType1 performs a merge with any union data inside the PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Type, using the provided PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType1
func (t *PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Type) MergePackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType1(v PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Type) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Type) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPackageListItemInstallationInfoInstalledKibanaType0 returns the union data inside the PackageListItem_InstallationInfo_InstalledKibana_Type as a PackageListItemInstallationInfoInstalledKibanaType0
func (t PackageListItem_InstallationInfo_InstalledKibana_Type) AsPackageListItemInstallationInfoInstalledKibanaType0() (PackageListItemInstallationInfoInstalledKibanaType0, error) {
	var body PackageListItemInstallationInfoInstalledKibanaType0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageListItemInstallationInfoInstalledKibanaType0 overwrites any union data inside the PackageListItem_InstallationInfo_InstalledKibana_Type as the provided PackageListItemInstallationInfoInstalledKibanaType0
func (t *PackageListItem_InstallationInfo_InstalledKibana_Type) FromPackageListItemInstallationInfoInstalledKibanaType0(v PackageListItemInstallationInfoInstalledKibanaType0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageListItemInstallationInfoInstalledKibanaType0 performs a merge with any union data inside the PackageListItem_InstallationInfo_InstalledKibana_Type, using the provided PackageListItemInstallationInfoInstalledKibanaType0
func (t *PackageListItem_InstallationInfo_InstalledKibana_Type) MergePackageListItemInstallationInfoInstalledKibanaType0(v PackageListItemInstallationInfoInstalledKibanaType0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPackageListItemInstallationInfoInstalledKibanaType1 returns the union data inside the PackageListItem_InstallationInfo_InstalledKibana_Type as a PackageListItemInstallationInfoInstalledKibanaType1
func (t PackageListItem_InstallationInfo_InstalledKibana_Type) AsPackageListItemInstallationInfoInstalledKibanaType1() (PackageListItemInstallationInfoInstalledKibanaType1, error) {
	var body PackageListItemInstallationInfoInstalledKibanaType1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageListItemInstallationInfoInstalledKibanaType1 overwrites any union data inside the PackageListItem_InstallationInfo_InstalledKibana_Type as the provided PackageListItemInstallationInfoInstalledKibanaType1
func (t *PackageListItem_InstallationInfo_InstalledKibana_Type) FromPackageListItemInstallationInfoInstalledKibanaType1(v PackageListItemInstallationInfoInstalledKibanaType1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageListItemInstallationInfoInstalledKibanaType1 performs a merge with any union data inside the PackageListItem_InstallationInfo_InstalledKibana_Type, using the provided PackageListItemInstallationInfoInstalledKibanaType1
func (t *PackageListItem_InstallationInfo_InstalledKibana_Type) MergePackageListItemInstallationInfoInstalledKibanaType1(v PackageListItemInstallationInfoInstalledKibanaType1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PackageListItem_InstallationInfo_InstalledKibana_Type) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PackageListItem_InstallationInfo_InstalledKibana_Type) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsPackageListItemType0 returns the union data inside the PackageListItem_Type as a PackageListItemType0
func (t PackageListItem_Type) AsPackageListItemType0() (PackageListItemType0, error) {
	var body PackageListItemType0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageListItemType0 overwrites any union data inside the PackageListItem_Type as the provided PackageListItemType0
func (t *PackageListItem_Type) FromPackageListItemType0(v PackageListItemType0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageListItemType0 performs a merge with any union data inside the PackageListItem_Type, using the provided PackageListItemType0
func (t *PackageListItem_Type) MergePackageListItemType0(v PackageListItemType0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPackageListItemType1 returns the union data inside the PackageListItem_Type as a PackageListItemType1
func (t PackageListItem_Type) AsPackageListItemType1() (PackageListItemType1, error) {
	var body PackageListItemType1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageListItemType1 overwrites any union data inside the PackageListItem_Type as the provided PackageListItemType1
func (t *PackageListItem_Type) FromPackageListItemType1(v PackageListItemType1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageListItemType1 performs a merge with any union data inside the PackageListItem_Type, using the provided PackageListItemType1
func (t *PackageListItem_Type) MergePackageListItemType1(v PackageListItemType1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPackageListItemType2 returns the union data inside the PackageListItem_Type as a PackageListItemType2
func (t PackageListItem_Type) AsPackageListItemType2() (PackageListItemType2, error) {
	var body PackageListItemType2
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageListItemType2 overwrites any union data inside the PackageListItem_Type as the provided PackageListItemType2
func (t *PackageListItem_Type) FromPackageListItemType2(v PackageListItemType2) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageListItemType2 performs a merge with any union data inside the PackageListItem_Type, using the provided PackageListItemType2
func (t *PackageListItem_Type) MergePackageListItemType2(v PackageListItemType2) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPackageListItemType3 returns the union data inside the PackageListItem_Type as a PackageListItemType3
func (t PackageListItem_Type) AsPackageListItemType3() (PackageListItemType3, error) {
	var body PackageListItemType3
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPackageListItemType3 overwrites any union data inside the PackageListItem_Type as the provided PackageListItemType3
func (t *PackageListItem_Type) FromPackageListItemType3(v PackageListItemType3) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePackageListItemType3 performs a merge with any union data inside the PackageListItem_Type, using the provided PackageListItemType3
func (t *PackageListItem_Type) MergePackageListItemType3(v PackageListItemType3) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t PackageListItem_Type) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *PackageListItem_Type) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsServerHostSecretsSslEsKey0 returns the union data inside the ServerHost_Secrets_Ssl_EsKey as a ServerHostSecretsSslEsKey0
func (t ServerHost_Secrets_Ssl_EsKey) AsServerHostSecretsSslEsKey0() (ServerHostSecretsSslEsKey0, error) {
	var body ServerHostSecretsSslEsKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServerHostSecretsSslEsKey0 overwrites any union data inside the ServerHost_Secrets_Ssl_EsKey as the provided ServerHostSecretsSslEsKey0
func (t *ServerHost_Secrets_Ssl_EsKey) FromServerHostSecretsSslEsKey0(v ServerHostSecretsSslEsKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServerHostSecretsSslEsKey0 performs a merge with any union data inside the ServerHost_Secrets_Ssl_EsKey, using the provided ServerHostSecretsSslEsKey0
func (t *ServerHost_Secrets_Ssl_EsKey) MergeServerHostSecretsSslEsKey0(v ServerHostSecretsSslEsKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsServerHostSecretsSslEsKey1 returns the union data inside the ServerHost_Secrets_Ssl_EsKey as a ServerHostSecretsSslEsKey1
func (t ServerHost_Secrets_Ssl_EsKey) AsServerHostSecretsSslEsKey1() (ServerHostSecretsSslEsKey1, error) {
	var body ServerHostSecretsSslEsKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServerHostSecretsSslEsKey1 overwrites any union data inside the ServerHost_Secrets_Ssl_EsKey as the provided ServerHostSecretsSslEsKey1
func (t *ServerHost_Secrets_Ssl_EsKey) FromServerHostSecretsSslEsKey1(v ServerHostSecretsSslEsKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServerHostSecretsSslEsKey1 performs a merge with any union data inside the ServerHost_Secrets_Ssl_EsKey, using the provided ServerHostSecretsSslEsKey1
func (t *ServerHost_Secrets_Ssl_EsKey) MergeServerHostSecretsSslEsKey1(v ServerHostSecretsSslEsKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ServerHost_Secrets_Ssl_EsKey) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ServerHost_Secrets_Ssl_EsKey) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsServerHostSecretsSslKey0 returns the union data inside the ServerHost_Secrets_Ssl_Key as a ServerHostSecretsSslKey0
func (t ServerHost_Secrets_Ssl_Key) AsServerHostSecretsSslKey0() (ServerHostSecretsSslKey0, error) {
	var body ServerHostSecretsSslKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServerHostSecretsSslKey0 overwrites any union data inside the ServerHost_Secrets_Ssl_Key as the provided ServerHostSecretsSslKey0
func (t *ServerHost_Secrets_Ssl_Key) FromServerHostSecretsSslKey0(v ServerHostSecretsSslKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServerHostSecretsSslKey0 performs a merge with any union data inside the ServerHost_Secrets_Ssl_Key, using the provided ServerHostSecretsSslKey0
func (t *ServerHost_Secrets_Ssl_Key) MergeServerHostSecretsSslKey0(v ServerHostSecretsSslKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsServerHostSecretsSslKey1 returns the union data inside the ServerHost_Secrets_Ssl_Key as a ServerHostSecretsSslKey1
func (t ServerHost_Secrets_Ssl_Key) AsServerHostSecretsSslKey1() (ServerHostSecretsSslKey1, error) {
	var body ServerHostSecretsSslKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServerHostSecretsSslKey1 overwrites any union data inside the ServerHost_Secrets_Ssl_Key as the provided ServerHostSecretsSslKey1
func (t *ServerHost_Secrets_Ssl_Key) FromServerHostSecretsSslKey1(v ServerHostSecretsSslKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServerHostSecretsSslKey1 performs a merge with any union data inside the ServerHost_Secrets_Ssl_Key, using the provided ServerHostSecretsSslKey1
func (t *ServerHost_Secrets_Ssl_Key) MergeServerHostSecretsSslKey1(v ServerHostSecretsSslKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ServerHost_Secrets_Ssl_Key) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ServerHost_Secrets_Ssl_Key) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsBedrockConfig returns the union data inside the UpdateConnectorConfig as a BedrockConfig
func (t UpdateConnectorConfig) AsBedrockConfig() (BedrockConfig, error) {
	var body BedrockConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBedrockConfig overwrites any union data inside the UpdateConnectorConfig as the provided BedrockConfig
func (t *UpdateConnectorConfig) FromBedrockConfig(v BedrockConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBedrockConfig performs a merge with any union data inside the UpdateConnectorConfig, using the provided BedrockConfig
func (t *UpdateConnectorConfig) MergeBedrockConfig(v BedrockConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCrowdstrikeConfig returns the union data inside the UpdateConnectorConfig as a CrowdstrikeConfig
func (t UpdateConnectorConfig) AsCrowdstrikeConfig() (CrowdstrikeConfig, error) {
	var body CrowdstrikeConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCrowdstrikeConfig overwrites any union data inside the UpdateConnectorConfig as the provided CrowdstrikeConfig
func (t *UpdateConnectorConfig) FromCrowdstrikeConfig(v CrowdstrikeConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCrowdstrikeConfig performs a merge with any union data inside the UpdateConnectorConfig, using the provided CrowdstrikeConfig
func (t *UpdateConnectorConfig) MergeCrowdstrikeConfig(v CrowdstrikeConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsD3securityConfig returns the union data inside the UpdateConnectorConfig as a D3securityConfig
func (t UpdateConnectorConfig) AsD3securityConfig() (D3securityConfig, error) {
	var body D3securityConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromD3securityConfig overwrites any union data inside the UpdateConnectorConfig as the provided D3securityConfig
func (t *UpdateConnectorConfig) FromD3securityConfig(v D3securityConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeD3securityConfig performs a merge with any union data inside the UpdateConnectorConfig, using the provided D3securityConfig
func (t *UpdateConnectorConfig) MergeD3securityConfig(v D3securityConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmailConfig returns the union data inside the UpdateConnectorConfig as a EmailConfig
func (t UpdateConnectorConfig) AsEmailConfig() (EmailConfig, error) {
	var body EmailConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmailConfig overwrites any union data inside the UpdateConnectorConfig as the provided EmailConfig
func (t *UpdateConnectorConfig) FromEmailConfig(v EmailConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmailConfig performs a merge with any union data inside the UpdateConnectorConfig, using the provided EmailConfig
func (t *UpdateConnectorConfig) MergeEmailConfig(v EmailConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGeminiConfig returns the union data inside the UpdateConnectorConfig as a GeminiConfig
func (t UpdateConnectorConfig) AsGeminiConfig() (GeminiConfig, error) {
	var body GeminiConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeminiConfig overwrites any union data inside the UpdateConnectorConfig as the provided GeminiConfig
func (t *UpdateConnectorConfig) FromGeminiConfig(v GeminiConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeminiConfig performs a merge with any union data inside the UpdateConnectorConfig, using the provided GeminiConfig
func (t *UpdateConnectorConfig) MergeGeminiConfig(v GeminiConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResilientConfig returns the union data inside the UpdateConnectorConfig as a ResilientConfig
func (t UpdateConnectorConfig) AsResilientConfig() (ResilientConfig, error) {
	var body ResilientConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResilientConfig overwrites any union data inside the UpdateConnectorConfig as the provided ResilientConfig
func (t *UpdateConnectorConfig) FromResilientConfig(v ResilientConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResilientConfig performs a merge with any union data inside the UpdateConnectorConfig, using the provided ResilientConfig
func (t *UpdateConnectorConfig) MergeResilientConfig(v ResilientConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsIndexConfig returns the union data inside the UpdateConnectorConfig as a IndexConfig
func (t UpdateConnectorConfig) AsIndexConfig() (IndexConfig, error) {
	var body IndexConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromIndexConfig overwrites any union data inside the UpdateConnectorConfig as the provided IndexConfig
func (t *UpdateConnectorConfig) FromIndexConfig(v IndexConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeIndexConfig performs a merge with any union data inside the UpdateConnectorConfig, using the provided IndexConfig
func (t *UpdateConnectorConfig) MergeIndexConfig(v IndexConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJiraConfig returns the union data inside the UpdateConnectorConfig as a JiraConfig
func (t UpdateConnectorConfig) AsJiraConfig() (JiraConfig, error) {
	var body JiraConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJiraConfig overwrites any union data inside the UpdateConnectorConfig as the provided JiraConfig
func (t *UpdateConnectorConfig) FromJiraConfig(v JiraConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJiraConfig performs a merge with any union data inside the UpdateConnectorConfig, using the provided JiraConfig
func (t *UpdateConnectorConfig) MergeJiraConfig(v JiraConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDefenderConfig returns the union data inside the UpdateConnectorConfig as a DefenderConfig
func (t UpdateConnectorConfig) AsDefenderConfig() (DefenderConfig, error) {
	var body DefenderConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDefenderConfig overwrites any union data inside the UpdateConnectorConfig as the provided DefenderConfig
func (t *UpdateConnectorConfig) FromDefenderConfig(v DefenderConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDefenderConfig performs a merge with any union data inside the UpdateConnectorConfig, using the provided DefenderConfig
func (t *UpdateConnectorConfig) MergeDefenderConfig(v DefenderConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGenaiAzureConfig returns the union data inside the UpdateConnectorConfig as a GenaiAzureConfig
func (t UpdateConnectorConfig) AsGenaiAzureConfig() (GenaiAzureConfig, error) {
	var body GenaiAzureConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGenaiAzureConfig overwrites any union data inside the UpdateConnectorConfig as the provided GenaiAzureConfig
func (t *UpdateConnectorConfig) FromGenaiAzureConfig(v GenaiAzureConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGenaiAzureConfig performs a merge with any union data inside the UpdateConnectorConfig, using the provided GenaiAzureConfig
func (t *UpdateConnectorConfig) MergeGenaiAzureConfig(v GenaiAzureConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGenaiOpenaiConfig returns the union data inside the UpdateConnectorConfig as a GenaiOpenaiConfig
func (t UpdateConnectorConfig) AsGenaiOpenaiConfig() (GenaiOpenaiConfig, error) {
	var body GenaiOpenaiConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGenaiOpenaiConfig overwrites any union data inside the UpdateConnectorConfig as the provided GenaiOpenaiConfig
func (t *UpdateConnectorConfig) FromGenaiOpenaiConfig(v GenaiOpenaiConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGenaiOpenaiConfig performs a merge with any union data inside the UpdateConnectorConfig, using the provided GenaiOpenaiConfig
func (t *UpdateConnectorConfig) MergeGenaiOpenaiConfig(v GenaiOpenaiConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpsgenieConfig returns the union data inside the UpdateConnectorConfig as a OpsgenieConfig
func (t UpdateConnectorConfig) AsOpsgenieConfig() (OpsgenieConfig, error) {
	var body OpsgenieConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpsgenieConfig overwrites any union data inside the UpdateConnectorConfig as the provided OpsgenieConfig
func (t *UpdateConnectorConfig) FromOpsgenieConfig(v OpsgenieConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpsgenieConfig performs a merge with any union data inside the UpdateConnectorConfig, using the provided OpsgenieConfig
func (t *UpdateConnectorConfig) MergeOpsgenieConfig(v OpsgenieConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPagerdutyConfig returns the union data inside the UpdateConnectorConfig as a PagerdutyConfig
func (t UpdateConnectorConfig) AsPagerdutyConfig() (PagerdutyConfig, error) {
	var body PagerdutyConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPagerdutyConfig overwrites any union data inside the UpdateConnectorConfig as the provided PagerdutyConfig
func (t *UpdateConnectorConfig) FromPagerdutyConfig(v PagerdutyConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePagerdutyConfig performs a merge with any union data inside the UpdateConnectorConfig, using the provided PagerdutyConfig
func (t *UpdateConnectorConfig) MergePagerdutyConfig(v PagerdutyConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSentineloneConfig returns the union data inside the UpdateConnectorConfig as a SentineloneConfig
func (t UpdateConnectorConfig) AsSentineloneConfig() (SentineloneConfig, error) {
	var body SentineloneConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSentineloneConfig overwrites any union data inside the UpdateConnectorConfig as the provided SentineloneConfig
func (t *UpdateConnectorConfig) FromSentineloneConfig(v SentineloneConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSentineloneConfig performs a merge with any union data inside the UpdateConnectorConfig, using the provided SentineloneConfig
func (t *UpdateConnectorConfig) MergeSentineloneConfig(v SentineloneConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsServicenowConfig returns the union data inside the UpdateConnectorConfig as a ServicenowConfig
func (t UpdateConnectorConfig) AsServicenowConfig() (ServicenowConfig, error) {
	var body ServicenowConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServicenowConfig overwrites any union data inside the UpdateConnectorConfig as the provided ServicenowConfig
func (t *UpdateConnectorConfig) FromServicenowConfig(v ServicenowConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServicenowConfig performs a merge with any union data inside the UpdateConnectorConfig, using the provided ServicenowConfig
func (t *UpdateConnectorConfig) MergeServicenowConfig(v ServicenowConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsServicenowItomConfig returns the union data inside the UpdateConnectorConfig as a ServicenowItomConfig
func (t UpdateConnectorConfig) AsServicenowItomConfig() (ServicenowItomConfig, error) {
	var body ServicenowItomConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServicenowItomConfig overwrites any union data inside the UpdateConnectorConfig as the provided ServicenowItomConfig
func (t *UpdateConnectorConfig) FromServicenowItomConfig(v ServicenowItomConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServicenowItomConfig performs a merge with any union data inside the UpdateConnectorConfig, using the provided ServicenowItomConfig
func (t *UpdateConnectorConfig) MergeServicenowItomConfig(v ServicenowItomConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSlackApiConfig returns the union data inside the UpdateConnectorConfig as a SlackApiConfig
func (t UpdateConnectorConfig) AsSlackApiConfig() (SlackApiConfig, error) {
	var body SlackApiConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSlackApiConfig overwrites any union data inside the UpdateConnectorConfig as the provided SlackApiConfig
func (t *UpdateConnectorConfig) FromSlackApiConfig(v SlackApiConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSlackApiConfig performs a merge with any union data inside the UpdateConnectorConfig, using the provided SlackApiConfig
func (t *UpdateConnectorConfig) MergeSlackApiConfig(v SlackApiConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSwimlaneConfig returns the union data inside the UpdateConnectorConfig as a SwimlaneConfig
func (t UpdateConnectorConfig) AsSwimlaneConfig() (SwimlaneConfig, error) {
	var body SwimlaneConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSwimlaneConfig overwrites any union data inside the UpdateConnectorConfig as the provided SwimlaneConfig
func (t *UpdateConnectorConfig) FromSwimlaneConfig(v SwimlaneConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSwimlaneConfig performs a merge with any union data inside the UpdateConnectorConfig, using the provided SwimlaneConfig
func (t *UpdateConnectorConfig) MergeSwimlaneConfig(v SwimlaneConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsThehiveConfig returns the union data inside the UpdateConnectorConfig as a ThehiveConfig
func (t UpdateConnectorConfig) AsThehiveConfig() (ThehiveConfig, error) {
	var body ThehiveConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromThehiveConfig overwrites any union data inside the UpdateConnectorConfig as the provided ThehiveConfig
func (t *UpdateConnectorConfig) FromThehiveConfig(v ThehiveConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeThehiveConfig performs a merge with any union data inside the UpdateConnectorConfig, using the provided ThehiveConfig
func (t *UpdateConnectorConfig) MergeThehiveConfig(v ThehiveConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTinesConfig returns the union data inside the UpdateConnectorConfig as a TinesConfig
func (t UpdateConnectorConfig) AsTinesConfig() (TinesConfig, error) {
	var body TinesConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTinesConfig overwrites any union data inside the UpdateConnectorConfig as the provided TinesConfig
func (t *UpdateConnectorConfig) FromTinesConfig(v TinesConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTinesConfig performs a merge with any union data inside the UpdateConnectorConfig, using the provided TinesConfig
func (t *UpdateConnectorConfig) MergeTinesConfig(v TinesConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTorqConfig returns the union data inside the UpdateConnectorConfig as a TorqConfig
func (t UpdateConnectorConfig) AsTorqConfig() (TorqConfig, error) {
	var body TorqConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTorqConfig overwrites any union data inside the UpdateConnectorConfig as the provided TorqConfig
func (t *UpdateConnectorConfig) FromTorqConfig(v TorqConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTorqConfig performs a merge with any union data inside the UpdateConnectorConfig, using the provided TorqConfig
func (t *UpdateConnectorConfig) MergeTorqConfig(v TorqConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWebhookConfig returns the union data inside the UpdateConnectorConfig as a WebhookConfig
func (t UpdateConnectorConfig) AsWebhookConfig() (WebhookConfig, error) {
	var body WebhookConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWebhookConfig overwrites any union data inside the UpdateConnectorConfig as the provided WebhookConfig
func (t *UpdateConnectorConfig) FromWebhookConfig(v WebhookConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWebhookConfig performs a merge with any union data inside the UpdateConnectorConfig, using the provided WebhookConfig
func (t *UpdateConnectorConfig) MergeWebhookConfig(v WebhookConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCasesWebhookConfig returns the union data inside the UpdateConnectorConfig as a CasesWebhookConfig
func (t UpdateConnectorConfig) AsCasesWebhookConfig() (CasesWebhookConfig, error) {
	var body CasesWebhookConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCasesWebhookConfig overwrites any union data inside the UpdateConnectorConfig as the provided CasesWebhookConfig
func (t *UpdateConnectorConfig) FromCasesWebhookConfig(v CasesWebhookConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCasesWebhookConfig performs a merge with any union data inside the UpdateConnectorConfig, using the provided CasesWebhookConfig
func (t *UpdateConnectorConfig) MergeCasesWebhookConfig(v CasesWebhookConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsXmattersConfig returns the union data inside the UpdateConnectorConfig as a XmattersConfig
func (t UpdateConnectorConfig) AsXmattersConfig() (XmattersConfig, error) {
	var body XmattersConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromXmattersConfig overwrites any union data inside the UpdateConnectorConfig as the provided XmattersConfig
func (t *UpdateConnectorConfig) FromXmattersConfig(v XmattersConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeXmattersConfig performs a merge with any union data inside the UpdateConnectorConfig, using the provided XmattersConfig
func (t *UpdateConnectorConfig) MergeXmattersConfig(v XmattersConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBedrockSecrets returns the union data inside the UpdateConnectorSecrets as a BedrockSecrets
func (t UpdateConnectorSecrets) AsBedrockSecrets() (BedrockSecrets, error) {
	var body BedrockSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBedrockSecrets overwrites any union data inside the UpdateConnectorSecrets as the provided BedrockSecrets
func (t *UpdateConnectorSecrets) FromBedrockSecrets(v BedrockSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBedrockSecrets performs a merge with any union data inside the UpdateConnectorSecrets, using the provided BedrockSecrets
func (t *UpdateConnectorSecrets) MergeBedrockSecrets(v BedrockSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCrowdstrikeSecrets returns the union data inside the UpdateConnectorSecrets as a CrowdstrikeSecrets
func (t UpdateConnectorSecrets) AsCrowdstrikeSecrets() (CrowdstrikeSecrets, error) {
	var body CrowdstrikeSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCrowdstrikeSecrets overwrites any union data inside the UpdateConnectorSecrets as the provided CrowdstrikeSecrets
func (t *UpdateConnectorSecrets) FromCrowdstrikeSecrets(v CrowdstrikeSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCrowdstrikeSecrets performs a merge with any union data inside the UpdateConnectorSecrets, using the provided CrowdstrikeSecrets
func (t *UpdateConnectorSecrets) MergeCrowdstrikeSecrets(v CrowdstrikeSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsD3securitySecrets returns the union data inside the UpdateConnectorSecrets as a D3securitySecrets
func (t UpdateConnectorSecrets) AsD3securitySecrets() (D3securitySecrets, error) {
	var body D3securitySecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromD3securitySecrets overwrites any union data inside the UpdateConnectorSecrets as the provided D3securitySecrets
func (t *UpdateConnectorSecrets) FromD3securitySecrets(v D3securitySecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeD3securitySecrets performs a merge with any union data inside the UpdateConnectorSecrets, using the provided D3securitySecrets
func (t *UpdateConnectorSecrets) MergeD3securitySecrets(v D3securitySecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsEmailSecrets returns the union data inside the UpdateConnectorSecrets as a EmailSecrets
func (t UpdateConnectorSecrets) AsEmailSecrets() (EmailSecrets, error) {
	var body EmailSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromEmailSecrets overwrites any union data inside the UpdateConnectorSecrets as the provided EmailSecrets
func (t *UpdateConnectorSecrets) FromEmailSecrets(v EmailSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeEmailSecrets performs a merge with any union data inside the UpdateConnectorSecrets, using the provided EmailSecrets
func (t *UpdateConnectorSecrets) MergeEmailSecrets(v EmailSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGeminiSecrets returns the union data inside the UpdateConnectorSecrets as a GeminiSecrets
func (t UpdateConnectorSecrets) AsGeminiSecrets() (GeminiSecrets, error) {
	var body GeminiSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGeminiSecrets overwrites any union data inside the UpdateConnectorSecrets as the provided GeminiSecrets
func (t *UpdateConnectorSecrets) FromGeminiSecrets(v GeminiSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGeminiSecrets performs a merge with any union data inside the UpdateConnectorSecrets, using the provided GeminiSecrets
func (t *UpdateConnectorSecrets) MergeGeminiSecrets(v GeminiSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsResilientSecrets returns the union data inside the UpdateConnectorSecrets as a ResilientSecrets
func (t UpdateConnectorSecrets) AsResilientSecrets() (ResilientSecrets, error) {
	var body ResilientSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromResilientSecrets overwrites any union data inside the UpdateConnectorSecrets as the provided ResilientSecrets
func (t *UpdateConnectorSecrets) FromResilientSecrets(v ResilientSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeResilientSecrets performs a merge with any union data inside the UpdateConnectorSecrets, using the provided ResilientSecrets
func (t *UpdateConnectorSecrets) MergeResilientSecrets(v ResilientSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsJiraSecrets returns the union data inside the UpdateConnectorSecrets as a JiraSecrets
func (t UpdateConnectorSecrets) AsJiraSecrets() (JiraSecrets, error) {
	var body JiraSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJiraSecrets overwrites any union data inside the UpdateConnectorSecrets as the provided JiraSecrets
func (t *UpdateConnectorSecrets) FromJiraSecrets(v JiraSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJiraSecrets performs a merge with any union data inside the UpdateConnectorSecrets, using the provided JiraSecrets
func (t *UpdateConnectorSecrets) MergeJiraSecrets(v JiraSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTeamsSecrets returns the union data inside the UpdateConnectorSecrets as a TeamsSecrets
func (t UpdateConnectorSecrets) AsTeamsSecrets() (TeamsSecrets, error) {
	var body TeamsSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTeamsSecrets overwrites any union data inside the UpdateConnectorSecrets as the provided TeamsSecrets
func (t *UpdateConnectorSecrets) FromTeamsSecrets(v TeamsSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTeamsSecrets performs a merge with any union data inside the UpdateConnectorSecrets, using the provided TeamsSecrets
func (t *UpdateConnectorSecrets) MergeTeamsSecrets(v TeamsSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsGenaiSecrets returns the union data inside the UpdateConnectorSecrets as a GenaiSecrets
func (t UpdateConnectorSecrets) AsGenaiSecrets() (GenaiSecrets, error) {
	var body GenaiSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromGenaiSecrets overwrites any union data inside the UpdateConnectorSecrets as the provided GenaiSecrets
func (t *UpdateConnectorSecrets) FromGenaiSecrets(v GenaiSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeGenaiSecrets performs a merge with any union data inside the UpdateConnectorSecrets, using the provided GenaiSecrets
func (t *UpdateConnectorSecrets) MergeGenaiSecrets(v GenaiSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOpsgenieSecrets returns the union data inside the UpdateConnectorSecrets as a OpsgenieSecrets
func (t UpdateConnectorSecrets) AsOpsgenieSecrets() (OpsgenieSecrets, error) {
	var body OpsgenieSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOpsgenieSecrets overwrites any union data inside the UpdateConnectorSecrets as the provided OpsgenieSecrets
func (t *UpdateConnectorSecrets) FromOpsgenieSecrets(v OpsgenieSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOpsgenieSecrets performs a merge with any union data inside the UpdateConnectorSecrets, using the provided OpsgenieSecrets
func (t *UpdateConnectorSecrets) MergeOpsgenieSecrets(v OpsgenieSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPagerdutySecrets returns the union data inside the UpdateConnectorSecrets as a PagerdutySecrets
func (t UpdateConnectorSecrets) AsPagerdutySecrets() (PagerdutySecrets, error) {
	var body PagerdutySecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPagerdutySecrets overwrites any union data inside the UpdateConnectorSecrets as the provided PagerdutySecrets
func (t *UpdateConnectorSecrets) FromPagerdutySecrets(v PagerdutySecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePagerdutySecrets performs a merge with any union data inside the UpdateConnectorSecrets, using the provided PagerdutySecrets
func (t *UpdateConnectorSecrets) MergePagerdutySecrets(v PagerdutySecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSentineloneSecrets returns the union data inside the UpdateConnectorSecrets as a SentineloneSecrets
func (t UpdateConnectorSecrets) AsSentineloneSecrets() (SentineloneSecrets, error) {
	var body SentineloneSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSentineloneSecrets overwrites any union data inside the UpdateConnectorSecrets as the provided SentineloneSecrets
func (t *UpdateConnectorSecrets) FromSentineloneSecrets(v SentineloneSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSentineloneSecrets performs a merge with any union data inside the UpdateConnectorSecrets, using the provided SentineloneSecrets
func (t *UpdateConnectorSecrets) MergeSentineloneSecrets(v SentineloneSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsServicenowSecrets returns the union data inside the UpdateConnectorSecrets as a ServicenowSecrets
func (t UpdateConnectorSecrets) AsServicenowSecrets() (ServicenowSecrets, error) {
	var body ServicenowSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromServicenowSecrets overwrites any union data inside the UpdateConnectorSecrets as the provided ServicenowSecrets
func (t *UpdateConnectorSecrets) FromServicenowSecrets(v ServicenowSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeServicenowSecrets performs a merge with any union data inside the UpdateConnectorSecrets, using the provided ServicenowSecrets
func (t *UpdateConnectorSecrets) MergeServicenowSecrets(v ServicenowSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSlackApiSecrets returns the union data inside the UpdateConnectorSecrets as a SlackApiSecrets
func (t UpdateConnectorSecrets) AsSlackApiSecrets() (SlackApiSecrets, error) {
	var body SlackApiSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSlackApiSecrets overwrites any union data inside the UpdateConnectorSecrets as the provided SlackApiSecrets
func (t *UpdateConnectorSecrets) FromSlackApiSecrets(v SlackApiSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSlackApiSecrets performs a merge with any union data inside the UpdateConnectorSecrets, using the provided SlackApiSecrets
func (t *UpdateConnectorSecrets) MergeSlackApiSecrets(v SlackApiSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSwimlaneSecrets returns the union data inside the UpdateConnectorSecrets as a SwimlaneSecrets
func (t UpdateConnectorSecrets) AsSwimlaneSecrets() (SwimlaneSecrets, error) {
	var body SwimlaneSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSwimlaneSecrets overwrites any union data inside the UpdateConnectorSecrets as the provided SwimlaneSecrets
func (t *UpdateConnectorSecrets) FromSwimlaneSecrets(v SwimlaneSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSwimlaneSecrets performs a merge with any union data inside the UpdateConnectorSecrets, using the provided SwimlaneSecrets
func (t *UpdateConnectorSecrets) MergeSwimlaneSecrets(v SwimlaneSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsThehiveSecrets returns the union data inside the UpdateConnectorSecrets as a ThehiveSecrets
func (t UpdateConnectorSecrets) AsThehiveSecrets() (ThehiveSecrets, error) {
	var body ThehiveSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromThehiveSecrets overwrites any union data inside the UpdateConnectorSecrets as the provided ThehiveSecrets
func (t *UpdateConnectorSecrets) FromThehiveSecrets(v ThehiveSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeThehiveSecrets performs a merge with any union data inside the UpdateConnectorSecrets, using the provided ThehiveSecrets
func (t *UpdateConnectorSecrets) MergeThehiveSecrets(v ThehiveSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTinesSecrets returns the union data inside the UpdateConnectorSecrets as a TinesSecrets
func (t UpdateConnectorSecrets) AsTinesSecrets() (TinesSecrets, error) {
	var body TinesSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTinesSecrets overwrites any union data inside the UpdateConnectorSecrets as the provided TinesSecrets
func (t *UpdateConnectorSecrets) FromTinesSecrets(v TinesSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTinesSecrets performs a merge with any union data inside the UpdateConnectorSecrets, using the provided TinesSecrets
func (t *UpdateConnectorSecrets) MergeTinesSecrets(v TinesSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTorqSecrets returns the union data inside the UpdateConnectorSecrets as a TorqSecrets
func (t UpdateConnectorSecrets) AsTorqSecrets() (TorqSecrets, error) {
	var body TorqSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTorqSecrets overwrites any union data inside the UpdateConnectorSecrets as the provided TorqSecrets
func (t *UpdateConnectorSecrets) FromTorqSecrets(v TorqSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTorqSecrets performs a merge with any union data inside the UpdateConnectorSecrets, using the provided TorqSecrets
func (t *UpdateConnectorSecrets) MergeTorqSecrets(v TorqSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWebhookSecrets returns the union data inside the UpdateConnectorSecrets as a WebhookSecrets
func (t UpdateConnectorSecrets) AsWebhookSecrets() (WebhookSecrets, error) {
	var body WebhookSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWebhookSecrets overwrites any union data inside the UpdateConnectorSecrets as the provided WebhookSecrets
func (t *UpdateConnectorSecrets) FromWebhookSecrets(v WebhookSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWebhookSecrets performs a merge with any union data inside the UpdateConnectorSecrets, using the provided WebhookSecrets
func (t *UpdateConnectorSecrets) MergeWebhookSecrets(v WebhookSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCasesWebhookSecrets returns the union data inside the UpdateConnectorSecrets as a CasesWebhookSecrets
func (t UpdateConnectorSecrets) AsCasesWebhookSecrets() (CasesWebhookSecrets, error) {
	var body CasesWebhookSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCasesWebhookSecrets overwrites any union data inside the UpdateConnectorSecrets as the provided CasesWebhookSecrets
func (t *UpdateConnectorSecrets) FromCasesWebhookSecrets(v CasesWebhookSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCasesWebhookSecrets performs a merge with any union data inside the UpdateConnectorSecrets, using the provided CasesWebhookSecrets
func (t *UpdateConnectorSecrets) MergeCasesWebhookSecrets(v CasesWebhookSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsXmattersSecrets returns the union data inside the UpdateConnectorSecrets as a XmattersSecrets
func (t UpdateConnectorSecrets) AsXmattersSecrets() (XmattersSecrets, error) {
	var body XmattersSecrets
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromXmattersSecrets overwrites any union data inside the UpdateConnectorSecrets as the provided XmattersSecrets
func (t *UpdateConnectorSecrets) FromXmattersSecrets(v XmattersSecrets) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeXmattersSecrets performs a merge with any union data inside the UpdateConnectorSecrets, using the provided XmattersSecrets
func (t *UpdateConnectorSecrets) MergeXmattersSecrets(v XmattersSecrets) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOutputElasticsearchSecretsSslKey0 returns the union data inside the UpdateOutputElasticsearch_Secrets_Ssl_Key as a UpdateOutputElasticsearchSecretsSslKey0
func (t UpdateOutputElasticsearch_Secrets_Ssl_Key) AsUpdateOutputElasticsearchSecretsSslKey0() (UpdateOutputElasticsearchSecretsSslKey0, error) {
	var body UpdateOutputElasticsearchSecretsSslKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputElasticsearchSecretsSslKey0 overwrites any union data inside the UpdateOutputElasticsearch_Secrets_Ssl_Key as the provided UpdateOutputElasticsearchSecretsSslKey0
func (t *UpdateOutputElasticsearch_Secrets_Ssl_Key) FromUpdateOutputElasticsearchSecretsSslKey0(v UpdateOutputElasticsearchSecretsSslKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputElasticsearchSecretsSslKey0 performs a merge with any union data inside the UpdateOutputElasticsearch_Secrets_Ssl_Key, using the provided UpdateOutputElasticsearchSecretsSslKey0
func (t *UpdateOutputElasticsearch_Secrets_Ssl_Key) MergeUpdateOutputElasticsearchSecretsSslKey0(v UpdateOutputElasticsearchSecretsSslKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOutputElasticsearchSecretsSslKey1 returns the union data inside the UpdateOutputElasticsearch_Secrets_Ssl_Key as a UpdateOutputElasticsearchSecretsSslKey1
func (t UpdateOutputElasticsearch_Secrets_Ssl_Key) AsUpdateOutputElasticsearchSecretsSslKey1() (UpdateOutputElasticsearchSecretsSslKey1, error) {
	var body UpdateOutputElasticsearchSecretsSslKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputElasticsearchSecretsSslKey1 overwrites any union data inside the UpdateOutputElasticsearch_Secrets_Ssl_Key as the provided UpdateOutputElasticsearchSecretsSslKey1
func (t *UpdateOutputElasticsearch_Secrets_Ssl_Key) FromUpdateOutputElasticsearchSecretsSslKey1(v UpdateOutputElasticsearchSecretsSslKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputElasticsearchSecretsSslKey1 performs a merge with any union data inside the UpdateOutputElasticsearch_Secrets_Ssl_Key, using the provided UpdateOutputElasticsearchSecretsSslKey1
func (t *UpdateOutputElasticsearch_Secrets_Ssl_Key) MergeUpdateOutputElasticsearchSecretsSslKey1(v UpdateOutputElasticsearchSecretsSslKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateOutputElasticsearch_Secrets_Ssl_Key) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateOutputElasticsearch_Secrets_Ssl_Key) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateOutputKafkaSecretsPassword0 returns the union data inside the UpdateOutputKafka_Secrets_Password as a UpdateOutputKafkaSecretsPassword0
func (t UpdateOutputKafka_Secrets_Password) AsUpdateOutputKafkaSecretsPassword0() (UpdateOutputKafkaSecretsPassword0, error) {
	var body UpdateOutputKafkaSecretsPassword0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputKafkaSecretsPassword0 overwrites any union data inside the UpdateOutputKafka_Secrets_Password as the provided UpdateOutputKafkaSecretsPassword0
func (t *UpdateOutputKafka_Secrets_Password) FromUpdateOutputKafkaSecretsPassword0(v UpdateOutputKafkaSecretsPassword0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputKafkaSecretsPassword0 performs a merge with any union data inside the UpdateOutputKafka_Secrets_Password, using the provided UpdateOutputKafkaSecretsPassword0
func (t *UpdateOutputKafka_Secrets_Password) MergeUpdateOutputKafkaSecretsPassword0(v UpdateOutputKafkaSecretsPassword0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOutputKafkaSecretsPassword1 returns the union data inside the UpdateOutputKafka_Secrets_Password as a UpdateOutputKafkaSecretsPassword1
func (t UpdateOutputKafka_Secrets_Password) AsUpdateOutputKafkaSecretsPassword1() (UpdateOutputKafkaSecretsPassword1, error) {
	var body UpdateOutputKafkaSecretsPassword1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputKafkaSecretsPassword1 overwrites any union data inside the UpdateOutputKafka_Secrets_Password as the provided UpdateOutputKafkaSecretsPassword1
func (t *UpdateOutputKafka_Secrets_Password) FromUpdateOutputKafkaSecretsPassword1(v UpdateOutputKafkaSecretsPassword1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputKafkaSecretsPassword1 performs a merge with any union data inside the UpdateOutputKafka_Secrets_Password, using the provided UpdateOutputKafkaSecretsPassword1
func (t *UpdateOutputKafka_Secrets_Password) MergeUpdateOutputKafkaSecretsPassword1(v UpdateOutputKafkaSecretsPassword1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateOutputKafka_Secrets_Password) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateOutputKafka_Secrets_Password) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateOutputKafkaSecretsSslKey0 returns the union data inside the UpdateOutputKafka_Secrets_Ssl_Key as a UpdateOutputKafkaSecretsSslKey0
func (t UpdateOutputKafka_Secrets_Ssl_Key) AsUpdateOutputKafkaSecretsSslKey0() (UpdateOutputKafkaSecretsSslKey0, error) {
	var body UpdateOutputKafkaSecretsSslKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputKafkaSecretsSslKey0 overwrites any union data inside the UpdateOutputKafka_Secrets_Ssl_Key as the provided UpdateOutputKafkaSecretsSslKey0
func (t *UpdateOutputKafka_Secrets_Ssl_Key) FromUpdateOutputKafkaSecretsSslKey0(v UpdateOutputKafkaSecretsSslKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputKafkaSecretsSslKey0 performs a merge with any union data inside the UpdateOutputKafka_Secrets_Ssl_Key, using the provided UpdateOutputKafkaSecretsSslKey0
func (t *UpdateOutputKafka_Secrets_Ssl_Key) MergeUpdateOutputKafkaSecretsSslKey0(v UpdateOutputKafkaSecretsSslKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOutputKafkaSecretsSslKey1 returns the union data inside the UpdateOutputKafka_Secrets_Ssl_Key as a UpdateOutputKafkaSecretsSslKey1
func (t UpdateOutputKafka_Secrets_Ssl_Key) AsUpdateOutputKafkaSecretsSslKey1() (UpdateOutputKafkaSecretsSslKey1, error) {
	var body UpdateOutputKafkaSecretsSslKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputKafkaSecretsSslKey1 overwrites any union data inside the UpdateOutputKafka_Secrets_Ssl_Key as the provided UpdateOutputKafkaSecretsSslKey1
func (t *UpdateOutputKafka_Secrets_Ssl_Key) FromUpdateOutputKafkaSecretsSslKey1(v UpdateOutputKafkaSecretsSslKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputKafkaSecretsSslKey1 performs a merge with any union data inside the UpdateOutputKafka_Secrets_Ssl_Key, using the provided UpdateOutputKafkaSecretsSslKey1
func (t *UpdateOutputKafka_Secrets_Ssl_Key) MergeUpdateOutputKafkaSecretsSslKey1(v UpdateOutputKafkaSecretsSslKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateOutputKafka_Secrets_Ssl_Key) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateOutputKafka_Secrets_Ssl_Key) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateOutputLogstashSecretsSslKey0 returns the union data inside the UpdateOutputLogstash_Secrets_Ssl_Key as a UpdateOutputLogstashSecretsSslKey0
func (t UpdateOutputLogstash_Secrets_Ssl_Key) AsUpdateOutputLogstashSecretsSslKey0() (UpdateOutputLogstashSecretsSslKey0, error) {
	var body UpdateOutputLogstashSecretsSslKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputLogstashSecretsSslKey0 overwrites any union data inside the UpdateOutputLogstash_Secrets_Ssl_Key as the provided UpdateOutputLogstashSecretsSslKey0
func (t *UpdateOutputLogstash_Secrets_Ssl_Key) FromUpdateOutputLogstashSecretsSslKey0(v UpdateOutputLogstashSecretsSslKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputLogstashSecretsSslKey0 performs a merge with any union data inside the UpdateOutputLogstash_Secrets_Ssl_Key, using the provided UpdateOutputLogstashSecretsSslKey0
func (t *UpdateOutputLogstash_Secrets_Ssl_Key) MergeUpdateOutputLogstashSecretsSslKey0(v UpdateOutputLogstashSecretsSslKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOutputLogstashSecretsSslKey1 returns the union data inside the UpdateOutputLogstash_Secrets_Ssl_Key as a UpdateOutputLogstashSecretsSslKey1
func (t UpdateOutputLogstash_Secrets_Ssl_Key) AsUpdateOutputLogstashSecretsSslKey1() (UpdateOutputLogstashSecretsSslKey1, error) {
	var body UpdateOutputLogstashSecretsSslKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputLogstashSecretsSslKey1 overwrites any union data inside the UpdateOutputLogstash_Secrets_Ssl_Key as the provided UpdateOutputLogstashSecretsSslKey1
func (t *UpdateOutputLogstash_Secrets_Ssl_Key) FromUpdateOutputLogstashSecretsSslKey1(v UpdateOutputLogstashSecretsSslKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputLogstashSecretsSslKey1 performs a merge with any union data inside the UpdateOutputLogstash_Secrets_Ssl_Key, using the provided UpdateOutputLogstashSecretsSslKey1
func (t *UpdateOutputLogstash_Secrets_Ssl_Key) MergeUpdateOutputLogstashSecretsSslKey1(v UpdateOutputLogstashSecretsSslKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateOutputLogstash_Secrets_Ssl_Key) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateOutputLogstash_Secrets_Ssl_Key) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateOutputRemoteElasticsearchSecretsServiceToken0 returns the union data inside the UpdateOutputRemoteElasticsearch_Secrets_ServiceToken as a UpdateOutputRemoteElasticsearchSecretsServiceToken0
func (t UpdateOutputRemoteElasticsearch_Secrets_ServiceToken) AsUpdateOutputRemoteElasticsearchSecretsServiceToken0() (UpdateOutputRemoteElasticsearchSecretsServiceToken0, error) {
	var body UpdateOutputRemoteElasticsearchSecretsServiceToken0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputRemoteElasticsearchSecretsServiceToken0 overwrites any union data inside the UpdateOutputRemoteElasticsearch_Secrets_ServiceToken as the provided UpdateOutputRemoteElasticsearchSecretsServiceToken0
func (t *UpdateOutputRemoteElasticsearch_Secrets_ServiceToken) FromUpdateOutputRemoteElasticsearchSecretsServiceToken0(v UpdateOutputRemoteElasticsearchSecretsServiceToken0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputRemoteElasticsearchSecretsServiceToken0 performs a merge with any union data inside the UpdateOutputRemoteElasticsearch_Secrets_ServiceToken, using the provided UpdateOutputRemoteElasticsearchSecretsServiceToken0
func (t *UpdateOutputRemoteElasticsearch_Secrets_ServiceToken) MergeUpdateOutputRemoteElasticsearchSecretsServiceToken0(v UpdateOutputRemoteElasticsearchSecretsServiceToken0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOutputRemoteElasticsearchSecretsServiceToken1 returns the union data inside the UpdateOutputRemoteElasticsearch_Secrets_ServiceToken as a UpdateOutputRemoteElasticsearchSecretsServiceToken1
func (t UpdateOutputRemoteElasticsearch_Secrets_ServiceToken) AsUpdateOutputRemoteElasticsearchSecretsServiceToken1() (UpdateOutputRemoteElasticsearchSecretsServiceToken1, error) {
	var body UpdateOutputRemoteElasticsearchSecretsServiceToken1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputRemoteElasticsearchSecretsServiceToken1 overwrites any union data inside the UpdateOutputRemoteElasticsearch_Secrets_ServiceToken as the provided UpdateOutputRemoteElasticsearchSecretsServiceToken1
func (t *UpdateOutputRemoteElasticsearch_Secrets_ServiceToken) FromUpdateOutputRemoteElasticsearchSecretsServiceToken1(v UpdateOutputRemoteElasticsearchSecretsServiceToken1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputRemoteElasticsearchSecretsServiceToken1 performs a merge with any union data inside the UpdateOutputRemoteElasticsearch_Secrets_ServiceToken, using the provided UpdateOutputRemoteElasticsearchSecretsServiceToken1
func (t *UpdateOutputRemoteElasticsearch_Secrets_ServiceToken) MergeUpdateOutputRemoteElasticsearchSecretsServiceToken1(v UpdateOutputRemoteElasticsearchSecretsServiceToken1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateOutputRemoteElasticsearch_Secrets_ServiceToken) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateOutputRemoteElasticsearch_Secrets_ServiceToken) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateOutputRemoteElasticsearchSecretsSslKey0 returns the union data inside the UpdateOutputRemoteElasticsearch_Secrets_Ssl_Key as a UpdateOutputRemoteElasticsearchSecretsSslKey0
func (t UpdateOutputRemoteElasticsearch_Secrets_Ssl_Key) AsUpdateOutputRemoteElasticsearchSecretsSslKey0() (UpdateOutputRemoteElasticsearchSecretsSslKey0, error) {
	var body UpdateOutputRemoteElasticsearchSecretsSslKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputRemoteElasticsearchSecretsSslKey0 overwrites any union data inside the UpdateOutputRemoteElasticsearch_Secrets_Ssl_Key as the provided UpdateOutputRemoteElasticsearchSecretsSslKey0
func (t *UpdateOutputRemoteElasticsearch_Secrets_Ssl_Key) FromUpdateOutputRemoteElasticsearchSecretsSslKey0(v UpdateOutputRemoteElasticsearchSecretsSslKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputRemoteElasticsearchSecretsSslKey0 performs a merge with any union data inside the UpdateOutputRemoteElasticsearch_Secrets_Ssl_Key, using the provided UpdateOutputRemoteElasticsearchSecretsSslKey0
func (t *UpdateOutputRemoteElasticsearch_Secrets_Ssl_Key) MergeUpdateOutputRemoteElasticsearchSecretsSslKey0(v UpdateOutputRemoteElasticsearchSecretsSslKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOutputRemoteElasticsearchSecretsSslKey1 returns the union data inside the UpdateOutputRemoteElasticsearch_Secrets_Ssl_Key as a UpdateOutputRemoteElasticsearchSecretsSslKey1
func (t UpdateOutputRemoteElasticsearch_Secrets_Ssl_Key) AsUpdateOutputRemoteElasticsearchSecretsSslKey1() (UpdateOutputRemoteElasticsearchSecretsSslKey1, error) {
	var body UpdateOutputRemoteElasticsearchSecretsSslKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputRemoteElasticsearchSecretsSslKey1 overwrites any union data inside the UpdateOutputRemoteElasticsearch_Secrets_Ssl_Key as the provided UpdateOutputRemoteElasticsearchSecretsSslKey1
func (t *UpdateOutputRemoteElasticsearch_Secrets_Ssl_Key) FromUpdateOutputRemoteElasticsearchSecretsSslKey1(v UpdateOutputRemoteElasticsearchSecretsSslKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputRemoteElasticsearchSecretsSslKey1 performs a merge with any union data inside the UpdateOutputRemoteElasticsearch_Secrets_Ssl_Key, using the provided UpdateOutputRemoteElasticsearchSecretsSslKey1
func (t *UpdateOutputRemoteElasticsearch_Secrets_Ssl_Key) MergeUpdateOutputRemoteElasticsearchSecretsSslKey1(v UpdateOutputRemoteElasticsearchSecretsSslKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateOutputRemoteElasticsearch_Secrets_Ssl_Key) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateOutputRemoteElasticsearch_Secrets_Ssl_Key) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateOutputElasticsearch returns the union data inside the UpdateOutputUnion as a UpdateOutputElasticsearch
func (t UpdateOutputUnion) AsUpdateOutputElasticsearch() (UpdateOutputElasticsearch, error) {
	var body UpdateOutputElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputElasticsearch overwrites any union data inside the UpdateOutputUnion as the provided UpdateOutputElasticsearch
func (t *UpdateOutputUnion) FromUpdateOutputElasticsearch(v UpdateOutputElasticsearch) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputElasticsearch performs a merge with any union data inside the UpdateOutputUnion, using the provided UpdateOutputElasticsearch
func (t *UpdateOutputUnion) MergeUpdateOutputElasticsearch(v UpdateOutputElasticsearch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOutputRemoteElasticsearch returns the union data inside the UpdateOutputUnion as a UpdateOutputRemoteElasticsearch
func (t UpdateOutputUnion) AsUpdateOutputRemoteElasticsearch() (UpdateOutputRemoteElasticsearch, error) {
	var body UpdateOutputRemoteElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputRemoteElasticsearch overwrites any union data inside the UpdateOutputUnion as the provided UpdateOutputRemoteElasticsearch
func (t *UpdateOutputUnion) FromUpdateOutputRemoteElasticsearch(v UpdateOutputRemoteElasticsearch) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputRemoteElasticsearch performs a merge with any union data inside the UpdateOutputUnion, using the provided UpdateOutputRemoteElasticsearch
func (t *UpdateOutputUnion) MergeUpdateOutputRemoteElasticsearch(v UpdateOutputRemoteElasticsearch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOutputLogstash returns the union data inside the UpdateOutputUnion as a UpdateOutputLogstash
func (t UpdateOutputUnion) AsUpdateOutputLogstash() (UpdateOutputLogstash, error) {
	var body UpdateOutputLogstash
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputLogstash overwrites any union data inside the UpdateOutputUnion as the provided UpdateOutputLogstash
func (t *UpdateOutputUnion) FromUpdateOutputLogstash(v UpdateOutputLogstash) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputLogstash performs a merge with any union data inside the UpdateOutputUnion, using the provided UpdateOutputLogstash
func (t *UpdateOutputUnion) MergeUpdateOutputLogstash(v UpdateOutputLogstash) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOutputKafka returns the union data inside the UpdateOutputUnion as a UpdateOutputKafka
func (t UpdateOutputUnion) AsUpdateOutputKafka() (UpdateOutputKafka, error) {
	var body UpdateOutputKafka
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputKafka overwrites any union data inside the UpdateOutputUnion as the provided UpdateOutputKafka
func (t *UpdateOutputUnion) FromUpdateOutputKafka(v UpdateOutputKafka) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputKafka performs a merge with any union data inside the UpdateOutputUnion, using the provided UpdateOutputKafka
func (t *UpdateOutputUnion) MergeUpdateOutputKafka(v UpdateOutputKafka) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateOutputUnion) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateOutputUnion) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// Override default JSON handling for CreateConnectorConfig to handle AdditionalProperties and union
func (a *CreateConnectorConfig) UnmarshalJSON(b []byte) error {
	err := a.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateConnectorConfig to handle AdditionalProperties and union
func (a CreateConnectorConfig) MarshalJSON() ([]byte, error) {
	var err error
	b, err := a.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if a.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Override default JSON handling for CreateConnectorSecrets to handle AdditionalProperties and union
func (a *CreateConnectorSecrets) UnmarshalJSON(b []byte) error {
	err := a.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateConnectorSecrets to handle AdditionalProperties and union
func (a CreateConnectorSecrets) MarshalJSON() ([]byte, error) {
	var err error
	b, err := a.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if a.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Override default JSON handling for UpdateConnectorConfig to handle AdditionalProperties and union
func (a *UpdateConnectorConfig) UnmarshalJSON(b []byte) error {
	err := a.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateConnectorConfig to handle AdditionalProperties and union
func (a UpdateConnectorConfig) MarshalJSON() ([]byte, error) {
	var err error
	b, err := a.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if a.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Override default JSON handling for UpdateConnectorSecrets to handle AdditionalProperties and union
func (a *UpdateConnectorSecrets) UnmarshalJSON(b []byte) error {
	err := a.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateConnectorSecrets to handle AdditionalProperties and union
func (a UpdateConnectorSecrets) MarshalJSON() ([]byte, error) {
	var err error
	b, err := a.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if a.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// DeleteAgentConfigurationWithBody request with any body
	DeleteAgentConfigurationWithBody(ctx context.Context, params *DeleteAgentConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteAgentConfiguration(ctx context.Context, params *DeleteAgentConfigurationParams, body DeleteAgentConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAgentConfigurations request
	GetAgentConfigurations(ctx context.Context, params *GetAgentConfigurationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateUpdateAgentConfigurationWithBody request with any body
	CreateUpdateAgentConfigurationWithBody(ctx context.Context, params *CreateUpdateAgentConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateUpdateAgentConfiguration(ctx context.Context, params *CreateUpdateAgentConfigurationParams, body CreateUpdateAgentConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRule request
	DeleteRule(ctx context.Context, params *DeleteRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadRule request
	ReadRule(ctx context.Context, params *ReadRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateRuleWithBody request with any body
	CreateRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateRule(ctx context.Context, body CreateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRuleWithBody request with any body
	UpdateRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRule(ctx context.Context, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFleetAgentPolicies request
	GetFleetAgentPolicies(ctx context.Context, params *GetFleetAgentPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFleetAgentPoliciesWithBody request with any body
	PostFleetAgentPoliciesWithBody(ctx context.Context, params *PostFleetAgentPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFleetAgentPolicies(ctx context.Context, params *PostFleetAgentPoliciesParams, body PostFleetAgentPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFleetAgentPoliciesDeleteWithBody request with any body
	PostFleetAgentPoliciesDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFleetAgentPoliciesDelete(ctx context.Context, body PostFleetAgentPoliciesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFleetAgentPoliciesAgentpolicyid request
	GetFleetAgentPoliciesAgentpolicyid(ctx context.Context, agentPolicyId string, params *GetFleetAgentPoliciesAgentpolicyidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutFleetAgentPoliciesAgentpolicyidWithBody request with any body
	PutFleetAgentPoliciesAgentpolicyidWithBody(ctx context.Context, agentPolicyId string, params *PutFleetAgentPoliciesAgentpolicyidParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutFleetAgentPoliciesAgentpolicyid(ctx context.Context, agentPolicyId string, params *PutFleetAgentPoliciesAgentpolicyidParams, body PutFleetAgentPoliciesAgentpolicyidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFleetEnrollmentApiKeys request
	GetFleetEnrollmentApiKeys(ctx context.Context, params *GetFleetEnrollmentApiKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFleetEpmPackages request
	GetFleetEpmPackages(ctx context.Context, params *GetFleetEpmPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFleetEpmPackagesWithBody request with any body
	PostFleetEpmPackagesWithBody(ctx context.Context, params *PostFleetEpmPackagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFleetEpmPackagesPkgnamePkgversion request
	DeleteFleetEpmPackagesPkgnamePkgversion(ctx context.Context, pkgName string, pkgVersion string, params *DeleteFleetEpmPackagesPkgnamePkgversionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFleetEpmPackagesPkgnamePkgversion request
	GetFleetEpmPackagesPkgnamePkgversion(ctx context.Context, pkgName string, pkgVersion string, params *GetFleetEpmPackagesPkgnamePkgversionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFleetEpmPackagesPkgnamePkgversionWithBody request with any body
	PostFleetEpmPackagesPkgnamePkgversionWithBody(ctx context.Context, pkgName string, pkgVersion string, params *PostFleetEpmPackagesPkgnamePkgversionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFleetEpmPackagesPkgnamePkgversion(ctx context.Context, pkgName string, pkgVersion string, params *PostFleetEpmPackagesPkgnamePkgversionParams, body PostFleetEpmPackagesPkgnamePkgversionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFleetFleetServerHosts request
	GetFleetFleetServerHosts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFleetFleetServerHostsWithBody request with any body
	PostFleetFleetServerHostsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFleetFleetServerHosts(ctx context.Context, body PostFleetFleetServerHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFleetFleetServerHostsItemid request
	DeleteFleetFleetServerHostsItemid(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFleetFleetServerHostsItemid request
	GetFleetFleetServerHostsItemid(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutFleetFleetServerHostsItemidWithBody request with any body
	PutFleetFleetServerHostsItemidWithBody(ctx context.Context, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutFleetFleetServerHostsItemid(ctx context.Context, itemId string, body PutFleetFleetServerHostsItemidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFleetOutputs request
	GetFleetOutputs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFleetOutputsWithBody request with any body
	PostFleetOutputsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFleetOutputs(ctx context.Context, body PostFleetOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFleetOutputsOutputid request
	DeleteFleetOutputsOutputid(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFleetOutputsOutputid request
	GetFleetOutputsOutputid(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutFleetOutputsOutputidWithBody request with any body
	PutFleetOutputsOutputidWithBody(ctx context.Context, outputId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutFleetOutputsOutputid(ctx context.Context, outputId string, body PutFleetOutputsOutputidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFleetPackagePolicies request
	GetFleetPackagePolicies(ctx context.Context, params *GetFleetPackagePoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFleetPackagePoliciesWithBody request with any body
	PostFleetPackagePoliciesWithBody(ctx context.Context, params *PostFleetPackagePoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFleetPackagePolicies(ctx context.Context, params *PostFleetPackagePoliciesParams, body PostFleetPackagePoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFleetPackagePoliciesPackagepolicyid request
	DeleteFleetPackagePoliciesPackagepolicyid(ctx context.Context, packagePolicyId string, params *DeleteFleetPackagePoliciesPackagepolicyidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFleetPackagePoliciesPackagepolicyid request
	GetFleetPackagePoliciesPackagepolicyid(ctx context.Context, packagePolicyId string, params *GetFleetPackagePoliciesPackagepolicyidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutFleetPackagePoliciesPackagepolicyidWithBody request with any body
	PutFleetPackagePoliciesPackagepolicyidWithBody(ctx context.Context, packagePolicyId string, params *PutFleetPackagePoliciesPackagepolicyidParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutFleetPackagePoliciesPackagepolicyid(ctx context.Context, packagePolicyId string, params *PutFleetPackagePoliciesPackagepolicyidParams, body PutFleetPackagePoliciesPackagepolicyidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostParametersWithBody request with any body
	PostParametersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostParameters(ctx context.Context, body PostParametersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteParameter request
	DeleteParameter(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetParameter request
	GetParameter(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutParameterWithBody request with any body
	PutParameterWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutParameter(ctx context.Context, id string, body PutParameterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteActionsConnectorId request
	DeleteActionsConnectorId(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActionsConnectorId request
	GetActionsConnectorId(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostActionsConnectorIdWithBody request with any body
	PostActionsConnectorIdWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostActionsConnectorId(ctx context.Context, spaceId SpaceId, id string, body PostActionsConnectorIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutActionsConnectorIdWithBody request with any body
	PutActionsConnectorIdWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutActionsConnectorId(ctx context.Context, spaceId SpaceId, id string, body PutActionsConnectorIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetActionsConnectors request
	GetActionsConnectors(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllDataViewsDefault request
	GetAllDataViewsDefault(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDataViewDefaultwWithBody request with any body
	CreateDataViewDefaultwWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDataViewDefaultw(ctx context.Context, spaceId SpaceId, body CreateDataViewDefaultwJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDataViewDefault request
	DeleteDataViewDefault(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataViewDefault request
	GetDataViewDefault(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDataViewDefaultWithBody request with any body
	UpdateDataViewDefaultWithBody(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDataViewDefault(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, body UpdateDataViewDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) DeleteAgentConfigurationWithBody(ctx context.Context, params *DeleteAgentConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAgentConfigurationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAgentConfiguration(ctx context.Context, params *DeleteAgentConfigurationParams, body DeleteAgentConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAgentConfigurationRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAgentConfigurations(ctx context.Context, params *GetAgentConfigurationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAgentConfigurationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUpdateAgentConfigurationWithBody(ctx context.Context, params *CreateUpdateAgentConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUpdateAgentConfigurationRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateUpdateAgentConfiguration(ctx context.Context, params *CreateUpdateAgentConfigurationParams, body CreateUpdateAgentConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateUpdateAgentConfigurationRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRule(ctx context.Context, params *DeleteRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRuleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadRule(ctx context.Context, params *ReadRuleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadRuleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRuleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateRule(ctx context.Context, body CreateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRuleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRuleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRule(ctx context.Context, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRuleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFleetAgentPolicies(ctx context.Context, params *GetFleetAgentPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetAgentPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetAgentPoliciesWithBody(ctx context.Context, params *PostFleetAgentPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetAgentPoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetAgentPolicies(ctx context.Context, params *PostFleetAgentPoliciesParams, body PostFleetAgentPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetAgentPoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetAgentPoliciesDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetAgentPoliciesDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetAgentPoliciesDelete(ctx context.Context, body PostFleetAgentPoliciesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetAgentPoliciesDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFleetAgentPoliciesAgentpolicyid(ctx context.Context, agentPolicyId string, params *GetFleetAgentPoliciesAgentpolicyidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetAgentPoliciesAgentpolicyidRequest(c.Server, agentPolicyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutFleetAgentPoliciesAgentpolicyidWithBody(ctx context.Context, agentPolicyId string, params *PutFleetAgentPoliciesAgentpolicyidParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutFleetAgentPoliciesAgentpolicyidRequestWithBody(c.Server, agentPolicyId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutFleetAgentPoliciesAgentpolicyid(ctx context.Context, agentPolicyId string, params *PutFleetAgentPoliciesAgentpolicyidParams, body PutFleetAgentPoliciesAgentpolicyidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutFleetAgentPoliciesAgentpolicyidRequest(c.Server, agentPolicyId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFleetEnrollmentApiKeys(ctx context.Context, params *GetFleetEnrollmentApiKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetEnrollmentApiKeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFleetEpmPackages(ctx context.Context, params *GetFleetEpmPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetEpmPackagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetEpmPackagesWithBody(ctx context.Context, params *PostFleetEpmPackagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetEpmPackagesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFleetEpmPackagesPkgnamePkgversion(ctx context.Context, pkgName string, pkgVersion string, params *DeleteFleetEpmPackagesPkgnamePkgversionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFleetEpmPackagesPkgnamePkgversionRequest(c.Server, pkgName, pkgVersion, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFleetEpmPackagesPkgnamePkgversion(ctx context.Context, pkgName string, pkgVersion string, params *GetFleetEpmPackagesPkgnamePkgversionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetEpmPackagesPkgnamePkgversionRequest(c.Server, pkgName, pkgVersion, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetEpmPackagesPkgnamePkgversionWithBody(ctx context.Context, pkgName string, pkgVersion string, params *PostFleetEpmPackagesPkgnamePkgversionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetEpmPackagesPkgnamePkgversionRequestWithBody(c.Server, pkgName, pkgVersion, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetEpmPackagesPkgnamePkgversion(ctx context.Context, pkgName string, pkgVersion string, params *PostFleetEpmPackagesPkgnamePkgversionParams, body PostFleetEpmPackagesPkgnamePkgversionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetEpmPackagesPkgnamePkgversionRequest(c.Server, pkgName, pkgVersion, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFleetFleetServerHosts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetFleetServerHostsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetFleetServerHostsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetFleetServerHostsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetFleetServerHosts(ctx context.Context, body PostFleetFleetServerHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetFleetServerHostsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFleetFleetServerHostsItemid(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFleetFleetServerHostsItemidRequest(c.Server, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFleetFleetServerHostsItemid(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetFleetServerHostsItemidRequest(c.Server, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutFleetFleetServerHostsItemidWithBody(ctx context.Context, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutFleetFleetServerHostsItemidRequestWithBody(c.Server, itemId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutFleetFleetServerHostsItemid(ctx context.Context, itemId string, body PutFleetFleetServerHostsItemidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutFleetFleetServerHostsItemidRequest(c.Server, itemId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFleetOutputs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetOutputsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetOutputsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetOutputsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetOutputs(ctx context.Context, body PostFleetOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetOutputsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFleetOutputsOutputid(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFleetOutputsOutputidRequest(c.Server, outputId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFleetOutputsOutputid(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetOutputsOutputidRequest(c.Server, outputId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutFleetOutputsOutputidWithBody(ctx context.Context, outputId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutFleetOutputsOutputidRequestWithBody(c.Server, outputId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutFleetOutputsOutputid(ctx context.Context, outputId string, body PutFleetOutputsOutputidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutFleetOutputsOutputidRequest(c.Server, outputId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFleetPackagePolicies(ctx context.Context, params *GetFleetPackagePoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetPackagePoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetPackagePoliciesWithBody(ctx context.Context, params *PostFleetPackagePoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetPackagePoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetPackagePolicies(ctx context.Context, params *PostFleetPackagePoliciesParams, body PostFleetPackagePoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetPackagePoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFleetPackagePoliciesPackagepolicyid(ctx context.Context, packagePolicyId string, params *DeleteFleetPackagePoliciesPackagepolicyidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFleetPackagePoliciesPackagepolicyidRequest(c.Server, packagePolicyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFleetPackagePoliciesPackagepolicyid(ctx context.Context, packagePolicyId string, params *GetFleetPackagePoliciesPackagepolicyidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetPackagePoliciesPackagepolicyidRequest(c.Server, packagePolicyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutFleetPackagePoliciesPackagepolicyidWithBody(ctx context.Context, packagePolicyId string, params *PutFleetPackagePoliciesPackagepolicyidParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutFleetPackagePoliciesPackagepolicyidRequestWithBody(c.Server, packagePolicyId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutFleetPackagePoliciesPackagepolicyid(ctx context.Context, packagePolicyId string, params *PutFleetPackagePoliciesPackagepolicyidParams, body PutFleetPackagePoliciesPackagepolicyidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutFleetPackagePoliciesPackagepolicyidRequest(c.Server, packagePolicyId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostParametersWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostParametersRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostParameters(ctx context.Context, body PostParametersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostParametersRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteParameter(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteParameterRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetParameter(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetParameterRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutParameterWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutParameterRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutParameter(ctx context.Context, id string, body PutParameterJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutParameterRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteActionsConnectorId(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteActionsConnectorIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActionsConnectorId(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActionsConnectorIdRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostActionsConnectorIdWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostActionsConnectorIdRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostActionsConnectorId(ctx context.Context, spaceId SpaceId, id string, body PostActionsConnectorIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostActionsConnectorIdRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutActionsConnectorIdWithBody(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutActionsConnectorIdRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutActionsConnectorId(ctx context.Context, spaceId SpaceId, id string, body PutActionsConnectorIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutActionsConnectorIdRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetActionsConnectors(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetActionsConnectorsRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllDataViewsDefault(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllDataViewsDefaultRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDataViewDefaultwWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDataViewDefaultwRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDataViewDefaultw(ctx context.Context, spaceId SpaceId, body CreateDataViewDefaultwJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDataViewDefaultwRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDataViewDefault(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDataViewDefaultRequest(c.Server, spaceId, viewId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataViewDefault(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataViewDefaultRequest(c.Server, spaceId, viewId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDataViewDefaultWithBody(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDataViewDefaultRequestWithBody(c.Server, spaceId, viewId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDataViewDefault(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, body UpdateDataViewDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDataViewDefaultRequest(c.Server, spaceId, viewId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewDeleteAgentConfigurationRequest calls the generic DeleteAgentConfiguration builder with application/json body
func NewDeleteAgentConfigurationRequest(server string, params *DeleteAgentConfigurationParams, body DeleteAgentConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteAgentConfigurationRequestWithBody(server, params, "application/json", bodyReader)
}

// NewDeleteAgentConfigurationRequestWithBody generates requests for DeleteAgentConfiguration with any type of body
func NewDeleteAgentConfigurationRequestWithBody(server string, params *DeleteAgentConfigurationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/apm/settings/agent-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "elastic-api-version", runtime.ParamLocationHeader, params.ElasticApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("elastic-api-version", headerParam0)

	}

	return req, nil
}

// NewGetAgentConfigurationsRequest generates requests for GetAgentConfigurations
func NewGetAgentConfigurationsRequest(server string, params *GetAgentConfigurationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/apm/settings/agent-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "elastic-api-version", runtime.ParamLocationHeader, params.ElasticApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("elastic-api-version", headerParam0)

	}

	return req, nil
}

// NewCreateUpdateAgentConfigurationRequest calls the generic CreateUpdateAgentConfiguration builder with application/json body
func NewCreateUpdateAgentConfigurationRequest(server string, params *CreateUpdateAgentConfigurationParams, body CreateUpdateAgentConfigurationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateUpdateAgentConfigurationRequestWithBody(server, params, "application/json", bodyReader)
}

// NewCreateUpdateAgentConfigurationRequestWithBody generates requests for CreateUpdateAgentConfiguration with any type of body
func NewCreateUpdateAgentConfigurationRequestWithBody(server string, params *CreateUpdateAgentConfigurationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/apm/settings/agent-configuration")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Overwrite != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "overwrite", runtime.ParamLocationQuery, *params.Overwrite); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "elastic-api-version", runtime.ParamLocationHeader, params.ElasticApiVersion)
		if err != nil {
			return nil, err
		}

		req.Header.Set("elastic-api-version", headerParam0)

	}

	return req, nil
}

// NewDeleteRuleRequest generates requests for DeleteRule
func NewDeleteRuleRequest(server string, params *DeleteRuleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/detection_engine/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RuleId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rule_id", runtime.ParamLocationQuery, *params.RuleId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadRuleRequest generates requests for ReadRule
func NewReadRuleRequest(server string, params *ReadRuleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/detection_engine/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Id != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RuleId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rule_id", runtime.ParamLocationQuery, *params.RuleId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateRuleRequest calls the generic CreateRule builder with application/json body
func NewCreateRuleRequest(server string, body CreateRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateRuleRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateRuleRequestWithBody generates requests for CreateRule with any type of body
func NewCreateRuleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/detection_engine/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateRuleRequest calls the generic UpdateRule builder with application/json body
func NewUpdateRuleRequest(server string, body UpdateRuleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRuleRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateRuleRequestWithBody generates requests for UpdateRule with any type of body
func NewUpdateRuleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/detection_engine/rules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFleetAgentPoliciesRequest generates requests for GetFleetAgentPolicies
func NewGetFleetAgentPoliciesRequest(server string, params *GetFleetAgentPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/agent_policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortField", runtime.ParamLocationQuery, *params.SortField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowUpgradeable != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "showUpgradeable", runtime.ParamLocationQuery, *params.ShowUpgradeable); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kuery != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kuery", runtime.ParamLocationQuery, *params.Kuery); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NoAgentCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "noAgentCount", runtime.ParamLocationQuery, *params.NoAgentCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithAgentCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withAgentCount", runtime.ParamLocationQuery, *params.WithAgentCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Full != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full", runtime.ParamLocationQuery, *params.Full); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostFleetAgentPoliciesRequest calls the generic PostFleetAgentPolicies builder with application/json body
func NewPostFleetAgentPoliciesRequest(server string, params *PostFleetAgentPoliciesParams, body PostFleetAgentPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFleetAgentPoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostFleetAgentPoliciesRequestWithBody generates requests for PostFleetAgentPolicies with any type of body
func NewPostFleetAgentPoliciesRequestWithBody(server string, params *PostFleetAgentPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/agent_policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SysMonitoring != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sys_monitoring", runtime.ParamLocationQuery, *params.SysMonitoring); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostFleetAgentPoliciesDeleteRequest calls the generic PostFleetAgentPoliciesDelete builder with application/json body
func NewPostFleetAgentPoliciesDeleteRequest(server string, body PostFleetAgentPoliciesDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFleetAgentPoliciesDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewPostFleetAgentPoliciesDeleteRequestWithBody generates requests for PostFleetAgentPoliciesDelete with any type of body
func NewPostFleetAgentPoliciesDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/agent_policies/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFleetAgentPoliciesAgentpolicyidRequest generates requests for GetFleetAgentPoliciesAgentpolicyid
func NewGetFleetAgentPoliciesAgentpolicyidRequest(server string, agentPolicyId string, params *GetFleetAgentPoliciesAgentpolicyidParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agentPolicyId", runtime.ParamLocationPath, agentPolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/agent_policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutFleetAgentPoliciesAgentpolicyidRequest calls the generic PutFleetAgentPoliciesAgentpolicyid builder with application/json body
func NewPutFleetAgentPoliciesAgentpolicyidRequest(server string, agentPolicyId string, params *PutFleetAgentPoliciesAgentpolicyidParams, body PutFleetAgentPoliciesAgentpolicyidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutFleetAgentPoliciesAgentpolicyidRequestWithBody(server, agentPolicyId, params, "application/json", bodyReader)
}

// NewPutFleetAgentPoliciesAgentpolicyidRequestWithBody generates requests for PutFleetAgentPoliciesAgentpolicyid with any type of body
func NewPutFleetAgentPoliciesAgentpolicyidRequestWithBody(server string, agentPolicyId string, params *PutFleetAgentPoliciesAgentpolicyidParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agentPolicyId", runtime.ParamLocationPath, agentPolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/agent_policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFleetEnrollmentApiKeysRequest generates requests for GetFleetEnrollmentApiKeys
func NewGetFleetEnrollmentApiKeysRequest(server string, params *GetFleetEnrollmentApiKeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/enrollment_api_keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kuery != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kuery", runtime.ParamLocationQuery, *params.Kuery); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFleetEpmPackagesRequest generates requests for GetFleetEpmPackages
func NewGetFleetEpmPackagesRequest(server string, params *GetFleetEpmPackagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/epm/packages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Category != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category", runtime.ParamLocationQuery, *params.Category); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Prerelease != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prerelease", runtime.ParamLocationQuery, *params.Prerelease); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeInstallStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeInstallStatus", runtime.ParamLocationQuery, *params.ExcludeInstallStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithPackagePoliciesCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withPackagePoliciesCount", runtime.ParamLocationQuery, *params.WithPackagePoliciesCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostFleetEpmPackagesRequestWithBody generates requests for PostFleetEpmPackages with any type of body
func NewPostFleetEpmPackagesRequestWithBody(server string, params *PostFleetEpmPackagesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/epm/packages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IgnoreMappingUpdateErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignoreMappingUpdateErrors", runtime.ParamLocationQuery, *params.IgnoreMappingUpdateErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipDataStreamRollover != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipDataStreamRollover", runtime.ParamLocationQuery, *params.SkipDataStreamRollover); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFleetEpmPackagesPkgnamePkgversionRequest generates requests for DeleteFleetEpmPackagesPkgnamePkgversion
func NewDeleteFleetEpmPackagesPkgnamePkgversionRequest(server string, pkgName string, pkgVersion string, params *DeleteFleetEpmPackagesPkgnamePkgversionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pkgName", runtime.ParamLocationPath, pkgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pkgVersion", runtime.ParamLocationPath, pkgVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/epm/packages/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFleetEpmPackagesPkgnamePkgversionRequest generates requests for GetFleetEpmPackagesPkgnamePkgversion
func NewGetFleetEpmPackagesPkgnamePkgversionRequest(server string, pkgName string, pkgVersion string, params *GetFleetEpmPackagesPkgnamePkgversionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pkgName", runtime.ParamLocationPath, pkgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pkgVersion", runtime.ParamLocationPath, pkgVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/epm/packages/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IgnoreUnverified != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignoreUnverified", runtime.ParamLocationQuery, *params.IgnoreUnverified); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Prerelease != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prerelease", runtime.ParamLocationQuery, *params.Prerelease); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Full != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full", runtime.ParamLocationQuery, *params.Full); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithMetadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withMetadata", runtime.ParamLocationQuery, *params.WithMetadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostFleetEpmPackagesPkgnamePkgversionRequest calls the generic PostFleetEpmPackagesPkgnamePkgversion builder with application/json body
func NewPostFleetEpmPackagesPkgnamePkgversionRequest(server string, pkgName string, pkgVersion string, params *PostFleetEpmPackagesPkgnamePkgversionParams, body PostFleetEpmPackagesPkgnamePkgversionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFleetEpmPackagesPkgnamePkgversionRequestWithBody(server, pkgName, pkgVersion, params, "application/json", bodyReader)
}

// NewPostFleetEpmPackagesPkgnamePkgversionRequestWithBody generates requests for PostFleetEpmPackagesPkgnamePkgversion with any type of body
func NewPostFleetEpmPackagesPkgnamePkgversionRequestWithBody(server string, pkgName string, pkgVersion string, params *PostFleetEpmPackagesPkgnamePkgversionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pkgName", runtime.ParamLocationPath, pkgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pkgVersion", runtime.ParamLocationPath, pkgVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/epm/packages/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Prerelease != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prerelease", runtime.ParamLocationQuery, *params.Prerelease); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IgnoreMappingUpdateErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignoreMappingUpdateErrors", runtime.ParamLocationQuery, *params.IgnoreMappingUpdateErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipDataStreamRollover != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipDataStreamRollover", runtime.ParamLocationQuery, *params.SkipDataStreamRollover); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFleetFleetServerHostsRequest generates requests for GetFleetFleetServerHosts
func NewGetFleetFleetServerHostsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/fleet_server_hosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostFleetFleetServerHostsRequest calls the generic PostFleetFleetServerHosts builder with application/json body
func NewPostFleetFleetServerHostsRequest(server string, body PostFleetFleetServerHostsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFleetFleetServerHostsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostFleetFleetServerHostsRequestWithBody generates requests for PostFleetFleetServerHosts with any type of body
func NewPostFleetFleetServerHostsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/fleet_server_hosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFleetFleetServerHostsItemidRequest generates requests for DeleteFleetFleetServerHostsItemid
func NewDeleteFleetFleetServerHostsItemidRequest(server string, itemId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/fleet_server_hosts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFleetFleetServerHostsItemidRequest generates requests for GetFleetFleetServerHostsItemid
func NewGetFleetFleetServerHostsItemidRequest(server string, itemId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/fleet_server_hosts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutFleetFleetServerHostsItemidRequest calls the generic PutFleetFleetServerHostsItemid builder with application/json body
func NewPutFleetFleetServerHostsItemidRequest(server string, itemId string, body PutFleetFleetServerHostsItemidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutFleetFleetServerHostsItemidRequestWithBody(server, itemId, "application/json", bodyReader)
}

// NewPutFleetFleetServerHostsItemidRequestWithBody generates requests for PutFleetFleetServerHostsItemid with any type of body
func NewPutFleetFleetServerHostsItemidRequestWithBody(server string, itemId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/fleet_server_hosts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFleetOutputsRequest generates requests for GetFleetOutputs
func NewGetFleetOutputsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/outputs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostFleetOutputsRequest calls the generic PostFleetOutputs builder with application/json body
func NewPostFleetOutputsRequest(server string, body PostFleetOutputsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFleetOutputsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostFleetOutputsRequestWithBody generates requests for PostFleetOutputs with any type of body
func NewPostFleetOutputsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/outputs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFleetOutputsOutputidRequest generates requests for DeleteFleetOutputsOutputid
func NewDeleteFleetOutputsOutputidRequest(server string, outputId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "outputId", runtime.ParamLocationPath, outputId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/outputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFleetOutputsOutputidRequest generates requests for GetFleetOutputsOutputid
func NewGetFleetOutputsOutputidRequest(server string, outputId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "outputId", runtime.ParamLocationPath, outputId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/outputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutFleetOutputsOutputidRequest calls the generic PutFleetOutputsOutputid builder with application/json body
func NewPutFleetOutputsOutputidRequest(server string, outputId string, body PutFleetOutputsOutputidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutFleetOutputsOutputidRequestWithBody(server, outputId, "application/json", bodyReader)
}

// NewPutFleetOutputsOutputidRequestWithBody generates requests for PutFleetOutputsOutputid with any type of body
func NewPutFleetOutputsOutputidRequestWithBody(server string, outputId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "outputId", runtime.ParamLocationPath, outputId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/outputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFleetPackagePoliciesRequest generates requests for GetFleetPackagePolicies
func NewGetFleetPackagePoliciesRequest(server string, params *GetFleetPackagePoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/package_policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortField", runtime.ParamLocationQuery, *params.SortField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowUpgradeable != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "showUpgradeable", runtime.ParamLocationQuery, *params.ShowUpgradeable); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kuery != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kuery", runtime.ParamLocationQuery, *params.Kuery); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithAgentCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withAgentCount", runtime.ParamLocationQuery, *params.WithAgentCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostFleetPackagePoliciesRequest calls the generic PostFleetPackagePolicies builder with application/json body
func NewPostFleetPackagePoliciesRequest(server string, params *PostFleetPackagePoliciesParams, body PostFleetPackagePoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFleetPackagePoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostFleetPackagePoliciesRequestWithBody generates requests for PostFleetPackagePolicies with any type of body
func NewPostFleetPackagePoliciesRequestWithBody(server string, params *PostFleetPackagePoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/package_policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFleetPackagePoliciesPackagepolicyidRequest generates requests for DeleteFleetPackagePoliciesPackagepolicyid
func NewDeleteFleetPackagePoliciesPackagepolicyidRequest(server string, packagePolicyId string, params *DeleteFleetPackagePoliciesPackagepolicyidParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "packagePolicyId", runtime.ParamLocationPath, packagePolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/package_policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFleetPackagePoliciesPackagepolicyidRequest generates requests for GetFleetPackagePoliciesPackagepolicyid
func NewGetFleetPackagePoliciesPackagepolicyidRequest(server string, packagePolicyId string, params *GetFleetPackagePoliciesPackagepolicyidParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "packagePolicyId", runtime.ParamLocationPath, packagePolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/package_policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutFleetPackagePoliciesPackagepolicyidRequest calls the generic PutFleetPackagePoliciesPackagepolicyid builder with application/json body
func NewPutFleetPackagePoliciesPackagepolicyidRequest(server string, packagePolicyId string, params *PutFleetPackagePoliciesPackagepolicyidParams, body PutFleetPackagePoliciesPackagepolicyidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutFleetPackagePoliciesPackagepolicyidRequestWithBody(server, packagePolicyId, params, "application/json", bodyReader)
}

// NewPutFleetPackagePoliciesPackagepolicyidRequestWithBody generates requests for PutFleetPackagePoliciesPackagepolicyid with any type of body
func NewPutFleetPackagePoliciesPackagepolicyidRequestWithBody(server string, packagePolicyId string, params *PutFleetPackagePoliciesPackagepolicyidParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "packagePolicyId", runtime.ParamLocationPath, packagePolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/package_policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostParametersRequest calls the generic PostParameters builder with application/json body
func NewPostParametersRequest(server string, body PostParametersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostParametersRequestWithBody(server, "application/json", bodyReader)
}

// NewPostParametersRequestWithBody generates requests for PostParameters with any type of body
func NewPostParametersRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/synthetics/params")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteParameterRequest generates requests for DeleteParameter
func NewDeleteParameterRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/synthetics/params/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetParameterRequest generates requests for GetParameter
func NewGetParameterRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/synthetics/params/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutParameterRequest calls the generic PutParameter builder with application/json body
func NewPutParameterRequest(server string, id string, body PutParameterJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutParameterRequestWithBody(server, id, "application/json", bodyReader)
}

// NewPutParameterRequestWithBody generates requests for PutParameter with any type of body
func NewPutParameterRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/synthetics/params/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteActionsConnectorIdRequest generates requests for DeleteActionsConnectorId
func NewDeleteActionsConnectorIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/actions/connector/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetActionsConnectorIdRequest generates requests for GetActionsConnectorId
func NewGetActionsConnectorIdRequest(server string, spaceId SpaceId, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/actions/connector/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostActionsConnectorIdRequest calls the generic PostActionsConnectorId builder with application/json body
func NewPostActionsConnectorIdRequest(server string, spaceId SpaceId, id string, body PostActionsConnectorIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostActionsConnectorIdRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewPostActionsConnectorIdRequestWithBody generates requests for PostActionsConnectorId with any type of body
func NewPostActionsConnectorIdRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/actions/connector/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPutActionsConnectorIdRequest calls the generic PutActionsConnectorId builder with application/json body
func NewPutActionsConnectorIdRequest(server string, spaceId SpaceId, id string, body PutActionsConnectorIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutActionsConnectorIdRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewPutActionsConnectorIdRequestWithBody generates requests for PutActionsConnectorId with any type of body
func NewPutActionsConnectorIdRequestWithBody(server string, spaceId SpaceId, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/actions/connector/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetActionsConnectorsRequest generates requests for GetActionsConnectors
func NewGetActionsConnectorsRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/actions/connectors", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllDataViewsDefaultRequest generates requests for GetAllDataViewsDefault
func NewGetAllDataViewsDefaultRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/data_views", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDataViewDefaultwRequest calls the generic CreateDataViewDefaultw builder with application/json body
func NewCreateDataViewDefaultwRequest(server string, spaceId SpaceId, body CreateDataViewDefaultwJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDataViewDefaultwRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateDataViewDefaultwRequestWithBody generates requests for CreateDataViewDefaultw with any type of body
func NewCreateDataViewDefaultwRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/data_views/data_view", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDataViewDefaultRequest generates requests for DeleteDataViewDefault
func NewDeleteDataViewDefaultRequest(server string, spaceId SpaceId, viewId DataViewsViewId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "viewId", runtime.ParamLocationPath, viewId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/data_views/data_view/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDataViewDefaultRequest generates requests for GetDataViewDefault
func NewGetDataViewDefaultRequest(server string, spaceId SpaceId, viewId DataViewsViewId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "viewId", runtime.ParamLocationPath, viewId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/data_views/data_view/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDataViewDefaultRequest calls the generic UpdateDataViewDefault builder with application/json body
func NewUpdateDataViewDefaultRequest(server string, spaceId SpaceId, viewId DataViewsViewId, body UpdateDataViewDefaultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDataViewDefaultRequestWithBody(server, spaceId, viewId, "application/json", bodyReader)
}

// NewUpdateDataViewDefaultRequestWithBody generates requests for UpdateDataViewDefault with any type of body
func NewUpdateDataViewDefaultRequestWithBody(server string, spaceId SpaceId, viewId DataViewsViewId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "viewId", runtime.ParamLocationPath, viewId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/data_views/data_view/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// DeleteAgentConfigurationWithBodyWithResponse request with any body
	DeleteAgentConfigurationWithBodyWithResponse(ctx context.Context, params *DeleteAgentConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteAgentConfigurationResponse, error)

	DeleteAgentConfigurationWithResponse(ctx context.Context, params *DeleteAgentConfigurationParams, body DeleteAgentConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteAgentConfigurationResponse, error)

	// GetAgentConfigurationsWithResponse request
	GetAgentConfigurationsWithResponse(ctx context.Context, params *GetAgentConfigurationsParams, reqEditors ...RequestEditorFn) (*GetAgentConfigurationsResponse, error)

	// CreateUpdateAgentConfigurationWithBodyWithResponse request with any body
	CreateUpdateAgentConfigurationWithBodyWithResponse(ctx context.Context, params *CreateUpdateAgentConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUpdateAgentConfigurationResponse, error)

	CreateUpdateAgentConfigurationWithResponse(ctx context.Context, params *CreateUpdateAgentConfigurationParams, body CreateUpdateAgentConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUpdateAgentConfigurationResponse, error)

	// DeleteRuleWithResponse request
	DeleteRuleWithResponse(ctx context.Context, params *DeleteRuleParams, reqEditors ...RequestEditorFn) (*DeleteRuleResponse, error)

	// ReadRuleWithResponse request
	ReadRuleWithResponse(ctx context.Context, params *ReadRuleParams, reqEditors ...RequestEditorFn) (*ReadRuleResponse, error)

	// CreateRuleWithBodyWithResponse request with any body
	CreateRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error)

	CreateRuleWithResponse(ctx context.Context, body CreateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error)

	// UpdateRuleWithBodyWithResponse request with any body
	UpdateRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error)

	UpdateRuleWithResponse(ctx context.Context, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error)

	// GetFleetAgentPoliciesWithResponse request
	GetFleetAgentPoliciesWithResponse(ctx context.Context, params *GetFleetAgentPoliciesParams, reqEditors ...RequestEditorFn) (*GetFleetAgentPoliciesResponse, error)

	// PostFleetAgentPoliciesWithBodyWithResponse request with any body
	PostFleetAgentPoliciesWithBodyWithResponse(ctx context.Context, params *PostFleetAgentPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetAgentPoliciesResponse, error)

	PostFleetAgentPoliciesWithResponse(ctx context.Context, params *PostFleetAgentPoliciesParams, body PostFleetAgentPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetAgentPoliciesResponse, error)

	// PostFleetAgentPoliciesDeleteWithBodyWithResponse request with any body
	PostFleetAgentPoliciesDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetAgentPoliciesDeleteResponse, error)

	PostFleetAgentPoliciesDeleteWithResponse(ctx context.Context, body PostFleetAgentPoliciesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetAgentPoliciesDeleteResponse, error)

	// GetFleetAgentPoliciesAgentpolicyidWithResponse request
	GetFleetAgentPoliciesAgentpolicyidWithResponse(ctx context.Context, agentPolicyId string, params *GetFleetAgentPoliciesAgentpolicyidParams, reqEditors ...RequestEditorFn) (*GetFleetAgentPoliciesAgentpolicyidResponse, error)

	// PutFleetAgentPoliciesAgentpolicyidWithBodyWithResponse request with any body
	PutFleetAgentPoliciesAgentpolicyidWithBodyWithResponse(ctx context.Context, agentPolicyId string, params *PutFleetAgentPoliciesAgentpolicyidParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutFleetAgentPoliciesAgentpolicyidResponse, error)

	PutFleetAgentPoliciesAgentpolicyidWithResponse(ctx context.Context, agentPolicyId string, params *PutFleetAgentPoliciesAgentpolicyidParams, body PutFleetAgentPoliciesAgentpolicyidJSONRequestBody, reqEditors ...RequestEditorFn) (*PutFleetAgentPoliciesAgentpolicyidResponse, error)

	// GetFleetEnrollmentApiKeysWithResponse request
	GetFleetEnrollmentApiKeysWithResponse(ctx context.Context, params *GetFleetEnrollmentApiKeysParams, reqEditors ...RequestEditorFn) (*GetFleetEnrollmentApiKeysResponse, error)

	// GetFleetEpmPackagesWithResponse request
	GetFleetEpmPackagesWithResponse(ctx context.Context, params *GetFleetEpmPackagesParams, reqEditors ...RequestEditorFn) (*GetFleetEpmPackagesResponse, error)

	// PostFleetEpmPackagesWithBodyWithResponse request with any body
	PostFleetEpmPackagesWithBodyWithResponse(ctx context.Context, params *PostFleetEpmPackagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetEpmPackagesResponse, error)

	// DeleteFleetEpmPackagesPkgnamePkgversionWithResponse request
	DeleteFleetEpmPackagesPkgnamePkgversionWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *DeleteFleetEpmPackagesPkgnamePkgversionParams, reqEditors ...RequestEditorFn) (*DeleteFleetEpmPackagesPkgnamePkgversionResponse, error)

	// GetFleetEpmPackagesPkgnamePkgversionWithResponse request
	GetFleetEpmPackagesPkgnamePkgversionWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *GetFleetEpmPackagesPkgnamePkgversionParams, reqEditors ...RequestEditorFn) (*GetFleetEpmPackagesPkgnamePkgversionResponse, error)

	// PostFleetEpmPackagesPkgnamePkgversionWithBodyWithResponse request with any body
	PostFleetEpmPackagesPkgnamePkgversionWithBodyWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *PostFleetEpmPackagesPkgnamePkgversionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetEpmPackagesPkgnamePkgversionResponse, error)

	PostFleetEpmPackagesPkgnamePkgversionWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *PostFleetEpmPackagesPkgnamePkgversionParams, body PostFleetEpmPackagesPkgnamePkgversionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetEpmPackagesPkgnamePkgversionResponse, error)

	// GetFleetFleetServerHostsWithResponse request
	GetFleetFleetServerHostsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFleetFleetServerHostsResponse, error)

	// PostFleetFleetServerHostsWithBodyWithResponse request with any body
	PostFleetFleetServerHostsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetFleetServerHostsResponse, error)

	PostFleetFleetServerHostsWithResponse(ctx context.Context, body PostFleetFleetServerHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetFleetServerHostsResponse, error)

	// DeleteFleetFleetServerHostsItemidWithResponse request
	DeleteFleetFleetServerHostsItemidWithResponse(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*DeleteFleetFleetServerHostsItemidResponse, error)

	// GetFleetFleetServerHostsItemidWithResponse request
	GetFleetFleetServerHostsItemidWithResponse(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*GetFleetFleetServerHostsItemidResponse, error)

	// PutFleetFleetServerHostsItemidWithBodyWithResponse request with any body
	PutFleetFleetServerHostsItemidWithBodyWithResponse(ctx context.Context, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutFleetFleetServerHostsItemidResponse, error)

	PutFleetFleetServerHostsItemidWithResponse(ctx context.Context, itemId string, body PutFleetFleetServerHostsItemidJSONRequestBody, reqEditors ...RequestEditorFn) (*PutFleetFleetServerHostsItemidResponse, error)

	// GetFleetOutputsWithResponse request
	GetFleetOutputsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFleetOutputsResponse, error)

	// PostFleetOutputsWithBodyWithResponse request with any body
	PostFleetOutputsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetOutputsResponse, error)

	PostFleetOutputsWithResponse(ctx context.Context, body PostFleetOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetOutputsResponse, error)

	// DeleteFleetOutputsOutputidWithResponse request
	DeleteFleetOutputsOutputidWithResponse(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*DeleteFleetOutputsOutputidResponse, error)

	// GetFleetOutputsOutputidWithResponse request
	GetFleetOutputsOutputidWithResponse(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*GetFleetOutputsOutputidResponse, error)

	// PutFleetOutputsOutputidWithBodyWithResponse request with any body
	PutFleetOutputsOutputidWithBodyWithResponse(ctx context.Context, outputId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutFleetOutputsOutputidResponse, error)

	PutFleetOutputsOutputidWithResponse(ctx context.Context, outputId string, body PutFleetOutputsOutputidJSONRequestBody, reqEditors ...RequestEditorFn) (*PutFleetOutputsOutputidResponse, error)

	// GetFleetPackagePoliciesWithResponse request
	GetFleetPackagePoliciesWithResponse(ctx context.Context, params *GetFleetPackagePoliciesParams, reqEditors ...RequestEditorFn) (*GetFleetPackagePoliciesResponse, error)

	// PostFleetPackagePoliciesWithBodyWithResponse request with any body
	PostFleetPackagePoliciesWithBodyWithResponse(ctx context.Context, params *PostFleetPackagePoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetPackagePoliciesResponse, error)

	PostFleetPackagePoliciesWithResponse(ctx context.Context, params *PostFleetPackagePoliciesParams, body PostFleetPackagePoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetPackagePoliciesResponse, error)

	// DeleteFleetPackagePoliciesPackagepolicyidWithResponse request
	DeleteFleetPackagePoliciesPackagepolicyidWithResponse(ctx context.Context, packagePolicyId string, params *DeleteFleetPackagePoliciesPackagepolicyidParams, reqEditors ...RequestEditorFn) (*DeleteFleetPackagePoliciesPackagepolicyidResponse, error)

	// GetFleetPackagePoliciesPackagepolicyidWithResponse request
	GetFleetPackagePoliciesPackagepolicyidWithResponse(ctx context.Context, packagePolicyId string, params *GetFleetPackagePoliciesPackagepolicyidParams, reqEditors ...RequestEditorFn) (*GetFleetPackagePoliciesPackagepolicyidResponse, error)

	// PutFleetPackagePoliciesPackagepolicyidWithBodyWithResponse request with any body
	PutFleetPackagePoliciesPackagepolicyidWithBodyWithResponse(ctx context.Context, packagePolicyId string, params *PutFleetPackagePoliciesPackagepolicyidParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutFleetPackagePoliciesPackagepolicyidResponse, error)

	PutFleetPackagePoliciesPackagepolicyidWithResponse(ctx context.Context, packagePolicyId string, params *PutFleetPackagePoliciesPackagepolicyidParams, body PutFleetPackagePoliciesPackagepolicyidJSONRequestBody, reqEditors ...RequestEditorFn) (*PutFleetPackagePoliciesPackagepolicyidResponse, error)

	// PostParametersWithBodyWithResponse request with any body
	PostParametersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostParametersResponse, error)

	PostParametersWithResponse(ctx context.Context, body PostParametersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostParametersResponse, error)

	// DeleteParameterWithResponse request
	DeleteParameterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteParameterResponse, error)

	// GetParameterWithResponse request
	GetParameterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetParameterResponse, error)

	// PutParameterWithBodyWithResponse request with any body
	PutParameterWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutParameterResponse, error)

	PutParameterWithResponse(ctx context.Context, id string, body PutParameterJSONRequestBody, reqEditors ...RequestEditorFn) (*PutParameterResponse, error)

	// DeleteActionsConnectorIdWithResponse request
	DeleteActionsConnectorIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteActionsConnectorIdResponse, error)

	// GetActionsConnectorIdWithResponse request
	GetActionsConnectorIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*GetActionsConnectorIdResponse, error)

	// PostActionsConnectorIdWithBodyWithResponse request with any body
	PostActionsConnectorIdWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostActionsConnectorIdResponse, error)

	PostActionsConnectorIdWithResponse(ctx context.Context, spaceId SpaceId, id string, body PostActionsConnectorIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostActionsConnectorIdResponse, error)

	// PutActionsConnectorIdWithBodyWithResponse request with any body
	PutActionsConnectorIdWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutActionsConnectorIdResponse, error)

	PutActionsConnectorIdWithResponse(ctx context.Context, spaceId SpaceId, id string, body PutActionsConnectorIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutActionsConnectorIdResponse, error)

	// GetActionsConnectorsWithResponse request
	GetActionsConnectorsWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*GetActionsConnectorsResponse, error)

	// GetAllDataViewsDefaultWithResponse request
	GetAllDataViewsDefaultWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*GetAllDataViewsDefaultResponse, error)

	// CreateDataViewDefaultwWithBodyWithResponse request with any body
	CreateDataViewDefaultwWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDataViewDefaultwResponse, error)

	CreateDataViewDefaultwWithResponse(ctx context.Context, spaceId SpaceId, body CreateDataViewDefaultwJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDataViewDefaultwResponse, error)

	// DeleteDataViewDefaultWithResponse request
	DeleteDataViewDefaultWithResponse(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, reqEditors ...RequestEditorFn) (*DeleteDataViewDefaultResponse, error)

	// GetDataViewDefaultWithResponse request
	GetDataViewDefaultWithResponse(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, reqEditors ...RequestEditorFn) (*GetDataViewDefaultResponse, error)

	// UpdateDataViewDefaultWithBodyWithResponse request with any body
	UpdateDataViewDefaultWithBodyWithResponse(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDataViewDefaultResponse, error)

	UpdateDataViewDefaultWithResponse(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, body UpdateDataViewDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDataViewDefaultResponse, error)
}

type DeleteAgentConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *APMUIDeleteAgentConfigurationsResponse
	JSON400      *APMUI400Response
	JSON401      *APMUI401Response
	JSON403      *APMUI403Response
	JSON404      *APMUI404Response
}

// Status returns HTTPResponse.Status
func (r DeleteAgentConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAgentConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAgentConfigurationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *APMUIAgentConfigurationsResponse
	JSON400      *APMUI400Response
	JSON401      *APMUI401Response
	JSON404      *APMUI404Response
}

// Status returns HTTPResponse.Status
func (r GetAgentConfigurationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAgentConfigurationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateUpdateAgentConfigurationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON400      *APMUI400Response
	JSON401      *APMUI401Response
	JSON403      *APMUI403Response
	JSON404      *APMUI404Response
}

// Status returns HTTPResponse.Status
func (r CreateUpdateAgentConfigurationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateUpdateAgentConfigurationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SecurityDetectionsAPIRuleResponse
}

// Status returns HTTPResponse.Status
func (r DeleteRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SecurityDetectionsAPIRuleResponse
}

// Status returns HTTPResponse.Status
func (r ReadRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SecurityDetectionsAPIRuleResponse
}

// Status returns HTTPResponse.Status
func (r CreateRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRuleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SecurityDetectionsAPIRuleResponse
}

// Status returns HTTPResponse.Status
func (r UpdateRuleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRuleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFleetAgentPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items   []AgentPolicy `json:"items"`
		Page    float32       `json:"page"`
		PerPage float32       `json:"perPage"`
		Total   float32       `json:"total"`
	}
	JSON400 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFleetAgentPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetAgentPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFleetAgentPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item AgentPolicy `json:"item"`
	}
	JSON400 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostFleetAgentPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFleetAgentPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFleetAgentPoliciesDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id   string `json:"id"`
		Name string `json:"name"`
	}
	JSON400 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostFleetAgentPoliciesDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFleetAgentPoliciesDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFleetAgentPoliciesAgentpolicyidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item AgentPolicy `json:"item"`
	}
	JSON400 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFleetAgentPoliciesAgentpolicyidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetAgentPoliciesAgentpolicyidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutFleetAgentPoliciesAgentpolicyidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item AgentPolicy `json:"item"`
	}
	JSON400 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PutFleetAgentPoliciesAgentpolicyidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutFleetAgentPoliciesAgentpolicyidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFleetEnrollmentApiKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items []EnrollmentApiKey `json:"items"`
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		List []struct {
			// Active When false, the enrollment API key is revoked and cannot be used for enrolling Elastic Agents.
			Active bool `json:"active"`

			// ApiKey The enrollment API key (token) used for enrolling Elastic Agents.
			ApiKey string `json:"api_key"`

			// ApiKeyId The ID of the API key in the Security API.
			ApiKeyId  string `json:"api_key_id"`
			CreatedAt string `json:"created_at"`
			Hidden    *bool  `json:"hidden,omitempty"`
			Id        string `json:"id"`

			// Name The name of the enrollment API key.
			Name *string `json:"name,omitempty"`

			// PolicyId The ID of the agent policy the Elastic Agent will be enrolled in.
			PolicyId *string `json:"policy_id,omitempty"`
		} `json:"list"`
		Page    float32 `json:"page"`
		PerPage float32 `json:"perPage"`
		Total   float32 `json:"total"`
	}
	JSON400 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFleetEnrollmentApiKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetEnrollmentApiKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFleetEpmPackagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items []PackageListItem `json:"items"`
	}
	JSON400 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFleetEpmPackagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetEpmPackagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFleetEpmPackagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostFleetEpmPackagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFleetEpmPackagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFleetEpmPackagesPkgnamePkgversionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items []DeleteFleetEpmPackagesPkgnamePkgversion_200_Items_Item `json:"items"`
	}
	JSON400 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
}
type DeleteFleetEpmPackagesPkgnamePkgversion200Items0 struct {
	Id       string                                                   `json:"id"`
	OriginId *string                                                  `json:"originId,omitempty"`
	Type     DeleteFleetEpmPackagesPkgnamePkgversion_200_Items_0_Type `json:"type"`
}
type DeleteFleetEpmPackagesPkgnamePkgversion200Items0Type0 string
type DeleteFleetEpmPackagesPkgnamePkgversion200Items0Type1 = string
type DeleteFleetEpmPackagesPkgnamePkgversion_200_Items_0_Type struct {
	union json.RawMessage
}
type DeleteFleetEpmPackagesPkgnamePkgversion200Items1 struct {
	Deferred *bool                                                `json:"deferred,omitempty"`
	Id       string                                               `json:"id"`
	Type     DeleteFleetEpmPackagesPkgnamePkgversion200Items1Type `json:"type"`
	Version  *string                                              `json:"version,omitempty"`
}
type DeleteFleetEpmPackagesPkgnamePkgversion200Items1Type string
type DeleteFleetEpmPackagesPkgnamePkgversion_200_Items_Item struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeleteFleetEpmPackagesPkgnamePkgversionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFleetEpmPackagesPkgnamePkgversionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFleetEpmPackagesPkgnamePkgversionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item     PackageInfo `json:"item"`
		Metadata *struct {
			HasPolicies bool `json:"has_policies"`
		} `json:"metadata,omitempty"`
	}
	JSON400 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFleetEpmPackagesPkgnamePkgversionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetEpmPackagesPkgnamePkgversionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFleetEpmPackagesPkgnamePkgversionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		UnderscoreMeta struct {
			InstallSource string `json:"install_source"`
			Name          string `json:"name"`
		} `json:"_meta"`
		Items []PostFleetEpmPackagesPkgnamePkgversion_200_Items_Item `json:"items"`
	}
	JSON400 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
}
type PostFleetEpmPackagesPkgnamePkgversion200Items0 struct {
	Id       string                                                 `json:"id"`
	OriginId *string                                                `json:"originId,omitempty"`
	Type     PostFleetEpmPackagesPkgnamePkgversion_200_Items_0_Type `json:"type"`
}
type PostFleetEpmPackagesPkgnamePkgversion200Items0Type0 string
type PostFleetEpmPackagesPkgnamePkgversion200Items0Type1 = string
type PostFleetEpmPackagesPkgnamePkgversion_200_Items_0_Type struct {
	union json.RawMessage
}
type PostFleetEpmPackagesPkgnamePkgversion200Items1 struct {
	Deferred *bool                                              `json:"deferred,omitempty"`
	Id       string                                             `json:"id"`
	Type     PostFleetEpmPackagesPkgnamePkgversion200Items1Type `json:"type"`
	Version  *string                                            `json:"version,omitempty"`
}
type PostFleetEpmPackagesPkgnamePkgversion200Items1Type string
type PostFleetEpmPackagesPkgnamePkgversion_200_Items_Item struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostFleetEpmPackagesPkgnamePkgversionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFleetEpmPackagesPkgnamePkgversionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFleetFleetServerHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items   []ServerHost `json:"items"`
		Page    float32      `json:"page"`
		PerPage float32      `json:"perPage"`
		Total   float32      `json:"total"`
	}
	JSON400 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFleetFleetServerHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetFleetServerHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFleetFleetServerHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item ServerHost `json:"item"`
	}
	JSON400 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostFleetFleetServerHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFleetFleetServerHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFleetFleetServerHostsItemidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id string `json:"id"`
	}
	JSON400 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteFleetFleetServerHostsItemidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFleetFleetServerHostsItemidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFleetFleetServerHostsItemidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item ServerHost `json:"item"`
	}
	JSON400 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFleetFleetServerHostsItemidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetFleetServerHostsItemidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutFleetFleetServerHostsItemidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item ServerHost `json:"item"`
	}
	JSON400 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PutFleetFleetServerHostsItemidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutFleetFleetServerHostsItemidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFleetOutputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items   []OutputUnion `json:"items"`
		Page    float32       `json:"page"`
		PerPage float32       `json:"perPage"`
		Total   float32       `json:"total"`
	}
	JSON400 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFleetOutputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetOutputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFleetOutputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item OutputUnion `json:"item"`
	}
	JSON400 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostFleetOutputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFleetOutputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFleetOutputsOutputidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id string `json:"id"`
	}
	JSON400 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
	JSON404 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteFleetOutputsOutputidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFleetOutputsOutputidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFleetOutputsOutputidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item OutputUnion `json:"item"`
	}
	JSON400 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFleetOutputsOutputidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetOutputsOutputidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutFleetOutputsOutputidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item OutputUnion `json:"item"`
	}
	JSON400 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PutFleetOutputsOutputidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutFleetOutputsOutputidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFleetPackagePoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items   []PackagePolicy `json:"items"`
		Page    float32         `json:"page"`
		PerPage float32         `json:"perPage"`
		Total   float32         `json:"total"`
	}
	JSON400 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFleetPackagePoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetPackagePoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFleetPackagePoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item PackagePolicy `json:"item"`
	}
	JSON400 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
	JSON409 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostFleetPackagePoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFleetPackagePoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFleetPackagePoliciesPackagepolicyidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id string `json:"id"`
	}
	JSON400 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteFleetPackagePoliciesPackagepolicyidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFleetPackagePoliciesPackagepolicyidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFleetPackagePoliciesPackagepolicyidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item PackagePolicy `json:"item"`
	}
	JSON400 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
	JSON404 *struct {
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFleetPackagePoliciesPackagepolicyidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetPackagePoliciesPackagepolicyidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutFleetPackagePoliciesPackagepolicyidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item PackagePolicy `json:"item"`
	}
	JSON400 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
	JSON403 *struct {
		Attributes interface{} `json:"attributes"`
		Error      *string     `json:"error,omitempty"`
		ErrorType  *string     `json:"errorType,omitempty"`
		Message    string      `json:"message"`
		StatusCode *float32    `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PutFleetPackagePoliciesPackagepolicyidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutFleetPackagePoliciesPackagepolicyidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostParametersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CreateParamResponse
}

// Status returns HTTPResponse.Status
func (r PostParametersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostParametersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteParameterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteParameterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteParameterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetParameterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SyntheticsGetParameterResponse
}

// Status returns HTTPResponse.Status
func (r GetParameterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetParameterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutParameterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
}

// Status returns HTTPResponse.Status
func (r PutParameterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutParameterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteActionsConnectorIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteActionsConnectorIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteActionsConnectorIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActionsConnectorIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ConnectorResponse
}

// Status returns HTTPResponse.Status
func (r GetActionsConnectorIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActionsConnectorIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostActionsConnectorIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Config *map[string]interface{} `json:"config,omitempty"`

		// ConnectorTypeId The connector type identifier.
		ConnectorTypeId string `json:"connector_type_id"`

		// Id The identifier for the connector.
		Id string `json:"id"`

		// IsDeprecated Indicates whether the connector is deprecated.
		IsDeprecated bool `json:"is_deprecated"`

		// IsMissingSecrets Indicates whether the connector is missing secrets.
		IsMissingSecrets *bool `json:"is_missing_secrets,omitempty"`

		// IsPreconfigured Indicates whether the connector is preconfigured. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
		IsPreconfigured bool `json:"is_preconfigured"`

		// IsSystemAction Indicates whether the connector is used for system actions.
		IsSystemAction bool `json:"is_system_action"`

		// Name  The name of the rule.
		Name string `json:"name"`
	}
}

// Status returns HTTPResponse.Status
func (r PostActionsConnectorIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostActionsConnectorIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutActionsConnectorIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Config *map[string]interface{} `json:"config,omitempty"`

		// ConnectorTypeId The connector type identifier.
		ConnectorTypeId string `json:"connector_type_id"`

		// Id The identifier for the connector.
		Id string `json:"id"`

		// IsDeprecated Indicates whether the connector is deprecated.
		IsDeprecated bool `json:"is_deprecated"`

		// IsMissingSecrets Indicates whether the connector is missing secrets.
		IsMissingSecrets *bool `json:"is_missing_secrets,omitempty"`

		// IsPreconfigured Indicates whether the connector is preconfigured. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
		IsPreconfigured bool `json:"is_preconfigured"`

		// IsSystemAction Indicates whether the connector is used for system actions.
		IsSystemAction bool `json:"is_system_action"`

		// Name  The name of the rule.
		Name string `json:"name"`
	}
}

// Status returns HTTPResponse.Status
func (r PutActionsConnectorIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutActionsConnectorIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetActionsConnectorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ConnectorResponse
}

// Status returns HTTPResponse.Status
func (r GetActionsConnectorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetActionsConnectorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllDataViewsDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DataView *[]GetDataViewsResponseItem `json:"data_view,omitempty"`
	}
	JSON400 *DataViews400Response
}

// Status returns HTTPResponse.Status
func (r GetAllDataViewsDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllDataViewsDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDataViewDefaultwResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataViewsDataViewResponseObject
	JSON400      *DataViews400Response
}

// Status returns HTTPResponse.Status
func (r CreateDataViewDefaultwResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDataViewDefaultwResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDataViewDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *DataViews404Response
}

// Status returns HTTPResponse.Status
func (r DeleteDataViewDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDataViewDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataViewDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataViewsDataViewResponseObject
	JSON404      *DataViews404Response
}

// Status returns HTTPResponse.Status
func (r GetDataViewDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataViewDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDataViewDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataViewsDataViewResponseObject
	JSON400      *DataViews400Response
}

// Status returns HTTPResponse.Status
func (r UpdateDataViewDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDataViewDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// DeleteAgentConfigurationWithBodyWithResponse request with arbitrary body returning *DeleteAgentConfigurationResponse
func (c *ClientWithResponses) DeleteAgentConfigurationWithBodyWithResponse(ctx context.Context, params *DeleteAgentConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteAgentConfigurationResponse, error) {
	rsp, err := c.DeleteAgentConfigurationWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAgentConfigurationResponse(rsp)
}

func (c *ClientWithResponses) DeleteAgentConfigurationWithResponse(ctx context.Context, params *DeleteAgentConfigurationParams, body DeleteAgentConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteAgentConfigurationResponse, error) {
	rsp, err := c.DeleteAgentConfiguration(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAgentConfigurationResponse(rsp)
}

// GetAgentConfigurationsWithResponse request returning *GetAgentConfigurationsResponse
func (c *ClientWithResponses) GetAgentConfigurationsWithResponse(ctx context.Context, params *GetAgentConfigurationsParams, reqEditors ...RequestEditorFn) (*GetAgentConfigurationsResponse, error) {
	rsp, err := c.GetAgentConfigurations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAgentConfigurationsResponse(rsp)
}

// CreateUpdateAgentConfigurationWithBodyWithResponse request with arbitrary body returning *CreateUpdateAgentConfigurationResponse
func (c *ClientWithResponses) CreateUpdateAgentConfigurationWithBodyWithResponse(ctx context.Context, params *CreateUpdateAgentConfigurationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateUpdateAgentConfigurationResponse, error) {
	rsp, err := c.CreateUpdateAgentConfigurationWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUpdateAgentConfigurationResponse(rsp)
}

func (c *ClientWithResponses) CreateUpdateAgentConfigurationWithResponse(ctx context.Context, params *CreateUpdateAgentConfigurationParams, body CreateUpdateAgentConfigurationJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateUpdateAgentConfigurationResponse, error) {
	rsp, err := c.CreateUpdateAgentConfiguration(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateUpdateAgentConfigurationResponse(rsp)
}

// DeleteRuleWithResponse request returning *DeleteRuleResponse
func (c *ClientWithResponses) DeleteRuleWithResponse(ctx context.Context, params *DeleteRuleParams, reqEditors ...RequestEditorFn) (*DeleteRuleResponse, error) {
	rsp, err := c.DeleteRule(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRuleResponse(rsp)
}

// ReadRuleWithResponse request returning *ReadRuleResponse
func (c *ClientWithResponses) ReadRuleWithResponse(ctx context.Context, params *ReadRuleParams, reqEditors ...RequestEditorFn) (*ReadRuleResponse, error) {
	rsp, err := c.ReadRule(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadRuleResponse(rsp)
}

// CreateRuleWithBodyWithResponse request with arbitrary body returning *CreateRuleResponse
func (c *ClientWithResponses) CreateRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error) {
	rsp, err := c.CreateRuleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRuleResponse(rsp)
}

func (c *ClientWithResponses) CreateRuleWithResponse(ctx context.Context, body CreateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateRuleResponse, error) {
	rsp, err := c.CreateRule(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateRuleResponse(rsp)
}

// UpdateRuleWithBodyWithResponse request with arbitrary body returning *UpdateRuleResponse
func (c *ClientWithResponses) UpdateRuleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error) {
	rsp, err := c.UpdateRuleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleResponse(rsp)
}

func (c *ClientWithResponses) UpdateRuleWithResponse(ctx context.Context, body UpdateRuleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRuleResponse, error) {
	rsp, err := c.UpdateRule(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRuleResponse(rsp)
}

// GetFleetAgentPoliciesWithResponse request returning *GetFleetAgentPoliciesResponse
func (c *ClientWithResponses) GetFleetAgentPoliciesWithResponse(ctx context.Context, params *GetFleetAgentPoliciesParams, reqEditors ...RequestEditorFn) (*GetFleetAgentPoliciesResponse, error) {
	rsp, err := c.GetFleetAgentPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetAgentPoliciesResponse(rsp)
}

// PostFleetAgentPoliciesWithBodyWithResponse request with arbitrary body returning *PostFleetAgentPoliciesResponse
func (c *ClientWithResponses) PostFleetAgentPoliciesWithBodyWithResponse(ctx context.Context, params *PostFleetAgentPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetAgentPoliciesResponse, error) {
	rsp, err := c.PostFleetAgentPoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetAgentPoliciesResponse(rsp)
}

func (c *ClientWithResponses) PostFleetAgentPoliciesWithResponse(ctx context.Context, params *PostFleetAgentPoliciesParams, body PostFleetAgentPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetAgentPoliciesResponse, error) {
	rsp, err := c.PostFleetAgentPolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetAgentPoliciesResponse(rsp)
}

// PostFleetAgentPoliciesDeleteWithBodyWithResponse request with arbitrary body returning *PostFleetAgentPoliciesDeleteResponse
func (c *ClientWithResponses) PostFleetAgentPoliciesDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetAgentPoliciesDeleteResponse, error) {
	rsp, err := c.PostFleetAgentPoliciesDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetAgentPoliciesDeleteResponse(rsp)
}

func (c *ClientWithResponses) PostFleetAgentPoliciesDeleteWithResponse(ctx context.Context, body PostFleetAgentPoliciesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetAgentPoliciesDeleteResponse, error) {
	rsp, err := c.PostFleetAgentPoliciesDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetAgentPoliciesDeleteResponse(rsp)
}

// GetFleetAgentPoliciesAgentpolicyidWithResponse request returning *GetFleetAgentPoliciesAgentpolicyidResponse
func (c *ClientWithResponses) GetFleetAgentPoliciesAgentpolicyidWithResponse(ctx context.Context, agentPolicyId string, params *GetFleetAgentPoliciesAgentpolicyidParams, reqEditors ...RequestEditorFn) (*GetFleetAgentPoliciesAgentpolicyidResponse, error) {
	rsp, err := c.GetFleetAgentPoliciesAgentpolicyid(ctx, agentPolicyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetAgentPoliciesAgentpolicyidResponse(rsp)
}

// PutFleetAgentPoliciesAgentpolicyidWithBodyWithResponse request with arbitrary body returning *PutFleetAgentPoliciesAgentpolicyidResponse
func (c *ClientWithResponses) PutFleetAgentPoliciesAgentpolicyidWithBodyWithResponse(ctx context.Context, agentPolicyId string, params *PutFleetAgentPoliciesAgentpolicyidParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutFleetAgentPoliciesAgentpolicyidResponse, error) {
	rsp, err := c.PutFleetAgentPoliciesAgentpolicyidWithBody(ctx, agentPolicyId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutFleetAgentPoliciesAgentpolicyidResponse(rsp)
}

func (c *ClientWithResponses) PutFleetAgentPoliciesAgentpolicyidWithResponse(ctx context.Context, agentPolicyId string, params *PutFleetAgentPoliciesAgentpolicyidParams, body PutFleetAgentPoliciesAgentpolicyidJSONRequestBody, reqEditors ...RequestEditorFn) (*PutFleetAgentPoliciesAgentpolicyidResponse, error) {
	rsp, err := c.PutFleetAgentPoliciesAgentpolicyid(ctx, agentPolicyId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutFleetAgentPoliciesAgentpolicyidResponse(rsp)
}

// GetFleetEnrollmentApiKeysWithResponse request returning *GetFleetEnrollmentApiKeysResponse
func (c *ClientWithResponses) GetFleetEnrollmentApiKeysWithResponse(ctx context.Context, params *GetFleetEnrollmentApiKeysParams, reqEditors ...RequestEditorFn) (*GetFleetEnrollmentApiKeysResponse, error) {
	rsp, err := c.GetFleetEnrollmentApiKeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetEnrollmentApiKeysResponse(rsp)
}

// GetFleetEpmPackagesWithResponse request returning *GetFleetEpmPackagesResponse
func (c *ClientWithResponses) GetFleetEpmPackagesWithResponse(ctx context.Context, params *GetFleetEpmPackagesParams, reqEditors ...RequestEditorFn) (*GetFleetEpmPackagesResponse, error) {
	rsp, err := c.GetFleetEpmPackages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetEpmPackagesResponse(rsp)
}

// PostFleetEpmPackagesWithBodyWithResponse request with arbitrary body returning *PostFleetEpmPackagesResponse
func (c *ClientWithResponses) PostFleetEpmPackagesWithBodyWithResponse(ctx context.Context, params *PostFleetEpmPackagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetEpmPackagesResponse, error) {
	rsp, err := c.PostFleetEpmPackagesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetEpmPackagesResponse(rsp)
}

// DeleteFleetEpmPackagesPkgnamePkgversionWithResponse request returning *DeleteFleetEpmPackagesPkgnamePkgversionResponse
func (c *ClientWithResponses) DeleteFleetEpmPackagesPkgnamePkgversionWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *DeleteFleetEpmPackagesPkgnamePkgversionParams, reqEditors ...RequestEditorFn) (*DeleteFleetEpmPackagesPkgnamePkgversionResponse, error) {
	rsp, err := c.DeleteFleetEpmPackagesPkgnamePkgversion(ctx, pkgName, pkgVersion, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFleetEpmPackagesPkgnamePkgversionResponse(rsp)
}

// GetFleetEpmPackagesPkgnamePkgversionWithResponse request returning *GetFleetEpmPackagesPkgnamePkgversionResponse
func (c *ClientWithResponses) GetFleetEpmPackagesPkgnamePkgversionWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *GetFleetEpmPackagesPkgnamePkgversionParams, reqEditors ...RequestEditorFn) (*GetFleetEpmPackagesPkgnamePkgversionResponse, error) {
	rsp, err := c.GetFleetEpmPackagesPkgnamePkgversion(ctx, pkgName, pkgVersion, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetEpmPackagesPkgnamePkgversionResponse(rsp)
}

// PostFleetEpmPackagesPkgnamePkgversionWithBodyWithResponse request with arbitrary body returning *PostFleetEpmPackagesPkgnamePkgversionResponse
func (c *ClientWithResponses) PostFleetEpmPackagesPkgnamePkgversionWithBodyWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *PostFleetEpmPackagesPkgnamePkgversionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetEpmPackagesPkgnamePkgversionResponse, error) {
	rsp, err := c.PostFleetEpmPackagesPkgnamePkgversionWithBody(ctx, pkgName, pkgVersion, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetEpmPackagesPkgnamePkgversionResponse(rsp)
}

func (c *ClientWithResponses) PostFleetEpmPackagesPkgnamePkgversionWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *PostFleetEpmPackagesPkgnamePkgversionParams, body PostFleetEpmPackagesPkgnamePkgversionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetEpmPackagesPkgnamePkgversionResponse, error) {
	rsp, err := c.PostFleetEpmPackagesPkgnamePkgversion(ctx, pkgName, pkgVersion, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetEpmPackagesPkgnamePkgversionResponse(rsp)
}

// GetFleetFleetServerHostsWithResponse request returning *GetFleetFleetServerHostsResponse
func (c *ClientWithResponses) GetFleetFleetServerHostsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFleetFleetServerHostsResponse, error) {
	rsp, err := c.GetFleetFleetServerHosts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetFleetServerHostsResponse(rsp)
}

// PostFleetFleetServerHostsWithBodyWithResponse request with arbitrary body returning *PostFleetFleetServerHostsResponse
func (c *ClientWithResponses) PostFleetFleetServerHostsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetFleetServerHostsResponse, error) {
	rsp, err := c.PostFleetFleetServerHostsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetFleetServerHostsResponse(rsp)
}

func (c *ClientWithResponses) PostFleetFleetServerHostsWithResponse(ctx context.Context, body PostFleetFleetServerHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetFleetServerHostsResponse, error) {
	rsp, err := c.PostFleetFleetServerHosts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetFleetServerHostsResponse(rsp)
}

// DeleteFleetFleetServerHostsItemidWithResponse request returning *DeleteFleetFleetServerHostsItemidResponse
func (c *ClientWithResponses) DeleteFleetFleetServerHostsItemidWithResponse(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*DeleteFleetFleetServerHostsItemidResponse, error) {
	rsp, err := c.DeleteFleetFleetServerHostsItemid(ctx, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFleetFleetServerHostsItemidResponse(rsp)
}

// GetFleetFleetServerHostsItemidWithResponse request returning *GetFleetFleetServerHostsItemidResponse
func (c *ClientWithResponses) GetFleetFleetServerHostsItemidWithResponse(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*GetFleetFleetServerHostsItemidResponse, error) {
	rsp, err := c.GetFleetFleetServerHostsItemid(ctx, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetFleetServerHostsItemidResponse(rsp)
}

// PutFleetFleetServerHostsItemidWithBodyWithResponse request with arbitrary body returning *PutFleetFleetServerHostsItemidResponse
func (c *ClientWithResponses) PutFleetFleetServerHostsItemidWithBodyWithResponse(ctx context.Context, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutFleetFleetServerHostsItemidResponse, error) {
	rsp, err := c.PutFleetFleetServerHostsItemidWithBody(ctx, itemId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutFleetFleetServerHostsItemidResponse(rsp)
}

func (c *ClientWithResponses) PutFleetFleetServerHostsItemidWithResponse(ctx context.Context, itemId string, body PutFleetFleetServerHostsItemidJSONRequestBody, reqEditors ...RequestEditorFn) (*PutFleetFleetServerHostsItemidResponse, error) {
	rsp, err := c.PutFleetFleetServerHostsItemid(ctx, itemId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutFleetFleetServerHostsItemidResponse(rsp)
}

// GetFleetOutputsWithResponse request returning *GetFleetOutputsResponse
func (c *ClientWithResponses) GetFleetOutputsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFleetOutputsResponse, error) {
	rsp, err := c.GetFleetOutputs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetOutputsResponse(rsp)
}

// PostFleetOutputsWithBodyWithResponse request with arbitrary body returning *PostFleetOutputsResponse
func (c *ClientWithResponses) PostFleetOutputsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetOutputsResponse, error) {
	rsp, err := c.PostFleetOutputsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetOutputsResponse(rsp)
}

func (c *ClientWithResponses) PostFleetOutputsWithResponse(ctx context.Context, body PostFleetOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetOutputsResponse, error) {
	rsp, err := c.PostFleetOutputs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetOutputsResponse(rsp)
}

// DeleteFleetOutputsOutputidWithResponse request returning *DeleteFleetOutputsOutputidResponse
func (c *ClientWithResponses) DeleteFleetOutputsOutputidWithResponse(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*DeleteFleetOutputsOutputidResponse, error) {
	rsp, err := c.DeleteFleetOutputsOutputid(ctx, outputId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFleetOutputsOutputidResponse(rsp)
}

// GetFleetOutputsOutputidWithResponse request returning *GetFleetOutputsOutputidResponse
func (c *ClientWithResponses) GetFleetOutputsOutputidWithResponse(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*GetFleetOutputsOutputidResponse, error) {
	rsp, err := c.GetFleetOutputsOutputid(ctx, outputId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetOutputsOutputidResponse(rsp)
}

// PutFleetOutputsOutputidWithBodyWithResponse request with arbitrary body returning *PutFleetOutputsOutputidResponse
func (c *ClientWithResponses) PutFleetOutputsOutputidWithBodyWithResponse(ctx context.Context, outputId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutFleetOutputsOutputidResponse, error) {
	rsp, err := c.PutFleetOutputsOutputidWithBody(ctx, outputId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutFleetOutputsOutputidResponse(rsp)
}

func (c *ClientWithResponses) PutFleetOutputsOutputidWithResponse(ctx context.Context, outputId string, body PutFleetOutputsOutputidJSONRequestBody, reqEditors ...RequestEditorFn) (*PutFleetOutputsOutputidResponse, error) {
	rsp, err := c.PutFleetOutputsOutputid(ctx, outputId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutFleetOutputsOutputidResponse(rsp)
}

// GetFleetPackagePoliciesWithResponse request returning *GetFleetPackagePoliciesResponse
func (c *ClientWithResponses) GetFleetPackagePoliciesWithResponse(ctx context.Context, params *GetFleetPackagePoliciesParams, reqEditors ...RequestEditorFn) (*GetFleetPackagePoliciesResponse, error) {
	rsp, err := c.GetFleetPackagePolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetPackagePoliciesResponse(rsp)
}

// PostFleetPackagePoliciesWithBodyWithResponse request with arbitrary body returning *PostFleetPackagePoliciesResponse
func (c *ClientWithResponses) PostFleetPackagePoliciesWithBodyWithResponse(ctx context.Context, params *PostFleetPackagePoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetPackagePoliciesResponse, error) {
	rsp, err := c.PostFleetPackagePoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetPackagePoliciesResponse(rsp)
}

func (c *ClientWithResponses) PostFleetPackagePoliciesWithResponse(ctx context.Context, params *PostFleetPackagePoliciesParams, body PostFleetPackagePoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetPackagePoliciesResponse, error) {
	rsp, err := c.PostFleetPackagePolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetPackagePoliciesResponse(rsp)
}

// DeleteFleetPackagePoliciesPackagepolicyidWithResponse request returning *DeleteFleetPackagePoliciesPackagepolicyidResponse
func (c *ClientWithResponses) DeleteFleetPackagePoliciesPackagepolicyidWithResponse(ctx context.Context, packagePolicyId string, params *DeleteFleetPackagePoliciesPackagepolicyidParams, reqEditors ...RequestEditorFn) (*DeleteFleetPackagePoliciesPackagepolicyidResponse, error) {
	rsp, err := c.DeleteFleetPackagePoliciesPackagepolicyid(ctx, packagePolicyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFleetPackagePoliciesPackagepolicyidResponse(rsp)
}

// GetFleetPackagePoliciesPackagepolicyidWithResponse request returning *GetFleetPackagePoliciesPackagepolicyidResponse
func (c *ClientWithResponses) GetFleetPackagePoliciesPackagepolicyidWithResponse(ctx context.Context, packagePolicyId string, params *GetFleetPackagePoliciesPackagepolicyidParams, reqEditors ...RequestEditorFn) (*GetFleetPackagePoliciesPackagepolicyidResponse, error) {
	rsp, err := c.GetFleetPackagePoliciesPackagepolicyid(ctx, packagePolicyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetPackagePoliciesPackagepolicyidResponse(rsp)
}

// PutFleetPackagePoliciesPackagepolicyidWithBodyWithResponse request with arbitrary body returning *PutFleetPackagePoliciesPackagepolicyidResponse
func (c *ClientWithResponses) PutFleetPackagePoliciesPackagepolicyidWithBodyWithResponse(ctx context.Context, packagePolicyId string, params *PutFleetPackagePoliciesPackagepolicyidParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutFleetPackagePoliciesPackagepolicyidResponse, error) {
	rsp, err := c.PutFleetPackagePoliciesPackagepolicyidWithBody(ctx, packagePolicyId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutFleetPackagePoliciesPackagepolicyidResponse(rsp)
}

func (c *ClientWithResponses) PutFleetPackagePoliciesPackagepolicyidWithResponse(ctx context.Context, packagePolicyId string, params *PutFleetPackagePoliciesPackagepolicyidParams, body PutFleetPackagePoliciesPackagepolicyidJSONRequestBody, reqEditors ...RequestEditorFn) (*PutFleetPackagePoliciesPackagepolicyidResponse, error) {
	rsp, err := c.PutFleetPackagePoliciesPackagepolicyid(ctx, packagePolicyId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutFleetPackagePoliciesPackagepolicyidResponse(rsp)
}

// PostParametersWithBodyWithResponse request with arbitrary body returning *PostParametersResponse
func (c *ClientWithResponses) PostParametersWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostParametersResponse, error) {
	rsp, err := c.PostParametersWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostParametersResponse(rsp)
}

func (c *ClientWithResponses) PostParametersWithResponse(ctx context.Context, body PostParametersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostParametersResponse, error) {
	rsp, err := c.PostParameters(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostParametersResponse(rsp)
}

// DeleteParameterWithResponse request returning *DeleteParameterResponse
func (c *ClientWithResponses) DeleteParameterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteParameterResponse, error) {
	rsp, err := c.DeleteParameter(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteParameterResponse(rsp)
}

// GetParameterWithResponse request returning *GetParameterResponse
func (c *ClientWithResponses) GetParameterWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetParameterResponse, error) {
	rsp, err := c.GetParameter(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetParameterResponse(rsp)
}

// PutParameterWithBodyWithResponse request with arbitrary body returning *PutParameterResponse
func (c *ClientWithResponses) PutParameterWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutParameterResponse, error) {
	rsp, err := c.PutParameterWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutParameterResponse(rsp)
}

func (c *ClientWithResponses) PutParameterWithResponse(ctx context.Context, id string, body PutParameterJSONRequestBody, reqEditors ...RequestEditorFn) (*PutParameterResponse, error) {
	rsp, err := c.PutParameter(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutParameterResponse(rsp)
}

// DeleteActionsConnectorIdWithResponse request returning *DeleteActionsConnectorIdResponse
func (c *ClientWithResponses) DeleteActionsConnectorIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*DeleteActionsConnectorIdResponse, error) {
	rsp, err := c.DeleteActionsConnectorId(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteActionsConnectorIdResponse(rsp)
}

// GetActionsConnectorIdWithResponse request returning *GetActionsConnectorIdResponse
func (c *ClientWithResponses) GetActionsConnectorIdWithResponse(ctx context.Context, spaceId SpaceId, id string, reqEditors ...RequestEditorFn) (*GetActionsConnectorIdResponse, error) {
	rsp, err := c.GetActionsConnectorId(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActionsConnectorIdResponse(rsp)
}

// PostActionsConnectorIdWithBodyWithResponse request with arbitrary body returning *PostActionsConnectorIdResponse
func (c *ClientWithResponses) PostActionsConnectorIdWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostActionsConnectorIdResponse, error) {
	rsp, err := c.PostActionsConnectorIdWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostActionsConnectorIdResponse(rsp)
}

func (c *ClientWithResponses) PostActionsConnectorIdWithResponse(ctx context.Context, spaceId SpaceId, id string, body PostActionsConnectorIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostActionsConnectorIdResponse, error) {
	rsp, err := c.PostActionsConnectorId(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostActionsConnectorIdResponse(rsp)
}

// PutActionsConnectorIdWithBodyWithResponse request with arbitrary body returning *PutActionsConnectorIdResponse
func (c *ClientWithResponses) PutActionsConnectorIdWithBodyWithResponse(ctx context.Context, spaceId SpaceId, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutActionsConnectorIdResponse, error) {
	rsp, err := c.PutActionsConnectorIdWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutActionsConnectorIdResponse(rsp)
}

func (c *ClientWithResponses) PutActionsConnectorIdWithResponse(ctx context.Context, spaceId SpaceId, id string, body PutActionsConnectorIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutActionsConnectorIdResponse, error) {
	rsp, err := c.PutActionsConnectorId(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutActionsConnectorIdResponse(rsp)
}

// GetActionsConnectorsWithResponse request returning *GetActionsConnectorsResponse
func (c *ClientWithResponses) GetActionsConnectorsWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*GetActionsConnectorsResponse, error) {
	rsp, err := c.GetActionsConnectors(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetActionsConnectorsResponse(rsp)
}

// GetAllDataViewsDefaultWithResponse request returning *GetAllDataViewsDefaultResponse
func (c *ClientWithResponses) GetAllDataViewsDefaultWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*GetAllDataViewsDefaultResponse, error) {
	rsp, err := c.GetAllDataViewsDefault(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllDataViewsDefaultResponse(rsp)
}

// CreateDataViewDefaultwWithBodyWithResponse request with arbitrary body returning *CreateDataViewDefaultwResponse
func (c *ClientWithResponses) CreateDataViewDefaultwWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDataViewDefaultwResponse, error) {
	rsp, err := c.CreateDataViewDefaultwWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDataViewDefaultwResponse(rsp)
}

func (c *ClientWithResponses) CreateDataViewDefaultwWithResponse(ctx context.Context, spaceId SpaceId, body CreateDataViewDefaultwJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDataViewDefaultwResponse, error) {
	rsp, err := c.CreateDataViewDefaultw(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDataViewDefaultwResponse(rsp)
}

// DeleteDataViewDefaultWithResponse request returning *DeleteDataViewDefaultResponse
func (c *ClientWithResponses) DeleteDataViewDefaultWithResponse(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, reqEditors ...RequestEditorFn) (*DeleteDataViewDefaultResponse, error) {
	rsp, err := c.DeleteDataViewDefault(ctx, spaceId, viewId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDataViewDefaultResponse(rsp)
}

// GetDataViewDefaultWithResponse request returning *GetDataViewDefaultResponse
func (c *ClientWithResponses) GetDataViewDefaultWithResponse(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, reqEditors ...RequestEditorFn) (*GetDataViewDefaultResponse, error) {
	rsp, err := c.GetDataViewDefault(ctx, spaceId, viewId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataViewDefaultResponse(rsp)
}

// UpdateDataViewDefaultWithBodyWithResponse request with arbitrary body returning *UpdateDataViewDefaultResponse
func (c *ClientWithResponses) UpdateDataViewDefaultWithBodyWithResponse(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDataViewDefaultResponse, error) {
	rsp, err := c.UpdateDataViewDefaultWithBody(ctx, spaceId, viewId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDataViewDefaultResponse(rsp)
}

func (c *ClientWithResponses) UpdateDataViewDefaultWithResponse(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, body UpdateDataViewDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDataViewDefaultResponse, error) {
	rsp, err := c.UpdateDataViewDefault(ctx, spaceId, viewId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDataViewDefaultResponse(rsp)
}

// ParseDeleteAgentConfigurationResponse parses an HTTP response from a DeleteAgentConfigurationWithResponse call
func ParseDeleteAgentConfigurationResponse(rsp *http.Response) (*DeleteAgentConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAgentConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest APMUIDeleteAgentConfigurationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APMUI400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APMUI401Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APMUI403Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APMUI404Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAgentConfigurationsResponse parses an HTTP response from a GetAgentConfigurationsWithResponse call
func ParseGetAgentConfigurationsResponse(rsp *http.Response) (*GetAgentConfigurationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAgentConfigurationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest APMUIAgentConfigurationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APMUI400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APMUI401Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APMUI404Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateUpdateAgentConfigurationResponse parses an HTTP response from a CreateUpdateAgentConfigurationWithResponse call
func ParseCreateUpdateAgentConfigurationResponse(rsp *http.Response) (*CreateUpdateAgentConfigurationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateUpdateAgentConfigurationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest APMUI400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest APMUI401Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest APMUI403Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest APMUI404Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteRuleResponse parses an HTTP response from a DeleteRuleWithResponse call
func ParseDeleteRuleResponse(rsp *http.Response) (*DeleteRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SecurityDetectionsAPIRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadRuleResponse parses an HTTP response from a ReadRuleWithResponse call
func ParseReadRuleResponse(rsp *http.Response) (*ReadRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SecurityDetectionsAPIRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateRuleResponse parses an HTTP response from a CreateRuleWithResponse call
func ParseCreateRuleResponse(rsp *http.Response) (*CreateRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SecurityDetectionsAPIRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateRuleResponse parses an HTTP response from a UpdateRuleWithResponse call
func ParseUpdateRuleResponse(rsp *http.Response) (*UpdateRuleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRuleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SecurityDetectionsAPIRuleResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFleetAgentPoliciesResponse parses an HTTP response from a GetFleetAgentPoliciesWithResponse call
func ParseGetFleetAgentPoliciesResponse(rsp *http.Response) (*GetFleetAgentPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetAgentPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items   []AgentPolicy `json:"items"`
			Page    float32       `json:"page"`
			PerPage float32       `json:"perPage"`
			Total   float32       `json:"total"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostFleetAgentPoliciesResponse parses an HTTP response from a PostFleetAgentPoliciesWithResponse call
func ParsePostFleetAgentPoliciesResponse(rsp *http.Response) (*PostFleetAgentPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFleetAgentPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item AgentPolicy `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostFleetAgentPoliciesDeleteResponse parses an HTTP response from a PostFleetAgentPoliciesDeleteWithResponse call
func ParsePostFleetAgentPoliciesDeleteResponse(rsp *http.Response) (*PostFleetAgentPoliciesDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFleetAgentPoliciesDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id   string `json:"id"`
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFleetAgentPoliciesAgentpolicyidResponse parses an HTTP response from a GetFleetAgentPoliciesAgentpolicyidWithResponse call
func ParseGetFleetAgentPoliciesAgentpolicyidResponse(rsp *http.Response) (*GetFleetAgentPoliciesAgentpolicyidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetAgentPoliciesAgentpolicyidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item AgentPolicy `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePutFleetAgentPoliciesAgentpolicyidResponse parses an HTTP response from a PutFleetAgentPoliciesAgentpolicyidWithResponse call
func ParsePutFleetAgentPoliciesAgentpolicyidResponse(rsp *http.Response) (*PutFleetAgentPoliciesAgentpolicyidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutFleetAgentPoliciesAgentpolicyidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item AgentPolicy `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFleetEnrollmentApiKeysResponse parses an HTTP response from a GetFleetEnrollmentApiKeysWithResponse call
func ParseGetFleetEnrollmentApiKeysResponse(rsp *http.Response) (*GetFleetEnrollmentApiKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetEnrollmentApiKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items []EnrollmentApiKey `json:"items"`
			// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
			List []struct {
				// Active When false, the enrollment API key is revoked and cannot be used for enrolling Elastic Agents.
				Active bool `json:"active"`

				// ApiKey The enrollment API key (token) used for enrolling Elastic Agents.
				ApiKey string `json:"api_key"`

				// ApiKeyId The ID of the API key in the Security API.
				ApiKeyId  string `json:"api_key_id"`
				CreatedAt string `json:"created_at"`
				Hidden    *bool  `json:"hidden,omitempty"`
				Id        string `json:"id"`

				// Name The name of the enrollment API key.
				Name *string `json:"name,omitempty"`

				// PolicyId The ID of the agent policy the Elastic Agent will be enrolled in.
				PolicyId *string `json:"policy_id,omitempty"`
			} `json:"list"`
			Page    float32 `json:"page"`
			PerPage float32 `json:"perPage"`
			Total   float32 `json:"total"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFleetEpmPackagesResponse parses an HTTP response from a GetFleetEpmPackagesWithResponse call
func ParseGetFleetEpmPackagesResponse(rsp *http.Response) (*GetFleetEpmPackagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetEpmPackagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items []PackageListItem `json:"items"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostFleetEpmPackagesResponse parses an HTTP response from a PostFleetEpmPackagesWithResponse call
func ParsePostFleetEpmPackagesResponse(rsp *http.Response) (*PostFleetEpmPackagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFleetEpmPackagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteFleetEpmPackagesPkgnamePkgversionResponse parses an HTTP response from a DeleteFleetEpmPackagesPkgnamePkgversionWithResponse call
func ParseDeleteFleetEpmPackagesPkgnamePkgversionResponse(rsp *http.Response) (*DeleteFleetEpmPackagesPkgnamePkgversionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFleetEpmPackagesPkgnamePkgversionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items []DeleteFleetEpmPackagesPkgnamePkgversion_200_Items_Item `json:"items"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFleetEpmPackagesPkgnamePkgversionResponse parses an HTTP response from a GetFleetEpmPackagesPkgnamePkgversionWithResponse call
func ParseGetFleetEpmPackagesPkgnamePkgversionResponse(rsp *http.Response) (*GetFleetEpmPackagesPkgnamePkgversionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetEpmPackagesPkgnamePkgversionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item     PackageInfo `json:"item"`
			Metadata *struct {
				HasPolicies bool `json:"has_policies"`
			} `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostFleetEpmPackagesPkgnamePkgversionResponse parses an HTTP response from a PostFleetEpmPackagesPkgnamePkgversionWithResponse call
func ParsePostFleetEpmPackagesPkgnamePkgversionResponse(rsp *http.Response) (*PostFleetEpmPackagesPkgnamePkgversionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFleetEpmPackagesPkgnamePkgversionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			UnderscoreMeta struct {
				InstallSource string `json:"install_source"`
				Name          string `json:"name"`
			} `json:"_meta"`
			Items []PostFleetEpmPackagesPkgnamePkgversion_200_Items_Item `json:"items"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFleetFleetServerHostsResponse parses an HTTP response from a GetFleetFleetServerHostsWithResponse call
func ParseGetFleetFleetServerHostsResponse(rsp *http.Response) (*GetFleetFleetServerHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetFleetServerHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items   []ServerHost `json:"items"`
			Page    float32      `json:"page"`
			PerPage float32      `json:"perPage"`
			Total   float32      `json:"total"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostFleetFleetServerHostsResponse parses an HTTP response from a PostFleetFleetServerHostsWithResponse call
func ParsePostFleetFleetServerHostsResponse(rsp *http.Response) (*PostFleetFleetServerHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFleetFleetServerHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item ServerHost `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteFleetFleetServerHostsItemidResponse parses an HTTP response from a DeleteFleetFleetServerHostsItemidWithResponse call
func ParseDeleteFleetFleetServerHostsItemidResponse(rsp *http.Response) (*DeleteFleetFleetServerHostsItemidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFleetFleetServerHostsItemidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFleetFleetServerHostsItemidResponse parses an HTTP response from a GetFleetFleetServerHostsItemidWithResponse call
func ParseGetFleetFleetServerHostsItemidResponse(rsp *http.Response) (*GetFleetFleetServerHostsItemidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetFleetServerHostsItemidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item ServerHost `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePutFleetFleetServerHostsItemidResponse parses an HTTP response from a PutFleetFleetServerHostsItemidWithResponse call
func ParsePutFleetFleetServerHostsItemidResponse(rsp *http.Response) (*PutFleetFleetServerHostsItemidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutFleetFleetServerHostsItemidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item ServerHost `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFleetOutputsResponse parses an HTTP response from a GetFleetOutputsWithResponse call
func ParseGetFleetOutputsResponse(rsp *http.Response) (*GetFleetOutputsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetOutputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items   []OutputUnion `json:"items"`
			Page    float32       `json:"page"`
			PerPage float32       `json:"perPage"`
			Total   float32       `json:"total"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostFleetOutputsResponse parses an HTTP response from a PostFleetOutputsWithResponse call
func ParsePostFleetOutputsResponse(rsp *http.Response) (*PostFleetOutputsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFleetOutputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item OutputUnion `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteFleetOutputsOutputidResponse parses an HTTP response from a DeleteFleetOutputsOutputidWithResponse call
func ParseDeleteFleetOutputsOutputidResponse(rsp *http.Response) (*DeleteFleetOutputsOutputidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFleetOutputsOutputidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetFleetOutputsOutputidResponse parses an HTTP response from a GetFleetOutputsOutputidWithResponse call
func ParseGetFleetOutputsOutputidResponse(rsp *http.Response) (*GetFleetOutputsOutputidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetOutputsOutputidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item OutputUnion `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePutFleetOutputsOutputidResponse parses an HTTP response from a PutFleetOutputsOutputidWithResponse call
func ParsePutFleetOutputsOutputidResponse(rsp *http.Response) (*PutFleetOutputsOutputidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutFleetOutputsOutputidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item OutputUnion `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFleetPackagePoliciesResponse parses an HTTP response from a GetFleetPackagePoliciesWithResponse call
func ParseGetFleetPackagePoliciesResponse(rsp *http.Response) (*GetFleetPackagePoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetPackagePoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items   []PackagePolicy `json:"items"`
			Page    float32         `json:"page"`
			PerPage float32         `json:"perPage"`
			Total   float32         `json:"total"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostFleetPackagePoliciesResponse parses an HTTP response from a PostFleetPackagePoliciesWithResponse call
func ParsePostFleetPackagePoliciesResponse(rsp *http.Response) (*PostFleetPackagePoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFleetPackagePoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item PackagePolicy `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteFleetPackagePoliciesPackagepolicyidResponse parses an HTTP response from a DeleteFleetPackagePoliciesPackagepolicyidWithResponse call
func ParseDeleteFleetPackagePoliciesPackagepolicyidResponse(rsp *http.Response) (*DeleteFleetPackagePoliciesPackagepolicyidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFleetPackagePoliciesPackagepolicyidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFleetPackagePoliciesPackagepolicyidResponse parses an HTTP response from a GetFleetPackagePoliciesPackagepolicyidWithResponse call
func ParseGetFleetPackagePoliciesPackagepolicyidResponse(rsp *http.Response) (*GetFleetPackagePoliciesPackagepolicyidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetPackagePoliciesPackagepolicyidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item PackagePolicy `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutFleetPackagePoliciesPackagepolicyidResponse parses an HTTP response from a PutFleetPackagePoliciesPackagepolicyidWithResponse call
func ParsePutFleetPackagePoliciesPackagepolicyidResponse(rsp *http.Response) (*PutFleetPackagePoliciesPackagepolicyidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutFleetPackagePoliciesPackagepolicyidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item PackagePolicy `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Attributes interface{} `json:"attributes"`
			Error      *string     `json:"error,omitempty"`
			ErrorType  *string     `json:"errorType,omitempty"`
			Message    string      `json:"message"`
			StatusCode *float32    `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParsePostParametersResponse parses an HTTP response from a PostParametersWithResponse call
func ParsePostParametersResponse(rsp *http.Response) (*PostParametersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostParametersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CreateParamResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteParameterResponse parses an HTTP response from a DeleteParameterWithResponse call
func ParseDeleteParameterResponse(rsp *http.Response) (*DeleteParameterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteParameterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetParameterResponse parses an HTTP response from a GetParameterWithResponse call
func ParseGetParameterResponse(rsp *http.Response) (*GetParameterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetParameterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SyntheticsGetParameterResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePutParameterResponse parses an HTTP response from a PutParameterWithResponse call
func ParsePutParameterResponse(rsp *http.Response) (*PutParameterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutParameterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteActionsConnectorIdResponse parses an HTTP response from a DeleteActionsConnectorIdWithResponse call
func ParseDeleteActionsConnectorIdResponse(rsp *http.Response) (*DeleteActionsConnectorIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteActionsConnectorIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetActionsConnectorIdResponse parses an HTTP response from a GetActionsConnectorIdWithResponse call
func ParseGetActionsConnectorIdResponse(rsp *http.Response) (*GetActionsConnectorIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActionsConnectorIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ConnectorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostActionsConnectorIdResponse parses an HTTP response from a PostActionsConnectorIdWithResponse call
func ParsePostActionsConnectorIdResponse(rsp *http.Response) (*PostActionsConnectorIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostActionsConnectorIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Config *map[string]interface{} `json:"config,omitempty"`

			// ConnectorTypeId The connector type identifier.
			ConnectorTypeId string `json:"connector_type_id"`

			// Id The identifier for the connector.
			Id string `json:"id"`

			// IsDeprecated Indicates whether the connector is deprecated.
			IsDeprecated bool `json:"is_deprecated"`

			// IsMissingSecrets Indicates whether the connector is missing secrets.
			IsMissingSecrets *bool `json:"is_missing_secrets,omitempty"`

			// IsPreconfigured Indicates whether the connector is preconfigured. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
			IsPreconfigured bool `json:"is_preconfigured"`

			// IsSystemAction Indicates whether the connector is used for system actions.
			IsSystemAction bool `json:"is_system_action"`

			// Name  The name of the rule.
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePutActionsConnectorIdResponse parses an HTTP response from a PutActionsConnectorIdWithResponse call
func ParsePutActionsConnectorIdResponse(rsp *http.Response) (*PutActionsConnectorIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutActionsConnectorIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Config *map[string]interface{} `json:"config,omitempty"`

			// ConnectorTypeId The connector type identifier.
			ConnectorTypeId string `json:"connector_type_id"`

			// Id The identifier for the connector.
			Id string `json:"id"`

			// IsDeprecated Indicates whether the connector is deprecated.
			IsDeprecated bool `json:"is_deprecated"`

			// IsMissingSecrets Indicates whether the connector is missing secrets.
			IsMissingSecrets *bool `json:"is_missing_secrets,omitempty"`

			// IsPreconfigured Indicates whether the connector is preconfigured. If true, the `config` and `is_missing_secrets` properties are omitted from the response.
			IsPreconfigured bool `json:"is_preconfigured"`

			// IsSystemAction Indicates whether the connector is used for system actions.
			IsSystemAction bool `json:"is_system_action"`

			// Name  The name of the rule.
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetActionsConnectorsResponse parses an HTTP response from a GetActionsConnectorsWithResponse call
func ParseGetActionsConnectorsResponse(rsp *http.Response) (*GetActionsConnectorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetActionsConnectorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ConnectorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAllDataViewsDefaultResponse parses an HTTP response from a GetAllDataViewsDefaultWithResponse call
func ParseGetAllDataViewsDefaultResponse(rsp *http.Response) (*GetAllDataViewsDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllDataViewsDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DataView *[]GetDataViewsResponseItem `json:"data_view,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest DataViews400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateDataViewDefaultwResponse parses an HTTP response from a CreateDataViewDefaultwWithResponse call
func ParseCreateDataViewDefaultwResponse(rsp *http.Response) (*CreateDataViewDefaultwResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDataViewDefaultwResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataViewsDataViewResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest DataViews400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteDataViewDefaultResponse parses an HTTP response from a DeleteDataViewDefaultWithResponse call
func ParseDeleteDataViewDefaultResponse(rsp *http.Response) (*DeleteDataViewDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDataViewDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest DataViews404Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetDataViewDefaultResponse parses an HTTP response from a GetDataViewDefaultWithResponse call
func ParseGetDataViewDefaultResponse(rsp *http.Response) (*GetDataViewDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataViewDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataViewsDataViewResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest DataViews404Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateDataViewDefaultResponse parses an HTTP response from a UpdateDataViewDefaultWithResponse call
func ParseUpdateDataViewDefaultResponse(rsp *http.Response) (*UpdateDataViewDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDataViewDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataViewsDataViewResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest DataViews400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}
