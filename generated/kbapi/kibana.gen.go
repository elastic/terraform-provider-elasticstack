// Package kbapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package kbapi

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyAuthScopes = "apiKeyAuth.Scopes"
	BasicAuthScopes  = "basicAuth.Scopes"
)

// Defines values for DataViews404ResponseError.
const (
	NotFound DataViews404ResponseError = "Not Found"
)

// Defines values for DataViews404ResponseStatusCode.
const (
	N404 DataViews404ResponseStatusCode = 404
)

// Defines values for AgentPolicyMonitoringEnabled.
const (
	AgentPolicyMonitoringEnabledLogs    AgentPolicyMonitoringEnabled = "logs"
	AgentPolicyMonitoringEnabledMetrics AgentPolicyMonitoringEnabled = "metrics"
	AgentPolicyMonitoringEnabledTraces  AgentPolicyMonitoringEnabled = "traces"
)

// Defines values for AgentPolicyPackagePolicies1InputsStreamsRelease.
const (
	AgentPolicyPackagePolicies1InputsStreamsReleaseBeta         AgentPolicyPackagePolicies1InputsStreamsRelease = "beta"
	AgentPolicyPackagePolicies1InputsStreamsReleaseExperimental AgentPolicyPackagePolicies1InputsStreamsRelease = "experimental"
	AgentPolicyPackagePolicies1InputsStreamsReleaseGa           AgentPolicyPackagePolicies1InputsStreamsRelease = "ga"
)

// Defines values for AgentPolicyStatus.
const (
	Active   AgentPolicyStatus = "active"
	Inactive AgentPolicyStatus = "inactive"
)

// Defines values for NewOutputElasticsearchPreset.
const (
	NewOutputElasticsearchPresetBalanced   NewOutputElasticsearchPreset = "balanced"
	NewOutputElasticsearchPresetCustom     NewOutputElasticsearchPreset = "custom"
	NewOutputElasticsearchPresetLatency    NewOutputElasticsearchPreset = "latency"
	NewOutputElasticsearchPresetScale      NewOutputElasticsearchPreset = "scale"
	NewOutputElasticsearchPresetThroughput NewOutputElasticsearchPreset = "throughput"
)

// Defines values for NewOutputElasticsearchType.
const (
	NewOutputElasticsearchTypeElasticsearch NewOutputElasticsearchType = "elasticsearch"
)

// Defines values for NewOutputKafkaAuthType.
const (
	NewOutputKafkaAuthTypeKerberos NewOutputKafkaAuthType = "kerberos"
	NewOutputKafkaAuthTypeNone     NewOutputKafkaAuthType = "none"
	NewOutputKafkaAuthTypeSsl      NewOutputKafkaAuthType = "ssl"
	NewOutputKafkaAuthTypeUserPass NewOutputKafkaAuthType = "user_pass"
)

// Defines values for NewOutputKafkaCompression.
const (
	NewOutputKafkaCompressionGzip   NewOutputKafkaCompression = "gzip"
	NewOutputKafkaCompressionLz4    NewOutputKafkaCompression = "lz4"
	NewOutputKafkaCompressionNone   NewOutputKafkaCompression = "none"
	NewOutputKafkaCompressionSnappy NewOutputKafkaCompression = "snappy"
)

// Defines values for NewOutputKafkaPartition.
const (
	NewOutputKafkaPartitionHash       NewOutputKafkaPartition = "hash"
	NewOutputKafkaPartitionRandom     NewOutputKafkaPartition = "random"
	NewOutputKafkaPartitionRoundRobin NewOutputKafkaPartition = "round_robin"
)

// Defines values for NewOutputKafkaRequiredAcks.
const (
	NewOutputKafkaRequiredAcksMinus1 NewOutputKafkaRequiredAcks = -1
	NewOutputKafkaRequiredAcksN0     NewOutputKafkaRequiredAcks = 0
	NewOutputKafkaRequiredAcksN1     NewOutputKafkaRequiredAcks = 1
)

// Defines values for NewOutputKafkaSaslMechanism.
const (
	NewOutputKafkaSaslMechanismPLAIN       NewOutputKafkaSaslMechanism = "PLAIN"
	NewOutputKafkaSaslMechanismSCRAMSHA256 NewOutputKafkaSaslMechanism = "SCRAM-SHA-256"
	NewOutputKafkaSaslMechanismSCRAMSHA512 NewOutputKafkaSaslMechanism = "SCRAM-SHA-512"
)

// Defines values for NewOutputKafkaType.
const (
	NewOutputKafkaTypeKafka NewOutputKafkaType = "kafka"
)

// Defines values for NewOutputLogstashType.
const (
	NewOutputLogstashTypeLogstash NewOutputLogstashType = "logstash"
)

// Defines values for NewOutputRemoteElasticsearchPreset.
const (
	NewOutputRemoteElasticsearchPresetBalanced   NewOutputRemoteElasticsearchPreset = "balanced"
	NewOutputRemoteElasticsearchPresetCustom     NewOutputRemoteElasticsearchPreset = "custom"
	NewOutputRemoteElasticsearchPresetLatency    NewOutputRemoteElasticsearchPreset = "latency"
	NewOutputRemoteElasticsearchPresetScale      NewOutputRemoteElasticsearchPreset = "scale"
	NewOutputRemoteElasticsearchPresetThroughput NewOutputRemoteElasticsearchPreset = "throughput"
)

// Defines values for NewOutputRemoteElasticsearchType.
const (
	NewOutputRemoteElasticsearchTypeRemoteElasticsearch NewOutputRemoteElasticsearchType = "remote_elasticsearch"
)

// Defines values for NewOutputSslVerificationMode.
const (
	NewOutputSslVerificationModeCertificate NewOutputSslVerificationMode = "certificate"
	NewOutputSslVerificationModeFull        NewOutputSslVerificationMode = "full"
	NewOutputSslVerificationModeNone        NewOutputSslVerificationMode = "none"
	NewOutputSslVerificationModeStrict      NewOutputSslVerificationMode = "strict"
)

// Defines values for OutputElasticsearchPreset.
const (
	OutputElasticsearchPresetBalanced   OutputElasticsearchPreset = "balanced"
	OutputElasticsearchPresetCustom     OutputElasticsearchPreset = "custom"
	OutputElasticsearchPresetLatency    OutputElasticsearchPreset = "latency"
	OutputElasticsearchPresetScale      OutputElasticsearchPreset = "scale"
	OutputElasticsearchPresetThroughput OutputElasticsearchPreset = "throughput"
)

// Defines values for OutputElasticsearchType.
const (
	OutputElasticsearchTypeElasticsearch OutputElasticsearchType = "elasticsearch"
)

// Defines values for OutputKafkaAuthType.
const (
	OutputKafkaAuthTypeKerberos OutputKafkaAuthType = "kerberos"
	OutputKafkaAuthTypeNone     OutputKafkaAuthType = "none"
	OutputKafkaAuthTypeSsl      OutputKafkaAuthType = "ssl"
	OutputKafkaAuthTypeUserPass OutputKafkaAuthType = "user_pass"
)

// Defines values for OutputKafkaCompression.
const (
	OutputKafkaCompressionGzip   OutputKafkaCompression = "gzip"
	OutputKafkaCompressionLz4    OutputKafkaCompression = "lz4"
	OutputKafkaCompressionNone   OutputKafkaCompression = "none"
	OutputKafkaCompressionSnappy OutputKafkaCompression = "snappy"
)

// Defines values for OutputKafkaPartition.
const (
	OutputKafkaPartitionHash       OutputKafkaPartition = "hash"
	OutputKafkaPartitionRandom     OutputKafkaPartition = "random"
	OutputKafkaPartitionRoundRobin OutputKafkaPartition = "round_robin"
)

// Defines values for OutputKafkaRequiredAcks.
const (
	OutputKafkaRequiredAcksMinus1 OutputKafkaRequiredAcks = -1
	OutputKafkaRequiredAcksN0     OutputKafkaRequiredAcks = 0
	OutputKafkaRequiredAcksN1     OutputKafkaRequiredAcks = 1
)

// Defines values for OutputKafkaSaslMechanism.
const (
	OutputKafkaSaslMechanismPLAIN       OutputKafkaSaslMechanism = "PLAIN"
	OutputKafkaSaslMechanismSCRAMSHA256 OutputKafkaSaslMechanism = "SCRAM-SHA-256"
	OutputKafkaSaslMechanismSCRAMSHA512 OutputKafkaSaslMechanism = "SCRAM-SHA-512"
)

// Defines values for OutputKafkaType.
const (
	OutputKafkaTypeKafka OutputKafkaType = "kafka"
)

// Defines values for OutputLogstashType.
const (
	OutputLogstashTypeLogstash OutputLogstashType = "logstash"
)

// Defines values for OutputRemoteElasticsearchPreset.
const (
	OutputRemoteElasticsearchPresetBalanced   OutputRemoteElasticsearchPreset = "balanced"
	OutputRemoteElasticsearchPresetCustom     OutputRemoteElasticsearchPreset = "custom"
	OutputRemoteElasticsearchPresetLatency    OutputRemoteElasticsearchPreset = "latency"
	OutputRemoteElasticsearchPresetScale      OutputRemoteElasticsearchPreset = "scale"
	OutputRemoteElasticsearchPresetThroughput OutputRemoteElasticsearchPreset = "throughput"
)

// Defines values for OutputRemoteElasticsearchType.
const (
	OutputRemoteElasticsearchTypeRemoteElasticsearch OutputRemoteElasticsearchType = "remote_elasticsearch"
)

// Defines values for OutputSslVerificationMode.
const (
	OutputSslVerificationModeCertificate OutputSslVerificationMode = "certificate"
	OutputSslVerificationModeFull        OutputSslVerificationMode = "full"
	OutputSslVerificationModeNone        OutputSslVerificationMode = "none"
	OutputSslVerificationModeStrict      OutputSslVerificationMode = "strict"
)

// Defines values for PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType.
const (
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaTypeCspRuleTemplate   PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType = "csp-rule-template"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaTypeDashboard         PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType = "dashboard"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaTypeIndexPattern      PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType = "index-pattern"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaTypeLens              PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType = "lens"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaTypeMap               PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType = "map"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaTypeMlModule          PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType = "ml-module"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaTypeOsqueryPackAsset  PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType = "osquery-pack-asset"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaTypeOsquerySavedQuery PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType = "osquery-saved-query"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaTypeSearch            PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType = "search"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaTypeSecurityRule      PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType = "security-rule"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaTypeTag               PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType = "tag"
	PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaTypeVisualization     PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType = "visualization"
)

// Defines values for PackageInfoInstallationInfoInstallSource.
const (
	PackageInfoInstallationInfoInstallSourceBundled  PackageInfoInstallationInfoInstallSource = "bundled"
	PackageInfoInstallationInfoInstallSourceCustom   PackageInfoInstallationInfoInstallSource = "custom"
	PackageInfoInstallationInfoInstallSourceRegistry PackageInfoInstallationInfoInstallSource = "registry"
	PackageInfoInstallationInfoInstallSourceUpload   PackageInfoInstallationInfoInstallSource = "upload"
)

// Defines values for PackageInfoInstallationInfoInstallStatus.
const (
	PackageInfoInstallationInfoInstallStatusInstallFailed PackageInfoInstallationInfoInstallStatus = "install_failed"
	PackageInfoInstallationInfoInstallStatusInstalled     PackageInfoInstallationInfoInstallStatus = "installed"
	PackageInfoInstallationInfoInstallStatusInstalling    PackageInfoInstallationInfoInstallStatus = "installing"
)

// Defines values for PackageInfoInstallationInfoInstalledEsType.
const (
	PackageInfoInstallationInfoInstalledEsTypeComponentTemplate   PackageInfoInstallationInfoInstalledEsType = "component_template"
	PackageInfoInstallationInfoInstalledEsTypeDataStreamIlmPolicy PackageInfoInstallationInfoInstalledEsType = "data_stream_ilm_policy"
	PackageInfoInstallationInfoInstalledEsTypeIlmPolicy           PackageInfoInstallationInfoInstalledEsType = "ilm_policy"
	PackageInfoInstallationInfoInstalledEsTypeIndex               PackageInfoInstallationInfoInstalledEsType = "index"
	PackageInfoInstallationInfoInstalledEsTypeIndexTemplate       PackageInfoInstallationInfoInstalledEsType = "index_template"
	PackageInfoInstallationInfoInstalledEsTypeIngestPipeline      PackageInfoInstallationInfoInstalledEsType = "ingest_pipeline"
	PackageInfoInstallationInfoInstalledEsTypeMlModel             PackageInfoInstallationInfoInstalledEsType = "ml_model"
	PackageInfoInstallationInfoInstalledEsTypeTransform           PackageInfoInstallationInfoInstalledEsType = "transform"
)

// Defines values for PackageInfoInstallationInfoInstalledKibanaType.
const (
	PackageInfoInstallationInfoInstalledKibanaTypeCspRuleTemplate   PackageInfoInstallationInfoInstalledKibanaType = "csp-rule-template"
	PackageInfoInstallationInfoInstalledKibanaTypeDashboard         PackageInfoInstallationInfoInstalledKibanaType = "dashboard"
	PackageInfoInstallationInfoInstalledKibanaTypeIndexPattern      PackageInfoInstallationInfoInstalledKibanaType = "index-pattern"
	PackageInfoInstallationInfoInstalledKibanaTypeLens              PackageInfoInstallationInfoInstalledKibanaType = "lens"
	PackageInfoInstallationInfoInstalledKibanaTypeMap               PackageInfoInstallationInfoInstalledKibanaType = "map"
	PackageInfoInstallationInfoInstalledKibanaTypeMlModule          PackageInfoInstallationInfoInstalledKibanaType = "ml-module"
	PackageInfoInstallationInfoInstalledKibanaTypeOsqueryPackAsset  PackageInfoInstallationInfoInstalledKibanaType = "osquery-pack-asset"
	PackageInfoInstallationInfoInstalledKibanaTypeOsquerySavedQuery PackageInfoInstallationInfoInstalledKibanaType = "osquery-saved-query"
	PackageInfoInstallationInfoInstalledKibanaTypeSearch            PackageInfoInstallationInfoInstalledKibanaType = "search"
	PackageInfoInstallationInfoInstalledKibanaTypeSecurityRule      PackageInfoInstallationInfoInstalledKibanaType = "security-rule"
	PackageInfoInstallationInfoInstalledKibanaTypeTag               PackageInfoInstallationInfoInstalledKibanaType = "tag"
	PackageInfoInstallationInfoInstalledKibanaTypeVisualization     PackageInfoInstallationInfoInstalledKibanaType = "visualization"
)

// Defines values for PackageInfoInstallationInfoVerificationStatus.
const (
	PackageInfoInstallationInfoVerificationStatusUnknown    PackageInfoInstallationInfoVerificationStatus = "unknown"
	PackageInfoInstallationInfoVerificationStatusUnverified PackageInfoInstallationInfoVerificationStatus = "unverified"
	PackageInfoInstallationInfoVerificationStatusVerified   PackageInfoInstallationInfoVerificationStatus = "verified"
)

// Defines values for PackageInfoOwnerType.
const (
	PackageInfoOwnerTypeCommunity PackageInfoOwnerType = "community"
	PackageInfoOwnerTypeElastic   PackageInfoOwnerType = "elastic"
	PackageInfoOwnerTypePartner   PackageInfoOwnerType = "partner"
)

// Defines values for PackageInfoRelease.
const (
	PackageInfoReleaseBeta         PackageInfoRelease = "beta"
	PackageInfoReleaseExperimental PackageInfoRelease = "experimental"
	PackageInfoReleaseGa           PackageInfoRelease = "ga"
)

// Defines values for PackageInfoType.
const (
	PackageInfoTypeContent     PackageInfoType = "content"
	PackageInfoTypeInput       PackageInfoType = "input"
	PackageInfoTypeIntegration PackageInfoType = "integration"
)

// Defines values for PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType.
const (
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaTypeCspRuleTemplate   PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType = "csp-rule-template"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaTypeDashboard         PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType = "dashboard"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaTypeIndexPattern      PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType = "index-pattern"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaTypeLens              PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType = "lens"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaTypeMap               PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType = "map"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaTypeMlModule          PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType = "ml-module"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaTypeOsqueryPackAsset  PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType = "osquery-pack-asset"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaTypeOsquerySavedQuery PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType = "osquery-saved-query"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaTypeSearch            PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType = "search"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaTypeSecurityRule      PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType = "security-rule"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaTypeTag               PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType = "tag"
	PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaTypeVisualization     PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType = "visualization"
)

// Defines values for PackageListItemInstallationInfoInstallSource.
const (
	PackageListItemInstallationInfoInstallSourceBundled  PackageListItemInstallationInfoInstallSource = "bundled"
	PackageListItemInstallationInfoInstallSourceCustom   PackageListItemInstallationInfoInstallSource = "custom"
	PackageListItemInstallationInfoInstallSourceRegistry PackageListItemInstallationInfoInstallSource = "registry"
	PackageListItemInstallationInfoInstallSourceUpload   PackageListItemInstallationInfoInstallSource = "upload"
)

// Defines values for PackageListItemInstallationInfoInstallStatus.
const (
	PackageListItemInstallationInfoInstallStatusInstallFailed PackageListItemInstallationInfoInstallStatus = "install_failed"
	PackageListItemInstallationInfoInstallStatusInstalled     PackageListItemInstallationInfoInstallStatus = "installed"
	PackageListItemInstallationInfoInstallStatusInstalling    PackageListItemInstallationInfoInstallStatus = "installing"
)

// Defines values for PackageListItemInstallationInfoInstalledEsType.
const (
	PackageListItemInstallationInfoInstalledEsTypeComponentTemplate   PackageListItemInstallationInfoInstalledEsType = "component_template"
	PackageListItemInstallationInfoInstalledEsTypeDataStreamIlmPolicy PackageListItemInstallationInfoInstalledEsType = "data_stream_ilm_policy"
	PackageListItemInstallationInfoInstalledEsTypeIlmPolicy           PackageListItemInstallationInfoInstalledEsType = "ilm_policy"
	PackageListItemInstallationInfoInstalledEsTypeIndex               PackageListItemInstallationInfoInstalledEsType = "index"
	PackageListItemInstallationInfoInstalledEsTypeIndexTemplate       PackageListItemInstallationInfoInstalledEsType = "index_template"
	PackageListItemInstallationInfoInstalledEsTypeIngestPipeline      PackageListItemInstallationInfoInstalledEsType = "ingest_pipeline"
	PackageListItemInstallationInfoInstalledEsTypeMlModel             PackageListItemInstallationInfoInstalledEsType = "ml_model"
	PackageListItemInstallationInfoInstalledEsTypeTransform           PackageListItemInstallationInfoInstalledEsType = "transform"
)

// Defines values for PackageListItemInstallationInfoInstalledKibanaType.
const (
	PackageListItemInstallationInfoInstalledKibanaTypeCspRuleTemplate   PackageListItemInstallationInfoInstalledKibanaType = "csp-rule-template"
	PackageListItemInstallationInfoInstalledKibanaTypeDashboard         PackageListItemInstallationInfoInstalledKibanaType = "dashboard"
	PackageListItemInstallationInfoInstalledKibanaTypeIndexPattern      PackageListItemInstallationInfoInstalledKibanaType = "index-pattern"
	PackageListItemInstallationInfoInstalledKibanaTypeLens              PackageListItemInstallationInfoInstalledKibanaType = "lens"
	PackageListItemInstallationInfoInstalledKibanaTypeMap               PackageListItemInstallationInfoInstalledKibanaType = "map"
	PackageListItemInstallationInfoInstalledKibanaTypeMlModule          PackageListItemInstallationInfoInstalledKibanaType = "ml-module"
	PackageListItemInstallationInfoInstalledKibanaTypeOsqueryPackAsset  PackageListItemInstallationInfoInstalledKibanaType = "osquery-pack-asset"
	PackageListItemInstallationInfoInstalledKibanaTypeOsquerySavedQuery PackageListItemInstallationInfoInstalledKibanaType = "osquery-saved-query"
	PackageListItemInstallationInfoInstalledKibanaTypeSearch            PackageListItemInstallationInfoInstalledKibanaType = "search"
	PackageListItemInstallationInfoInstalledKibanaTypeSecurityRule      PackageListItemInstallationInfoInstalledKibanaType = "security-rule"
	PackageListItemInstallationInfoInstalledKibanaTypeTag               PackageListItemInstallationInfoInstalledKibanaType = "tag"
	PackageListItemInstallationInfoInstalledKibanaTypeVisualization     PackageListItemInstallationInfoInstalledKibanaType = "visualization"
)

// Defines values for PackageListItemInstallationInfoVerificationStatus.
const (
	PackageListItemInstallationInfoVerificationStatusUnknown    PackageListItemInstallationInfoVerificationStatus = "unknown"
	PackageListItemInstallationInfoVerificationStatusUnverified PackageListItemInstallationInfoVerificationStatus = "unverified"
	PackageListItemInstallationInfoVerificationStatusVerified   PackageListItemInstallationInfoVerificationStatus = "verified"
)

// Defines values for PackageListItemOwnerType.
const (
	PackageListItemOwnerTypeCommunity PackageListItemOwnerType = "community"
	PackageListItemOwnerTypeElastic   PackageListItemOwnerType = "elastic"
	PackageListItemOwnerTypePartner   PackageListItemOwnerType = "partner"
)

// Defines values for PackageListItemRelease.
const (
	Beta         PackageListItemRelease = "beta"
	Experimental PackageListItemRelease = "experimental"
	Ga           PackageListItemRelease = "ga"
)

// Defines values for PackageListItemType.
const (
	PackageListItemTypeContent     PackageListItemType = "content"
	PackageListItemTypeInput       PackageListItemType = "input"
	PackageListItemTypeIntegration PackageListItemType = "integration"
)

// Defines values for UpdateOutputElasticsearchPreset.
const (
	UpdateOutputElasticsearchPresetBalanced   UpdateOutputElasticsearchPreset = "balanced"
	UpdateOutputElasticsearchPresetCustom     UpdateOutputElasticsearchPreset = "custom"
	UpdateOutputElasticsearchPresetLatency    UpdateOutputElasticsearchPreset = "latency"
	UpdateOutputElasticsearchPresetScale      UpdateOutputElasticsearchPreset = "scale"
	UpdateOutputElasticsearchPresetThroughput UpdateOutputElasticsearchPreset = "throughput"
)

// Defines values for UpdateOutputElasticsearchType.
const (
	Elasticsearch UpdateOutputElasticsearchType = "elasticsearch"
)

// Defines values for UpdateOutputKafkaAuthType.
const (
	UpdateOutputKafkaAuthTypeKerberos UpdateOutputKafkaAuthType = "kerberos"
	UpdateOutputKafkaAuthTypeNone     UpdateOutputKafkaAuthType = "none"
	UpdateOutputKafkaAuthTypeSsl      UpdateOutputKafkaAuthType = "ssl"
	UpdateOutputKafkaAuthTypeUserPass UpdateOutputKafkaAuthType = "user_pass"
)

// Defines values for UpdateOutputKafkaCompression.
const (
	UpdateOutputKafkaCompressionGzip   UpdateOutputKafkaCompression = "gzip"
	UpdateOutputKafkaCompressionLz4    UpdateOutputKafkaCompression = "lz4"
	UpdateOutputKafkaCompressionNone   UpdateOutputKafkaCompression = "none"
	UpdateOutputKafkaCompressionSnappy UpdateOutputKafkaCompression = "snappy"
)

// Defines values for UpdateOutputKafkaPartition.
const (
	Hash       UpdateOutputKafkaPartition = "hash"
	Random     UpdateOutputKafkaPartition = "random"
	RoundRobin UpdateOutputKafkaPartition = "round_robin"
)

// Defines values for UpdateOutputKafkaRequiredAcks.
const (
	Minus1 UpdateOutputKafkaRequiredAcks = -1
	N0     UpdateOutputKafkaRequiredAcks = 0
	N1     UpdateOutputKafkaRequiredAcks = 1
)

// Defines values for UpdateOutputKafkaSaslMechanism.
const (
	PLAIN       UpdateOutputKafkaSaslMechanism = "PLAIN"
	SCRAMSHA256 UpdateOutputKafkaSaslMechanism = "SCRAM-SHA-256"
	SCRAMSHA512 UpdateOutputKafkaSaslMechanism = "SCRAM-SHA-512"
)

// Defines values for UpdateOutputKafkaType.
const (
	Kafka UpdateOutputKafkaType = "kafka"
)

// Defines values for UpdateOutputLogstashType.
const (
	Logstash UpdateOutputLogstashType = "logstash"
)

// Defines values for UpdateOutputRemoteElasticsearchPreset.
const (
	UpdateOutputRemoteElasticsearchPresetBalanced   UpdateOutputRemoteElasticsearchPreset = "balanced"
	UpdateOutputRemoteElasticsearchPresetCustom     UpdateOutputRemoteElasticsearchPreset = "custom"
	UpdateOutputRemoteElasticsearchPresetLatency    UpdateOutputRemoteElasticsearchPreset = "latency"
	UpdateOutputRemoteElasticsearchPresetScale      UpdateOutputRemoteElasticsearchPreset = "scale"
	UpdateOutputRemoteElasticsearchPresetThroughput UpdateOutputRemoteElasticsearchPreset = "throughput"
)

// Defines values for UpdateOutputRemoteElasticsearchType.
const (
	RemoteElasticsearch UpdateOutputRemoteElasticsearchType = "remote_elasticsearch"
)

// Defines values for UpdateOutputSslVerificationMode.
const (
	Certificate UpdateOutputSslVerificationMode = "certificate"
	Full        UpdateOutputSslVerificationMode = "full"
	None        UpdateOutputSslVerificationMode = "none"
	Strict      UpdateOutputSslVerificationMode = "strict"
)

// Defines values for GetFleetAgentPoliciesParamsSortOrder.
const (
	GetFleetAgentPoliciesParamsSortOrderAsc  GetFleetAgentPoliciesParamsSortOrder = "asc"
	GetFleetAgentPoliciesParamsSortOrderDesc GetFleetAgentPoliciesParamsSortOrder = "desc"
)

// Defines values for GetFleetAgentPoliciesParamsFormat.
const (
	GetFleetAgentPoliciesParamsFormatLegacy     GetFleetAgentPoliciesParamsFormat = "legacy"
	GetFleetAgentPoliciesParamsFormatSimplified GetFleetAgentPoliciesParamsFormat = "simplified"
)

// Defines values for PostFleetAgentPoliciesJSONBodyMonitoringEnabled.
const (
	PostFleetAgentPoliciesJSONBodyMonitoringEnabledLogs    PostFleetAgentPoliciesJSONBodyMonitoringEnabled = "logs"
	PostFleetAgentPoliciesJSONBodyMonitoringEnabledMetrics PostFleetAgentPoliciesJSONBodyMonitoringEnabled = "metrics"
	PostFleetAgentPoliciesJSONBodyMonitoringEnabledTraces  PostFleetAgentPoliciesJSONBodyMonitoringEnabled = "traces"
)

// Defines values for GetFleetAgentPoliciesAgentpolicyidParamsFormat.
const (
	GetFleetAgentPoliciesAgentpolicyidParamsFormatLegacy     GetFleetAgentPoliciesAgentpolicyidParamsFormat = "legacy"
	GetFleetAgentPoliciesAgentpolicyidParamsFormatSimplified GetFleetAgentPoliciesAgentpolicyidParamsFormat = "simplified"
)

// Defines values for PutFleetAgentPoliciesAgentpolicyidParamsFormat.
const (
	PutFleetAgentPoliciesAgentpolicyidParamsFormatLegacy     PutFleetAgentPoliciesAgentpolicyidParamsFormat = "legacy"
	PutFleetAgentPoliciesAgentpolicyidParamsFormatSimplified PutFleetAgentPoliciesAgentpolicyidParamsFormat = "simplified"
)

// Defines values for PutFleetAgentPoliciesAgentpolicyidJSONBodyMonitoringEnabled.
const (
	Logs    PutFleetAgentPoliciesAgentpolicyidJSONBodyMonitoringEnabled = "logs"
	Metrics PutFleetAgentPoliciesAgentpolicyidJSONBodyMonitoringEnabled = "metrics"
	Traces  PutFleetAgentPoliciesAgentpolicyidJSONBodyMonitoringEnabled = "traces"
)

// Defines values for GetFleetPackagePoliciesParamsSortOrder.
const (
	GetFleetPackagePoliciesParamsSortOrderAsc  GetFleetPackagePoliciesParamsSortOrder = "asc"
	GetFleetPackagePoliciesParamsSortOrderDesc GetFleetPackagePoliciesParamsSortOrder = "desc"
)

// Defines values for GetFleetPackagePoliciesParamsFormat.
const (
	GetFleetPackagePoliciesParamsFormatLegacy     GetFleetPackagePoliciesParamsFormat = "legacy"
	GetFleetPackagePoliciesParamsFormatSimplified GetFleetPackagePoliciesParamsFormat = "simplified"
)

// Defines values for PostFleetPackagePoliciesParamsFormat.
const (
	PostFleetPackagePoliciesParamsFormatLegacy     PostFleetPackagePoliciesParamsFormat = "legacy"
	PostFleetPackagePoliciesParamsFormatSimplified PostFleetPackagePoliciesParamsFormat = "simplified"
)

// Defines values for GetFleetPackagePoliciesPackagepolicyidParamsFormat.
const (
	GetFleetPackagePoliciesPackagepolicyidParamsFormatLegacy     GetFleetPackagePoliciesPackagepolicyidParamsFormat = "legacy"
	GetFleetPackagePoliciesPackagepolicyidParamsFormatSimplified GetFleetPackagePoliciesPackagepolicyidParamsFormat = "simplified"
)

// Defines values for PutFleetPackagePoliciesPackagepolicyidParamsFormat.
const (
	Legacy     PutFleetPackagePoliciesPackagepolicyidParamsFormat = "legacy"
	Simplified PutFleetPackagePoliciesPackagepolicyidParamsFormat = "simplified"
)

// DataViews400Response defines model for Data_views_400_response.
type DataViews400Response struct {
	Error      string  `json:"error"`
	Message    string  `json:"message"`
	StatusCode float32 `json:"statusCode"`
}

// DataViews404Response defines model for Data_views_404_response.
type DataViews404Response struct {
	Error      *DataViews404ResponseError      `json:"error,omitempty"`
	Message    *string                         `json:"message,omitempty"`
	StatusCode *DataViews404ResponseStatusCode `json:"statusCode,omitempty"`
}

// DataViews404ResponseError defines model for DataViews404Response.Error.
type DataViews404ResponseError string

// DataViews404ResponseStatusCode defines model for DataViews404Response.StatusCode.
type DataViews404ResponseStatusCode int

// DataViewsAllownoindex Allows the data view saved object to exist before the data is available.
type DataViewsAllownoindex = bool

// DataViewsCreateDataViewRequestObject defines model for Data_views_create_data_view_request_object.
type DataViewsCreateDataViewRequestObject struct {
	// DataView The data view object.
	DataView DataViewsCreateDataViewRequestObjectInner `json:"data_view"`

	// Override Override an existing data view if a data view with the provided title already exists.
	Override *bool `json:"override,omitempty"`
}

// DataViewsCreateDataViewRequestObjectInner The data view object.
type DataViewsCreateDataViewRequestObjectInner struct {
	// AllowNoIndex Allows the data view saved object to exist before the data is available.
	AllowNoIndex *DataViewsAllownoindex          `json:"allowNoIndex,omitempty"`
	FieldAttrs   *map[string]DataViewsFieldattrs `json:"fieldAttrs,omitempty"`

	// FieldFormats A map of field formats by field name.
	FieldFormats *DataViewsFieldformats  `json:"fieldFormats,omitempty"`
	Fields       *map[string]interface{} `json:"fields,omitempty"`
	Id           *string                 `json:"id,omitempty"`

	// Name The data view name.
	Name *string `json:"name,omitempty"`

	// Namespaces An array of space identifiers for sharing the data view between multiple spaces.
	Namespaces      *DataViewsNamespaces                 `json:"namespaces,omitempty"`
	RuntimeFieldMap *map[string]DataViewsRuntimefieldmap `json:"runtimeFieldMap,omitempty"`

	// SourceFilters The array of field names you want to filter out in Discover.
	SourceFilters *DataViewsSourcefilters `json:"sourceFilters,omitempty"`

	// TimeFieldName The timestamp field name, which you use for time-based data views.
	TimeFieldName *DataViewsTimefieldname `json:"timeFieldName,omitempty"`

	// Title Comma-separated list of data streams, indices, and aliases that you want to search. Supports wildcards (`*`).
	Title DataViewsTitle `json:"title"`

	// Type When set to `rollup`, identifies the rollup data views.
	Type *DataViewsType `json:"type,omitempty"`

	// TypeMeta When you use rollup indices, contains the field list for the rollup data view API endpoints.
	TypeMeta *DataViewsTypemeta `json:"typeMeta,omitempty"`
	Version  *string            `json:"version,omitempty"`
}

// DataViewsDataViewResponseObject defines model for Data_views_data_view_response_object.
type DataViewsDataViewResponseObject struct {
	DataView *DataViewsDataViewResponseObjectInner `json:"data_view,omitempty"`
}

// DataViewsDataViewResponseObjectInner defines model for Data_views_data_view_response_object_inner.
type DataViewsDataViewResponseObjectInner struct {
	// AllowNoIndex Allows the data view saved object to exist before the data is available.
	AllowNoIndex *DataViewsAllownoindex          `json:"allowNoIndex,omitempty"`
	FieldAttrs   *map[string]DataViewsFieldattrs `json:"fieldAttrs,omitempty"`

	// FieldFormats A map of field formats by field name.
	FieldFormats *DataViewsFieldformats  `json:"fieldFormats,omitempty"`
	Fields       *map[string]interface{} `json:"fields,omitempty"`
	Id           *string                 `json:"id,omitempty"`

	// Name The data view name.
	Name *string `json:"name,omitempty"`

	// Namespaces An array of space identifiers for sharing the data view between multiple spaces.
	Namespaces      *DataViewsNamespaces                 `json:"namespaces,omitempty"`
	RuntimeFieldMap *map[string]DataViewsRuntimefieldmap `json:"runtimeFieldMap,omitempty"`

	// SourceFilters The array of field names you want to filter out in Discover.
	SourceFilters *DataViewsSourcefilters `json:"sourceFilters,omitempty"`

	// TimeFieldName The timestamp field name, which you use for time-based data views.
	TimeFieldName *DataViewsTimefieldname `json:"timeFieldName,omitempty"`

	// Title Comma-separated list of data streams, indices, and aliases that you want to search. Supports wildcards (`*`).
	Title *DataViewsTitle `json:"title,omitempty"`

	// TypeMeta When you use rollup indices, contains the field list for the rollup data view API endpoints.
	TypeMeta *DataViewsTypemetaResponse `json:"typeMeta"`
	Version  *string                    `json:"version,omitempty"`
}

// DataViewsFieldattrs A map of field attributes by field name.
type DataViewsFieldattrs struct {
	// Count Popularity count for the field.
	Count *int `json:"count,omitempty"`

	// CustomDescription Custom description for the field.
	CustomDescription *string `json:"customDescription,omitempty"`

	// CustomLabel Custom label for the field.
	CustomLabel *string `json:"customLabel,omitempty"`
}

// DataViewsFieldformat defines model for Data_views_fieldformat.
type DataViewsFieldformat struct {
	Id     *string                     `json:"id,omitempty"`
	Params *DataViewsFieldformatParams `json:"params,omitempty"`
}

// DataViewsFieldformatParams defines model for Data_views_fieldformat_params.
type DataViewsFieldformatParams struct {
	Colors                 *[]DataViewsFieldformatParamsColor  `json:"colors,omitempty"`
	FieldLength            *int                                `json:"fieldLength,omitempty"`
	FieldType              *string                             `json:"fieldType,omitempty"`
	Height                 *int                                `json:"height,omitempty"`
	IncludeSpaceWithSuffix *bool                               `json:"includeSpaceWithSuffix,omitempty"`
	InputFormat            *string                             `json:"inputFormat,omitempty"`
	LabelTemplate          *string                             `json:"labelTemplate,omitempty"`
	LookupEntries          *[]DataViewsFieldformatParamsLookup `json:"lookupEntries,omitempty"`
	OutputFormat           *string                             `json:"outputFormat,omitempty"`
	OutputPrecision        *int                                `json:"outputPrecision,omitempty"`
	Pattern                *string                             `json:"pattern,omitempty"`
	Timezone               *string                             `json:"timezone,omitempty"`
	Transform              *string                             `json:"transform,omitempty"`
	Type                   *string                             `json:"type,omitempty"`
	UnknownKeyValue        *string                             `json:"unknownKeyValue,omitempty"`
	UrlTemplate            *string                             `json:"urlTemplate,omitempty"`
	UseShortSuffix         *bool                               `json:"useShortSuffix,omitempty"`
	Width                  *int                                `json:"width,omitempty"`
}

// DataViewsFieldformatParamsColor defines model for Data_views_fieldformat_params_color.
type DataViewsFieldformatParamsColor struct {
	Background *string `json:"background,omitempty"`
	Range      *string `json:"range,omitempty"`
	Regex      *string `json:"regex,omitempty"`
	Text       *string `json:"text,omitempty"`
}

// DataViewsFieldformatParamsLookup defines model for Data_views_fieldformat_params_lookup.
type DataViewsFieldformatParamsLookup struct {
	Key   *string `json:"key,omitempty"`
	Value *string `json:"value,omitempty"`
}

// DataViewsFieldformats A map of field formats by field name.
type DataViewsFieldformats map[string]DataViewsFieldformat

// DataViewsNamespaces An array of space identifiers for sharing the data view between multiple spaces.
type DataViewsNamespaces = []string

// DataViewsRuntimefieldmap A map of runtime field definitions by field name.
type DataViewsRuntimefieldmap struct {
	Script DataViewsRuntimefieldmapScript `json:"script"`

	// Type Mapping type of the runtime field.
	Type string `json:"type"`
}

// DataViewsRuntimefieldmapScript defines model for Data_views_runtimefieldmap_script.
type DataViewsRuntimefieldmapScript struct {
	// Source Script for the runtime field.
	Source *string `json:"source,omitempty"`
}

// DataViewsSourcefilterItem defines model for Data_views_sourcefilter_item.
type DataViewsSourcefilterItem struct {
	Value string `json:"value"`
}

// DataViewsSourcefilters The array of field names you want to filter out in Discover.
type DataViewsSourcefilters = []DataViewsSourcefilterItem

// DataViewsTimefieldname The timestamp field name, which you use for time-based data views.
type DataViewsTimefieldname = string

// DataViewsTitle Comma-separated list of data streams, indices, and aliases that you want to search. Supports wildcards (`*`).
type DataViewsTitle = string

// DataViewsType When set to `rollup`, identifies the rollup data views.
type DataViewsType = string

// DataViewsTypemeta When you use rollup indices, contains the field list for the rollup data view API endpoints.
type DataViewsTypemeta struct {
	// Aggs A map of rollup restrictions by aggregation type and field name.
	Aggs map[string]interface{} `json:"aggs"`

	// Params Properties for retrieving rollup fields.
	Params map[string]interface{} `json:"params"`
}

// DataViewsTypemetaResponse When you use rollup indices, contains the field list for the rollup data view API endpoints.
type DataViewsTypemetaResponse struct {
	// Aggs A map of rollup restrictions by aggregation type and field name.
	Aggs *map[string]interface{} `json:"aggs,omitempty"`

	// Params Properties for retrieving rollup fields.
	Params *map[string]interface{} `json:"params,omitempty"`
}

// DataViewsUpdateDataViewRequestObject defines model for Data_views_update_data_view_request_object.
type DataViewsUpdateDataViewRequestObject struct {
	// DataView The data view properties you want to update. Only the specified properties are updated in the data view. Unspecified fields stay as they are persisted.
	DataView DataViewsUpdateDataViewRequestObjectInner `json:"data_view"`

	// RefreshFields Reloads the data view fields after the data view is updated.
	RefreshFields *bool `json:"refresh_fields,omitempty"`
}

// DataViewsUpdateDataViewRequestObjectInner The data view properties you want to update. Only the specified properties are updated in the data view. Unspecified fields stay as they are persisted.
type DataViewsUpdateDataViewRequestObjectInner struct {
	// AllowNoIndex Allows the data view saved object to exist before the data is available.
	AllowNoIndex *DataViewsAllownoindex `json:"allowNoIndex,omitempty"`

	// FieldFormats A map of field formats by field name.
	FieldFormats    *DataViewsFieldformats               `json:"fieldFormats,omitempty"`
	Fields          *map[string]interface{}              `json:"fields,omitempty"`
	Name            *string                              `json:"name,omitempty"`
	RuntimeFieldMap *map[string]DataViewsRuntimefieldmap `json:"runtimeFieldMap,omitempty"`

	// SourceFilters The array of field names you want to filter out in Discover.
	SourceFilters *DataViewsSourcefilters `json:"sourceFilters,omitempty"`

	// TimeFieldName The timestamp field name, which you use for time-based data views.
	TimeFieldName *DataViewsTimefieldname `json:"timeFieldName,omitempty"`

	// Title Comma-separated list of data streams, indices, and aliases that you want to search. Supports wildcards (`*`).
	Title *DataViewsTitle `json:"title,omitempty"`

	// Type When set to `rollup`, identifies the rollup data views.
	Type *DataViewsType `json:"type,omitempty"`

	// TypeMeta When you use rollup indices, contains the field list for the rollup data view API endpoints.
	TypeMeta *DataViewsTypemeta `json:"typeMeta,omitempty"`
}

// AgentPolicy defines model for agent_policy.
type AgentPolicy struct {
	AdvancedSettings *struct {
		AgentDownloadTargetDirectory *interface{} `json:"agent_download_target_directory"`
		AgentDownloadTimeout         *interface{} `json:"agent_download_timeout"`
		AgentLimitsGoMaxProcs        *interface{} `json:"agent_limits_go_max_procs"`
		AgentLoggingLevel            *interface{} `json:"agent_logging_level"`
		AgentLoggingMetricsPeriod    *interface{} `json:"agent_logging_metrics_period"`
	} `json:"advanced_settings,omitempty"`
	AgentFeatures *[]struct {
		Enabled bool   `json:"enabled"`
		Name    string `json:"name"`
	} `json:"agent_features,omitempty"`
	Agents            *float32 `json:"agents,omitempty"`
	DataOutputId      *string  `json:"data_output_id"`
	Description       *string  `json:"description,omitempty"`
	DownloadSourceId  *string  `json:"download_source_id"`
	FleetServerHostId *string  `json:"fleet_server_host_id"`

	// GlobalDataTags User defined data tags that are added to all of the inputs. The values can be strings or numbers.
	GlobalDataTags       *[]AgentPolicyGlobalDataTagsItem `json:"global_data_tags,omitempty"`
	HasFleetServer       *bool                            `json:"has_fleet_server,omitempty"`
	Id                   string                           `json:"id"`
	InactivityTimeout    *float32                         `json:"inactivity_timeout,omitempty"`
	IsDefault            *bool                            `json:"is_default,omitempty"`
	IsDefaultFleetServer *bool                            `json:"is_default_fleet_server,omitempty"`
	IsManaged            bool                             `json:"is_managed"`
	IsPreconfigured      *bool                            `json:"is_preconfigured,omitempty"`

	// IsProtected Indicates whether the agent policy has tamper protection enabled. Default false.
	IsProtected bool `json:"is_protected"`

	// KeepMonitoringAlive When set to true, monitoring will be enabled but logs/metrics collection will be disabled
	KeepMonitoringAlive   *bool `json:"keep_monitoring_alive"`
	MonitoringDiagnostics *struct {
		Limit *struct {
			Burst    *float32 `json:"burst,omitempty"`
			Interval *string  `json:"interval,omitempty"`
		} `json:"limit,omitempty"`
		Uploader *struct {
			InitDur    *string  `json:"init_dur,omitempty"`
			MaxDur     *string  `json:"max_dur,omitempty"`
			MaxRetries *float32 `json:"max_retries,omitempty"`
		} `json:"uploader,omitempty"`
	} `json:"monitoring_diagnostics,omitempty"`
	MonitoringEnabled *[]AgentPolicyMonitoringEnabled `json:"monitoring_enabled,omitempty"`
	MonitoringHttp    *struct {
		Buffer *struct {
			Enabled *bool `json:"enabled,omitempty"`
		} `json:"buffer,omitempty"`
		Enabled bool     `json:"enabled"`
		Host    *string  `json:"host,omitempty"`
		Port    *float32 `json:"port,omitempty"`
	} `json:"monitoring_http,omitempty"`
	MonitoringOutputId     *string `json:"monitoring_output_id"`
	MonitoringPprofEnabled *bool   `json:"monitoring_pprof_enabled,omitempty"`
	Name                   string  `json:"name"`
	Namespace              string  `json:"namespace"`

	// Overrides Override settings that are defined in the agent policy. Input settings cannot be overridden. The override option should be used only in unusual circumstances and not as a routine procedure.
	Overrides       *map[string]interface{}      `json:"overrides"`
	PackagePolicies *AgentPolicy_PackagePolicies `json:"package_policies,omitempty"`
	Revision        float32                      `json:"revision"`
	SchemaVersion   *string                      `json:"schema_version,omitempty"`
	SpaceIds        *[]string                    `json:"space_ids,omitempty"`
	Status          AgentPolicyStatus            `json:"status"`

	// SupportsAgentless Indicates whether the agent policy supports agentless integrations.
	SupportsAgentless  *bool    `json:"supports_agentless"`
	UnenrollTimeout    *float32 `json:"unenroll_timeout,omitempty"`
	UnprivilegedAgents *float32 `json:"unprivileged_agents,omitempty"`
	UpdatedAt          string   `json:"updated_at"`
	UpdatedBy          string   `json:"updated_by"`
	Version            *string  `json:"version,omitempty"`
}

// AgentPolicyMonitoringEnabled defines model for AgentPolicy.MonitoringEnabled.
type AgentPolicyMonitoringEnabled string

// AgentPolicyPackagePolicies0 defines model for .
type AgentPolicyPackagePolicies0 = []string

// AgentPolicyPackagePolicies1 This field is present only when retrieving a single agent policy, or when retrieving a list of agent policies with the ?full=true parameter
type AgentPolicyPackagePolicies1 = []struct {
	CreatedAt string `json:"created_at"`
	CreatedBy string `json:"created_by"`

	// Description Package policy description
	Description   *string                                      `json:"description,omitempty"`
	Elasticsearch *AgentPolicy_PackagePolicies_1_Elasticsearch `json:"elasticsearch,omitempty"`
	Enabled       bool                                         `json:"enabled"`
	Id            string                                       `json:"id"`
	Inputs        []struct {
		CompiledInput interface{} `json:"compiled_input"`

		// Config Package variable (see integration documentation for more information)
		Config *map[string]struct {
			Frozen *bool       `json:"frozen,omitempty"`
			Type   *string     `json:"type,omitempty"`
			Value  interface{} `json:"value"`
		} `json:"config,omitempty"`
		Enabled        bool    `json:"enabled"`
		Id             *string `json:"id,omitempty"`
		KeepEnabled    *bool   `json:"keep_enabled,omitempty"`
		PolicyTemplate *string `json:"policy_template,omitempty"`
		Streams        []struct {
			CompiledStream interface{} `json:"compiled_stream"`

			// Config Package variable (see integration documentation for more information)
			Config *map[string]struct {
				Frozen *bool       `json:"frozen,omitempty"`
				Type   *string     `json:"type,omitempty"`
				Value  interface{} `json:"value"`
			} `json:"config,omitempty"`
			DataStream struct {
				Dataset       string `json:"dataset"`
				Elasticsearch *struct {
					DynamicDataset   *bool `json:"dynamic_dataset,omitempty"`
					DynamicNamespace *bool `json:"dynamic_namespace,omitempty"`
					Privileges       *struct {
						Indices *[]string `json:"indices,omitempty"`
					} `json:"privileges,omitempty"`
				} `json:"elasticsearch,omitempty"`
				Type string `json:"type"`
			} `json:"data_stream"`
			Enabled     bool                                             `json:"enabled"`
			Id          *string                                          `json:"id,omitempty"`
			KeepEnabled *bool                                            `json:"keep_enabled,omitempty"`
			Release     *AgentPolicyPackagePolicies1InputsStreamsRelease `json:"release,omitempty"`

			// Vars Package variable (see integration documentation for more information)
			Vars *map[string]struct {
				Frozen *bool       `json:"frozen,omitempty"`
				Type   *string     `json:"type,omitempty"`
				Value  interface{} `json:"value"`
			} `json:"vars,omitempty"`
		} `json:"streams"`
		Type string `json:"type"`

		// Vars Package variable (see integration documentation for more information)
		Vars *map[string]struct {
			Frozen *bool       `json:"frozen,omitempty"`
			Type   *string     `json:"type,omitempty"`
			Value  interface{} `json:"value"`
		} `json:"vars,omitempty"`
	} `json:"inputs"`
	IsManaged *bool `json:"is_managed,omitempty"`

	// Name Package policy name (should be unique)
	Name string `json:"name"`

	// Namespace The package policy namespace. Leave blank to inherit the agent policy's namespace.
	Namespace *string `json:"namespace,omitempty"`
	OutputId  *string `json:"output_id"`

	// Overrides Override settings that are defined in the package policy. The override option should be used only in unusual circumstances and not as a routine procedure.
	Overrides *struct {
		Inputs *map[string]interface{} `json:"inputs,omitempty"`
	} `json:"overrides"`
	Package *struct {
		ExperimentalDataStreamFeatures *[]struct {
			DataStream string `json:"data_stream"`
			Features   struct {
				DocValueOnlyNumeric *bool `json:"doc_value_only_numeric,omitempty"`
				DocValueOnlyOther   *bool `json:"doc_value_only_other,omitempty"`
				SyntheticSource     *bool `json:"synthetic_source,omitempty"`
				Tsdb                *bool `json:"tsdb,omitempty"`
			} `json:"features"`
		} `json:"experimental_data_stream_features,omitempty"`

		// Name Package name
		Name         string  `json:"name"`
		RequiresRoot *bool   `json:"requires_root,omitempty"`
		Title        *string `json:"title,omitempty"`

		// Version Package version
		Version string `json:"version"`
	} `json:"package,omitempty"`

	// PolicyId Agent policy ID where that package policy will be added
	// Deprecated:
	PolicyId         *string   `json:"policy_id"`
	PolicyIds        *[]string `json:"policy_ids,omitempty"`
	Revision         float32   `json:"revision"`
	SecretReferences *[]struct {
		Id string `json:"id"`
	} `json:"secret_references,omitempty"`
	UpdatedAt string `json:"updated_at"`
	UpdatedBy string `json:"updated_by"`

	// Vars Package variable (see integration documentation for more information)
	Vars *map[string]struct {
		Frozen *bool       `json:"frozen,omitempty"`
		Type   *string     `json:"type,omitempty"`
		Value  interface{} `json:"value"`
	} `json:"vars,omitempty"`
	Version *string `json:"version,omitempty"`
}

// AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges defines model for AgentPolicy.PackagePolicies.1.Elasticsearch.Privileges.
type AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges struct {
	Cluster              *[]string              `json:"cluster,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// AgentPolicy_PackagePolicies_1_Elasticsearch defines model for AgentPolicy.PackagePolicies.1.Elasticsearch.
type AgentPolicy_PackagePolicies_1_Elasticsearch struct {
	Privileges           *AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges `json:"privileges,omitempty"`
	AdditionalProperties map[string]interface{}                                  `json:"-"`
}

// AgentPolicyPackagePolicies1InputsStreamsRelease defines model for AgentPolicy.PackagePolicies.1.Inputs.Streams.Release.
type AgentPolicyPackagePolicies1InputsStreamsRelease string

// AgentPolicy_PackagePolicies defines model for AgentPolicy.PackagePolicies.
type AgentPolicy_PackagePolicies struct {
	union json.RawMessage
}

// AgentPolicyStatus defines model for AgentPolicy.Status.
type AgentPolicyStatus string

// AgentPolicyGlobalDataTagsItem defines model for agent_policy_global_data_tags_item.
type AgentPolicyGlobalDataTagsItem struct {
	Name  string                              `json:"name"`
	Value AgentPolicyGlobalDataTagsItem_Value `json:"value"`
}

// AgentPolicyGlobalDataTagsItemValue0 defines model for .
type AgentPolicyGlobalDataTagsItemValue0 = string

// AgentPolicyGlobalDataTagsItemValue1 defines model for .
type AgentPolicyGlobalDataTagsItemValue1 = float32

// AgentPolicyGlobalDataTagsItem_Value defines model for AgentPolicyGlobalDataTagsItem.Value.
type AgentPolicyGlobalDataTagsItem_Value struct {
	union json.RawMessage
}

// EnrollmentApiKey defines model for enrollment_api_key.
type EnrollmentApiKey struct {
	// Active When false, the enrollment API key is revoked and cannot be used for enrolling Elastic Agents.
	Active bool `json:"active"`

	// ApiKey The enrollment API key (token) used for enrolling Elastic Agents.
	ApiKey string `json:"api_key"`

	// ApiKeyId The ID of the API key in the Security API.
	ApiKeyId  string `json:"api_key_id"`
	CreatedAt string `json:"created_at"`
	Id        string `json:"id"`

	// Name The name of the enrollment API key.
	Name *string `json:"name,omitempty"`

	// PolicyId The ID of the agent policy the Elastic Agent will be enrolled in.
	PolicyId *string `json:"policy_id,omitempty"`
}

// GetDataViewsResponseItem defines model for get_data_views_response_item.
type GetDataViewsResponseItem struct {
	Id         *string                 `json:"id,omitempty"`
	Name       *string                 `json:"name,omitempty"`
	Namespaces *[]string               `json:"namespaces,omitempty"`
	Title      *string                 `json:"title,omitempty"`
	TypeMeta   *map[string]interface{} `json:"typeMeta,omitempty"`
}

// NewOutputElasticsearch defines model for new_output_elasticsearch.
type NewOutputElasticsearch struct {
	AllowEdit            *[]string                     `json:"allow_edit,omitempty"`
	CaSha256             *string                       `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                       `json:"ca_trusted_fingerprint,omitempty"`
	ConfigYaml           *string                       `json:"config_yaml"`
	Hosts                []string                      `json:"hosts"`
	Id                   *string                       `json:"id,omitempty"`
	IsDefault            *bool                         `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                         `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                         `json:"is_internal,omitempty"`
	IsPreconfigured      *bool                         `json:"is_preconfigured,omitempty"`
	Name                 string                        `json:"name"`
	Preset               *NewOutputElasticsearchPreset `json:"preset,omitempty"`
	ProxyId              *string                       `json:"proxy_id,omitempty"`
	Shipper              *NewOutputShipper             `json:"shipper,omitempty"`
	Ssl                  *NewOutputSsl                 `json:"ssl,omitempty"`
	Type                 NewOutputElasticsearchType    `json:"type"`
}

// NewOutputElasticsearchPreset defines model for NewOutputElasticsearch.Preset.
type NewOutputElasticsearchPreset string

// NewOutputElasticsearchType defines model for NewOutputElasticsearch.Type.
type NewOutputElasticsearchType string

// NewOutputKafka defines model for new_output_kafka.
type NewOutputKafka struct {
	AllowEdit            *[]string                  `json:"allow_edit,omitempty"`
	AuthType             NewOutputKafkaAuthType     `json:"auth_type"`
	BrokerTimeout        *float32                   `json:"broker_timeout,omitempty"`
	CaSha256             *string                    `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                    `json:"ca_trusted_fingerprint,omitempty"`
	ClientId             *string                    `json:"client_id,omitempty"`
	Compression          *NewOutputKafkaCompression `json:"compression,omitempty"`
	CompressionLevel     interface{}                `json:"compression_level"`
	ConfigYaml           *string                    `json:"config_yaml"`
	ConnectionType       interface{}                `json:"connection_type"`
	Hash                 *struct {
		Hash   *string `json:"hash,omitempty"`
		Random *bool   `json:"random,omitempty"`
	} `json:"hash,omitempty"`
	Headers *[]struct {
		Key   string `json:"key"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Hosts               []string                 `json:"hosts"`
	Id                  *string                  `json:"id,omitempty"`
	IsDefault           *bool                    `json:"is_default,omitempty"`
	IsDefaultMonitoring *bool                    `json:"is_default_monitoring,omitempty"`
	IsInternal          *bool                    `json:"is_internal,omitempty"`
	IsPreconfigured     *bool                    `json:"is_preconfigured,omitempty"`
	Key                 *string                  `json:"key,omitempty"`
	Name                string                   `json:"name"`
	Partition           *NewOutputKafkaPartition `json:"partition,omitempty"`
	Password            interface{}              `json:"password"`
	ProxyId             *string                  `json:"proxy_id,omitempty"`
	Random              *struct {
		GroupEvents *float32 `json:"group_events,omitempty"`
	} `json:"random,omitempty"`
	RequiredAcks *NewOutputKafkaRequiredAcks `json:"required_acks,omitempty"`
	RoundRobin   *struct {
		GroupEvents *float32 `json:"group_events,omitempty"`
	} `json:"round_robin,omitempty"`
	Sasl *struct {
		Mechanism *NewOutputKafkaSaslMechanism `json:"mechanism,omitempty"`
	} `json:"sasl"`
	Secrets *struct {
		Password *NewOutputKafka_Secrets_Password `json:"password,omitempty"`
		Ssl      *struct {
			Key NewOutputKafka_Secrets_Ssl_Key `json:"key"`
		} `json:"ssl,omitempty"`
	} `json:"secrets,omitempty"`
	Shipper  *NewOutputShipper  `json:"shipper,omitempty"`
	Ssl      *NewOutputSsl      `json:"ssl,omitempty"`
	Timeout  *float32           `json:"timeout,omitempty"`
	Topic    *string            `json:"topic,omitempty"`
	Type     NewOutputKafkaType `json:"type"`
	Username interface{}        `json:"username"`
	Version  *string            `json:"version,omitempty"`
}

// NewOutputKafkaAuthType defines model for NewOutputKafka.AuthType.
type NewOutputKafkaAuthType string

// NewOutputKafkaCompression defines model for NewOutputKafka.Compression.
type NewOutputKafkaCompression string

// NewOutputKafkaPartition defines model for NewOutputKafka.Partition.
type NewOutputKafkaPartition string

// NewOutputKafkaRequiredAcks defines model for NewOutputKafka.RequiredAcks.
type NewOutputKafkaRequiredAcks int

// NewOutputKafkaSaslMechanism defines model for NewOutputKafka.Sasl.Mechanism.
type NewOutputKafkaSaslMechanism string

// NewOutputKafkaSecretsPassword0 defines model for .
type NewOutputKafkaSecretsPassword0 struct {
	Id string `json:"id"`
}

// NewOutputKafkaSecretsPassword1 defines model for .
type NewOutputKafkaSecretsPassword1 = string

// NewOutputKafka_Secrets_Password defines model for NewOutputKafka.Secrets.Password.
type NewOutputKafka_Secrets_Password struct {
	union json.RawMessage
}

// NewOutputKafkaSecretsSslKey0 defines model for .
type NewOutputKafkaSecretsSslKey0 struct {
	Id string `json:"id"`
}

// NewOutputKafkaSecretsSslKey1 defines model for .
type NewOutputKafkaSecretsSslKey1 = string

// NewOutputKafka_Secrets_Ssl_Key defines model for NewOutputKafka.Secrets.Ssl.Key.
type NewOutputKafka_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// NewOutputKafkaType defines model for NewOutputKafka.Type.
type NewOutputKafkaType string

// NewOutputLogstash defines model for new_output_logstash.
type NewOutputLogstash struct {
	AllowEdit            *[]string `json:"allow_edit,omitempty"`
	CaSha256             *string   `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string   `json:"ca_trusted_fingerprint,omitempty"`
	ConfigYaml           *string   `json:"config_yaml"`
	Hosts                []string  `json:"hosts"`
	Id                   *string   `json:"id,omitempty"`
	IsDefault            *bool     `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool     `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool     `json:"is_internal,omitempty"`
	IsPreconfigured      *bool     `json:"is_preconfigured,omitempty"`
	Name                 string    `json:"name"`
	ProxyId              *string   `json:"proxy_id,omitempty"`
	Secrets              *struct {
		Ssl *struct {
			Key *NewOutputLogstash_Secrets_Ssl_Key `json:"key,omitempty"`
		} `json:"ssl,omitempty"`
	} `json:"secrets,omitempty"`
	Shipper *NewOutputShipper     `json:"shipper,omitempty"`
	Ssl     *NewOutputSsl         `json:"ssl,omitempty"`
	Type    NewOutputLogstashType `json:"type"`
}

// NewOutputLogstashSecretsSslKey0 defines model for .
type NewOutputLogstashSecretsSslKey0 struct {
	Id string `json:"id"`
}

// NewOutputLogstashSecretsSslKey1 defines model for .
type NewOutputLogstashSecretsSslKey1 = string

// NewOutputLogstash_Secrets_Ssl_Key defines model for NewOutputLogstash.Secrets.Ssl.Key.
type NewOutputLogstash_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// NewOutputLogstashType defines model for NewOutputLogstash.Type.
type NewOutputLogstashType string

// NewOutputRemoteElasticsearch defines model for new_output_remote_elasticsearch.
type NewOutputRemoteElasticsearch struct {
	AllowEdit            *[]string                           `json:"allow_edit,omitempty"`
	CaSha256             *string                             `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                             `json:"ca_trusted_fingerprint,omitempty"`
	ConfigYaml           *string                             `json:"config_yaml"`
	Hosts                []string                            `json:"hosts"`
	Id                   *string                             `json:"id,omitempty"`
	IsDefault            *bool                               `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                               `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                               `json:"is_internal,omitempty"`
	IsPreconfigured      *bool                               `json:"is_preconfigured,omitempty"`
	Name                 string                              `json:"name"`
	Preset               *NewOutputRemoteElasticsearchPreset `json:"preset,omitempty"`
	ProxyId              *string                             `json:"proxy_id,omitempty"`
	Secrets              *struct {
		ServiceToken *NewOutputRemoteElasticsearch_Secrets_ServiceToken `json:"service_token,omitempty"`
	} `json:"secrets,omitempty"`
	ServiceToken *string                          `json:"service_token"`
	Shipper      *NewOutputShipper                `json:"shipper,omitempty"`
	Ssl          *NewOutputSsl                    `json:"ssl,omitempty"`
	Type         NewOutputRemoteElasticsearchType `json:"type"`
}

// NewOutputRemoteElasticsearchPreset defines model for NewOutputRemoteElasticsearch.Preset.
type NewOutputRemoteElasticsearchPreset string

// NewOutputRemoteElasticsearchSecretsServiceToken0 defines model for .
type NewOutputRemoteElasticsearchSecretsServiceToken0 struct {
	Id string `json:"id"`
}

// NewOutputRemoteElasticsearchSecretsServiceToken1 defines model for .
type NewOutputRemoteElasticsearchSecretsServiceToken1 = string

// NewOutputRemoteElasticsearch_Secrets_ServiceToken defines model for NewOutputRemoteElasticsearch.Secrets.ServiceToken.
type NewOutputRemoteElasticsearch_Secrets_ServiceToken struct {
	union json.RawMessage
}

// NewOutputRemoteElasticsearchType defines model for NewOutputRemoteElasticsearch.Type.
type NewOutputRemoteElasticsearchType string

// NewOutputShipper defines model for new_output_shipper.
type NewOutputShipper struct {
	CompressionLevel            *float32 `json:"compression_level"`
	DiskQueueCompressionEnabled *bool    `json:"disk_queue_compression_enabled"`
	DiskQueueEnabled            *bool    `json:"disk_queue_enabled"`
	DiskQueueEncryptionEnabled  *bool    `json:"disk_queue_encryption_enabled"`
	DiskQueueMaxSize            *float32 `json:"disk_queue_max_size"`
	DiskQueuePath               *string  `json:"disk_queue_path"`
	Loadbalance                 *bool    `json:"loadbalance"`
	MaxBatchBytes               *float32 `json:"max_batch_bytes"`
	MemQueueEvents              *float32 `json:"mem_queue_events"`
	QueueFlushTimeout           *float32 `json:"queue_flush_timeout"`
}

// NewOutputSsl defines model for new_output_ssl.
type NewOutputSsl struct {
	Certificate            *string                       `json:"certificate,omitempty"`
	CertificateAuthorities *[]string                     `json:"certificate_authorities,omitempty"`
	Key                    *string                       `json:"key,omitempty"`
	VerificationMode       *NewOutputSslVerificationMode `json:"verification_mode,omitempty"`
}

// NewOutputSslVerificationMode defines model for NewOutputSsl.VerificationMode.
type NewOutputSslVerificationMode string

// NewOutputUnion defines model for new_output_union.
type NewOutputUnion struct {
	union json.RawMessage
}

// OutputElasticsearch defines model for output_elasticsearch.
type OutputElasticsearch struct {
	AllowEdit            *[]string                  `json:"allow_edit,omitempty"`
	CaSha256             *string                    `json:"ca_sha256"`
	CaTrustedFingerprint *string                    `json:"ca_trusted_fingerprint"`
	ConfigYaml           *string                    `json:"config_yaml"`
	Hosts                []string                   `json:"hosts"`
	Id                   *string                    `json:"id,omitempty"`
	IsDefault            *bool                      `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                      `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                      `json:"is_internal,omitempty"`
	IsPreconfigured      *bool                      `json:"is_preconfigured,omitempty"`
	Name                 string                     `json:"name"`
	Preset               *OutputElasticsearchPreset `json:"preset,omitempty"`
	ProxyId              *string                    `json:"proxy_id"`
	Shipper              *OutputShipper             `json:"shipper"`
	Ssl                  *OutputSsl                 `json:"ssl"`
	Type                 OutputElasticsearchType    `json:"type"`
	AdditionalProperties map[string]interface{}     `json:"-"`
}

// OutputElasticsearchPreset defines model for OutputElasticsearch.Preset.
type OutputElasticsearchPreset string

// OutputElasticsearchType defines model for OutputElasticsearch.Type.
type OutputElasticsearchType string

// OutputKafka defines model for output_kafka.
type OutputKafka struct {
	AllowEdit            *[]string                   `json:"allow_edit,omitempty"`
	AuthType             OutputKafkaAuthType         `json:"auth_type"`
	BrokerTimeout        *float32                    `json:"broker_timeout,omitempty"`
	CaSha256             *string                     `json:"ca_sha256"`
	CaTrustedFingerprint *string                     `json:"ca_trusted_fingerprint"`
	ClientId             *string                     `json:"client_id,omitempty"`
	Compression          *OutputKafkaCompression     `json:"compression,omitempty"`
	CompressionLevel     interface{}                 `json:"compression_level"`
	ConfigYaml           *string                     `json:"config_yaml"`
	ConnectionType       interface{}                 `json:"connection_type"`
	Hash                 *OutputKafka_Hash           `json:"hash,omitempty"`
	Headers              *[]OutputKafka_Headers_Item `json:"headers,omitempty"`
	Hosts                []string                    `json:"hosts"`
	Id                   *string                     `json:"id,omitempty"`
	IsDefault            *bool                       `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                       `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                       `json:"is_internal,omitempty"`
	IsPreconfigured      *bool                       `json:"is_preconfigured,omitempty"`
	Key                  *string                     `json:"key,omitempty"`
	Name                 string                      `json:"name"`
	Partition            *OutputKafkaPartition       `json:"partition,omitempty"`
	Password             interface{}                 `json:"password"`
	ProxyId              *string                     `json:"proxy_id"`
	Random               *OutputKafka_Random         `json:"random,omitempty"`
	RequiredAcks         *OutputKafkaRequiredAcks    `json:"required_acks,omitempty"`
	RoundRobin           *OutputKafka_RoundRobin     `json:"round_robin,omitempty"`
	Sasl                 *OutputKafka_Sasl           `json:"sasl"`
	Secrets              *OutputKafka_Secrets        `json:"secrets,omitempty"`
	Shipper              *OutputShipper              `json:"shipper"`
	Ssl                  *OutputSsl                  `json:"ssl"`
	Timeout              *float32                    `json:"timeout,omitempty"`
	Topic                *string                     `json:"topic,omitempty"`
	Type                 OutputKafkaType             `json:"type"`
	Username             interface{}                 `json:"username"`
	Version              *string                     `json:"version,omitempty"`
	AdditionalProperties map[string]interface{}      `json:"-"`
}

// OutputKafkaAuthType defines model for OutputKafka.AuthType.
type OutputKafkaAuthType string

// OutputKafkaCompression defines model for OutputKafka.Compression.
type OutputKafkaCompression string

// OutputKafka_Hash defines model for OutputKafka.Hash.
type OutputKafka_Hash struct {
	Hash                 *string                `json:"hash,omitempty"`
	Random               *bool                  `json:"random,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputKafka_Headers_Item defines model for output_kafka.headers.Item.
type OutputKafka_Headers_Item struct {
	Key                  string                 `json:"key"`
	Value                string                 `json:"value"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputKafkaPartition defines model for OutputKafka.Partition.
type OutputKafkaPartition string

// OutputKafka_Random defines model for OutputKafka.Random.
type OutputKafka_Random struct {
	GroupEvents          *float32               `json:"group_events,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputKafkaRequiredAcks defines model for OutputKafka.RequiredAcks.
type OutputKafkaRequiredAcks int

// OutputKafka_RoundRobin defines model for OutputKafka.RoundRobin.
type OutputKafka_RoundRobin struct {
	GroupEvents          *float32               `json:"group_events,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputKafkaSaslMechanism defines model for OutputKafka.Sasl.Mechanism.
type OutputKafkaSaslMechanism string

// OutputKafka_Sasl defines model for OutputKafka.Sasl.
type OutputKafka_Sasl struct {
	Mechanism            *OutputKafkaSaslMechanism `json:"mechanism,omitempty"`
	AdditionalProperties map[string]interface{}    `json:"-"`
}

// OutputKafkaSecretsPassword0 defines model for .
type OutputKafkaSecretsPassword0 struct {
	Id                   string                 `json:"id"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputKafkaSecretsPassword1 defines model for .
type OutputKafkaSecretsPassword1 = string

// OutputKafka_Secrets_Password defines model for OutputKafka.Secrets.Password.
type OutputKafka_Secrets_Password struct {
	union json.RawMessage
}

// OutputKafkaSecretsSslKey0 defines model for .
type OutputKafkaSecretsSslKey0 struct {
	Id                   string                 `json:"id"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputKafkaSecretsSslKey1 defines model for .
type OutputKafkaSecretsSslKey1 = string

// OutputKafka_Secrets_Ssl_Key defines model for OutputKafka.Secrets.Ssl.Key.
type OutputKafka_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// OutputKafka_Secrets_Ssl defines model for OutputKafka.Secrets.Ssl.
type OutputKafka_Secrets_Ssl struct {
	Key                  OutputKafka_Secrets_Ssl_Key `json:"key"`
	AdditionalProperties map[string]interface{}      `json:"-"`
}

// OutputKafka_Secrets defines model for OutputKafka.Secrets.
type OutputKafka_Secrets struct {
	Password             *OutputKafka_Secrets_Password `json:"password,omitempty"`
	Ssl                  *OutputKafka_Secrets_Ssl      `json:"ssl,omitempty"`
	AdditionalProperties map[string]interface{}        `json:"-"`
}

// OutputKafkaType defines model for OutputKafka.Type.
type OutputKafkaType string

// OutputLogstash defines model for output_logstash.
type OutputLogstash struct {
	AllowEdit            *[]string               `json:"allow_edit,omitempty"`
	CaSha256             *string                 `json:"ca_sha256"`
	CaTrustedFingerprint *string                 `json:"ca_trusted_fingerprint"`
	ConfigYaml           *string                 `json:"config_yaml"`
	Hosts                []string                `json:"hosts"`
	Id                   *string                 `json:"id,omitempty"`
	IsDefault            *bool                   `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                   `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                   `json:"is_internal,omitempty"`
	IsPreconfigured      *bool                   `json:"is_preconfigured,omitempty"`
	Name                 string                  `json:"name"`
	ProxyId              *string                 `json:"proxy_id"`
	Secrets              *OutputLogstash_Secrets `json:"secrets,omitempty"`
	Shipper              *OutputShipper          `json:"shipper"`
	Ssl                  *OutputSsl              `json:"ssl"`
	Type                 OutputLogstashType      `json:"type"`
	AdditionalProperties map[string]interface{}  `json:"-"`
}

// OutputLogstashSecretsSslKey0 defines model for .
type OutputLogstashSecretsSslKey0 struct {
	Id                   string                 `json:"id"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputLogstashSecretsSslKey1 defines model for .
type OutputLogstashSecretsSslKey1 = string

// OutputLogstash_Secrets_Ssl_Key defines model for OutputLogstash.Secrets.Ssl.Key.
type OutputLogstash_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// OutputLogstash_Secrets_Ssl defines model for OutputLogstash.Secrets.Ssl.
type OutputLogstash_Secrets_Ssl struct {
	Key                  *OutputLogstash_Secrets_Ssl_Key `json:"key,omitempty"`
	AdditionalProperties map[string]interface{}          `json:"-"`
}

// OutputLogstash_Secrets defines model for OutputLogstash.Secrets.
type OutputLogstash_Secrets struct {
	Ssl                  *OutputLogstash_Secrets_Ssl `json:"ssl,omitempty"`
	AdditionalProperties map[string]interface{}      `json:"-"`
}

// OutputLogstashType defines model for OutputLogstash.Type.
type OutputLogstashType string

// OutputRemoteElasticsearch defines model for output_remote_elasticsearch.
type OutputRemoteElasticsearch struct {
	AllowEdit            *[]string                          `json:"allow_edit,omitempty"`
	CaSha256             *string                            `json:"ca_sha256"`
	CaTrustedFingerprint *string                            `json:"ca_trusted_fingerprint"`
	ConfigYaml           *string                            `json:"config_yaml"`
	Hosts                []string                           `json:"hosts"`
	Id                   *string                            `json:"id,omitempty"`
	IsDefault            *bool                              `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                              `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                              `json:"is_internal,omitempty"`
	IsPreconfigured      *bool                              `json:"is_preconfigured,omitempty"`
	Name                 string                             `json:"name"`
	Preset               *OutputRemoteElasticsearchPreset   `json:"preset,omitempty"`
	ProxyId              *string                            `json:"proxy_id"`
	Secrets              *OutputRemoteElasticsearch_Secrets `json:"secrets,omitempty"`
	ServiceToken         *string                            `json:"service_token"`
	Shipper              *OutputShipper                     `json:"shipper"`
	Ssl                  *OutputSsl                         `json:"ssl"`
	Type                 OutputRemoteElasticsearchType      `json:"type"`
	AdditionalProperties map[string]interface{}             `json:"-"`
}

// OutputRemoteElasticsearchPreset defines model for OutputRemoteElasticsearch.Preset.
type OutputRemoteElasticsearchPreset string

// OutputRemoteElasticsearchSecretsServiceToken0 defines model for .
type OutputRemoteElasticsearchSecretsServiceToken0 struct {
	Id                   string                 `json:"id"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// OutputRemoteElasticsearchSecretsServiceToken1 defines model for .
type OutputRemoteElasticsearchSecretsServiceToken1 = string

// OutputRemoteElasticsearch_Secrets_ServiceToken defines model for OutputRemoteElasticsearch.Secrets.ServiceToken.
type OutputRemoteElasticsearch_Secrets_ServiceToken struct {
	union json.RawMessage
}

// OutputRemoteElasticsearch_Secrets defines model for OutputRemoteElasticsearch.Secrets.
type OutputRemoteElasticsearch_Secrets struct {
	ServiceToken         *OutputRemoteElasticsearch_Secrets_ServiceToken `json:"service_token,omitempty"`
	AdditionalProperties map[string]interface{}                          `json:"-"`
}

// OutputRemoteElasticsearchType defines model for OutputRemoteElasticsearch.Type.
type OutputRemoteElasticsearchType string

// OutputShipper defines model for output_shipper.
type OutputShipper struct {
	CompressionLevel            *float32               `json:"compression_level"`
	DiskQueueCompressionEnabled *bool                  `json:"disk_queue_compression_enabled"`
	DiskQueueEnabled            *bool                  `json:"disk_queue_enabled"`
	DiskQueueEncryptionEnabled  *bool                  `json:"disk_queue_encryption_enabled"`
	DiskQueueMaxSize            *float32               `json:"disk_queue_max_size"`
	DiskQueuePath               *string                `json:"disk_queue_path"`
	Loadbalance                 *bool                  `json:"loadbalance"`
	MaxBatchBytes               *float32               `json:"max_batch_bytes"`
	MemQueueEvents              *float32               `json:"mem_queue_events"`
	QueueFlushTimeout           *float32               `json:"queue_flush_timeout"`
	AdditionalProperties        map[string]interface{} `json:"-"`
}

// OutputSsl defines model for output_ssl.
type OutputSsl struct {
	Certificate            *string                    `json:"certificate,omitempty"`
	CertificateAuthorities *[]string                  `json:"certificate_authorities,omitempty"`
	Key                    *string                    `json:"key,omitempty"`
	VerificationMode       *OutputSslVerificationMode `json:"verification_mode,omitempty"`
	AdditionalProperties   map[string]interface{}     `json:"-"`
}

// OutputSslVerificationMode defines model for OutputSsl.VerificationMode.
type OutputSslVerificationMode string

// OutputUnion defines model for output_union.
type OutputUnion struct {
	union json.RawMessage
}

// PackageInfo defines model for package_info.
type PackageInfo struct {
	Agent *struct {
		Privileges *struct {
			Root *bool `json:"root,omitempty"`
		} `json:"privileges,omitempty"`
	} `json:"agent,omitempty"`
	AssetTags *[]struct {
		AssetIds   *[]string `json:"asset_ids,omitempty"`
		AssetTypes *[]string `json:"asset_types,omitempty"`
		Text       string    `json:"text"`
	} `json:"asset_tags,omitempty"`
	Assets               map[string]interface{}        `json:"assets"`
	Categories           *[]string                     `json:"categories,omitempty"`
	Conditions           *PackageInfo_Conditions       `json:"conditions,omitempty"`
	DataStreams          *[]map[string]interface{}     `json:"data_streams,omitempty"`
	Description          *string                       `json:"description,omitempty"`
	Discovery            *PackageInfo_Discovery        `json:"discovery,omitempty"`
	Download             *string                       `json:"download,omitempty"`
	Elasticsearch        *map[string]interface{}       `json:"elasticsearch,omitempty"`
	FormatVersion        *string                       `json:"format_version,omitempty"`
	Icons                *[]PackageInfo_Icons_Item     `json:"icons,omitempty"`
	InstallationInfo     *PackageInfo_InstallationInfo `json:"installationInfo,omitempty"`
	Internal             *bool                         `json:"internal,omitempty"`
	KeepPoliciesUpToDate *bool                         `json:"keepPoliciesUpToDate,omitempty"`
	LatestVersion        *string                       `json:"latestVersion,omitempty"`
	License              *string                       `json:"license,omitempty"`
	LicensePath          *string                       `json:"licensePath,omitempty"`
	Name                 string                        `json:"name"`
	Notice               *string                       `json:"notice,omitempty"`
	Owner                *PackageInfo_Owner            `json:"owner,omitempty"`
	Path                 *string                       `json:"path,omitempty"`
	PolicyTemplates      *[]map[string]interface{}     `json:"policy_templates,omitempty"`
	Readme               *string                       `json:"readme,omitempty"`
	Release              *PackageInfoRelease           `json:"release,omitempty"`
	Screenshots          *[]struct {
		DarkMode *bool   `json:"dark_mode,omitempty"`
		Path     *string `json:"path,omitempty"`
		Size     *string `json:"size,omitempty"`
		Src      string  `json:"src"`
		Title    *string `json:"title,omitempty"`
		Type     *string `json:"type,omitempty"`
	} `json:"screenshots,omitempty"`
	SignaturePath        *string                   `json:"signature_path,omitempty"`
	Source               *PackageInfo_Source       `json:"source,omitempty"`
	Status               *string                   `json:"status,omitempty"`
	Title                string                    `json:"title"`
	Type                 *PackageInfoType          `json:"type,omitempty"`
	Vars                 *[]map[string]interface{} `json:"vars,omitempty"`
	Version              string                    `json:"version"`
	AdditionalProperties map[string]interface{}    `json:"-"`
}

// PackageInfo_Conditions_Elastic defines model for PackageInfo.Conditions.Elastic.
type PackageInfo_Conditions_Elastic struct {
	Capabilities         *[]string              `json:"capabilities,omitempty"`
	Subscription         *string                `json:"subscription,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfo_Conditions_Kibana defines model for PackageInfo.Conditions.Kibana.
type PackageInfo_Conditions_Kibana struct {
	Version              *string                `json:"version,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfo_Conditions defines model for PackageInfo.Conditions.
type PackageInfo_Conditions struct {
	Elastic              *PackageInfo_Conditions_Elastic `json:"elastic,omitempty"`
	Kibana               *PackageInfo_Conditions_Kibana  `json:"kibana,omitempty"`
	AdditionalProperties map[string]interface{}          `json:"-"`
}

// PackageInfo_Discovery_Fields_Item defines model for PackageInfo.Discovery.Fields.Item.
type PackageInfo_Discovery_Fields_Item struct {
	Name                 string                 `json:"name"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfo_Discovery defines model for PackageInfo.Discovery.
type PackageInfo_Discovery struct {
	Fields               *[]PackageInfo_Discovery_Fields_Item `json:"fields,omitempty"`
	AdditionalProperties map[string]interface{}               `json:"-"`
}

// PackageInfo_Icons_Item defines model for package_info.icons.Item.
type PackageInfo_Icons_Item struct {
	DarkMode             *bool                  `json:"dark_mode,omitempty"`
	Path                 *string                `json:"path,omitempty"`
	Size                 *string                `json:"size,omitempty"`
	Src                  string                 `json:"src"`
	Title                *string                `json:"title,omitempty"`
	Type                 *string                `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType defines model for PackageInfo.InstallationInfo.AdditionalSpacesInstalledKibana.Type.
type PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType string

// PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item defines model for PackageInfo.InstallationInfo.AdditionalSpacesInstalledKibana.Item.
type PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item struct {
	Id                   string                                                         `json:"id"`
	OriginId             *string                                                        `json:"originId,omitempty"`
	Type                 PackageInfoInstallationInfoAdditionalSpacesInstalledKibanaType `json:"type"`
	AdditionalProperties map[string]interface{}                                         `json:"-"`
}

// PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features defines model for PackageInfo.InstallationInfo.ExperimentalDataStreamFeatures.Features.
type PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features struct {
	DocValueOnlyNumeric  *bool                  `json:"doc_value_only_numeric,omitempty"`
	DocValueOnlyOther    *bool                  `json:"doc_value_only_other,omitempty"`
	SyntheticSource      *bool                  `json:"synthetic_source,omitempty"`
	Tsdb                 *bool                  `json:"tsdb,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item defines model for PackageInfo.InstallationInfo.ExperimentalDataStreamFeatures.Item.
type PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item struct {
	DataStream           string                                                               `json:"data_stream"`
	Features             PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features `json:"features"`
	AdditionalProperties map[string]interface{}                                               `json:"-"`
}

// PackageInfoInstallationInfoInstallSource defines model for PackageInfo.InstallationInfo.InstallSource.
type PackageInfoInstallationInfoInstallSource string

// PackageInfoInstallationInfoInstallStatus defines model for PackageInfo.InstallationInfo.InstallStatus.
type PackageInfoInstallationInfoInstallStatus string

// PackageInfoInstallationInfoInstalledEsType defines model for PackageInfo.InstallationInfo.InstalledEs.Type.
type PackageInfoInstallationInfoInstalledEsType string

// PackageInfo_InstallationInfo_InstalledEs_Item defines model for PackageInfo.InstallationInfo.InstalledEs.Item.
type PackageInfo_InstallationInfo_InstalledEs_Item struct {
	Deferred             *bool                                      `json:"deferred,omitempty"`
	Id                   string                                     `json:"id"`
	Type                 PackageInfoInstallationInfoInstalledEsType `json:"type"`
	Version              *string                                    `json:"version,omitempty"`
	AdditionalProperties map[string]interface{}                     `json:"-"`
}

// PackageInfoInstallationInfoInstalledKibanaType defines model for PackageInfo.InstallationInfo.InstalledKibana.Type.
type PackageInfoInstallationInfoInstalledKibanaType string

// PackageInfo_InstallationInfo_InstalledKibana_Item defines model for PackageInfo.InstallationInfo.InstalledKibana.Item.
type PackageInfo_InstallationInfo_InstalledKibana_Item struct {
	Id                   string                                         `json:"id"`
	OriginId             *string                                        `json:"originId,omitempty"`
	Type                 PackageInfoInstallationInfoInstalledKibanaType `json:"type"`
	AdditionalProperties map[string]interface{}                         `json:"-"`
}

// PackageInfo_InstallationInfo_LatestExecutedState defines model for PackageInfo.InstallationInfo.LatestExecutedState.
type PackageInfo_InstallationInfo_LatestExecutedState struct {
	Error                *string                `json:"error,omitempty"`
	Name                 string                 `json:"name"`
	StartedAt            string                 `json:"started_at"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error defines model for PackageInfo.InstallationInfo.LatestInstallFailedAttempts.Error.
type PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error struct {
	Message              string                 `json:"message"`
	Name                 string                 `json:"name"`
	Stack                *string                `json:"stack,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item defines model for PackageInfo.InstallationInfo.LatestInstallFailedAttempts.Item.
type PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item struct {
	CreatedAt            string                                                         `json:"created_at"`
	Error                PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error `json:"error"`
	TargetVersion        string                                                         `json:"target_version"`
	AdditionalProperties map[string]interface{}                                         `json:"-"`
}

// PackageInfoInstallationInfoVerificationStatus defines model for PackageInfo.InstallationInfo.VerificationStatus.
type PackageInfoInstallationInfoVerificationStatus string

// PackageInfo_InstallationInfo defines model for PackageInfo.InstallationInfo.
type PackageInfo_InstallationInfo struct {
	AdditionalSpacesInstalledKibana *map[string][]PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item `json:"additional_spaces_installed_kibana,omitempty"`
	CreatedAt                       *string                                                                         `json:"created_at,omitempty"`
	ExperimentalDataStreamFeatures  *[]PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item             `json:"experimental_data_stream_features,omitempty"`
	InstallFormatSchemaVersion      *string                                                                         `json:"install_format_schema_version,omitempty"`
	InstallSource                   PackageInfoInstallationInfoInstallSource                                        `json:"install_source"`
	InstallStatus                   PackageInfoInstallationInfoInstallStatus                                        `json:"install_status"`
	InstalledEs                     []PackageInfo_InstallationInfo_InstalledEs_Item                                 `json:"installed_es"`
	InstalledKibana                 []PackageInfo_InstallationInfo_InstalledKibana_Item                             `json:"installed_kibana"`
	InstalledKibanaSpaceId          *string                                                                         `json:"installed_kibana_space_id,omitempty"`
	LatestExecutedState             *PackageInfo_InstallationInfo_LatestExecutedState                               `json:"latest_executed_state,omitempty"`
	LatestInstallFailedAttempts     *[]PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item                `json:"latest_install_failed_attempts,omitempty"`
	Name                            string                                                                          `json:"name"`
	Namespaces                      *[]string                                                                       `json:"namespaces,omitempty"`
	Type                            string                                                                          `json:"type"`
	UpdatedAt                       *string                                                                         `json:"updated_at,omitempty"`
	VerificationKeyId               *string                                                                         `json:"verification_key_id"`
	VerificationStatus              PackageInfoInstallationInfoVerificationStatus                                   `json:"verification_status"`
	Version                         string                                                                          `json:"version"`
	AdditionalProperties            map[string]interface{}                                                          `json:"-"`
}

// PackageInfoOwnerType defines model for PackageInfo.Owner.Type.
type PackageInfoOwnerType string

// PackageInfo_Owner defines model for PackageInfo.Owner.
type PackageInfo_Owner struct {
	Github               *string                `json:"github,omitempty"`
	Type                 *PackageInfoOwnerType  `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfoRelease defines model for PackageInfo.Release.
type PackageInfoRelease string

// PackageInfo_Source defines model for PackageInfo.Source.
type PackageInfo_Source struct {
	License              string                 `json:"license"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageInfoType defines model for PackageInfo.Type.
type PackageInfoType string

// PackageListItem defines model for package_list_item.
type PackageListItem struct {
	Categories           *[]string                         `json:"categories,omitempty"`
	Conditions           *PackageListItem_Conditions       `json:"conditions,omitempty"`
	DataStreams          *[]map[string]interface{}         `json:"data_streams,omitempty"`
	Description          *string                           `json:"description,omitempty"`
	Discovery            *PackageListItem_Discovery        `json:"discovery,omitempty"`
	Download             *string                           `json:"download,omitempty"`
	FormatVersion        *string                           `json:"format_version,omitempty"`
	Icons                *[]PackageListItem_Icons_Item     `json:"icons,omitempty"`
	Id                   string                            `json:"id"`
	InstallationInfo     *PackageListItem_InstallationInfo `json:"installationInfo,omitempty"`
	Integration          *string                           `json:"integration,omitempty"`
	Internal             *bool                             `json:"internal,omitempty"`
	LatestVersion        *string                           `json:"latestVersion,omitempty"`
	Name                 string                            `json:"name"`
	Owner                *PackageListItem_Owner            `json:"owner,omitempty"`
	Path                 *string                           `json:"path,omitempty"`
	PolicyTemplates      *[]map[string]interface{}         `json:"policy_templates,omitempty"`
	Readme               *string                           `json:"readme,omitempty"`
	Release              *PackageListItemRelease           `json:"release,omitempty"`
	SignaturePath        *string                           `json:"signature_path,omitempty"`
	Source               *PackageListItem_Source           `json:"source,omitempty"`
	Status               *string                           `json:"status,omitempty"`
	Title                string                            `json:"title"`
	Type                 *PackageListItemType              `json:"type,omitempty"`
	Vars                 *[]map[string]interface{}         `json:"vars,omitempty"`
	Version              string                            `json:"version"`
	AdditionalProperties map[string]interface{}            `json:"-"`
}

// PackageListItem_Conditions_Elastic defines model for PackageListItem.Conditions.Elastic.
type PackageListItem_Conditions_Elastic struct {
	Capabilities         *[]string              `json:"capabilities,omitempty"`
	Subscription         *string                `json:"subscription,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageListItem_Conditions_Kibana defines model for PackageListItem.Conditions.Kibana.
type PackageListItem_Conditions_Kibana struct {
	Version              *string                `json:"version,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageListItem_Conditions defines model for PackageListItem.Conditions.
type PackageListItem_Conditions struct {
	Elastic              *PackageListItem_Conditions_Elastic `json:"elastic,omitempty"`
	Kibana               *PackageListItem_Conditions_Kibana  `json:"kibana,omitempty"`
	AdditionalProperties map[string]interface{}              `json:"-"`
}

// PackageListItem_Discovery_Fields_Item defines model for PackageListItem.Discovery.Fields.Item.
type PackageListItem_Discovery_Fields_Item struct {
	Name                 string                 `json:"name"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageListItem_Discovery defines model for PackageListItem.Discovery.
type PackageListItem_Discovery struct {
	Fields               *[]PackageListItem_Discovery_Fields_Item `json:"fields,omitempty"`
	AdditionalProperties map[string]interface{}                   `json:"-"`
}

// PackageListItem_Icons_Item defines model for package_list_item.icons.Item.
type PackageListItem_Icons_Item struct {
	DarkMode             *bool                  `json:"dark_mode,omitempty"`
	Path                 *string                `json:"path,omitempty"`
	Size                 *string                `json:"size,omitempty"`
	Src                  string                 `json:"src"`
	Title                *string                `json:"title,omitempty"`
	Type                 *string                `json:"type,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType defines model for PackageListItem.InstallationInfo.AdditionalSpacesInstalledKibana.Type.
type PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType string

// PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item defines model for PackageListItem.InstallationInfo.AdditionalSpacesInstalledKibana.Item.
type PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item struct {
	Id                   string                                                             `json:"id"`
	OriginId             *string                                                            `json:"originId,omitempty"`
	Type                 PackageListItemInstallationInfoAdditionalSpacesInstalledKibanaType `json:"type"`
	AdditionalProperties map[string]interface{}                                             `json:"-"`
}

// PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features defines model for PackageListItem.InstallationInfo.ExperimentalDataStreamFeatures.Features.
type PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features struct {
	DocValueOnlyNumeric  *bool                  `json:"doc_value_only_numeric,omitempty"`
	DocValueOnlyOther    *bool                  `json:"doc_value_only_other,omitempty"`
	SyntheticSource      *bool                  `json:"synthetic_source,omitempty"`
	Tsdb                 *bool                  `json:"tsdb,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item defines model for PackageListItem.InstallationInfo.ExperimentalDataStreamFeatures.Item.
type PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item struct {
	DataStream           string                                                                   `json:"data_stream"`
	Features             PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features `json:"features"`
	AdditionalProperties map[string]interface{}                                                   `json:"-"`
}

// PackageListItemInstallationInfoInstallSource defines model for PackageListItem.InstallationInfo.InstallSource.
type PackageListItemInstallationInfoInstallSource string

// PackageListItemInstallationInfoInstallStatus defines model for PackageListItem.InstallationInfo.InstallStatus.
type PackageListItemInstallationInfoInstallStatus string

// PackageListItemInstallationInfoInstalledEsType defines model for PackageListItem.InstallationInfo.InstalledEs.Type.
type PackageListItemInstallationInfoInstalledEsType string

// PackageListItem_InstallationInfo_InstalledEs_Item defines model for PackageListItem.InstallationInfo.InstalledEs.Item.
type PackageListItem_InstallationInfo_InstalledEs_Item struct {
	Deferred             *bool                                          `json:"deferred,omitempty"`
	Id                   string                                         `json:"id"`
	Type                 PackageListItemInstallationInfoInstalledEsType `json:"type"`
	Version              *string                                        `json:"version,omitempty"`
	AdditionalProperties map[string]interface{}                         `json:"-"`
}

// PackageListItemInstallationInfoInstalledKibanaType defines model for PackageListItem.InstallationInfo.InstalledKibana.Type.
type PackageListItemInstallationInfoInstalledKibanaType string

// PackageListItem_InstallationInfo_InstalledKibana_Item defines model for PackageListItem.InstallationInfo.InstalledKibana.Item.
type PackageListItem_InstallationInfo_InstalledKibana_Item struct {
	Id                   string                                             `json:"id"`
	OriginId             *string                                            `json:"originId,omitempty"`
	Type                 PackageListItemInstallationInfoInstalledKibanaType `json:"type"`
	AdditionalProperties map[string]interface{}                             `json:"-"`
}

// PackageListItem_InstallationInfo_LatestExecutedState defines model for PackageListItem.InstallationInfo.LatestExecutedState.
type PackageListItem_InstallationInfo_LatestExecutedState struct {
	Error                *string                `json:"error,omitempty"`
	Name                 string                 `json:"name"`
	StartedAt            string                 `json:"started_at"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error defines model for PackageListItem.InstallationInfo.LatestInstallFailedAttempts.Error.
type PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error struct {
	Message              string                 `json:"message"`
	Name                 string                 `json:"name"`
	Stack                *string                `json:"stack,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item defines model for PackageListItem.InstallationInfo.LatestInstallFailedAttempts.Item.
type PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item struct {
	CreatedAt            string                                                             `json:"created_at"`
	Error                PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error `json:"error"`
	TargetVersion        string                                                             `json:"target_version"`
	AdditionalProperties map[string]interface{}                                             `json:"-"`
}

// PackageListItemInstallationInfoVerificationStatus defines model for PackageListItem.InstallationInfo.VerificationStatus.
type PackageListItemInstallationInfoVerificationStatus string

// PackageListItem_InstallationInfo defines model for PackageListItem.InstallationInfo.
type PackageListItem_InstallationInfo struct {
	AdditionalSpacesInstalledKibana *map[string][]PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item `json:"additional_spaces_installed_kibana,omitempty"`
	CreatedAt                       *string                                                                             `json:"created_at,omitempty"`
	ExperimentalDataStreamFeatures  *[]PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item             `json:"experimental_data_stream_features,omitempty"`
	InstallFormatSchemaVersion      *string                                                                             `json:"install_format_schema_version,omitempty"`
	InstallSource                   PackageListItemInstallationInfoInstallSource                                        `json:"install_source"`
	InstallStatus                   PackageListItemInstallationInfoInstallStatus                                        `json:"install_status"`
	InstalledEs                     []PackageListItem_InstallationInfo_InstalledEs_Item                                 `json:"installed_es"`
	InstalledKibana                 []PackageListItem_InstallationInfo_InstalledKibana_Item                             `json:"installed_kibana"`
	InstalledKibanaSpaceId          *string                                                                             `json:"installed_kibana_space_id,omitempty"`
	LatestExecutedState             *PackageListItem_InstallationInfo_LatestExecutedState                               `json:"latest_executed_state,omitempty"`
	LatestInstallFailedAttempts     *[]PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item                `json:"latest_install_failed_attempts,omitempty"`
	Name                            string                                                                              `json:"name"`
	Namespaces                      *[]string                                                                           `json:"namespaces,omitempty"`
	Type                            string                                                                              `json:"type"`
	UpdatedAt                       *string                                                                             `json:"updated_at,omitempty"`
	VerificationKeyId               *string                                                                             `json:"verification_key_id"`
	VerificationStatus              PackageListItemInstallationInfoVerificationStatus                                   `json:"verification_status"`
	Version                         string                                                                              `json:"version"`
	AdditionalProperties            map[string]interface{}                                                              `json:"-"`
}

// PackageListItemOwnerType defines model for PackageListItem.Owner.Type.
type PackageListItemOwnerType string

// PackageListItem_Owner defines model for PackageListItem.Owner.
type PackageListItem_Owner struct {
	Github               *string                   `json:"github,omitempty"`
	Type                 *PackageListItemOwnerType `json:"type,omitempty"`
	AdditionalProperties map[string]interface{}    `json:"-"`
}

// PackageListItemRelease defines model for PackageListItem.Release.
type PackageListItemRelease string

// PackageListItem_Source defines model for PackageListItem.Source.
type PackageListItem_Source struct {
	License              string                 `json:"license"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackageListItemType defines model for PackageListItem.Type.
type PackageListItemType string

// PackagePolicy defines model for package_policy.
type PackagePolicy struct {
	Agents    *float32 `json:"agents,omitempty"`
	CreatedAt string   `json:"created_at"`
	CreatedBy string   `json:"created_by"`

	// Description Package policy description
	Description   *string                      `json:"description,omitempty"`
	Elasticsearch *PackagePolicy_Elasticsearch `json:"elasticsearch,omitempty"`
	Enabled       bool                         `json:"enabled"`
	Id            string                       `json:"id"`

	// Inputs Package policy inputs (see integration documentation to know what inputs are available)
	Inputs    map[string]PackagePolicyInput `json:"inputs"`
	IsManaged *bool                         `json:"is_managed,omitempty"`

	// Name Package policy name (should be unique)
	Name string `json:"name"`

	// Namespace The package policy namespace. Leave blank to inherit the agent policy's namespace.
	Namespace *string `json:"namespace,omitempty"`
	OutputId  *string `json:"output_id"`

	// Overrides Override settings that are defined in the package policy. The override option should be used only in unusual circumstances and not as a routine procedure.
	Overrides *struct {
		Inputs *map[string]interface{} `json:"inputs,omitempty"`
	} `json:"overrides"`
	Package *struct {
		ExperimentalDataStreamFeatures *[]struct {
			DataStream string `json:"data_stream"`
			Features   struct {
				DocValueOnlyNumeric *bool `json:"doc_value_only_numeric,omitempty"`
				DocValueOnlyOther   *bool `json:"doc_value_only_other,omitempty"`
				SyntheticSource     *bool `json:"synthetic_source,omitempty"`
				Tsdb                *bool `json:"tsdb,omitempty"`
			} `json:"features"`
		} `json:"experimental_data_stream_features,omitempty"`

		// Name Package name
		Name         string  `json:"name"`
		RequiresRoot *bool   `json:"requires_root,omitempty"`
		Title        *string `json:"title,omitempty"`

		// Version Package version
		Version string `json:"version"`
	} `json:"package,omitempty"`

	// PolicyId Agent policy ID where that package policy will be added
	// Deprecated:
	PolicyId         *string                   `json:"policy_id"`
	PolicyIds        *[]string                 `json:"policy_ids,omitempty"`
	Revision         float32                   `json:"revision"`
	SecretReferences *[]PackagePolicySecretRef `json:"secret_references,omitempty"`
	SpaceIds         *[]string                 `json:"spaceIds,omitempty"`
	UpdatedAt        string                    `json:"updated_at"`
	UpdatedBy        string                    `json:"updated_by"`
	Vars             *map[string]interface{}   `json:"vars,omitempty"`
	Version          *string                   `json:"version,omitempty"`
}

// PackagePolicy_Elasticsearch_Privileges defines model for PackagePolicy.Elasticsearch.Privileges.
type PackagePolicy_Elasticsearch_Privileges struct {
	Cluster              *[]string              `json:"cluster,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// PackagePolicy_Elasticsearch defines model for PackagePolicy.Elasticsearch.
type PackagePolicy_Elasticsearch struct {
	Privileges           *PackagePolicy_Elasticsearch_Privileges `json:"privileges,omitempty"`
	AdditionalProperties map[string]interface{}                  `json:"-"`
}

// PackagePolicyInput defines model for package_policy_input.
type PackagePolicyInput struct {
	// Enabled enable or disable that input, (default to true)
	Enabled *bool `json:"enabled,omitempty"`

	// Streams Input streams (see integration documentation to know what streams are available)
	Streams *map[string]PackagePolicyInputStream `json:"streams,omitempty"`
	Vars    *map[string]interface{}              `json:"vars,omitempty"`
}

// PackagePolicyInputStream defines model for package_policy_input_stream.
type PackagePolicyInputStream struct {
	// Enabled enable or disable that stream, (default to true)
	Enabled *bool                   `json:"enabled,omitempty"`
	Vars    *map[string]interface{} `json:"vars,omitempty"`
}

// PackagePolicyRequest defines model for package_policy_request.
type PackagePolicyRequest struct {
	Description *string `json:"description,omitempty"`
	Force       *bool   `json:"force,omitempty"`
	Id          *string `json:"id,omitempty"`

	// Inputs Package policy inputs (see integration documentation to know what inputs are available)
	Inputs    *map[string]PackagePolicyRequestInput `json:"inputs,omitempty"`
	Name      string                                `json:"name"`
	Namespace *string                               `json:"namespace,omitempty"`
	OutputId  *string                               `json:"output_id,omitempty"`
	Package   PackagePolicyRequestPackage           `json:"package"`
	PolicyId  *string                               `json:"policy_id"`
	PolicyIds *[]string                             `json:"policy_ids,omitempty"`
	Vars      *map[string]interface{}               `json:"vars,omitempty"`
}

// PackagePolicyRequestInput defines model for package_policy_request_input.
type PackagePolicyRequestInput struct {
	// Enabled enable or disable that input, (default to true)
	Enabled *bool `json:"enabled,omitempty"`

	// Streams Input streams (see integration documentation to know what streams are available)
	Streams *map[string]PackagePolicyRequestInputStream `json:"streams,omitempty"`
	Vars    *map[string]interface{}                     `json:"vars,omitempty"`
}

// PackagePolicyRequestInputStream defines model for package_policy_request_input_stream.
type PackagePolicyRequestInputStream struct {
	// Enabled enable or disable that stream, (default to true)
	Enabled *bool                   `json:"enabled,omitempty"`
	Vars    *map[string]interface{} `json:"vars,omitempty"`
}

// PackagePolicyRequestPackage defines model for package_policy_request_package.
type PackagePolicyRequestPackage struct {
	ExperimentalDataStreamFeatures *[]struct {
		DataStream string `json:"data_stream"`
		Features   struct {
			DocValueOnlyNumeric *bool `json:"doc_value_only_numeric,omitempty"`
			DocValueOnlyOther   *bool `json:"doc_value_only_other,omitempty"`
			SyntheticSource     *bool `json:"synthetic_source,omitempty"`
			Tsdb                *bool `json:"tsdb,omitempty"`
		} `json:"features"`
	} `json:"experimental_data_stream_features,omitempty"`

	// Name Package name
	Name         string  `json:"name"`
	RequiresRoot *bool   `json:"requires_root,omitempty"`
	Title        *string `json:"title,omitempty"`

	// Version Package version
	Version string `json:"version"`
}

// PackagePolicySecretRef defines model for package_policy_secret_ref.
type PackagePolicySecretRef struct {
	Id string `json:"id"`
}

// ServerHost defines model for server_host.
type ServerHost struct {
	HostUrls        []string `json:"host_urls"`
	Id              string   `json:"id"`
	IsDefault       *bool    `json:"is_default,omitempty"`
	IsInternal      *bool    `json:"is_internal,omitempty"`
	IsPreconfigured *bool    `json:"is_preconfigured,omitempty"`
	Name            string   `json:"name"`
	ProxyId         *string  `json:"proxy_id"`
}

// UpdateOutputElasticsearch defines model for update_output_elasticsearch.
type UpdateOutputElasticsearch struct {
	AllowEdit            *[]string                        `json:"allow_edit,omitempty"`
	CaSha256             *string                          `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                          `json:"ca_trusted_fingerprint,omitempty"`
	ConfigYaml           *string                          `json:"config_yaml"`
	Hosts                *[]string                        `json:"hosts,omitempty"`
	IsDefault            *bool                            `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                            `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                            `json:"is_internal,omitempty"`
	IsPreconfigured      *bool                            `json:"is_preconfigured,omitempty"`
	Name                 *string                          `json:"name,omitempty"`
	Preset               *UpdateOutputElasticsearchPreset `json:"preset,omitempty"`
	ProxyId              *string                          `json:"proxy_id,omitempty"`
	Shipper              *UpdateOutputShipper             `json:"shipper,omitempty"`
	Ssl                  *UpdateOutputSsl                 `json:"ssl,omitempty"`
	Type                 *UpdateOutputElasticsearchType   `json:"type,omitempty"`
}

// UpdateOutputElasticsearchPreset defines model for UpdateOutputElasticsearch.Preset.
type UpdateOutputElasticsearchPreset string

// UpdateOutputElasticsearchType defines model for UpdateOutputElasticsearch.Type.
type UpdateOutputElasticsearchType string

// UpdateOutputKafka defines model for update_output_kafka.
type UpdateOutputKafka struct {
	AllowEdit            *[]string                     `json:"allow_edit,omitempty"`
	AuthType             *UpdateOutputKafkaAuthType    `json:"auth_type,omitempty"`
	BrokerTimeout        *float32                      `json:"broker_timeout,omitempty"`
	CaSha256             *string                       `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                       `json:"ca_trusted_fingerprint,omitempty"`
	ClientId             *string                       `json:"client_id,omitempty"`
	Compression          *UpdateOutputKafkaCompression `json:"compression,omitempty"`
	CompressionLevel     interface{}                   `json:"compression_level"`
	ConfigYaml           *string                       `json:"config_yaml"`
	ConnectionType       interface{}                   `json:"connection_type"`
	Hash                 *struct {
		Hash   *string `json:"hash,omitempty"`
		Random *bool   `json:"random,omitempty"`
	} `json:"hash,omitempty"`
	Headers *[]struct {
		Key   string `json:"key"`
		Value string `json:"value"`
	} `json:"headers,omitempty"`
	Hosts               *[]string                   `json:"hosts,omitempty"`
	IsDefault           *bool                       `json:"is_default,omitempty"`
	IsDefaultMonitoring *bool                       `json:"is_default_monitoring,omitempty"`
	IsInternal          *bool                       `json:"is_internal,omitempty"`
	IsPreconfigured     *bool                       `json:"is_preconfigured,omitempty"`
	Key                 *string                     `json:"key,omitempty"`
	Name                string                      `json:"name"`
	Partition           *UpdateOutputKafkaPartition `json:"partition,omitempty"`
	Password            interface{}                 `json:"password"`
	ProxyId             *string                     `json:"proxy_id,omitempty"`
	Random              *struct {
		GroupEvents *float32 `json:"group_events,omitempty"`
	} `json:"random,omitempty"`
	RequiredAcks *UpdateOutputKafkaRequiredAcks `json:"required_acks,omitempty"`
	RoundRobin   *struct {
		GroupEvents *float32 `json:"group_events,omitempty"`
	} `json:"round_robin,omitempty"`
	Sasl *struct {
		Mechanism *UpdateOutputKafkaSaslMechanism `json:"mechanism,omitempty"`
	} `json:"sasl"`
	Secrets *struct {
		Password *UpdateOutputKafka_Secrets_Password `json:"password,omitempty"`
		Ssl      *struct {
			Key UpdateOutputKafka_Secrets_Ssl_Key `json:"key"`
		} `json:"ssl,omitempty"`
	} `json:"secrets,omitempty"`
	Shipper  *UpdateOutputShipper   `json:"shipper,omitempty"`
	Ssl      *UpdateOutputSsl       `json:"ssl,omitempty"`
	Timeout  *float32               `json:"timeout,omitempty"`
	Topic    *string                `json:"topic,omitempty"`
	Type     *UpdateOutputKafkaType `json:"type,omitempty"`
	Username interface{}            `json:"username"`
	Version  *string                `json:"version,omitempty"`
}

// UpdateOutputKafkaAuthType defines model for UpdateOutputKafka.AuthType.
type UpdateOutputKafkaAuthType string

// UpdateOutputKafkaCompression defines model for UpdateOutputKafka.Compression.
type UpdateOutputKafkaCompression string

// UpdateOutputKafkaPartition defines model for UpdateOutputKafka.Partition.
type UpdateOutputKafkaPartition string

// UpdateOutputKafkaRequiredAcks defines model for UpdateOutputKafka.RequiredAcks.
type UpdateOutputKafkaRequiredAcks int

// UpdateOutputKafkaSaslMechanism defines model for UpdateOutputKafka.Sasl.Mechanism.
type UpdateOutputKafkaSaslMechanism string

// UpdateOutputKafkaSecretsPassword0 defines model for .
type UpdateOutputKafkaSecretsPassword0 struct {
	Id string `json:"id"`
}

// UpdateOutputKafkaSecretsPassword1 defines model for .
type UpdateOutputKafkaSecretsPassword1 = string

// UpdateOutputKafka_Secrets_Password defines model for UpdateOutputKafka.Secrets.Password.
type UpdateOutputKafka_Secrets_Password struct {
	union json.RawMessage
}

// UpdateOutputKafkaSecretsSslKey0 defines model for .
type UpdateOutputKafkaSecretsSslKey0 struct {
	Id string `json:"id"`
}

// UpdateOutputKafkaSecretsSslKey1 defines model for .
type UpdateOutputKafkaSecretsSslKey1 = string

// UpdateOutputKafka_Secrets_Ssl_Key defines model for UpdateOutputKafka.Secrets.Ssl.Key.
type UpdateOutputKafka_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// UpdateOutputKafkaType defines model for UpdateOutputKafka.Type.
type UpdateOutputKafkaType string

// UpdateOutputLogstash defines model for update_output_logstash.
type UpdateOutputLogstash struct {
	AllowEdit            *[]string `json:"allow_edit,omitempty"`
	CaSha256             *string   `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string   `json:"ca_trusted_fingerprint,omitempty"`
	ConfigYaml           *string   `json:"config_yaml"`
	Hosts                *[]string `json:"hosts,omitempty"`
	IsDefault            *bool     `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool     `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool     `json:"is_internal,omitempty"`
	IsPreconfigured      *bool     `json:"is_preconfigured,omitempty"`
	Name                 *string   `json:"name,omitempty"`
	ProxyId              *string   `json:"proxy_id,omitempty"`
	Secrets              *struct {
		Ssl *struct {
			Key *UpdateOutputLogstash_Secrets_Ssl_Key `json:"key,omitempty"`
		} `json:"ssl,omitempty"`
	} `json:"secrets,omitempty"`
	Shipper *UpdateOutputShipper      `json:"shipper,omitempty"`
	Ssl     *UpdateOutputSsl          `json:"ssl,omitempty"`
	Type    *UpdateOutputLogstashType `json:"type,omitempty"`
}

// UpdateOutputLogstashSecretsSslKey0 defines model for .
type UpdateOutputLogstashSecretsSslKey0 struct {
	Id string `json:"id"`
}

// UpdateOutputLogstashSecretsSslKey1 defines model for .
type UpdateOutputLogstashSecretsSslKey1 = string

// UpdateOutputLogstash_Secrets_Ssl_Key defines model for UpdateOutputLogstash.Secrets.Ssl.Key.
type UpdateOutputLogstash_Secrets_Ssl_Key struct {
	union json.RawMessage
}

// UpdateOutputLogstashType defines model for UpdateOutputLogstash.Type.
type UpdateOutputLogstashType string

// UpdateOutputRemoteElasticsearch defines model for update_output_remote_elasticsearch.
type UpdateOutputRemoteElasticsearch struct {
	AllowEdit            *[]string                              `json:"allow_edit,omitempty"`
	CaSha256             *string                                `json:"ca_sha256,omitempty"`
	CaTrustedFingerprint *string                                `json:"ca_trusted_fingerprint,omitempty"`
	ConfigYaml           *string                                `json:"config_yaml"`
	Hosts                *[]string                              `json:"hosts,omitempty"`
	IsDefault            *bool                                  `json:"is_default,omitempty"`
	IsDefaultMonitoring  *bool                                  `json:"is_default_monitoring,omitempty"`
	IsInternal           *bool                                  `json:"is_internal,omitempty"`
	IsPreconfigured      *bool                                  `json:"is_preconfigured,omitempty"`
	Name                 *string                                `json:"name,omitempty"`
	Preset               *UpdateOutputRemoteElasticsearchPreset `json:"preset,omitempty"`
	ProxyId              *string                                `json:"proxy_id,omitempty"`
	Secrets              *struct {
		ServiceToken *UpdateOutputRemoteElasticsearch_Secrets_ServiceToken `json:"service_token,omitempty"`
	} `json:"secrets,omitempty"`
	ServiceToken *string                              `json:"service_token"`
	Shipper      *UpdateOutputShipper                 `json:"shipper,omitempty"`
	Ssl          *UpdateOutputSsl                     `json:"ssl,omitempty"`
	Type         *UpdateOutputRemoteElasticsearchType `json:"type,omitempty"`
}

// UpdateOutputRemoteElasticsearchPreset defines model for UpdateOutputRemoteElasticsearch.Preset.
type UpdateOutputRemoteElasticsearchPreset string

// UpdateOutputRemoteElasticsearchSecretsServiceToken0 defines model for .
type UpdateOutputRemoteElasticsearchSecretsServiceToken0 struct {
	Id string `json:"id"`
}

// UpdateOutputRemoteElasticsearchSecretsServiceToken1 defines model for .
type UpdateOutputRemoteElasticsearchSecretsServiceToken1 = string

// UpdateOutputRemoteElasticsearch_Secrets_ServiceToken defines model for UpdateOutputRemoteElasticsearch.Secrets.ServiceToken.
type UpdateOutputRemoteElasticsearch_Secrets_ServiceToken struct {
	union json.RawMessage
}

// UpdateOutputRemoteElasticsearchType defines model for UpdateOutputRemoteElasticsearch.Type.
type UpdateOutputRemoteElasticsearchType string

// UpdateOutputShipper defines model for update_output_shipper.
type UpdateOutputShipper struct {
	CompressionLevel            *float32 `json:"compression_level"`
	DiskQueueCompressionEnabled *bool    `json:"disk_queue_compression_enabled"`
	DiskQueueEnabled            *bool    `json:"disk_queue_enabled"`
	DiskQueueEncryptionEnabled  *bool    `json:"disk_queue_encryption_enabled"`
	DiskQueueMaxSize            *float32 `json:"disk_queue_max_size"`
	DiskQueuePath               *string  `json:"disk_queue_path"`
	Loadbalance                 *bool    `json:"loadbalance"`
	MaxBatchBytes               *float32 `json:"max_batch_bytes"`
	MemQueueEvents              *float32 `json:"mem_queue_events"`
	QueueFlushTimeout           *float32 `json:"queue_flush_timeout"`
}

// UpdateOutputSsl defines model for update_output_ssl.
type UpdateOutputSsl struct {
	Certificate            *string                          `json:"certificate,omitempty"`
	CertificateAuthorities *[]string                        `json:"certificate_authorities,omitempty"`
	Key                    *string                          `json:"key,omitempty"`
	VerificationMode       *UpdateOutputSslVerificationMode `json:"verification_mode,omitempty"`
}

// UpdateOutputSslVerificationMode defines model for UpdateOutputSsl.VerificationMode.
type UpdateOutputSslVerificationMode string

// UpdateOutputUnion defines model for update_output_union.
type UpdateOutputUnion struct {
	union json.RawMessage
}

// DataViewsViewId defines model for Data_views_view_id.
type DataViewsViewId = string

// SpaceId defines model for spaceId.
type SpaceId = string

// GetFleetAgentPoliciesParams defines parameters for GetFleetAgentPolicies.
type GetFleetAgentPoliciesParams struct {
	Page            *float32                              `form:"page,omitempty" json:"page,omitempty"`
	PerPage         *float32                              `form:"perPage,omitempty" json:"perPage,omitempty"`
	SortField       *string                               `form:"sortField,omitempty" json:"sortField,omitempty"`
	SortOrder       *GetFleetAgentPoliciesParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`
	ShowUpgradeable *bool                                 `form:"showUpgradeable,omitempty" json:"showUpgradeable,omitempty"`
	Kuery           *string                               `form:"kuery,omitempty" json:"kuery,omitempty"`

	// NoAgentCount use withAgentCount instead
	NoAgentCount *bool `form:"noAgentCount,omitempty" json:"noAgentCount,omitempty"`

	// WithAgentCount get policies with agent count
	WithAgentCount *bool `form:"withAgentCount,omitempty" json:"withAgentCount,omitempty"`

	// Full get full policies with package policies populated
	Full   *bool                              `form:"full,omitempty" json:"full,omitempty"`
	Format *GetFleetAgentPoliciesParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GetFleetAgentPoliciesParamsSortOrder defines parameters for GetFleetAgentPolicies.
type GetFleetAgentPoliciesParamsSortOrder string

// GetFleetAgentPoliciesParamsFormat defines parameters for GetFleetAgentPolicies.
type GetFleetAgentPoliciesParamsFormat string

// PostFleetAgentPoliciesJSONBody defines parameters for PostFleetAgentPolicies.
type PostFleetAgentPoliciesJSONBody struct {
	AdvancedSettings *struct {
		AgentDownloadTargetDirectory *interface{} `json:"agent_download_target_directory"`
		AgentDownloadTimeout         *interface{} `json:"agent_download_timeout"`
		AgentLimitsGoMaxProcs        *interface{} `json:"agent_limits_go_max_procs"`
		AgentLoggingLevel            *interface{} `json:"agent_logging_level"`
		AgentLoggingMetricsPeriod    *interface{} `json:"agent_logging_metrics_period"`
	} `json:"advanced_settings,omitempty"`
	AgentFeatures *[]struct {
		Enabled bool   `json:"enabled"`
		Name    string `json:"name"`
	} `json:"agent_features,omitempty"`
	DataOutputId      *string `json:"data_output_id"`
	Description       *string `json:"description,omitempty"`
	DownloadSourceId  *string `json:"download_source_id"`
	FleetServerHostId *string `json:"fleet_server_host_id"`
	Force             *bool   `json:"force,omitempty"`

	// GlobalDataTags User defined data tags that are added to all of the inputs. The values can be strings or numbers.
	GlobalDataTags       *[]AgentPolicyGlobalDataTagsItem `json:"global_data_tags,omitempty"`
	HasFleetServer       *bool                            `json:"has_fleet_server,omitempty"`
	Id                   *string                          `json:"id,omitempty"`
	InactivityTimeout    *float32                         `json:"inactivity_timeout,omitempty"`
	IsDefault            *bool                            `json:"is_default,omitempty"`
	IsDefaultFleetServer *bool                            `json:"is_default_fleet_server,omitempty"`
	IsManaged            *bool                            `json:"is_managed,omitempty"`
	IsProtected          *bool                            `json:"is_protected,omitempty"`

	// KeepMonitoringAlive When set to true, monitoring will be enabled but logs/metrics collection will be disabled
	KeepMonitoringAlive   *bool `json:"keep_monitoring_alive,omitempty"`
	MonitoringDiagnostics *struct {
		Limit *struct {
			Burst    *float32 `json:"burst,omitempty"`
			Interval *string  `json:"interval,omitempty"`
		} `json:"limit,omitempty"`
		Uploader *struct {
			InitDur    *string  `json:"init_dur,omitempty"`
			MaxDur     *string  `json:"max_dur,omitempty"`
			MaxRetries *float32 `json:"max_retries,omitempty"`
		} `json:"uploader,omitempty"`
	} `json:"monitoring_diagnostics,omitempty"`
	MonitoringEnabled *[]PostFleetAgentPoliciesJSONBodyMonitoringEnabled `json:"monitoring_enabled,omitempty"`
	MonitoringHttp    *struct {
		Buffer *struct {
			Enabled *bool `json:"enabled,omitempty"`
		} `json:"buffer,omitempty"`
		Enabled bool     `json:"enabled"`
		Host    *string  `json:"host,omitempty"`
		Port    *float32 `json:"port,omitempty"`
	} `json:"monitoring_http,omitempty"`
	MonitoringOutputId     *string `json:"monitoring_output_id"`
	MonitoringPprofEnabled *bool   `json:"monitoring_pprof_enabled,omitempty"`
	Name                   string  `json:"name"`
	Namespace              string  `json:"namespace"`

	// Overrides Override settings that are defined in the agent policy. Input settings cannot be overridden. The override option should be used only in unusual circumstances and not as a routine procedure.
	Overrides        *map[string]interface{} `json:"overrides,omitempty"`
	RequiredVersions *interface{}            `json:"required_versions,omitempty"`
	SpaceIds         *[]string               `json:"space_ids,omitempty"`

	// SupportsAgentless Indicates whether the agent policy supports agentless integrations.
	SupportsAgentless *bool    `json:"supports_agentless,omitempty"`
	UnenrollTimeout   *float32 `json:"unenroll_timeout,omitempty"`
}

// PostFleetAgentPoliciesParams defines parameters for PostFleetAgentPolicies.
type PostFleetAgentPoliciesParams struct {
	SysMonitoring *bool `form:"sys_monitoring,omitempty" json:"sys_monitoring,omitempty"`
}

// PostFleetAgentPoliciesJSONBodyMonitoringEnabled defines parameters for PostFleetAgentPolicies.
type PostFleetAgentPoliciesJSONBodyMonitoringEnabled string

// PostFleetAgentPoliciesDeleteJSONBody defines parameters for PostFleetAgentPoliciesDelete.
type PostFleetAgentPoliciesDeleteJSONBody struct {
	AgentPolicyId string `json:"agentPolicyId"`

	// Force bypass validation checks that can prevent agent policy deletion
	Force *bool `json:"force,omitempty"`
}

// GetFleetAgentPoliciesAgentpolicyidParams defines parameters for GetFleetAgentPoliciesAgentpolicyid.
type GetFleetAgentPoliciesAgentpolicyidParams struct {
	Format *GetFleetAgentPoliciesAgentpolicyidParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GetFleetAgentPoliciesAgentpolicyidParamsFormat defines parameters for GetFleetAgentPoliciesAgentpolicyid.
type GetFleetAgentPoliciesAgentpolicyidParamsFormat string

// PutFleetAgentPoliciesAgentpolicyidJSONBody defines parameters for PutFleetAgentPoliciesAgentpolicyid.
type PutFleetAgentPoliciesAgentpolicyidJSONBody struct {
	AdvancedSettings *struct {
		AgentDownloadTargetDirectory *interface{} `json:"agent_download_target_directory"`
		AgentDownloadTimeout         *interface{} `json:"agent_download_timeout"`
		AgentLimitsGoMaxProcs        *interface{} `json:"agent_limits_go_max_procs"`
		AgentLoggingLevel            *interface{} `json:"agent_logging_level"`
		AgentLoggingMetricsPeriod    *interface{} `json:"agent_logging_metrics_period"`
	} `json:"advanced_settings,omitempty"`
	AgentFeatures *[]struct {
		Enabled bool   `json:"enabled"`
		Name    string `json:"name"`
	} `json:"agent_features,omitempty"`
	DataOutputId      *string `json:"data_output_id"`
	Description       *string `json:"description,omitempty"`
	DownloadSourceId  *string `json:"download_source_id"`
	FleetServerHostId *string `json:"fleet_server_host_id"`
	Force             *bool   `json:"force,omitempty"`

	// GlobalDataTags User defined data tags that are added to all of the inputs. The values can be strings or numbers.
	GlobalDataTags       *[]AgentPolicyGlobalDataTagsItem `json:"global_data_tags,omitempty"`
	HasFleetServer       *bool                            `json:"has_fleet_server,omitempty"`
	Id                   *string                          `json:"id,omitempty"`
	InactivityTimeout    *float32                         `json:"inactivity_timeout,omitempty"`
	IsDefault            *bool                            `json:"is_default,omitempty"`
	IsDefaultFleetServer *bool                            `json:"is_default_fleet_server,omitempty"`
	IsManaged            *bool                            `json:"is_managed,omitempty"`
	IsProtected          *bool                            `json:"is_protected,omitempty"`

	// KeepMonitoringAlive When set to true, monitoring will be enabled but logs/metrics collection will be disabled
	KeepMonitoringAlive   *bool `json:"keep_monitoring_alive,omitempty"`
	MonitoringDiagnostics *struct {
		Limit *struct {
			Burst    *float32 `json:"burst,omitempty"`
			Interval *string  `json:"interval,omitempty"`
		} `json:"limit,omitempty"`
		Uploader *struct {
			InitDur    *string  `json:"init_dur,omitempty"`
			MaxDur     *string  `json:"max_dur,omitempty"`
			MaxRetries *float32 `json:"max_retries,omitempty"`
		} `json:"uploader,omitempty"`
	} `json:"monitoring_diagnostics,omitempty"`
	MonitoringEnabled *[]PutFleetAgentPoliciesAgentpolicyidJSONBodyMonitoringEnabled `json:"monitoring_enabled,omitempty"`
	MonitoringHttp    *struct {
		Buffer *struct {
			Enabled *bool `json:"enabled,omitempty"`
		} `json:"buffer,omitempty"`
		Enabled bool     `json:"enabled"`
		Host    *string  `json:"host,omitempty"`
		Port    *float32 `json:"port,omitempty"`
	} `json:"monitoring_http,omitempty"`
	MonitoringOutputId     *string `json:"monitoring_output_id"`
	MonitoringPprofEnabled *bool   `json:"monitoring_pprof_enabled,omitempty"`
	Name                   string  `json:"name"`
	Namespace              string  `json:"namespace"`

	// Overrides Override settings that are defined in the agent policy. Input settings cannot be overridden. The override option should be used only in unusual circumstances and not as a routine procedure.
	Overrides        *map[string]interface{} `json:"overrides,omitempty"`
	RequiredVersions *interface{}            `json:"required_versions,omitempty"`
	SpaceIds         *[]string               `json:"space_ids,omitempty"`

	// SupportsAgentless Indicates whether the agent policy supports agentless integrations.
	SupportsAgentless *bool    `json:"supports_agentless,omitempty"`
	UnenrollTimeout   *float32 `json:"unenroll_timeout,omitempty"`
}

// PutFleetAgentPoliciesAgentpolicyidParams defines parameters for PutFleetAgentPoliciesAgentpolicyid.
type PutFleetAgentPoliciesAgentpolicyidParams struct {
	Format *PutFleetAgentPoliciesAgentpolicyidParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// PutFleetAgentPoliciesAgentpolicyidParamsFormat defines parameters for PutFleetAgentPoliciesAgentpolicyid.
type PutFleetAgentPoliciesAgentpolicyidParamsFormat string

// PutFleetAgentPoliciesAgentpolicyidJSONBodyMonitoringEnabled defines parameters for PutFleetAgentPoliciesAgentpolicyid.
type PutFleetAgentPoliciesAgentpolicyidJSONBodyMonitoringEnabled string

// GetFleetEnrollmentApiKeysParams defines parameters for GetFleetEnrollmentApiKeys.
type GetFleetEnrollmentApiKeysParams struct {
	Page    *float32 `form:"page,omitempty" json:"page,omitempty"`
	PerPage *float32 `form:"perPage,omitempty" json:"perPage,omitempty"`
	Kuery   *string  `form:"kuery,omitempty" json:"kuery,omitempty"`
}

// GetFleetEpmPackagesParams defines parameters for GetFleetEpmPackages.
type GetFleetEpmPackagesParams struct {
	Category             *string `form:"category,omitempty" json:"category,omitempty"`
	Prerelease           *bool   `form:"prerelease,omitempty" json:"prerelease,omitempty"`
	ExcludeInstallStatus *bool   `form:"excludeInstallStatus,omitempty" json:"excludeInstallStatus,omitempty"`
}

// PostFleetEpmPackagesParams defines parameters for PostFleetEpmPackages.
type PostFleetEpmPackagesParams struct {
	IgnoreMappingUpdateErrors *bool `form:"ignoreMappingUpdateErrors,omitempty" json:"ignoreMappingUpdateErrors,omitempty"`
	SkipDataStreamRollover    *bool `form:"skipDataStreamRollover,omitempty" json:"skipDataStreamRollover,omitempty"`
}

// DeleteFleetEpmPackagesPkgnamePkgversionParams defines parameters for DeleteFleetEpmPackagesPkgnamePkgversion.
type DeleteFleetEpmPackagesPkgnamePkgversionParams struct {
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// GetFleetEpmPackagesPkgnamePkgversionParams defines parameters for GetFleetEpmPackagesPkgnamePkgversion.
type GetFleetEpmPackagesPkgnamePkgversionParams struct {
	IgnoreUnverified *bool `form:"ignoreUnverified,omitempty" json:"ignoreUnverified,omitempty"`
	Prerelease       *bool `form:"prerelease,omitempty" json:"prerelease,omitempty"`
	Full             *bool `form:"full,omitempty" json:"full,omitempty"`
	WithMetadata     *bool `form:"withMetadata,omitempty" json:"withMetadata,omitempty"`
}

// PostFleetEpmPackagesPkgnamePkgversionJSONBody defines parameters for PostFleetEpmPackagesPkgnamePkgversion.
type PostFleetEpmPackagesPkgnamePkgversionJSONBody struct {
	Force             *bool `json:"force,omitempty"`
	IgnoreConstraints *bool `json:"ignore_constraints,omitempty"`
}

// PostFleetEpmPackagesPkgnamePkgversionParams defines parameters for PostFleetEpmPackagesPkgnamePkgversion.
type PostFleetEpmPackagesPkgnamePkgversionParams struct {
	Prerelease                *bool `form:"prerelease,omitempty" json:"prerelease,omitempty"`
	IgnoreMappingUpdateErrors *bool `form:"ignoreMappingUpdateErrors,omitempty" json:"ignoreMappingUpdateErrors,omitempty"`
	SkipDataStreamRollover    *bool `form:"skipDataStreamRollover,omitempty" json:"skipDataStreamRollover,omitempty"`
}

// PostFleetFleetServerHostsJSONBody defines parameters for PostFleetFleetServerHosts.
type PostFleetFleetServerHostsJSONBody struct {
	HostUrls        []string `json:"host_urls"`
	Id              *string  `json:"id,omitempty"`
	IsDefault       *bool    `json:"is_default,omitempty"`
	IsInternal      *bool    `json:"is_internal,omitempty"`
	IsPreconfigured *bool    `json:"is_preconfigured,omitempty"`
	Name            string   `json:"name"`
	ProxyId         *string  `json:"proxy_id,omitempty"`
}

// PutFleetFleetServerHostsItemidJSONBody defines parameters for PutFleetFleetServerHostsItemid.
type PutFleetFleetServerHostsItemidJSONBody struct {
	HostUrls   *[]string `json:"host_urls,omitempty"`
	IsDefault  *bool     `json:"is_default,omitempty"`
	IsInternal *bool     `json:"is_internal,omitempty"`
	Name       *string   `json:"name,omitempty"`
	ProxyId    *string   `json:"proxy_id,omitempty"`
}

// GetFleetPackagePoliciesParams defines parameters for GetFleetPackagePolicies.
type GetFleetPackagePoliciesParams struct {
	Page            *float32                                `form:"page,omitempty" json:"page,omitempty"`
	PerPage         *float32                                `form:"perPage,omitempty" json:"perPage,omitempty"`
	SortField       *string                                 `form:"sortField,omitempty" json:"sortField,omitempty"`
	SortOrder       *GetFleetPackagePoliciesParamsSortOrder `form:"sortOrder,omitempty" json:"sortOrder,omitempty"`
	ShowUpgradeable *bool                                   `form:"showUpgradeable,omitempty" json:"showUpgradeable,omitempty"`
	Kuery           *string                                 `form:"kuery,omitempty" json:"kuery,omitempty"`
	Format          *GetFleetPackagePoliciesParamsFormat    `form:"format,omitempty" json:"format,omitempty"`
	WithAgentCount  *bool                                   `form:"withAgentCount,omitempty" json:"withAgentCount,omitempty"`
}

// GetFleetPackagePoliciesParamsSortOrder defines parameters for GetFleetPackagePolicies.
type GetFleetPackagePoliciesParamsSortOrder string

// GetFleetPackagePoliciesParamsFormat defines parameters for GetFleetPackagePolicies.
type GetFleetPackagePoliciesParamsFormat string

// PostFleetPackagePoliciesParams defines parameters for PostFleetPackagePolicies.
type PostFleetPackagePoliciesParams struct {
	Format *PostFleetPackagePoliciesParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// PostFleetPackagePoliciesParamsFormat defines parameters for PostFleetPackagePolicies.
type PostFleetPackagePoliciesParamsFormat string

// DeleteFleetPackagePoliciesPackagepolicyidParams defines parameters for DeleteFleetPackagePoliciesPackagepolicyid.
type DeleteFleetPackagePoliciesPackagepolicyidParams struct {
	Force *bool `form:"force,omitempty" json:"force,omitempty"`
}

// GetFleetPackagePoliciesPackagepolicyidParams defines parameters for GetFleetPackagePoliciesPackagepolicyid.
type GetFleetPackagePoliciesPackagepolicyidParams struct {
	Format *GetFleetPackagePoliciesPackagepolicyidParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// GetFleetPackagePoliciesPackagepolicyidParamsFormat defines parameters for GetFleetPackagePoliciesPackagepolicyid.
type GetFleetPackagePoliciesPackagepolicyidParamsFormat string

// PutFleetPackagePoliciesPackagepolicyidParams defines parameters for PutFleetPackagePoliciesPackagepolicyid.
type PutFleetPackagePoliciesPackagepolicyidParams struct {
	Format *PutFleetPackagePoliciesPackagepolicyidParamsFormat `form:"format,omitempty" json:"format,omitempty"`
}

// PutFleetPackagePoliciesPackagepolicyidParamsFormat defines parameters for PutFleetPackagePoliciesPackagepolicyid.
type PutFleetPackagePoliciesPackagepolicyidParamsFormat string

// PostFleetAgentPoliciesJSONRequestBody defines body for PostFleetAgentPolicies for application/json ContentType.
type PostFleetAgentPoliciesJSONRequestBody PostFleetAgentPoliciesJSONBody

// PostFleetAgentPoliciesDeleteJSONRequestBody defines body for PostFleetAgentPoliciesDelete for application/json ContentType.
type PostFleetAgentPoliciesDeleteJSONRequestBody PostFleetAgentPoliciesDeleteJSONBody

// PutFleetAgentPoliciesAgentpolicyidJSONRequestBody defines body for PutFleetAgentPoliciesAgentpolicyid for application/json ContentType.
type PutFleetAgentPoliciesAgentpolicyidJSONRequestBody PutFleetAgentPoliciesAgentpolicyidJSONBody

// PostFleetEpmPackagesPkgnamePkgversionJSONRequestBody defines body for PostFleetEpmPackagesPkgnamePkgversion for application/json ContentType.
type PostFleetEpmPackagesPkgnamePkgversionJSONRequestBody PostFleetEpmPackagesPkgnamePkgversionJSONBody

// PostFleetFleetServerHostsJSONRequestBody defines body for PostFleetFleetServerHosts for application/json ContentType.
type PostFleetFleetServerHostsJSONRequestBody PostFleetFleetServerHostsJSONBody

// PutFleetFleetServerHostsItemidJSONRequestBody defines body for PutFleetFleetServerHostsItemid for application/json ContentType.
type PutFleetFleetServerHostsItemidJSONRequestBody PutFleetFleetServerHostsItemidJSONBody

// PostFleetOutputsJSONRequestBody defines body for PostFleetOutputs for application/json ContentType.
type PostFleetOutputsJSONRequestBody = NewOutputUnion

// PutFleetOutputsOutputidJSONRequestBody defines body for PutFleetOutputsOutputid for application/json ContentType.
type PutFleetOutputsOutputidJSONRequestBody = UpdateOutputUnion

// PostFleetPackagePoliciesJSONRequestBody defines body for PostFleetPackagePolicies for application/json ContentType.
type PostFleetPackagePoliciesJSONRequestBody = PackagePolicyRequest

// PutFleetPackagePoliciesPackagepolicyidJSONRequestBody defines body for PutFleetPackagePoliciesPackagepolicyid for application/json ContentType.
type PutFleetPackagePoliciesPackagepolicyidJSONRequestBody = PackagePolicyRequest

// CreateDataViewDefaultwJSONRequestBody defines body for CreateDataViewDefaultw for application/json ContentType.
type CreateDataViewDefaultwJSONRequestBody = DataViewsCreateDataViewRequestObject

// UpdateDataViewDefaultJSONRequestBody defines body for UpdateDataViewDefault for application/json ContentType.
type UpdateDataViewDefaultJSONRequestBody = DataViewsUpdateDataViewRequestObject

// Getter for additional properties for AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges. Returns the specified
// element and whether it was found
func (a AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges
func (a *AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges to handle AdditionalProperties
func (a *AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["cluster"]; found {
		err = json.Unmarshal(raw, &a.Cluster)
		if err != nil {
			return fmt.Errorf("error reading 'cluster': %w", err)
		}
		delete(object, "cluster")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges to handle AdditionalProperties
func (a AgentPolicy_PackagePolicies_1_Elasticsearch_Privileges) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Cluster != nil {
		object["cluster"], err = json.Marshal(a.Cluster)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'cluster': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for AgentPolicy_PackagePolicies_1_Elasticsearch. Returns the specified
// element and whether it was found
func (a AgentPolicy_PackagePolicies_1_Elasticsearch) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for AgentPolicy_PackagePolicies_1_Elasticsearch
func (a *AgentPolicy_PackagePolicies_1_Elasticsearch) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for AgentPolicy_PackagePolicies_1_Elasticsearch to handle AdditionalProperties
func (a *AgentPolicy_PackagePolicies_1_Elasticsearch) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["privileges"]; found {
		err = json.Unmarshal(raw, &a.Privileges)
		if err != nil {
			return fmt.Errorf("error reading 'privileges': %w", err)
		}
		delete(object, "privileges")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for AgentPolicy_PackagePolicies_1_Elasticsearch to handle AdditionalProperties
func (a AgentPolicy_PackagePolicies_1_Elasticsearch) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Privileges != nil {
		object["privileges"], err = json.Marshal(a.Privileges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'privileges': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputElasticsearch. Returns the specified
// element and whether it was found
func (a OutputElasticsearch) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputElasticsearch
func (a *OutputElasticsearch) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputElasticsearch to handle AdditionalProperties
func (a *OutputElasticsearch) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["allow_edit"]; found {
		err = json.Unmarshal(raw, &a.AllowEdit)
		if err != nil {
			return fmt.Errorf("error reading 'allow_edit': %w", err)
		}
		delete(object, "allow_edit")
	}

	if raw, found := object["ca_sha256"]; found {
		err = json.Unmarshal(raw, &a.CaSha256)
		if err != nil {
			return fmt.Errorf("error reading 'ca_sha256': %w", err)
		}
		delete(object, "ca_sha256")
	}

	if raw, found := object["ca_trusted_fingerprint"]; found {
		err = json.Unmarshal(raw, &a.CaTrustedFingerprint)
		if err != nil {
			return fmt.Errorf("error reading 'ca_trusted_fingerprint': %w", err)
		}
		delete(object, "ca_trusted_fingerprint")
	}

	if raw, found := object["config_yaml"]; found {
		err = json.Unmarshal(raw, &a.ConfigYaml)
		if err != nil {
			return fmt.Errorf("error reading 'config_yaml': %w", err)
		}
		delete(object, "config_yaml")
	}

	if raw, found := object["hosts"]; found {
		err = json.Unmarshal(raw, &a.Hosts)
		if err != nil {
			return fmt.Errorf("error reading 'hosts': %w", err)
		}
		delete(object, "hosts")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["is_default"]; found {
		err = json.Unmarshal(raw, &a.IsDefault)
		if err != nil {
			return fmt.Errorf("error reading 'is_default': %w", err)
		}
		delete(object, "is_default")
	}

	if raw, found := object["is_default_monitoring"]; found {
		err = json.Unmarshal(raw, &a.IsDefaultMonitoring)
		if err != nil {
			return fmt.Errorf("error reading 'is_default_monitoring': %w", err)
		}
		delete(object, "is_default_monitoring")
	}

	if raw, found := object["is_internal"]; found {
		err = json.Unmarshal(raw, &a.IsInternal)
		if err != nil {
			return fmt.Errorf("error reading 'is_internal': %w", err)
		}
		delete(object, "is_internal")
	}

	if raw, found := object["is_preconfigured"]; found {
		err = json.Unmarshal(raw, &a.IsPreconfigured)
		if err != nil {
			return fmt.Errorf("error reading 'is_preconfigured': %w", err)
		}
		delete(object, "is_preconfigured")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["preset"]; found {
		err = json.Unmarshal(raw, &a.Preset)
		if err != nil {
			return fmt.Errorf("error reading 'preset': %w", err)
		}
		delete(object, "preset")
	}

	if raw, found := object["proxy_id"]; found {
		err = json.Unmarshal(raw, &a.ProxyId)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_id': %w", err)
		}
		delete(object, "proxy_id")
	}

	if raw, found := object["shipper"]; found {
		err = json.Unmarshal(raw, &a.Shipper)
		if err != nil {
			return fmt.Errorf("error reading 'shipper': %w", err)
		}
		delete(object, "shipper")
	}

	if raw, found := object["ssl"]; found {
		err = json.Unmarshal(raw, &a.Ssl)
		if err != nil {
			return fmt.Errorf("error reading 'ssl': %w", err)
		}
		delete(object, "ssl")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputElasticsearch to handle AdditionalProperties
func (a OutputElasticsearch) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AllowEdit != nil {
		object["allow_edit"], err = json.Marshal(a.AllowEdit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allow_edit': %w", err)
		}
	}

	if a.CaSha256 != nil {
		object["ca_sha256"], err = json.Marshal(a.CaSha256)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ca_sha256': %w", err)
		}
	}

	if a.CaTrustedFingerprint != nil {
		object["ca_trusted_fingerprint"], err = json.Marshal(a.CaTrustedFingerprint)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ca_trusted_fingerprint': %w", err)
		}
	}

	if a.ConfigYaml != nil {
		object["config_yaml"], err = json.Marshal(a.ConfigYaml)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'config_yaml': %w", err)
		}
	}

	object["hosts"], err = json.Marshal(a.Hosts)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'hosts': %w", err)
	}

	if a.Id != nil {
		object["id"], err = json.Marshal(a.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if a.IsDefault != nil {
		object["is_default"], err = json.Marshal(a.IsDefault)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_default': %w", err)
		}
	}

	if a.IsDefaultMonitoring != nil {
		object["is_default_monitoring"], err = json.Marshal(a.IsDefaultMonitoring)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_default_monitoring': %w", err)
		}
	}

	if a.IsInternal != nil {
		object["is_internal"], err = json.Marshal(a.IsInternal)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_internal': %w", err)
		}
	}

	if a.IsPreconfigured != nil {
		object["is_preconfigured"], err = json.Marshal(a.IsPreconfigured)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_preconfigured': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Preset != nil {
		object["preset"], err = json.Marshal(a.Preset)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'preset': %w", err)
		}
	}

	if a.ProxyId != nil {
		object["proxy_id"], err = json.Marshal(a.ProxyId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_id': %w", err)
		}
	}

	if a.Shipper != nil {
		object["shipper"], err = json.Marshal(a.Shipper)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'shipper': %w", err)
		}
	}

	if a.Ssl != nil {
		object["ssl"], err = json.Marshal(a.Ssl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka. Returns the specified
// element and whether it was found
func (a OutputKafka) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka
func (a *OutputKafka) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka to handle AdditionalProperties
func (a *OutputKafka) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["allow_edit"]; found {
		err = json.Unmarshal(raw, &a.AllowEdit)
		if err != nil {
			return fmt.Errorf("error reading 'allow_edit': %w", err)
		}
		delete(object, "allow_edit")
	}

	if raw, found := object["auth_type"]; found {
		err = json.Unmarshal(raw, &a.AuthType)
		if err != nil {
			return fmt.Errorf("error reading 'auth_type': %w", err)
		}
		delete(object, "auth_type")
	}

	if raw, found := object["broker_timeout"]; found {
		err = json.Unmarshal(raw, &a.BrokerTimeout)
		if err != nil {
			return fmt.Errorf("error reading 'broker_timeout': %w", err)
		}
		delete(object, "broker_timeout")
	}

	if raw, found := object["ca_sha256"]; found {
		err = json.Unmarshal(raw, &a.CaSha256)
		if err != nil {
			return fmt.Errorf("error reading 'ca_sha256': %w", err)
		}
		delete(object, "ca_sha256")
	}

	if raw, found := object["ca_trusted_fingerprint"]; found {
		err = json.Unmarshal(raw, &a.CaTrustedFingerprint)
		if err != nil {
			return fmt.Errorf("error reading 'ca_trusted_fingerprint': %w", err)
		}
		delete(object, "ca_trusted_fingerprint")
	}

	if raw, found := object["client_id"]; found {
		err = json.Unmarshal(raw, &a.ClientId)
		if err != nil {
			return fmt.Errorf("error reading 'client_id': %w", err)
		}
		delete(object, "client_id")
	}

	if raw, found := object["compression"]; found {
		err = json.Unmarshal(raw, &a.Compression)
		if err != nil {
			return fmt.Errorf("error reading 'compression': %w", err)
		}
		delete(object, "compression")
	}

	if raw, found := object["compression_level"]; found {
		err = json.Unmarshal(raw, &a.CompressionLevel)
		if err != nil {
			return fmt.Errorf("error reading 'compression_level': %w", err)
		}
		delete(object, "compression_level")
	}

	if raw, found := object["config_yaml"]; found {
		err = json.Unmarshal(raw, &a.ConfigYaml)
		if err != nil {
			return fmt.Errorf("error reading 'config_yaml': %w", err)
		}
		delete(object, "config_yaml")
	}

	if raw, found := object["connection_type"]; found {
		err = json.Unmarshal(raw, &a.ConnectionType)
		if err != nil {
			return fmt.Errorf("error reading 'connection_type': %w", err)
		}
		delete(object, "connection_type")
	}

	if raw, found := object["hash"]; found {
		err = json.Unmarshal(raw, &a.Hash)
		if err != nil {
			return fmt.Errorf("error reading 'hash': %w", err)
		}
		delete(object, "hash")
	}

	if raw, found := object["headers"]; found {
		err = json.Unmarshal(raw, &a.Headers)
		if err != nil {
			return fmt.Errorf("error reading 'headers': %w", err)
		}
		delete(object, "headers")
	}

	if raw, found := object["hosts"]; found {
		err = json.Unmarshal(raw, &a.Hosts)
		if err != nil {
			return fmt.Errorf("error reading 'hosts': %w", err)
		}
		delete(object, "hosts")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["is_default"]; found {
		err = json.Unmarshal(raw, &a.IsDefault)
		if err != nil {
			return fmt.Errorf("error reading 'is_default': %w", err)
		}
		delete(object, "is_default")
	}

	if raw, found := object["is_default_monitoring"]; found {
		err = json.Unmarshal(raw, &a.IsDefaultMonitoring)
		if err != nil {
			return fmt.Errorf("error reading 'is_default_monitoring': %w", err)
		}
		delete(object, "is_default_monitoring")
	}

	if raw, found := object["is_internal"]; found {
		err = json.Unmarshal(raw, &a.IsInternal)
		if err != nil {
			return fmt.Errorf("error reading 'is_internal': %w", err)
		}
		delete(object, "is_internal")
	}

	if raw, found := object["is_preconfigured"]; found {
		err = json.Unmarshal(raw, &a.IsPreconfigured)
		if err != nil {
			return fmt.Errorf("error reading 'is_preconfigured': %w", err)
		}
		delete(object, "is_preconfigured")
	}

	if raw, found := object["key"]; found {
		err = json.Unmarshal(raw, &a.Key)
		if err != nil {
			return fmt.Errorf("error reading 'key': %w", err)
		}
		delete(object, "key")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["partition"]; found {
		err = json.Unmarshal(raw, &a.Partition)
		if err != nil {
			return fmt.Errorf("error reading 'partition': %w", err)
		}
		delete(object, "partition")
	}

	if raw, found := object["password"]; found {
		err = json.Unmarshal(raw, &a.Password)
		if err != nil {
			return fmt.Errorf("error reading 'password': %w", err)
		}
		delete(object, "password")
	}

	if raw, found := object["proxy_id"]; found {
		err = json.Unmarshal(raw, &a.ProxyId)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_id': %w", err)
		}
		delete(object, "proxy_id")
	}

	if raw, found := object["random"]; found {
		err = json.Unmarshal(raw, &a.Random)
		if err != nil {
			return fmt.Errorf("error reading 'random': %w", err)
		}
		delete(object, "random")
	}

	if raw, found := object["required_acks"]; found {
		err = json.Unmarshal(raw, &a.RequiredAcks)
		if err != nil {
			return fmt.Errorf("error reading 'required_acks': %w", err)
		}
		delete(object, "required_acks")
	}

	if raw, found := object["round_robin"]; found {
		err = json.Unmarshal(raw, &a.RoundRobin)
		if err != nil {
			return fmt.Errorf("error reading 'round_robin': %w", err)
		}
		delete(object, "round_robin")
	}

	if raw, found := object["sasl"]; found {
		err = json.Unmarshal(raw, &a.Sasl)
		if err != nil {
			return fmt.Errorf("error reading 'sasl': %w", err)
		}
		delete(object, "sasl")
	}

	if raw, found := object["secrets"]; found {
		err = json.Unmarshal(raw, &a.Secrets)
		if err != nil {
			return fmt.Errorf("error reading 'secrets': %w", err)
		}
		delete(object, "secrets")
	}

	if raw, found := object["shipper"]; found {
		err = json.Unmarshal(raw, &a.Shipper)
		if err != nil {
			return fmt.Errorf("error reading 'shipper': %w", err)
		}
		delete(object, "shipper")
	}

	if raw, found := object["ssl"]; found {
		err = json.Unmarshal(raw, &a.Ssl)
		if err != nil {
			return fmt.Errorf("error reading 'ssl': %w", err)
		}
		delete(object, "ssl")
	}

	if raw, found := object["timeout"]; found {
		err = json.Unmarshal(raw, &a.Timeout)
		if err != nil {
			return fmt.Errorf("error reading 'timeout': %w", err)
		}
		delete(object, "timeout")
	}

	if raw, found := object["topic"]; found {
		err = json.Unmarshal(raw, &a.Topic)
		if err != nil {
			return fmt.Errorf("error reading 'topic': %w", err)
		}
		delete(object, "topic")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["username"]; found {
		err = json.Unmarshal(raw, &a.Username)
		if err != nil {
			return fmt.Errorf("error reading 'username': %w", err)
		}
		delete(object, "username")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka to handle AdditionalProperties
func (a OutputKafka) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AllowEdit != nil {
		object["allow_edit"], err = json.Marshal(a.AllowEdit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allow_edit': %w", err)
		}
	}

	object["auth_type"], err = json.Marshal(a.AuthType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'auth_type': %w", err)
	}

	if a.BrokerTimeout != nil {
		object["broker_timeout"], err = json.Marshal(a.BrokerTimeout)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'broker_timeout': %w", err)
		}
	}

	if a.CaSha256 != nil {
		object["ca_sha256"], err = json.Marshal(a.CaSha256)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ca_sha256': %w", err)
		}
	}

	if a.CaTrustedFingerprint != nil {
		object["ca_trusted_fingerprint"], err = json.Marshal(a.CaTrustedFingerprint)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ca_trusted_fingerprint': %w", err)
		}
	}

	if a.ClientId != nil {
		object["client_id"], err = json.Marshal(a.ClientId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'client_id': %w", err)
		}
	}

	if a.Compression != nil {
		object["compression"], err = json.Marshal(a.Compression)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'compression': %w", err)
		}
	}

	object["compression_level"], err = json.Marshal(a.CompressionLevel)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'compression_level': %w", err)
	}

	if a.ConfigYaml != nil {
		object["config_yaml"], err = json.Marshal(a.ConfigYaml)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'config_yaml': %w", err)
		}
	}

	object["connection_type"], err = json.Marshal(a.ConnectionType)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'connection_type': %w", err)
	}

	if a.Hash != nil {
		object["hash"], err = json.Marshal(a.Hash)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'hash': %w", err)
		}
	}

	if a.Headers != nil {
		object["headers"], err = json.Marshal(a.Headers)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'headers': %w", err)
		}
	}

	object["hosts"], err = json.Marshal(a.Hosts)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'hosts': %w", err)
	}

	if a.Id != nil {
		object["id"], err = json.Marshal(a.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if a.IsDefault != nil {
		object["is_default"], err = json.Marshal(a.IsDefault)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_default': %w", err)
		}
	}

	if a.IsDefaultMonitoring != nil {
		object["is_default_monitoring"], err = json.Marshal(a.IsDefaultMonitoring)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_default_monitoring': %w", err)
		}
	}

	if a.IsInternal != nil {
		object["is_internal"], err = json.Marshal(a.IsInternal)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_internal': %w", err)
		}
	}

	if a.IsPreconfigured != nil {
		object["is_preconfigured"], err = json.Marshal(a.IsPreconfigured)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_preconfigured': %w", err)
		}
	}

	if a.Key != nil {
		object["key"], err = json.Marshal(a.Key)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'key': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Partition != nil {
		object["partition"], err = json.Marshal(a.Partition)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'partition': %w", err)
		}
	}

	object["password"], err = json.Marshal(a.Password)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'password': %w", err)
	}

	if a.ProxyId != nil {
		object["proxy_id"], err = json.Marshal(a.ProxyId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_id': %w", err)
		}
	}

	if a.Random != nil {
		object["random"], err = json.Marshal(a.Random)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'random': %w", err)
		}
	}

	if a.RequiredAcks != nil {
		object["required_acks"], err = json.Marshal(a.RequiredAcks)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'required_acks': %w", err)
		}
	}

	if a.RoundRobin != nil {
		object["round_robin"], err = json.Marshal(a.RoundRobin)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'round_robin': %w", err)
		}
	}

	if a.Sasl != nil {
		object["sasl"], err = json.Marshal(a.Sasl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'sasl': %w", err)
		}
	}

	if a.Secrets != nil {
		object["secrets"], err = json.Marshal(a.Secrets)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secrets': %w", err)
		}
	}

	if a.Shipper != nil {
		object["shipper"], err = json.Marshal(a.Shipper)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'shipper': %w", err)
		}
	}

	if a.Ssl != nil {
		object["ssl"], err = json.Marshal(a.Ssl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl': %w", err)
		}
	}

	if a.Timeout != nil {
		object["timeout"], err = json.Marshal(a.Timeout)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'timeout': %w", err)
		}
	}

	if a.Topic != nil {
		object["topic"], err = json.Marshal(a.Topic)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'topic': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	object["username"], err = json.Marshal(a.Username)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'username': %w", err)
	}

	if a.Version != nil {
		object["version"], err = json.Marshal(a.Version)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'version': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka_Hash. Returns the specified
// element and whether it was found
func (a OutputKafka_Hash) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka_Hash
func (a *OutputKafka_Hash) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka_Hash to handle AdditionalProperties
func (a *OutputKafka_Hash) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["hash"]; found {
		err = json.Unmarshal(raw, &a.Hash)
		if err != nil {
			return fmt.Errorf("error reading 'hash': %w", err)
		}
		delete(object, "hash")
	}

	if raw, found := object["random"]; found {
		err = json.Unmarshal(raw, &a.Random)
		if err != nil {
			return fmt.Errorf("error reading 'random': %w", err)
		}
		delete(object, "random")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka_Hash to handle AdditionalProperties
func (a OutputKafka_Hash) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Hash != nil {
		object["hash"], err = json.Marshal(a.Hash)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'hash': %w", err)
		}
	}

	if a.Random != nil {
		object["random"], err = json.Marshal(a.Random)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'random': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka_Headers_Item. Returns the specified
// element and whether it was found
func (a OutputKafka_Headers_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka_Headers_Item
func (a *OutputKafka_Headers_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka_Headers_Item to handle AdditionalProperties
func (a *OutputKafka_Headers_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["key"]; found {
		err = json.Unmarshal(raw, &a.Key)
		if err != nil {
			return fmt.Errorf("error reading 'key': %w", err)
		}
		delete(object, "key")
	}

	if raw, found := object["value"]; found {
		err = json.Unmarshal(raw, &a.Value)
		if err != nil {
			return fmt.Errorf("error reading 'value': %w", err)
		}
		delete(object, "value")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka_Headers_Item to handle AdditionalProperties
func (a OutputKafka_Headers_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["key"], err = json.Marshal(a.Key)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'key': %w", err)
	}

	object["value"], err = json.Marshal(a.Value)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'value': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka_Random. Returns the specified
// element and whether it was found
func (a OutputKafka_Random) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka_Random
func (a *OutputKafka_Random) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka_Random to handle AdditionalProperties
func (a *OutputKafka_Random) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["group_events"]; found {
		err = json.Unmarshal(raw, &a.GroupEvents)
		if err != nil {
			return fmt.Errorf("error reading 'group_events': %w", err)
		}
		delete(object, "group_events")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka_Random to handle AdditionalProperties
func (a OutputKafka_Random) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.GroupEvents != nil {
		object["group_events"], err = json.Marshal(a.GroupEvents)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'group_events': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka_RoundRobin. Returns the specified
// element and whether it was found
func (a OutputKafka_RoundRobin) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka_RoundRobin
func (a *OutputKafka_RoundRobin) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka_RoundRobin to handle AdditionalProperties
func (a *OutputKafka_RoundRobin) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["group_events"]; found {
		err = json.Unmarshal(raw, &a.GroupEvents)
		if err != nil {
			return fmt.Errorf("error reading 'group_events': %w", err)
		}
		delete(object, "group_events")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka_RoundRobin to handle AdditionalProperties
func (a OutputKafka_RoundRobin) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.GroupEvents != nil {
		object["group_events"], err = json.Marshal(a.GroupEvents)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'group_events': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka_Sasl. Returns the specified
// element and whether it was found
func (a OutputKafka_Sasl) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka_Sasl
func (a *OutputKafka_Sasl) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka_Sasl to handle AdditionalProperties
func (a *OutputKafka_Sasl) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["mechanism"]; found {
		err = json.Unmarshal(raw, &a.Mechanism)
		if err != nil {
			return fmt.Errorf("error reading 'mechanism': %w", err)
		}
		delete(object, "mechanism")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka_Sasl to handle AdditionalProperties
func (a OutputKafka_Sasl) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Mechanism != nil {
		object["mechanism"], err = json.Marshal(a.Mechanism)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'mechanism': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafkaSecretsPassword0. Returns the specified
// element and whether it was found
func (a OutputKafkaSecretsPassword0) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafkaSecretsPassword0
func (a *OutputKafkaSecretsPassword0) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafkaSecretsPassword0 to handle AdditionalProperties
func (a *OutputKafkaSecretsPassword0) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafkaSecretsPassword0 to handle AdditionalProperties
func (a OutputKafkaSecretsPassword0) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafkaSecretsSslKey0. Returns the specified
// element and whether it was found
func (a OutputKafkaSecretsSslKey0) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafkaSecretsSslKey0
func (a *OutputKafkaSecretsSslKey0) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafkaSecretsSslKey0 to handle AdditionalProperties
func (a *OutputKafkaSecretsSslKey0) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafkaSecretsSslKey0 to handle AdditionalProperties
func (a OutputKafkaSecretsSslKey0) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka_Secrets_Ssl. Returns the specified
// element and whether it was found
func (a OutputKafka_Secrets_Ssl) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka_Secrets_Ssl
func (a *OutputKafka_Secrets_Ssl) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka_Secrets_Ssl to handle AdditionalProperties
func (a *OutputKafka_Secrets_Ssl) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["key"]; found {
		err = json.Unmarshal(raw, &a.Key)
		if err != nil {
			return fmt.Errorf("error reading 'key': %w", err)
		}
		delete(object, "key")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka_Secrets_Ssl to handle AdditionalProperties
func (a OutputKafka_Secrets_Ssl) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["key"], err = json.Marshal(a.Key)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'key': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputKafka_Secrets. Returns the specified
// element and whether it was found
func (a OutputKafka_Secrets) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputKafka_Secrets
func (a *OutputKafka_Secrets) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputKafka_Secrets to handle AdditionalProperties
func (a *OutputKafka_Secrets) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["password"]; found {
		err = json.Unmarshal(raw, &a.Password)
		if err != nil {
			return fmt.Errorf("error reading 'password': %w", err)
		}
		delete(object, "password")
	}

	if raw, found := object["ssl"]; found {
		err = json.Unmarshal(raw, &a.Ssl)
		if err != nil {
			return fmt.Errorf("error reading 'ssl': %w", err)
		}
		delete(object, "ssl")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputKafka_Secrets to handle AdditionalProperties
func (a OutputKafka_Secrets) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Password != nil {
		object["password"], err = json.Marshal(a.Password)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'password': %w", err)
		}
	}

	if a.Ssl != nil {
		object["ssl"], err = json.Marshal(a.Ssl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputLogstash. Returns the specified
// element and whether it was found
func (a OutputLogstash) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputLogstash
func (a *OutputLogstash) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputLogstash to handle AdditionalProperties
func (a *OutputLogstash) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["allow_edit"]; found {
		err = json.Unmarshal(raw, &a.AllowEdit)
		if err != nil {
			return fmt.Errorf("error reading 'allow_edit': %w", err)
		}
		delete(object, "allow_edit")
	}

	if raw, found := object["ca_sha256"]; found {
		err = json.Unmarshal(raw, &a.CaSha256)
		if err != nil {
			return fmt.Errorf("error reading 'ca_sha256': %w", err)
		}
		delete(object, "ca_sha256")
	}

	if raw, found := object["ca_trusted_fingerprint"]; found {
		err = json.Unmarshal(raw, &a.CaTrustedFingerprint)
		if err != nil {
			return fmt.Errorf("error reading 'ca_trusted_fingerprint': %w", err)
		}
		delete(object, "ca_trusted_fingerprint")
	}

	if raw, found := object["config_yaml"]; found {
		err = json.Unmarshal(raw, &a.ConfigYaml)
		if err != nil {
			return fmt.Errorf("error reading 'config_yaml': %w", err)
		}
		delete(object, "config_yaml")
	}

	if raw, found := object["hosts"]; found {
		err = json.Unmarshal(raw, &a.Hosts)
		if err != nil {
			return fmt.Errorf("error reading 'hosts': %w", err)
		}
		delete(object, "hosts")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["is_default"]; found {
		err = json.Unmarshal(raw, &a.IsDefault)
		if err != nil {
			return fmt.Errorf("error reading 'is_default': %w", err)
		}
		delete(object, "is_default")
	}

	if raw, found := object["is_default_monitoring"]; found {
		err = json.Unmarshal(raw, &a.IsDefaultMonitoring)
		if err != nil {
			return fmt.Errorf("error reading 'is_default_monitoring': %w", err)
		}
		delete(object, "is_default_monitoring")
	}

	if raw, found := object["is_internal"]; found {
		err = json.Unmarshal(raw, &a.IsInternal)
		if err != nil {
			return fmt.Errorf("error reading 'is_internal': %w", err)
		}
		delete(object, "is_internal")
	}

	if raw, found := object["is_preconfigured"]; found {
		err = json.Unmarshal(raw, &a.IsPreconfigured)
		if err != nil {
			return fmt.Errorf("error reading 'is_preconfigured': %w", err)
		}
		delete(object, "is_preconfigured")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["proxy_id"]; found {
		err = json.Unmarshal(raw, &a.ProxyId)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_id': %w", err)
		}
		delete(object, "proxy_id")
	}

	if raw, found := object["secrets"]; found {
		err = json.Unmarshal(raw, &a.Secrets)
		if err != nil {
			return fmt.Errorf("error reading 'secrets': %w", err)
		}
		delete(object, "secrets")
	}

	if raw, found := object["shipper"]; found {
		err = json.Unmarshal(raw, &a.Shipper)
		if err != nil {
			return fmt.Errorf("error reading 'shipper': %w", err)
		}
		delete(object, "shipper")
	}

	if raw, found := object["ssl"]; found {
		err = json.Unmarshal(raw, &a.Ssl)
		if err != nil {
			return fmt.Errorf("error reading 'ssl': %w", err)
		}
		delete(object, "ssl")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputLogstash to handle AdditionalProperties
func (a OutputLogstash) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AllowEdit != nil {
		object["allow_edit"], err = json.Marshal(a.AllowEdit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allow_edit': %w", err)
		}
	}

	if a.CaSha256 != nil {
		object["ca_sha256"], err = json.Marshal(a.CaSha256)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ca_sha256': %w", err)
		}
	}

	if a.CaTrustedFingerprint != nil {
		object["ca_trusted_fingerprint"], err = json.Marshal(a.CaTrustedFingerprint)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ca_trusted_fingerprint': %w", err)
		}
	}

	if a.ConfigYaml != nil {
		object["config_yaml"], err = json.Marshal(a.ConfigYaml)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'config_yaml': %w", err)
		}
	}

	object["hosts"], err = json.Marshal(a.Hosts)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'hosts': %w", err)
	}

	if a.Id != nil {
		object["id"], err = json.Marshal(a.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if a.IsDefault != nil {
		object["is_default"], err = json.Marshal(a.IsDefault)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_default': %w", err)
		}
	}

	if a.IsDefaultMonitoring != nil {
		object["is_default_monitoring"], err = json.Marshal(a.IsDefaultMonitoring)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_default_monitoring': %w", err)
		}
	}

	if a.IsInternal != nil {
		object["is_internal"], err = json.Marshal(a.IsInternal)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_internal': %w", err)
		}
	}

	if a.IsPreconfigured != nil {
		object["is_preconfigured"], err = json.Marshal(a.IsPreconfigured)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_preconfigured': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.ProxyId != nil {
		object["proxy_id"], err = json.Marshal(a.ProxyId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_id': %w", err)
		}
	}

	if a.Secrets != nil {
		object["secrets"], err = json.Marshal(a.Secrets)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secrets': %w", err)
		}
	}

	if a.Shipper != nil {
		object["shipper"], err = json.Marshal(a.Shipper)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'shipper': %w", err)
		}
	}

	if a.Ssl != nil {
		object["ssl"], err = json.Marshal(a.Ssl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputLogstashSecretsSslKey0. Returns the specified
// element and whether it was found
func (a OutputLogstashSecretsSslKey0) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputLogstashSecretsSslKey0
func (a *OutputLogstashSecretsSslKey0) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputLogstashSecretsSslKey0 to handle AdditionalProperties
func (a *OutputLogstashSecretsSslKey0) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputLogstashSecretsSslKey0 to handle AdditionalProperties
func (a OutputLogstashSecretsSslKey0) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputLogstash_Secrets_Ssl. Returns the specified
// element and whether it was found
func (a OutputLogstash_Secrets_Ssl) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputLogstash_Secrets_Ssl
func (a *OutputLogstash_Secrets_Ssl) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputLogstash_Secrets_Ssl to handle AdditionalProperties
func (a *OutputLogstash_Secrets_Ssl) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["key"]; found {
		err = json.Unmarshal(raw, &a.Key)
		if err != nil {
			return fmt.Errorf("error reading 'key': %w", err)
		}
		delete(object, "key")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputLogstash_Secrets_Ssl to handle AdditionalProperties
func (a OutputLogstash_Secrets_Ssl) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Key != nil {
		object["key"], err = json.Marshal(a.Key)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'key': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputLogstash_Secrets. Returns the specified
// element and whether it was found
func (a OutputLogstash_Secrets) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputLogstash_Secrets
func (a *OutputLogstash_Secrets) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputLogstash_Secrets to handle AdditionalProperties
func (a *OutputLogstash_Secrets) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["ssl"]; found {
		err = json.Unmarshal(raw, &a.Ssl)
		if err != nil {
			return fmt.Errorf("error reading 'ssl': %w", err)
		}
		delete(object, "ssl")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputLogstash_Secrets to handle AdditionalProperties
func (a OutputLogstash_Secrets) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Ssl != nil {
		object["ssl"], err = json.Marshal(a.Ssl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputRemoteElasticsearch. Returns the specified
// element and whether it was found
func (a OutputRemoteElasticsearch) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputRemoteElasticsearch
func (a *OutputRemoteElasticsearch) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputRemoteElasticsearch to handle AdditionalProperties
func (a *OutputRemoteElasticsearch) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["allow_edit"]; found {
		err = json.Unmarshal(raw, &a.AllowEdit)
		if err != nil {
			return fmt.Errorf("error reading 'allow_edit': %w", err)
		}
		delete(object, "allow_edit")
	}

	if raw, found := object["ca_sha256"]; found {
		err = json.Unmarshal(raw, &a.CaSha256)
		if err != nil {
			return fmt.Errorf("error reading 'ca_sha256': %w", err)
		}
		delete(object, "ca_sha256")
	}

	if raw, found := object["ca_trusted_fingerprint"]; found {
		err = json.Unmarshal(raw, &a.CaTrustedFingerprint)
		if err != nil {
			return fmt.Errorf("error reading 'ca_trusted_fingerprint': %w", err)
		}
		delete(object, "ca_trusted_fingerprint")
	}

	if raw, found := object["config_yaml"]; found {
		err = json.Unmarshal(raw, &a.ConfigYaml)
		if err != nil {
			return fmt.Errorf("error reading 'config_yaml': %w", err)
		}
		delete(object, "config_yaml")
	}

	if raw, found := object["hosts"]; found {
		err = json.Unmarshal(raw, &a.Hosts)
		if err != nil {
			return fmt.Errorf("error reading 'hosts': %w", err)
		}
		delete(object, "hosts")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["is_default"]; found {
		err = json.Unmarshal(raw, &a.IsDefault)
		if err != nil {
			return fmt.Errorf("error reading 'is_default': %w", err)
		}
		delete(object, "is_default")
	}

	if raw, found := object["is_default_monitoring"]; found {
		err = json.Unmarshal(raw, &a.IsDefaultMonitoring)
		if err != nil {
			return fmt.Errorf("error reading 'is_default_monitoring': %w", err)
		}
		delete(object, "is_default_monitoring")
	}

	if raw, found := object["is_internal"]; found {
		err = json.Unmarshal(raw, &a.IsInternal)
		if err != nil {
			return fmt.Errorf("error reading 'is_internal': %w", err)
		}
		delete(object, "is_internal")
	}

	if raw, found := object["is_preconfigured"]; found {
		err = json.Unmarshal(raw, &a.IsPreconfigured)
		if err != nil {
			return fmt.Errorf("error reading 'is_preconfigured': %w", err)
		}
		delete(object, "is_preconfigured")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["preset"]; found {
		err = json.Unmarshal(raw, &a.Preset)
		if err != nil {
			return fmt.Errorf("error reading 'preset': %w", err)
		}
		delete(object, "preset")
	}

	if raw, found := object["proxy_id"]; found {
		err = json.Unmarshal(raw, &a.ProxyId)
		if err != nil {
			return fmt.Errorf("error reading 'proxy_id': %w", err)
		}
		delete(object, "proxy_id")
	}

	if raw, found := object["secrets"]; found {
		err = json.Unmarshal(raw, &a.Secrets)
		if err != nil {
			return fmt.Errorf("error reading 'secrets': %w", err)
		}
		delete(object, "secrets")
	}

	if raw, found := object["service_token"]; found {
		err = json.Unmarshal(raw, &a.ServiceToken)
		if err != nil {
			return fmt.Errorf("error reading 'service_token': %w", err)
		}
		delete(object, "service_token")
	}

	if raw, found := object["shipper"]; found {
		err = json.Unmarshal(raw, &a.Shipper)
		if err != nil {
			return fmt.Errorf("error reading 'shipper': %w", err)
		}
		delete(object, "shipper")
	}

	if raw, found := object["ssl"]; found {
		err = json.Unmarshal(raw, &a.Ssl)
		if err != nil {
			return fmt.Errorf("error reading 'ssl': %w", err)
		}
		delete(object, "ssl")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputRemoteElasticsearch to handle AdditionalProperties
func (a OutputRemoteElasticsearch) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AllowEdit != nil {
		object["allow_edit"], err = json.Marshal(a.AllowEdit)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'allow_edit': %w", err)
		}
	}

	if a.CaSha256 != nil {
		object["ca_sha256"], err = json.Marshal(a.CaSha256)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ca_sha256': %w", err)
		}
	}

	if a.CaTrustedFingerprint != nil {
		object["ca_trusted_fingerprint"], err = json.Marshal(a.CaTrustedFingerprint)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ca_trusted_fingerprint': %w", err)
		}
	}

	if a.ConfigYaml != nil {
		object["config_yaml"], err = json.Marshal(a.ConfigYaml)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'config_yaml': %w", err)
		}
	}

	object["hosts"], err = json.Marshal(a.Hosts)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'hosts': %w", err)
	}

	if a.Id != nil {
		object["id"], err = json.Marshal(a.Id)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'id': %w", err)
		}
	}

	if a.IsDefault != nil {
		object["is_default"], err = json.Marshal(a.IsDefault)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_default': %w", err)
		}
	}

	if a.IsDefaultMonitoring != nil {
		object["is_default_monitoring"], err = json.Marshal(a.IsDefaultMonitoring)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_default_monitoring': %w", err)
		}
	}

	if a.IsInternal != nil {
		object["is_internal"], err = json.Marshal(a.IsInternal)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_internal': %w", err)
		}
	}

	if a.IsPreconfigured != nil {
		object["is_preconfigured"], err = json.Marshal(a.IsPreconfigured)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'is_preconfigured': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Preset != nil {
		object["preset"], err = json.Marshal(a.Preset)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'preset': %w", err)
		}
	}

	if a.ProxyId != nil {
		object["proxy_id"], err = json.Marshal(a.ProxyId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'proxy_id': %w", err)
		}
	}

	if a.Secrets != nil {
		object["secrets"], err = json.Marshal(a.Secrets)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'secrets': %w", err)
		}
	}

	if a.ServiceToken != nil {
		object["service_token"], err = json.Marshal(a.ServiceToken)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'service_token': %w", err)
		}
	}

	if a.Shipper != nil {
		object["shipper"], err = json.Marshal(a.Shipper)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'shipper': %w", err)
		}
	}

	if a.Ssl != nil {
		object["ssl"], err = json.Marshal(a.Ssl)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'ssl': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputRemoteElasticsearchSecretsServiceToken0. Returns the specified
// element and whether it was found
func (a OutputRemoteElasticsearchSecretsServiceToken0) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputRemoteElasticsearchSecretsServiceToken0
func (a *OutputRemoteElasticsearchSecretsServiceToken0) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputRemoteElasticsearchSecretsServiceToken0 to handle AdditionalProperties
func (a *OutputRemoteElasticsearchSecretsServiceToken0) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputRemoteElasticsearchSecretsServiceToken0 to handle AdditionalProperties
func (a OutputRemoteElasticsearchSecretsServiceToken0) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputRemoteElasticsearch_Secrets. Returns the specified
// element and whether it was found
func (a OutputRemoteElasticsearch_Secrets) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputRemoteElasticsearch_Secrets
func (a *OutputRemoteElasticsearch_Secrets) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputRemoteElasticsearch_Secrets to handle AdditionalProperties
func (a *OutputRemoteElasticsearch_Secrets) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["service_token"]; found {
		err = json.Unmarshal(raw, &a.ServiceToken)
		if err != nil {
			return fmt.Errorf("error reading 'service_token': %w", err)
		}
		delete(object, "service_token")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputRemoteElasticsearch_Secrets to handle AdditionalProperties
func (a OutputRemoteElasticsearch_Secrets) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.ServiceToken != nil {
		object["service_token"], err = json.Marshal(a.ServiceToken)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'service_token': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputShipper. Returns the specified
// element and whether it was found
func (a OutputShipper) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputShipper
func (a *OutputShipper) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputShipper to handle AdditionalProperties
func (a *OutputShipper) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["compression_level"]; found {
		err = json.Unmarshal(raw, &a.CompressionLevel)
		if err != nil {
			return fmt.Errorf("error reading 'compression_level': %w", err)
		}
		delete(object, "compression_level")
	}

	if raw, found := object["disk_queue_compression_enabled"]; found {
		err = json.Unmarshal(raw, &a.DiskQueueCompressionEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'disk_queue_compression_enabled': %w", err)
		}
		delete(object, "disk_queue_compression_enabled")
	}

	if raw, found := object["disk_queue_enabled"]; found {
		err = json.Unmarshal(raw, &a.DiskQueueEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'disk_queue_enabled': %w", err)
		}
		delete(object, "disk_queue_enabled")
	}

	if raw, found := object["disk_queue_encryption_enabled"]; found {
		err = json.Unmarshal(raw, &a.DiskQueueEncryptionEnabled)
		if err != nil {
			return fmt.Errorf("error reading 'disk_queue_encryption_enabled': %w", err)
		}
		delete(object, "disk_queue_encryption_enabled")
	}

	if raw, found := object["disk_queue_max_size"]; found {
		err = json.Unmarshal(raw, &a.DiskQueueMaxSize)
		if err != nil {
			return fmt.Errorf("error reading 'disk_queue_max_size': %w", err)
		}
		delete(object, "disk_queue_max_size")
	}

	if raw, found := object["disk_queue_path"]; found {
		err = json.Unmarshal(raw, &a.DiskQueuePath)
		if err != nil {
			return fmt.Errorf("error reading 'disk_queue_path': %w", err)
		}
		delete(object, "disk_queue_path")
	}

	if raw, found := object["loadbalance"]; found {
		err = json.Unmarshal(raw, &a.Loadbalance)
		if err != nil {
			return fmt.Errorf("error reading 'loadbalance': %w", err)
		}
		delete(object, "loadbalance")
	}

	if raw, found := object["max_batch_bytes"]; found {
		err = json.Unmarshal(raw, &a.MaxBatchBytes)
		if err != nil {
			return fmt.Errorf("error reading 'max_batch_bytes': %w", err)
		}
		delete(object, "max_batch_bytes")
	}

	if raw, found := object["mem_queue_events"]; found {
		err = json.Unmarshal(raw, &a.MemQueueEvents)
		if err != nil {
			return fmt.Errorf("error reading 'mem_queue_events': %w", err)
		}
		delete(object, "mem_queue_events")
	}

	if raw, found := object["queue_flush_timeout"]; found {
		err = json.Unmarshal(raw, &a.QueueFlushTimeout)
		if err != nil {
			return fmt.Errorf("error reading 'queue_flush_timeout': %w", err)
		}
		delete(object, "queue_flush_timeout")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputShipper to handle AdditionalProperties
func (a OutputShipper) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["compression_level"], err = json.Marshal(a.CompressionLevel)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'compression_level': %w", err)
	}

	object["disk_queue_compression_enabled"], err = json.Marshal(a.DiskQueueCompressionEnabled)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'disk_queue_compression_enabled': %w", err)
	}

	if a.DiskQueueEnabled != nil {
		object["disk_queue_enabled"], err = json.Marshal(a.DiskQueueEnabled)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'disk_queue_enabled': %w", err)
		}
	}

	object["disk_queue_encryption_enabled"], err = json.Marshal(a.DiskQueueEncryptionEnabled)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'disk_queue_encryption_enabled': %w", err)
	}

	object["disk_queue_max_size"], err = json.Marshal(a.DiskQueueMaxSize)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'disk_queue_max_size': %w", err)
	}

	object["disk_queue_path"], err = json.Marshal(a.DiskQueuePath)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'disk_queue_path': %w", err)
	}

	object["loadbalance"], err = json.Marshal(a.Loadbalance)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'loadbalance': %w", err)
	}

	object["max_batch_bytes"], err = json.Marshal(a.MaxBatchBytes)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'max_batch_bytes': %w", err)
	}

	object["mem_queue_events"], err = json.Marshal(a.MemQueueEvents)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'mem_queue_events': %w", err)
	}

	object["queue_flush_timeout"], err = json.Marshal(a.QueueFlushTimeout)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'queue_flush_timeout': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OutputSsl. Returns the specified
// element and whether it was found
func (a OutputSsl) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OutputSsl
func (a *OutputSsl) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OutputSsl to handle AdditionalProperties
func (a *OutputSsl) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["certificate"]; found {
		err = json.Unmarshal(raw, &a.Certificate)
		if err != nil {
			return fmt.Errorf("error reading 'certificate': %w", err)
		}
		delete(object, "certificate")
	}

	if raw, found := object["certificate_authorities"]; found {
		err = json.Unmarshal(raw, &a.CertificateAuthorities)
		if err != nil {
			return fmt.Errorf("error reading 'certificate_authorities': %w", err)
		}
		delete(object, "certificate_authorities")
	}

	if raw, found := object["key"]; found {
		err = json.Unmarshal(raw, &a.Key)
		if err != nil {
			return fmt.Errorf("error reading 'key': %w", err)
		}
		delete(object, "key")
	}

	if raw, found := object["verification_mode"]; found {
		err = json.Unmarshal(raw, &a.VerificationMode)
		if err != nil {
			return fmt.Errorf("error reading 'verification_mode': %w", err)
		}
		delete(object, "verification_mode")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OutputSsl to handle AdditionalProperties
func (a OutputSsl) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Certificate != nil {
		object["certificate"], err = json.Marshal(a.Certificate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'certificate': %w", err)
		}
	}

	if a.CertificateAuthorities != nil {
		object["certificate_authorities"], err = json.Marshal(a.CertificateAuthorities)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'certificate_authorities': %w", err)
		}
	}

	if a.Key != nil {
		object["key"], err = json.Marshal(a.Key)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'key': %w", err)
		}
	}

	if a.VerificationMode != nil {
		object["verification_mode"], err = json.Marshal(a.VerificationMode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'verification_mode': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo. Returns the specified
// element and whether it was found
func (a PackageInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo
func (a *PackageInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo to handle AdditionalProperties
func (a *PackageInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["agent"]; found {
		err = json.Unmarshal(raw, &a.Agent)
		if err != nil {
			return fmt.Errorf("error reading 'agent': %w", err)
		}
		delete(object, "agent")
	}

	if raw, found := object["asset_tags"]; found {
		err = json.Unmarshal(raw, &a.AssetTags)
		if err != nil {
			return fmt.Errorf("error reading 'asset_tags': %w", err)
		}
		delete(object, "asset_tags")
	}

	if raw, found := object["assets"]; found {
		err = json.Unmarshal(raw, &a.Assets)
		if err != nil {
			return fmt.Errorf("error reading 'assets': %w", err)
		}
		delete(object, "assets")
	}

	if raw, found := object["categories"]; found {
		err = json.Unmarshal(raw, &a.Categories)
		if err != nil {
			return fmt.Errorf("error reading 'categories': %w", err)
		}
		delete(object, "categories")
	}

	if raw, found := object["conditions"]; found {
		err = json.Unmarshal(raw, &a.Conditions)
		if err != nil {
			return fmt.Errorf("error reading 'conditions': %w", err)
		}
		delete(object, "conditions")
	}

	if raw, found := object["data_streams"]; found {
		err = json.Unmarshal(raw, &a.DataStreams)
		if err != nil {
			return fmt.Errorf("error reading 'data_streams': %w", err)
		}
		delete(object, "data_streams")
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["discovery"]; found {
		err = json.Unmarshal(raw, &a.Discovery)
		if err != nil {
			return fmt.Errorf("error reading 'discovery': %w", err)
		}
		delete(object, "discovery")
	}

	if raw, found := object["download"]; found {
		err = json.Unmarshal(raw, &a.Download)
		if err != nil {
			return fmt.Errorf("error reading 'download': %w", err)
		}
		delete(object, "download")
	}

	if raw, found := object["elasticsearch"]; found {
		err = json.Unmarshal(raw, &a.Elasticsearch)
		if err != nil {
			return fmt.Errorf("error reading 'elasticsearch': %w", err)
		}
		delete(object, "elasticsearch")
	}

	if raw, found := object["format_version"]; found {
		err = json.Unmarshal(raw, &a.FormatVersion)
		if err != nil {
			return fmt.Errorf("error reading 'format_version': %w", err)
		}
		delete(object, "format_version")
	}

	if raw, found := object["icons"]; found {
		err = json.Unmarshal(raw, &a.Icons)
		if err != nil {
			return fmt.Errorf("error reading 'icons': %w", err)
		}
		delete(object, "icons")
	}

	if raw, found := object["installationInfo"]; found {
		err = json.Unmarshal(raw, &a.InstallationInfo)
		if err != nil {
			return fmt.Errorf("error reading 'installationInfo': %w", err)
		}
		delete(object, "installationInfo")
	}

	if raw, found := object["internal"]; found {
		err = json.Unmarshal(raw, &a.Internal)
		if err != nil {
			return fmt.Errorf("error reading 'internal': %w", err)
		}
		delete(object, "internal")
	}

	if raw, found := object["keepPoliciesUpToDate"]; found {
		err = json.Unmarshal(raw, &a.KeepPoliciesUpToDate)
		if err != nil {
			return fmt.Errorf("error reading 'keepPoliciesUpToDate': %w", err)
		}
		delete(object, "keepPoliciesUpToDate")
	}

	if raw, found := object["latestVersion"]; found {
		err = json.Unmarshal(raw, &a.LatestVersion)
		if err != nil {
			return fmt.Errorf("error reading 'latestVersion': %w", err)
		}
		delete(object, "latestVersion")
	}

	if raw, found := object["license"]; found {
		err = json.Unmarshal(raw, &a.License)
		if err != nil {
			return fmt.Errorf("error reading 'license': %w", err)
		}
		delete(object, "license")
	}

	if raw, found := object["licensePath"]; found {
		err = json.Unmarshal(raw, &a.LicensePath)
		if err != nil {
			return fmt.Errorf("error reading 'licensePath': %w", err)
		}
		delete(object, "licensePath")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["notice"]; found {
		err = json.Unmarshal(raw, &a.Notice)
		if err != nil {
			return fmt.Errorf("error reading 'notice': %w", err)
		}
		delete(object, "notice")
	}

	if raw, found := object["owner"]; found {
		err = json.Unmarshal(raw, &a.Owner)
		if err != nil {
			return fmt.Errorf("error reading 'owner': %w", err)
		}
		delete(object, "owner")
	}

	if raw, found := object["path"]; found {
		err = json.Unmarshal(raw, &a.Path)
		if err != nil {
			return fmt.Errorf("error reading 'path': %w", err)
		}
		delete(object, "path")
	}

	if raw, found := object["policy_templates"]; found {
		err = json.Unmarshal(raw, &a.PolicyTemplates)
		if err != nil {
			return fmt.Errorf("error reading 'policy_templates': %w", err)
		}
		delete(object, "policy_templates")
	}

	if raw, found := object["readme"]; found {
		err = json.Unmarshal(raw, &a.Readme)
		if err != nil {
			return fmt.Errorf("error reading 'readme': %w", err)
		}
		delete(object, "readme")
	}

	if raw, found := object["release"]; found {
		err = json.Unmarshal(raw, &a.Release)
		if err != nil {
			return fmt.Errorf("error reading 'release': %w", err)
		}
		delete(object, "release")
	}

	if raw, found := object["screenshots"]; found {
		err = json.Unmarshal(raw, &a.Screenshots)
		if err != nil {
			return fmt.Errorf("error reading 'screenshots': %w", err)
		}
		delete(object, "screenshots")
	}

	if raw, found := object["signature_path"]; found {
		err = json.Unmarshal(raw, &a.SignaturePath)
		if err != nil {
			return fmt.Errorf("error reading 'signature_path': %w", err)
		}
		delete(object, "signature_path")
	}

	if raw, found := object["source"]; found {
		err = json.Unmarshal(raw, &a.Source)
		if err != nil {
			return fmt.Errorf("error reading 'source': %w", err)
		}
		delete(object, "source")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
		delete(object, "title")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["vars"]; found {
		err = json.Unmarshal(raw, &a.Vars)
		if err != nil {
			return fmt.Errorf("error reading 'vars': %w", err)
		}
		delete(object, "vars")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo to handle AdditionalProperties
func (a PackageInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Agent != nil {
		object["agent"], err = json.Marshal(a.Agent)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'agent': %w", err)
		}
	}

	if a.AssetTags != nil {
		object["asset_tags"], err = json.Marshal(a.AssetTags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'asset_tags': %w", err)
		}
	}

	object["assets"], err = json.Marshal(a.Assets)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'assets': %w", err)
	}

	if a.Categories != nil {
		object["categories"], err = json.Marshal(a.Categories)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'categories': %w", err)
		}
	}

	if a.Conditions != nil {
		object["conditions"], err = json.Marshal(a.Conditions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'conditions': %w", err)
		}
	}

	if a.DataStreams != nil {
		object["data_streams"], err = json.Marshal(a.DataStreams)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'data_streams': %w", err)
		}
	}

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.Discovery != nil {
		object["discovery"], err = json.Marshal(a.Discovery)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'discovery': %w", err)
		}
	}

	if a.Download != nil {
		object["download"], err = json.Marshal(a.Download)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'download': %w", err)
		}
	}

	if a.Elasticsearch != nil {
		object["elasticsearch"], err = json.Marshal(a.Elasticsearch)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'elasticsearch': %w", err)
		}
	}

	if a.FormatVersion != nil {
		object["format_version"], err = json.Marshal(a.FormatVersion)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'format_version': %w", err)
		}
	}

	if a.Icons != nil {
		object["icons"], err = json.Marshal(a.Icons)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'icons': %w", err)
		}
	}

	if a.InstallationInfo != nil {
		object["installationInfo"], err = json.Marshal(a.InstallationInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'installationInfo': %w", err)
		}
	}

	if a.Internal != nil {
		object["internal"], err = json.Marshal(a.Internal)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'internal': %w", err)
		}
	}

	if a.KeepPoliciesUpToDate != nil {
		object["keepPoliciesUpToDate"], err = json.Marshal(a.KeepPoliciesUpToDate)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'keepPoliciesUpToDate': %w", err)
		}
	}

	if a.LatestVersion != nil {
		object["latestVersion"], err = json.Marshal(a.LatestVersion)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'latestVersion': %w", err)
		}
	}

	if a.License != nil {
		object["license"], err = json.Marshal(a.License)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'license': %w", err)
		}
	}

	if a.LicensePath != nil {
		object["licensePath"], err = json.Marshal(a.LicensePath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'licensePath': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Notice != nil {
		object["notice"], err = json.Marshal(a.Notice)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'notice': %w", err)
		}
	}

	if a.Owner != nil {
		object["owner"], err = json.Marshal(a.Owner)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'owner': %w", err)
		}
	}

	if a.Path != nil {
		object["path"], err = json.Marshal(a.Path)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'path': %w", err)
		}
	}

	if a.PolicyTemplates != nil {
		object["policy_templates"], err = json.Marshal(a.PolicyTemplates)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'policy_templates': %w", err)
		}
	}

	if a.Readme != nil {
		object["readme"], err = json.Marshal(a.Readme)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'readme': %w", err)
		}
	}

	if a.Release != nil {
		object["release"], err = json.Marshal(a.Release)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'release': %w", err)
		}
	}

	if a.Screenshots != nil {
		object["screenshots"], err = json.Marshal(a.Screenshots)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'screenshots': %w", err)
		}
	}

	if a.SignaturePath != nil {
		object["signature_path"], err = json.Marshal(a.SignaturePath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'signature_path': %w", err)
		}
	}

	if a.Source != nil {
		object["source"], err = json.Marshal(a.Source)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'source': %w", err)
		}
	}

	if a.Status != nil {
		object["status"], err = json.Marshal(a.Status)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status': %w", err)
		}
	}

	object["title"], err = json.Marshal(a.Title)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'title': %w", err)
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	if a.Vars != nil {
		object["vars"], err = json.Marshal(a.Vars)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'vars': %w", err)
		}
	}

	object["version"], err = json.Marshal(a.Version)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'version': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_Conditions_Elastic. Returns the specified
// element and whether it was found
func (a PackageInfo_Conditions_Elastic) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_Conditions_Elastic
func (a *PackageInfo_Conditions_Elastic) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_Conditions_Elastic to handle AdditionalProperties
func (a *PackageInfo_Conditions_Elastic) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["capabilities"]; found {
		err = json.Unmarshal(raw, &a.Capabilities)
		if err != nil {
			return fmt.Errorf("error reading 'capabilities': %w", err)
		}
		delete(object, "capabilities")
	}

	if raw, found := object["subscription"]; found {
		err = json.Unmarshal(raw, &a.Subscription)
		if err != nil {
			return fmt.Errorf("error reading 'subscription': %w", err)
		}
		delete(object, "subscription")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_Conditions_Elastic to handle AdditionalProperties
func (a PackageInfo_Conditions_Elastic) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Capabilities != nil {
		object["capabilities"], err = json.Marshal(a.Capabilities)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'capabilities': %w", err)
		}
	}

	if a.Subscription != nil {
		object["subscription"], err = json.Marshal(a.Subscription)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subscription': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_Conditions_Kibana. Returns the specified
// element and whether it was found
func (a PackageInfo_Conditions_Kibana) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_Conditions_Kibana
func (a *PackageInfo_Conditions_Kibana) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_Conditions_Kibana to handle AdditionalProperties
func (a *PackageInfo_Conditions_Kibana) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_Conditions_Kibana to handle AdditionalProperties
func (a PackageInfo_Conditions_Kibana) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Version != nil {
		object["version"], err = json.Marshal(a.Version)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'version': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_Conditions. Returns the specified
// element and whether it was found
func (a PackageInfo_Conditions) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_Conditions
func (a *PackageInfo_Conditions) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_Conditions to handle AdditionalProperties
func (a *PackageInfo_Conditions) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["elastic"]; found {
		err = json.Unmarshal(raw, &a.Elastic)
		if err != nil {
			return fmt.Errorf("error reading 'elastic': %w", err)
		}
		delete(object, "elastic")
	}

	if raw, found := object["kibana"]; found {
		err = json.Unmarshal(raw, &a.Kibana)
		if err != nil {
			return fmt.Errorf("error reading 'kibana': %w", err)
		}
		delete(object, "kibana")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_Conditions to handle AdditionalProperties
func (a PackageInfo_Conditions) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Elastic != nil {
		object["elastic"], err = json.Marshal(a.Elastic)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'elastic': %w", err)
		}
	}

	if a.Kibana != nil {
		object["kibana"], err = json.Marshal(a.Kibana)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'kibana': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_Discovery_Fields_Item. Returns the specified
// element and whether it was found
func (a PackageInfo_Discovery_Fields_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_Discovery_Fields_Item
func (a *PackageInfo_Discovery_Fields_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_Discovery_Fields_Item to handle AdditionalProperties
func (a *PackageInfo_Discovery_Fields_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_Discovery_Fields_Item to handle AdditionalProperties
func (a PackageInfo_Discovery_Fields_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_Discovery. Returns the specified
// element and whether it was found
func (a PackageInfo_Discovery) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_Discovery
func (a *PackageInfo_Discovery) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_Discovery to handle AdditionalProperties
func (a *PackageInfo_Discovery) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["fields"]; found {
		err = json.Unmarshal(raw, &a.Fields)
		if err != nil {
			return fmt.Errorf("error reading 'fields': %w", err)
		}
		delete(object, "fields")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_Discovery to handle AdditionalProperties
func (a PackageInfo_Discovery) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Fields != nil {
		object["fields"], err = json.Marshal(a.Fields)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fields': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_Icons_Item. Returns the specified
// element and whether it was found
func (a PackageInfo_Icons_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_Icons_Item
func (a *PackageInfo_Icons_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_Icons_Item to handle AdditionalProperties
func (a *PackageInfo_Icons_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["dark_mode"]; found {
		err = json.Unmarshal(raw, &a.DarkMode)
		if err != nil {
			return fmt.Errorf("error reading 'dark_mode': %w", err)
		}
		delete(object, "dark_mode")
	}

	if raw, found := object["path"]; found {
		err = json.Unmarshal(raw, &a.Path)
		if err != nil {
			return fmt.Errorf("error reading 'path': %w", err)
		}
		delete(object, "path")
	}

	if raw, found := object["size"]; found {
		err = json.Unmarshal(raw, &a.Size)
		if err != nil {
			return fmt.Errorf("error reading 'size': %w", err)
		}
		delete(object, "size")
	}

	if raw, found := object["src"]; found {
		err = json.Unmarshal(raw, &a.Src)
		if err != nil {
			return fmt.Errorf("error reading 'src': %w", err)
		}
		delete(object, "src")
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
		delete(object, "title")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_Icons_Item to handle AdditionalProperties
func (a PackageInfo_Icons_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.DarkMode != nil {
		object["dark_mode"], err = json.Marshal(a.DarkMode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dark_mode': %w", err)
		}
	}

	if a.Path != nil {
		object["path"], err = json.Marshal(a.Path)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'path': %w", err)
		}
	}

	if a.Size != nil {
		object["size"], err = json.Marshal(a.Size)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'size': %w", err)
		}
	}

	object["src"], err = json.Marshal(a.Src)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'src': %w", err)
	}

	if a.Title != nil {
		object["title"], err = json.Marshal(a.Title)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'title': %w", err)
		}
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item
func (a *PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["originId"]; found {
		err = json.Unmarshal(raw, &a.OriginId)
		if err != nil {
			return fmt.Errorf("error reading 'originId': %w", err)
		}
		delete(object, "originId")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item to handle AdditionalProperties
func (a PackageInfo_InstallationInfo_AdditionalSpacesInstalledKibana_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if a.OriginId != nil {
		object["originId"], err = json.Marshal(a.OriginId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'originId': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features
func (a *PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["doc_value_only_numeric"]; found {
		err = json.Unmarshal(raw, &a.DocValueOnlyNumeric)
		if err != nil {
			return fmt.Errorf("error reading 'doc_value_only_numeric': %w", err)
		}
		delete(object, "doc_value_only_numeric")
	}

	if raw, found := object["doc_value_only_other"]; found {
		err = json.Unmarshal(raw, &a.DocValueOnlyOther)
		if err != nil {
			return fmt.Errorf("error reading 'doc_value_only_other': %w", err)
		}
		delete(object, "doc_value_only_other")
	}

	if raw, found := object["synthetic_source"]; found {
		err = json.Unmarshal(raw, &a.SyntheticSource)
		if err != nil {
			return fmt.Errorf("error reading 'synthetic_source': %w", err)
		}
		delete(object, "synthetic_source")
	}

	if raw, found := object["tsdb"]; found {
		err = json.Unmarshal(raw, &a.Tsdb)
		if err != nil {
			return fmt.Errorf("error reading 'tsdb': %w", err)
		}
		delete(object, "tsdb")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features to handle AdditionalProperties
func (a PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Features) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.DocValueOnlyNumeric != nil {
		object["doc_value_only_numeric"], err = json.Marshal(a.DocValueOnlyNumeric)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'doc_value_only_numeric': %w", err)
		}
	}

	if a.DocValueOnlyOther != nil {
		object["doc_value_only_other"], err = json.Marshal(a.DocValueOnlyOther)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'doc_value_only_other': %w", err)
		}
	}

	if a.SyntheticSource != nil {
		object["synthetic_source"], err = json.Marshal(a.SyntheticSource)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'synthetic_source': %w", err)
		}
	}

	if a.Tsdb != nil {
		object["tsdb"], err = json.Marshal(a.Tsdb)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tsdb': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item
func (a *PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["data_stream"]; found {
		err = json.Unmarshal(raw, &a.DataStream)
		if err != nil {
			return fmt.Errorf("error reading 'data_stream': %w", err)
		}
		delete(object, "data_stream")
	}

	if raw, found := object["features"]; found {
		err = json.Unmarshal(raw, &a.Features)
		if err != nil {
			return fmt.Errorf("error reading 'features': %w", err)
		}
		delete(object, "features")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item to handle AdditionalProperties
func (a PackageInfo_InstallationInfo_ExperimentalDataStreamFeatures_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["data_stream"], err = json.Marshal(a.DataStream)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'data_stream': %w", err)
	}

	object["features"], err = json.Marshal(a.Features)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'features': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo_InstalledEs_Item. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo_InstalledEs_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo_InstalledEs_Item
func (a *PackageInfo_InstallationInfo_InstalledEs_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo_InstalledEs_Item to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo_InstalledEs_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["deferred"]; found {
		err = json.Unmarshal(raw, &a.Deferred)
		if err != nil {
			return fmt.Errorf("error reading 'deferred': %w", err)
		}
		delete(object, "deferred")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo_InstalledEs_Item to handle AdditionalProperties
func (a PackageInfo_InstallationInfo_InstalledEs_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Deferred != nil {
		object["deferred"], err = json.Marshal(a.Deferred)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'deferred': %w", err)
		}
	}

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	if a.Version != nil {
		object["version"], err = json.Marshal(a.Version)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'version': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo_InstalledKibana_Item. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo_InstalledKibana_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo_InstalledKibana_Item
func (a *PackageInfo_InstallationInfo_InstalledKibana_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo_InstalledKibana_Item to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo_InstalledKibana_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["originId"]; found {
		err = json.Unmarshal(raw, &a.OriginId)
		if err != nil {
			return fmt.Errorf("error reading 'originId': %w", err)
		}
		delete(object, "originId")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo_InstalledKibana_Item to handle AdditionalProperties
func (a PackageInfo_InstallationInfo_InstalledKibana_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if a.OriginId != nil {
		object["originId"], err = json.Marshal(a.OriginId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'originId': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo_LatestExecutedState. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo_LatestExecutedState) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo_LatestExecutedState
func (a *PackageInfo_InstallationInfo_LatestExecutedState) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo_LatestExecutedState to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo_LatestExecutedState) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["error"]; found {
		err = json.Unmarshal(raw, &a.Error)
		if err != nil {
			return fmt.Errorf("error reading 'error': %w", err)
		}
		delete(object, "error")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["started_at"]; found {
		err = json.Unmarshal(raw, &a.StartedAt)
		if err != nil {
			return fmt.Errorf("error reading 'started_at': %w", err)
		}
		delete(object, "started_at")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo_LatestExecutedState to handle AdditionalProperties
func (a PackageInfo_InstallationInfo_LatestExecutedState) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Error != nil {
		object["error"], err = json.Marshal(a.Error)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'error': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	object["started_at"], err = json.Marshal(a.StartedAt)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'started_at': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error
func (a *PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &a.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
		delete(object, "message")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["stack"]; found {
		err = json.Unmarshal(raw, &a.Stack)
		if err != nil {
			return fmt.Errorf("error reading 'stack': %w", err)
		}
		delete(object, "stack")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error to handle AdditionalProperties
func (a PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Error) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["message"], err = json.Marshal(a.Message)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'message': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Stack != nil {
		object["stack"], err = json.Marshal(a.Stack)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stack': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item
func (a *PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["created_at"]; found {
		err = json.Unmarshal(raw, &a.CreatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'created_at': %w", err)
		}
		delete(object, "created_at")
	}

	if raw, found := object["error"]; found {
		err = json.Unmarshal(raw, &a.Error)
		if err != nil {
			return fmt.Errorf("error reading 'error': %w", err)
		}
		delete(object, "error")
	}

	if raw, found := object["target_version"]; found {
		err = json.Unmarshal(raw, &a.TargetVersion)
		if err != nil {
			return fmt.Errorf("error reading 'target_version': %w", err)
		}
		delete(object, "target_version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item to handle AdditionalProperties
func (a PackageInfo_InstallationInfo_LatestInstallFailedAttempts_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["created_at"], err = json.Marshal(a.CreatedAt)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'created_at': %w", err)
	}

	object["error"], err = json.Marshal(a.Error)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'error': %w", err)
	}

	object["target_version"], err = json.Marshal(a.TargetVersion)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'target_version': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_InstallationInfo. Returns the specified
// element and whether it was found
func (a PackageInfo_InstallationInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_InstallationInfo
func (a *PackageInfo_InstallationInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_InstallationInfo to handle AdditionalProperties
func (a *PackageInfo_InstallationInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["additional_spaces_installed_kibana"]; found {
		err = json.Unmarshal(raw, &a.AdditionalSpacesInstalledKibana)
		if err != nil {
			return fmt.Errorf("error reading 'additional_spaces_installed_kibana': %w", err)
		}
		delete(object, "additional_spaces_installed_kibana")
	}

	if raw, found := object["created_at"]; found {
		err = json.Unmarshal(raw, &a.CreatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'created_at': %w", err)
		}
		delete(object, "created_at")
	}

	if raw, found := object["experimental_data_stream_features"]; found {
		err = json.Unmarshal(raw, &a.ExperimentalDataStreamFeatures)
		if err != nil {
			return fmt.Errorf("error reading 'experimental_data_stream_features': %w", err)
		}
		delete(object, "experimental_data_stream_features")
	}

	if raw, found := object["install_format_schema_version"]; found {
		err = json.Unmarshal(raw, &a.InstallFormatSchemaVersion)
		if err != nil {
			return fmt.Errorf("error reading 'install_format_schema_version': %w", err)
		}
		delete(object, "install_format_schema_version")
	}

	if raw, found := object["install_source"]; found {
		err = json.Unmarshal(raw, &a.InstallSource)
		if err != nil {
			return fmt.Errorf("error reading 'install_source': %w", err)
		}
		delete(object, "install_source")
	}

	if raw, found := object["install_status"]; found {
		err = json.Unmarshal(raw, &a.InstallStatus)
		if err != nil {
			return fmt.Errorf("error reading 'install_status': %w", err)
		}
		delete(object, "install_status")
	}

	if raw, found := object["installed_es"]; found {
		err = json.Unmarshal(raw, &a.InstalledEs)
		if err != nil {
			return fmt.Errorf("error reading 'installed_es': %w", err)
		}
		delete(object, "installed_es")
	}

	if raw, found := object["installed_kibana"]; found {
		err = json.Unmarshal(raw, &a.InstalledKibana)
		if err != nil {
			return fmt.Errorf("error reading 'installed_kibana': %w", err)
		}
		delete(object, "installed_kibana")
	}

	if raw, found := object["installed_kibana_space_id"]; found {
		err = json.Unmarshal(raw, &a.InstalledKibanaSpaceId)
		if err != nil {
			return fmt.Errorf("error reading 'installed_kibana_space_id': %w", err)
		}
		delete(object, "installed_kibana_space_id")
	}

	if raw, found := object["latest_executed_state"]; found {
		err = json.Unmarshal(raw, &a.LatestExecutedState)
		if err != nil {
			return fmt.Errorf("error reading 'latest_executed_state': %w", err)
		}
		delete(object, "latest_executed_state")
	}

	if raw, found := object["latest_install_failed_attempts"]; found {
		err = json.Unmarshal(raw, &a.LatestInstallFailedAttempts)
		if err != nil {
			return fmt.Errorf("error reading 'latest_install_failed_attempts': %w", err)
		}
		delete(object, "latest_install_failed_attempts")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["namespaces"]; found {
		err = json.Unmarshal(raw, &a.Namespaces)
		if err != nil {
			return fmt.Errorf("error reading 'namespaces': %w", err)
		}
		delete(object, "namespaces")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["updated_at"]; found {
		err = json.Unmarshal(raw, &a.UpdatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'updated_at': %w", err)
		}
		delete(object, "updated_at")
	}

	if raw, found := object["verification_key_id"]; found {
		err = json.Unmarshal(raw, &a.VerificationKeyId)
		if err != nil {
			return fmt.Errorf("error reading 'verification_key_id': %w", err)
		}
		delete(object, "verification_key_id")
	}

	if raw, found := object["verification_status"]; found {
		err = json.Unmarshal(raw, &a.VerificationStatus)
		if err != nil {
			return fmt.Errorf("error reading 'verification_status': %w", err)
		}
		delete(object, "verification_status")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_InstallationInfo to handle AdditionalProperties
func (a PackageInfo_InstallationInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AdditionalSpacesInstalledKibana != nil {
		object["additional_spaces_installed_kibana"], err = json.Marshal(a.AdditionalSpacesInstalledKibana)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'additional_spaces_installed_kibana': %w", err)
		}
	}

	if a.CreatedAt != nil {
		object["created_at"], err = json.Marshal(a.CreatedAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'created_at': %w", err)
		}
	}

	if a.ExperimentalDataStreamFeatures != nil {
		object["experimental_data_stream_features"], err = json.Marshal(a.ExperimentalDataStreamFeatures)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'experimental_data_stream_features': %w", err)
		}
	}

	if a.InstallFormatSchemaVersion != nil {
		object["install_format_schema_version"], err = json.Marshal(a.InstallFormatSchemaVersion)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'install_format_schema_version': %w", err)
		}
	}

	object["install_source"], err = json.Marshal(a.InstallSource)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'install_source': %w", err)
	}

	object["install_status"], err = json.Marshal(a.InstallStatus)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'install_status': %w", err)
	}

	object["installed_es"], err = json.Marshal(a.InstalledEs)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'installed_es': %w", err)
	}

	object["installed_kibana"], err = json.Marshal(a.InstalledKibana)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'installed_kibana': %w", err)
	}

	if a.InstalledKibanaSpaceId != nil {
		object["installed_kibana_space_id"], err = json.Marshal(a.InstalledKibanaSpaceId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'installed_kibana_space_id': %w", err)
		}
	}

	if a.LatestExecutedState != nil {
		object["latest_executed_state"], err = json.Marshal(a.LatestExecutedState)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'latest_executed_state': %w", err)
		}
	}

	if a.LatestInstallFailedAttempts != nil {
		object["latest_install_failed_attempts"], err = json.Marshal(a.LatestInstallFailedAttempts)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'latest_install_failed_attempts': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Namespaces != nil {
		object["namespaces"], err = json.Marshal(a.Namespaces)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'namespaces': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	if a.UpdatedAt != nil {
		object["updated_at"], err = json.Marshal(a.UpdatedAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'updated_at': %w", err)
		}
	}

	if a.VerificationKeyId != nil {
		object["verification_key_id"], err = json.Marshal(a.VerificationKeyId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'verification_key_id': %w", err)
		}
	}

	object["verification_status"], err = json.Marshal(a.VerificationStatus)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'verification_status': %w", err)
	}

	object["version"], err = json.Marshal(a.Version)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'version': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_Owner. Returns the specified
// element and whether it was found
func (a PackageInfo_Owner) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_Owner
func (a *PackageInfo_Owner) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_Owner to handle AdditionalProperties
func (a *PackageInfo_Owner) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["github"]; found {
		err = json.Unmarshal(raw, &a.Github)
		if err != nil {
			return fmt.Errorf("error reading 'github': %w", err)
		}
		delete(object, "github")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_Owner to handle AdditionalProperties
func (a PackageInfo_Owner) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Github != nil {
		object["github"], err = json.Marshal(a.Github)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'github': %w", err)
		}
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageInfo_Source. Returns the specified
// element and whether it was found
func (a PackageInfo_Source) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageInfo_Source
func (a *PackageInfo_Source) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageInfo_Source to handle AdditionalProperties
func (a *PackageInfo_Source) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["license"]; found {
		err = json.Unmarshal(raw, &a.License)
		if err != nil {
			return fmt.Errorf("error reading 'license': %w", err)
		}
		delete(object, "license")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageInfo_Source to handle AdditionalProperties
func (a PackageInfo_Source) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["license"], err = json.Marshal(a.License)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'license': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem. Returns the specified
// element and whether it was found
func (a PackageListItem) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem
func (a *PackageListItem) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem to handle AdditionalProperties
func (a *PackageListItem) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["categories"]; found {
		err = json.Unmarshal(raw, &a.Categories)
		if err != nil {
			return fmt.Errorf("error reading 'categories': %w", err)
		}
		delete(object, "categories")
	}

	if raw, found := object["conditions"]; found {
		err = json.Unmarshal(raw, &a.Conditions)
		if err != nil {
			return fmt.Errorf("error reading 'conditions': %w", err)
		}
		delete(object, "conditions")
	}

	if raw, found := object["data_streams"]; found {
		err = json.Unmarshal(raw, &a.DataStreams)
		if err != nil {
			return fmt.Errorf("error reading 'data_streams': %w", err)
		}
		delete(object, "data_streams")
	}

	if raw, found := object["description"]; found {
		err = json.Unmarshal(raw, &a.Description)
		if err != nil {
			return fmt.Errorf("error reading 'description': %w", err)
		}
		delete(object, "description")
	}

	if raw, found := object["discovery"]; found {
		err = json.Unmarshal(raw, &a.Discovery)
		if err != nil {
			return fmt.Errorf("error reading 'discovery': %w", err)
		}
		delete(object, "discovery")
	}

	if raw, found := object["download"]; found {
		err = json.Unmarshal(raw, &a.Download)
		if err != nil {
			return fmt.Errorf("error reading 'download': %w", err)
		}
		delete(object, "download")
	}

	if raw, found := object["format_version"]; found {
		err = json.Unmarshal(raw, &a.FormatVersion)
		if err != nil {
			return fmt.Errorf("error reading 'format_version': %w", err)
		}
		delete(object, "format_version")
	}

	if raw, found := object["icons"]; found {
		err = json.Unmarshal(raw, &a.Icons)
		if err != nil {
			return fmt.Errorf("error reading 'icons': %w", err)
		}
		delete(object, "icons")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["installationInfo"]; found {
		err = json.Unmarshal(raw, &a.InstallationInfo)
		if err != nil {
			return fmt.Errorf("error reading 'installationInfo': %w", err)
		}
		delete(object, "installationInfo")
	}

	if raw, found := object["integration"]; found {
		err = json.Unmarshal(raw, &a.Integration)
		if err != nil {
			return fmt.Errorf("error reading 'integration': %w", err)
		}
		delete(object, "integration")
	}

	if raw, found := object["internal"]; found {
		err = json.Unmarshal(raw, &a.Internal)
		if err != nil {
			return fmt.Errorf("error reading 'internal': %w", err)
		}
		delete(object, "internal")
	}

	if raw, found := object["latestVersion"]; found {
		err = json.Unmarshal(raw, &a.LatestVersion)
		if err != nil {
			return fmt.Errorf("error reading 'latestVersion': %w", err)
		}
		delete(object, "latestVersion")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["owner"]; found {
		err = json.Unmarshal(raw, &a.Owner)
		if err != nil {
			return fmt.Errorf("error reading 'owner': %w", err)
		}
		delete(object, "owner")
	}

	if raw, found := object["path"]; found {
		err = json.Unmarshal(raw, &a.Path)
		if err != nil {
			return fmt.Errorf("error reading 'path': %w", err)
		}
		delete(object, "path")
	}

	if raw, found := object["policy_templates"]; found {
		err = json.Unmarshal(raw, &a.PolicyTemplates)
		if err != nil {
			return fmt.Errorf("error reading 'policy_templates': %w", err)
		}
		delete(object, "policy_templates")
	}

	if raw, found := object["readme"]; found {
		err = json.Unmarshal(raw, &a.Readme)
		if err != nil {
			return fmt.Errorf("error reading 'readme': %w", err)
		}
		delete(object, "readme")
	}

	if raw, found := object["release"]; found {
		err = json.Unmarshal(raw, &a.Release)
		if err != nil {
			return fmt.Errorf("error reading 'release': %w", err)
		}
		delete(object, "release")
	}

	if raw, found := object["signature_path"]; found {
		err = json.Unmarshal(raw, &a.SignaturePath)
		if err != nil {
			return fmt.Errorf("error reading 'signature_path': %w", err)
		}
		delete(object, "signature_path")
	}

	if raw, found := object["source"]; found {
		err = json.Unmarshal(raw, &a.Source)
		if err != nil {
			return fmt.Errorf("error reading 'source': %w", err)
		}
		delete(object, "source")
	}

	if raw, found := object["status"]; found {
		err = json.Unmarshal(raw, &a.Status)
		if err != nil {
			return fmt.Errorf("error reading 'status': %w", err)
		}
		delete(object, "status")
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
		delete(object, "title")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["vars"]; found {
		err = json.Unmarshal(raw, &a.Vars)
		if err != nil {
			return fmt.Errorf("error reading 'vars': %w", err)
		}
		delete(object, "vars")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem to handle AdditionalProperties
func (a PackageListItem) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Categories != nil {
		object["categories"], err = json.Marshal(a.Categories)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'categories': %w", err)
		}
	}

	if a.Conditions != nil {
		object["conditions"], err = json.Marshal(a.Conditions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'conditions': %w", err)
		}
	}

	if a.DataStreams != nil {
		object["data_streams"], err = json.Marshal(a.DataStreams)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'data_streams': %w", err)
		}
	}

	if a.Description != nil {
		object["description"], err = json.Marshal(a.Description)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'description': %w", err)
		}
	}

	if a.Discovery != nil {
		object["discovery"], err = json.Marshal(a.Discovery)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'discovery': %w", err)
		}
	}

	if a.Download != nil {
		object["download"], err = json.Marshal(a.Download)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'download': %w", err)
		}
	}

	if a.FormatVersion != nil {
		object["format_version"], err = json.Marshal(a.FormatVersion)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'format_version': %w", err)
		}
	}

	if a.Icons != nil {
		object["icons"], err = json.Marshal(a.Icons)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'icons': %w", err)
		}
	}

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if a.InstallationInfo != nil {
		object["installationInfo"], err = json.Marshal(a.InstallationInfo)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'installationInfo': %w", err)
		}
	}

	if a.Integration != nil {
		object["integration"], err = json.Marshal(a.Integration)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'integration': %w", err)
		}
	}

	if a.Internal != nil {
		object["internal"], err = json.Marshal(a.Internal)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'internal': %w", err)
		}
	}

	if a.LatestVersion != nil {
		object["latestVersion"], err = json.Marshal(a.LatestVersion)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'latestVersion': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Owner != nil {
		object["owner"], err = json.Marshal(a.Owner)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'owner': %w", err)
		}
	}

	if a.Path != nil {
		object["path"], err = json.Marshal(a.Path)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'path': %w", err)
		}
	}

	if a.PolicyTemplates != nil {
		object["policy_templates"], err = json.Marshal(a.PolicyTemplates)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'policy_templates': %w", err)
		}
	}

	if a.Readme != nil {
		object["readme"], err = json.Marshal(a.Readme)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'readme': %w", err)
		}
	}

	if a.Release != nil {
		object["release"], err = json.Marshal(a.Release)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'release': %w", err)
		}
	}

	if a.SignaturePath != nil {
		object["signature_path"], err = json.Marshal(a.SignaturePath)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'signature_path': %w", err)
		}
	}

	if a.Source != nil {
		object["source"], err = json.Marshal(a.Source)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'source': %w", err)
		}
	}

	if a.Status != nil {
		object["status"], err = json.Marshal(a.Status)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'status': %w", err)
		}
	}

	object["title"], err = json.Marshal(a.Title)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'title': %w", err)
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	if a.Vars != nil {
		object["vars"], err = json.Marshal(a.Vars)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'vars': %w", err)
		}
	}

	object["version"], err = json.Marshal(a.Version)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'version': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_Conditions_Elastic. Returns the specified
// element and whether it was found
func (a PackageListItem_Conditions_Elastic) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_Conditions_Elastic
func (a *PackageListItem_Conditions_Elastic) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_Conditions_Elastic to handle AdditionalProperties
func (a *PackageListItem_Conditions_Elastic) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["capabilities"]; found {
		err = json.Unmarshal(raw, &a.Capabilities)
		if err != nil {
			return fmt.Errorf("error reading 'capabilities': %w", err)
		}
		delete(object, "capabilities")
	}

	if raw, found := object["subscription"]; found {
		err = json.Unmarshal(raw, &a.Subscription)
		if err != nil {
			return fmt.Errorf("error reading 'subscription': %w", err)
		}
		delete(object, "subscription")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_Conditions_Elastic to handle AdditionalProperties
func (a PackageListItem_Conditions_Elastic) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Capabilities != nil {
		object["capabilities"], err = json.Marshal(a.Capabilities)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'capabilities': %w", err)
		}
	}

	if a.Subscription != nil {
		object["subscription"], err = json.Marshal(a.Subscription)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'subscription': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_Conditions_Kibana. Returns the specified
// element and whether it was found
func (a PackageListItem_Conditions_Kibana) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_Conditions_Kibana
func (a *PackageListItem_Conditions_Kibana) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_Conditions_Kibana to handle AdditionalProperties
func (a *PackageListItem_Conditions_Kibana) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_Conditions_Kibana to handle AdditionalProperties
func (a PackageListItem_Conditions_Kibana) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Version != nil {
		object["version"], err = json.Marshal(a.Version)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'version': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_Conditions. Returns the specified
// element and whether it was found
func (a PackageListItem_Conditions) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_Conditions
func (a *PackageListItem_Conditions) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_Conditions to handle AdditionalProperties
func (a *PackageListItem_Conditions) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["elastic"]; found {
		err = json.Unmarshal(raw, &a.Elastic)
		if err != nil {
			return fmt.Errorf("error reading 'elastic': %w", err)
		}
		delete(object, "elastic")
	}

	if raw, found := object["kibana"]; found {
		err = json.Unmarshal(raw, &a.Kibana)
		if err != nil {
			return fmt.Errorf("error reading 'kibana': %w", err)
		}
		delete(object, "kibana")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_Conditions to handle AdditionalProperties
func (a PackageListItem_Conditions) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Elastic != nil {
		object["elastic"], err = json.Marshal(a.Elastic)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'elastic': %w", err)
		}
	}

	if a.Kibana != nil {
		object["kibana"], err = json.Marshal(a.Kibana)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'kibana': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_Discovery_Fields_Item. Returns the specified
// element and whether it was found
func (a PackageListItem_Discovery_Fields_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_Discovery_Fields_Item
func (a *PackageListItem_Discovery_Fields_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_Discovery_Fields_Item to handle AdditionalProperties
func (a *PackageListItem_Discovery_Fields_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_Discovery_Fields_Item to handle AdditionalProperties
func (a PackageListItem_Discovery_Fields_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_Discovery. Returns the specified
// element and whether it was found
func (a PackageListItem_Discovery) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_Discovery
func (a *PackageListItem_Discovery) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_Discovery to handle AdditionalProperties
func (a *PackageListItem_Discovery) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["fields"]; found {
		err = json.Unmarshal(raw, &a.Fields)
		if err != nil {
			return fmt.Errorf("error reading 'fields': %w", err)
		}
		delete(object, "fields")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_Discovery to handle AdditionalProperties
func (a PackageListItem_Discovery) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Fields != nil {
		object["fields"], err = json.Marshal(a.Fields)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'fields': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_Icons_Item. Returns the specified
// element and whether it was found
func (a PackageListItem_Icons_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_Icons_Item
func (a *PackageListItem_Icons_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_Icons_Item to handle AdditionalProperties
func (a *PackageListItem_Icons_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["dark_mode"]; found {
		err = json.Unmarshal(raw, &a.DarkMode)
		if err != nil {
			return fmt.Errorf("error reading 'dark_mode': %w", err)
		}
		delete(object, "dark_mode")
	}

	if raw, found := object["path"]; found {
		err = json.Unmarshal(raw, &a.Path)
		if err != nil {
			return fmt.Errorf("error reading 'path': %w", err)
		}
		delete(object, "path")
	}

	if raw, found := object["size"]; found {
		err = json.Unmarshal(raw, &a.Size)
		if err != nil {
			return fmt.Errorf("error reading 'size': %w", err)
		}
		delete(object, "size")
	}

	if raw, found := object["src"]; found {
		err = json.Unmarshal(raw, &a.Src)
		if err != nil {
			return fmt.Errorf("error reading 'src': %w", err)
		}
		delete(object, "src")
	}

	if raw, found := object["title"]; found {
		err = json.Unmarshal(raw, &a.Title)
		if err != nil {
			return fmt.Errorf("error reading 'title': %w", err)
		}
		delete(object, "title")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_Icons_Item to handle AdditionalProperties
func (a PackageListItem_Icons_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.DarkMode != nil {
		object["dark_mode"], err = json.Marshal(a.DarkMode)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'dark_mode': %w", err)
		}
	}

	if a.Path != nil {
		object["path"], err = json.Marshal(a.Path)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'path': %w", err)
		}
	}

	if a.Size != nil {
		object["size"], err = json.Marshal(a.Size)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'size': %w", err)
		}
	}

	object["src"], err = json.Marshal(a.Src)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'src': %w", err)
	}

	if a.Title != nil {
		object["title"], err = json.Marshal(a.Title)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'title': %w", err)
		}
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item
func (a *PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["originId"]; found {
		err = json.Unmarshal(raw, &a.OriginId)
		if err != nil {
			return fmt.Errorf("error reading 'originId': %w", err)
		}
		delete(object, "originId")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item to handle AdditionalProperties
func (a PackageListItem_InstallationInfo_AdditionalSpacesInstalledKibana_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if a.OriginId != nil {
		object["originId"], err = json.Marshal(a.OriginId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'originId': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features
func (a *PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["doc_value_only_numeric"]; found {
		err = json.Unmarshal(raw, &a.DocValueOnlyNumeric)
		if err != nil {
			return fmt.Errorf("error reading 'doc_value_only_numeric': %w", err)
		}
		delete(object, "doc_value_only_numeric")
	}

	if raw, found := object["doc_value_only_other"]; found {
		err = json.Unmarshal(raw, &a.DocValueOnlyOther)
		if err != nil {
			return fmt.Errorf("error reading 'doc_value_only_other': %w", err)
		}
		delete(object, "doc_value_only_other")
	}

	if raw, found := object["synthetic_source"]; found {
		err = json.Unmarshal(raw, &a.SyntheticSource)
		if err != nil {
			return fmt.Errorf("error reading 'synthetic_source': %w", err)
		}
		delete(object, "synthetic_source")
	}

	if raw, found := object["tsdb"]; found {
		err = json.Unmarshal(raw, &a.Tsdb)
		if err != nil {
			return fmt.Errorf("error reading 'tsdb': %w", err)
		}
		delete(object, "tsdb")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features to handle AdditionalProperties
func (a PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Features) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.DocValueOnlyNumeric != nil {
		object["doc_value_only_numeric"], err = json.Marshal(a.DocValueOnlyNumeric)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'doc_value_only_numeric': %w", err)
		}
	}

	if a.DocValueOnlyOther != nil {
		object["doc_value_only_other"], err = json.Marshal(a.DocValueOnlyOther)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'doc_value_only_other': %w", err)
		}
	}

	if a.SyntheticSource != nil {
		object["synthetic_source"], err = json.Marshal(a.SyntheticSource)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'synthetic_source': %w", err)
		}
	}

	if a.Tsdb != nil {
		object["tsdb"], err = json.Marshal(a.Tsdb)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tsdb': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item
func (a *PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["data_stream"]; found {
		err = json.Unmarshal(raw, &a.DataStream)
		if err != nil {
			return fmt.Errorf("error reading 'data_stream': %w", err)
		}
		delete(object, "data_stream")
	}

	if raw, found := object["features"]; found {
		err = json.Unmarshal(raw, &a.Features)
		if err != nil {
			return fmt.Errorf("error reading 'features': %w", err)
		}
		delete(object, "features")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item to handle AdditionalProperties
func (a PackageListItem_InstallationInfo_ExperimentalDataStreamFeatures_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["data_stream"], err = json.Marshal(a.DataStream)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'data_stream': %w", err)
	}

	object["features"], err = json.Marshal(a.Features)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'features': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo_InstalledEs_Item. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo_InstalledEs_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo_InstalledEs_Item
func (a *PackageListItem_InstallationInfo_InstalledEs_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo_InstalledEs_Item to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo_InstalledEs_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["deferred"]; found {
		err = json.Unmarshal(raw, &a.Deferred)
		if err != nil {
			return fmt.Errorf("error reading 'deferred': %w", err)
		}
		delete(object, "deferred")
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo_InstalledEs_Item to handle AdditionalProperties
func (a PackageListItem_InstallationInfo_InstalledEs_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Deferred != nil {
		object["deferred"], err = json.Marshal(a.Deferred)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'deferred': %w", err)
		}
	}

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	if a.Version != nil {
		object["version"], err = json.Marshal(a.Version)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'version': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo_InstalledKibana_Item. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo_InstalledKibana_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo_InstalledKibana_Item
func (a *PackageListItem_InstallationInfo_InstalledKibana_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo_InstalledKibana_Item to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo_InstalledKibana_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["id"]; found {
		err = json.Unmarshal(raw, &a.Id)
		if err != nil {
			return fmt.Errorf("error reading 'id': %w", err)
		}
		delete(object, "id")
	}

	if raw, found := object["originId"]; found {
		err = json.Unmarshal(raw, &a.OriginId)
		if err != nil {
			return fmt.Errorf("error reading 'originId': %w", err)
		}
		delete(object, "originId")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo_InstalledKibana_Item to handle AdditionalProperties
func (a PackageListItem_InstallationInfo_InstalledKibana_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["id"], err = json.Marshal(a.Id)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'id': %w", err)
	}

	if a.OriginId != nil {
		object["originId"], err = json.Marshal(a.OriginId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'originId': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo_LatestExecutedState. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo_LatestExecutedState) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo_LatestExecutedState
func (a *PackageListItem_InstallationInfo_LatestExecutedState) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo_LatestExecutedState to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo_LatestExecutedState) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["error"]; found {
		err = json.Unmarshal(raw, &a.Error)
		if err != nil {
			return fmt.Errorf("error reading 'error': %w", err)
		}
		delete(object, "error")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["started_at"]; found {
		err = json.Unmarshal(raw, &a.StartedAt)
		if err != nil {
			return fmt.Errorf("error reading 'started_at': %w", err)
		}
		delete(object, "started_at")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo_LatestExecutedState to handle AdditionalProperties
func (a PackageListItem_InstallationInfo_LatestExecutedState) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Error != nil {
		object["error"], err = json.Marshal(a.Error)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'error': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	object["started_at"], err = json.Marshal(a.StartedAt)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'started_at': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error
func (a *PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["message"]; found {
		err = json.Unmarshal(raw, &a.Message)
		if err != nil {
			return fmt.Errorf("error reading 'message': %w", err)
		}
		delete(object, "message")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["stack"]; found {
		err = json.Unmarshal(raw, &a.Stack)
		if err != nil {
			return fmt.Errorf("error reading 'stack': %w", err)
		}
		delete(object, "stack")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error to handle AdditionalProperties
func (a PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Error) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["message"], err = json.Marshal(a.Message)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'message': %w", err)
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Stack != nil {
		object["stack"], err = json.Marshal(a.Stack)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'stack': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item
func (a *PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["created_at"]; found {
		err = json.Unmarshal(raw, &a.CreatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'created_at': %w", err)
		}
		delete(object, "created_at")
	}

	if raw, found := object["error"]; found {
		err = json.Unmarshal(raw, &a.Error)
		if err != nil {
			return fmt.Errorf("error reading 'error': %w", err)
		}
		delete(object, "error")
	}

	if raw, found := object["target_version"]; found {
		err = json.Unmarshal(raw, &a.TargetVersion)
		if err != nil {
			return fmt.Errorf("error reading 'target_version': %w", err)
		}
		delete(object, "target_version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item to handle AdditionalProperties
func (a PackageListItem_InstallationInfo_LatestInstallFailedAttempts_Item) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["created_at"], err = json.Marshal(a.CreatedAt)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'created_at': %w", err)
	}

	object["error"], err = json.Marshal(a.Error)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'error': %w", err)
	}

	object["target_version"], err = json.Marshal(a.TargetVersion)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'target_version': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_InstallationInfo. Returns the specified
// element and whether it was found
func (a PackageListItem_InstallationInfo) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_InstallationInfo
func (a *PackageListItem_InstallationInfo) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_InstallationInfo to handle AdditionalProperties
func (a *PackageListItem_InstallationInfo) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["additional_spaces_installed_kibana"]; found {
		err = json.Unmarshal(raw, &a.AdditionalSpacesInstalledKibana)
		if err != nil {
			return fmt.Errorf("error reading 'additional_spaces_installed_kibana': %w", err)
		}
		delete(object, "additional_spaces_installed_kibana")
	}

	if raw, found := object["created_at"]; found {
		err = json.Unmarshal(raw, &a.CreatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'created_at': %w", err)
		}
		delete(object, "created_at")
	}

	if raw, found := object["experimental_data_stream_features"]; found {
		err = json.Unmarshal(raw, &a.ExperimentalDataStreamFeatures)
		if err != nil {
			return fmt.Errorf("error reading 'experimental_data_stream_features': %w", err)
		}
		delete(object, "experimental_data_stream_features")
	}

	if raw, found := object["install_format_schema_version"]; found {
		err = json.Unmarshal(raw, &a.InstallFormatSchemaVersion)
		if err != nil {
			return fmt.Errorf("error reading 'install_format_schema_version': %w", err)
		}
		delete(object, "install_format_schema_version")
	}

	if raw, found := object["install_source"]; found {
		err = json.Unmarshal(raw, &a.InstallSource)
		if err != nil {
			return fmt.Errorf("error reading 'install_source': %w", err)
		}
		delete(object, "install_source")
	}

	if raw, found := object["install_status"]; found {
		err = json.Unmarshal(raw, &a.InstallStatus)
		if err != nil {
			return fmt.Errorf("error reading 'install_status': %w", err)
		}
		delete(object, "install_status")
	}

	if raw, found := object["installed_es"]; found {
		err = json.Unmarshal(raw, &a.InstalledEs)
		if err != nil {
			return fmt.Errorf("error reading 'installed_es': %w", err)
		}
		delete(object, "installed_es")
	}

	if raw, found := object["installed_kibana"]; found {
		err = json.Unmarshal(raw, &a.InstalledKibana)
		if err != nil {
			return fmt.Errorf("error reading 'installed_kibana': %w", err)
		}
		delete(object, "installed_kibana")
	}

	if raw, found := object["installed_kibana_space_id"]; found {
		err = json.Unmarshal(raw, &a.InstalledKibanaSpaceId)
		if err != nil {
			return fmt.Errorf("error reading 'installed_kibana_space_id': %w", err)
		}
		delete(object, "installed_kibana_space_id")
	}

	if raw, found := object["latest_executed_state"]; found {
		err = json.Unmarshal(raw, &a.LatestExecutedState)
		if err != nil {
			return fmt.Errorf("error reading 'latest_executed_state': %w", err)
		}
		delete(object, "latest_executed_state")
	}

	if raw, found := object["latest_install_failed_attempts"]; found {
		err = json.Unmarshal(raw, &a.LatestInstallFailedAttempts)
		if err != nil {
			return fmt.Errorf("error reading 'latest_install_failed_attempts': %w", err)
		}
		delete(object, "latest_install_failed_attempts")
	}

	if raw, found := object["name"]; found {
		err = json.Unmarshal(raw, &a.Name)
		if err != nil {
			return fmt.Errorf("error reading 'name': %w", err)
		}
		delete(object, "name")
	}

	if raw, found := object["namespaces"]; found {
		err = json.Unmarshal(raw, &a.Namespaces)
		if err != nil {
			return fmt.Errorf("error reading 'namespaces': %w", err)
		}
		delete(object, "namespaces")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if raw, found := object["updated_at"]; found {
		err = json.Unmarshal(raw, &a.UpdatedAt)
		if err != nil {
			return fmt.Errorf("error reading 'updated_at': %w", err)
		}
		delete(object, "updated_at")
	}

	if raw, found := object["verification_key_id"]; found {
		err = json.Unmarshal(raw, &a.VerificationKeyId)
		if err != nil {
			return fmt.Errorf("error reading 'verification_key_id': %w", err)
		}
		delete(object, "verification_key_id")
	}

	if raw, found := object["verification_status"]; found {
		err = json.Unmarshal(raw, &a.VerificationStatus)
		if err != nil {
			return fmt.Errorf("error reading 'verification_status': %w", err)
		}
		delete(object, "verification_status")
	}

	if raw, found := object["version"]; found {
		err = json.Unmarshal(raw, &a.Version)
		if err != nil {
			return fmt.Errorf("error reading 'version': %w", err)
		}
		delete(object, "version")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_InstallationInfo to handle AdditionalProperties
func (a PackageListItem_InstallationInfo) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.AdditionalSpacesInstalledKibana != nil {
		object["additional_spaces_installed_kibana"], err = json.Marshal(a.AdditionalSpacesInstalledKibana)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'additional_spaces_installed_kibana': %w", err)
		}
	}

	if a.CreatedAt != nil {
		object["created_at"], err = json.Marshal(a.CreatedAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'created_at': %w", err)
		}
	}

	if a.ExperimentalDataStreamFeatures != nil {
		object["experimental_data_stream_features"], err = json.Marshal(a.ExperimentalDataStreamFeatures)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'experimental_data_stream_features': %w", err)
		}
	}

	if a.InstallFormatSchemaVersion != nil {
		object["install_format_schema_version"], err = json.Marshal(a.InstallFormatSchemaVersion)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'install_format_schema_version': %w", err)
		}
	}

	object["install_source"], err = json.Marshal(a.InstallSource)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'install_source': %w", err)
	}

	object["install_status"], err = json.Marshal(a.InstallStatus)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'install_status': %w", err)
	}

	object["installed_es"], err = json.Marshal(a.InstalledEs)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'installed_es': %w", err)
	}

	object["installed_kibana"], err = json.Marshal(a.InstalledKibana)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'installed_kibana': %w", err)
	}

	if a.InstalledKibanaSpaceId != nil {
		object["installed_kibana_space_id"], err = json.Marshal(a.InstalledKibanaSpaceId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'installed_kibana_space_id': %w", err)
		}
	}

	if a.LatestExecutedState != nil {
		object["latest_executed_state"], err = json.Marshal(a.LatestExecutedState)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'latest_executed_state': %w", err)
		}
	}

	if a.LatestInstallFailedAttempts != nil {
		object["latest_install_failed_attempts"], err = json.Marshal(a.LatestInstallFailedAttempts)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'latest_install_failed_attempts': %w", err)
		}
	}

	object["name"], err = json.Marshal(a.Name)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'name': %w", err)
	}

	if a.Namespaces != nil {
		object["namespaces"], err = json.Marshal(a.Namespaces)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'namespaces': %w", err)
		}
	}

	object["type"], err = json.Marshal(a.Type)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'type': %w", err)
	}

	if a.UpdatedAt != nil {
		object["updated_at"], err = json.Marshal(a.UpdatedAt)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'updated_at': %w", err)
		}
	}

	if a.VerificationKeyId != nil {
		object["verification_key_id"], err = json.Marshal(a.VerificationKeyId)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'verification_key_id': %w", err)
		}
	}

	object["verification_status"], err = json.Marshal(a.VerificationStatus)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'verification_status': %w", err)
	}

	object["version"], err = json.Marshal(a.Version)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'version': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_Owner. Returns the specified
// element and whether it was found
func (a PackageListItem_Owner) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_Owner
func (a *PackageListItem_Owner) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_Owner to handle AdditionalProperties
func (a *PackageListItem_Owner) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["github"]; found {
		err = json.Unmarshal(raw, &a.Github)
		if err != nil {
			return fmt.Errorf("error reading 'github': %w", err)
		}
		delete(object, "github")
	}

	if raw, found := object["type"]; found {
		err = json.Unmarshal(raw, &a.Type)
		if err != nil {
			return fmt.Errorf("error reading 'type': %w", err)
		}
		delete(object, "type")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_Owner to handle AdditionalProperties
func (a PackageListItem_Owner) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Github != nil {
		object["github"], err = json.Marshal(a.Github)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'github': %w", err)
		}
	}

	if a.Type != nil {
		object["type"], err = json.Marshal(a.Type)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'type': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackageListItem_Source. Returns the specified
// element and whether it was found
func (a PackageListItem_Source) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackageListItem_Source
func (a *PackageListItem_Source) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackageListItem_Source to handle AdditionalProperties
func (a *PackageListItem_Source) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["license"]; found {
		err = json.Unmarshal(raw, &a.License)
		if err != nil {
			return fmt.Errorf("error reading 'license': %w", err)
		}
		delete(object, "license")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackageListItem_Source to handle AdditionalProperties
func (a PackageListItem_Source) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	object["license"], err = json.Marshal(a.License)
	if err != nil {
		return nil, fmt.Errorf("error marshaling 'license': %w", err)
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackagePolicy_Elasticsearch_Privileges. Returns the specified
// element and whether it was found
func (a PackagePolicy_Elasticsearch_Privileges) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackagePolicy_Elasticsearch_Privileges
func (a *PackagePolicy_Elasticsearch_Privileges) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackagePolicy_Elasticsearch_Privileges to handle AdditionalProperties
func (a *PackagePolicy_Elasticsearch_Privileges) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["cluster"]; found {
		err = json.Unmarshal(raw, &a.Cluster)
		if err != nil {
			return fmt.Errorf("error reading 'cluster': %w", err)
		}
		delete(object, "cluster")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackagePolicy_Elasticsearch_Privileges to handle AdditionalProperties
func (a PackagePolicy_Elasticsearch_Privileges) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Cluster != nil {
		object["cluster"], err = json.Marshal(a.Cluster)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'cluster': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for PackagePolicy_Elasticsearch. Returns the specified
// element and whether it was found
func (a PackagePolicy_Elasticsearch) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for PackagePolicy_Elasticsearch
func (a *PackagePolicy_Elasticsearch) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for PackagePolicy_Elasticsearch to handle AdditionalProperties
func (a *PackagePolicy_Elasticsearch) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["privileges"]; found {
		err = json.Unmarshal(raw, &a.Privileges)
		if err != nil {
			return fmt.Errorf("error reading 'privileges': %w", err)
		}
		delete(object, "privileges")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for PackagePolicy_Elasticsearch to handle AdditionalProperties
func (a PackagePolicy_Elasticsearch) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Privileges != nil {
		object["privileges"], err = json.Marshal(a.Privileges)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'privileges': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsAgentPolicyPackagePolicies0 returns the union data inside the AgentPolicy_PackagePolicies as a AgentPolicyPackagePolicies0
func (t AgentPolicy_PackagePolicies) AsAgentPolicyPackagePolicies0() (AgentPolicyPackagePolicies0, error) {
	var body AgentPolicyPackagePolicies0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies0 overwrites any union data inside the AgentPolicy_PackagePolicies as the provided AgentPolicyPackagePolicies0
func (t *AgentPolicy_PackagePolicies) FromAgentPolicyPackagePolicies0(v AgentPolicyPackagePolicies0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies0 performs a merge with any union data inside the AgentPolicy_PackagePolicies, using the provided AgentPolicyPackagePolicies0
func (t *AgentPolicy_PackagePolicies) MergeAgentPolicyPackagePolicies0(v AgentPolicyPackagePolicies0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyPackagePolicies1 returns the union data inside the AgentPolicy_PackagePolicies as a AgentPolicyPackagePolicies1
func (t AgentPolicy_PackagePolicies) AsAgentPolicyPackagePolicies1() (AgentPolicyPackagePolicies1, error) {
	var body AgentPolicyPackagePolicies1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyPackagePolicies1 overwrites any union data inside the AgentPolicy_PackagePolicies as the provided AgentPolicyPackagePolicies1
func (t *AgentPolicy_PackagePolicies) FromAgentPolicyPackagePolicies1(v AgentPolicyPackagePolicies1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyPackagePolicies1 performs a merge with any union data inside the AgentPolicy_PackagePolicies, using the provided AgentPolicyPackagePolicies1
func (t *AgentPolicy_PackagePolicies) MergeAgentPolicyPackagePolicies1(v AgentPolicyPackagePolicies1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AgentPolicy_PackagePolicies) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AgentPolicy_PackagePolicies) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAgentPolicyGlobalDataTagsItemValue0 returns the union data inside the AgentPolicyGlobalDataTagsItem_Value as a AgentPolicyGlobalDataTagsItemValue0
func (t AgentPolicyGlobalDataTagsItem_Value) AsAgentPolicyGlobalDataTagsItemValue0() (AgentPolicyGlobalDataTagsItemValue0, error) {
	var body AgentPolicyGlobalDataTagsItemValue0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyGlobalDataTagsItemValue0 overwrites any union data inside the AgentPolicyGlobalDataTagsItem_Value as the provided AgentPolicyGlobalDataTagsItemValue0
func (t *AgentPolicyGlobalDataTagsItem_Value) FromAgentPolicyGlobalDataTagsItemValue0(v AgentPolicyGlobalDataTagsItemValue0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyGlobalDataTagsItemValue0 performs a merge with any union data inside the AgentPolicyGlobalDataTagsItem_Value, using the provided AgentPolicyGlobalDataTagsItemValue0
func (t *AgentPolicyGlobalDataTagsItem_Value) MergeAgentPolicyGlobalDataTagsItemValue0(v AgentPolicyGlobalDataTagsItemValue0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAgentPolicyGlobalDataTagsItemValue1 returns the union data inside the AgentPolicyGlobalDataTagsItem_Value as a AgentPolicyGlobalDataTagsItemValue1
func (t AgentPolicyGlobalDataTagsItem_Value) AsAgentPolicyGlobalDataTagsItemValue1() (AgentPolicyGlobalDataTagsItemValue1, error) {
	var body AgentPolicyGlobalDataTagsItemValue1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAgentPolicyGlobalDataTagsItemValue1 overwrites any union data inside the AgentPolicyGlobalDataTagsItem_Value as the provided AgentPolicyGlobalDataTagsItemValue1
func (t *AgentPolicyGlobalDataTagsItem_Value) FromAgentPolicyGlobalDataTagsItemValue1(v AgentPolicyGlobalDataTagsItemValue1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAgentPolicyGlobalDataTagsItemValue1 performs a merge with any union data inside the AgentPolicyGlobalDataTagsItem_Value, using the provided AgentPolicyGlobalDataTagsItemValue1
func (t *AgentPolicyGlobalDataTagsItem_Value) MergeAgentPolicyGlobalDataTagsItemValue1(v AgentPolicyGlobalDataTagsItemValue1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t AgentPolicyGlobalDataTagsItem_Value) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *AgentPolicyGlobalDataTagsItem_Value) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNewOutputKafkaSecretsPassword0 returns the union data inside the NewOutputKafka_Secrets_Password as a NewOutputKafkaSecretsPassword0
func (t NewOutputKafka_Secrets_Password) AsNewOutputKafkaSecretsPassword0() (NewOutputKafkaSecretsPassword0, error) {
	var body NewOutputKafkaSecretsPassword0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputKafkaSecretsPassword0 overwrites any union data inside the NewOutputKafka_Secrets_Password as the provided NewOutputKafkaSecretsPassword0
func (t *NewOutputKafka_Secrets_Password) FromNewOutputKafkaSecretsPassword0(v NewOutputKafkaSecretsPassword0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputKafkaSecretsPassword0 performs a merge with any union data inside the NewOutputKafka_Secrets_Password, using the provided NewOutputKafkaSecretsPassword0
func (t *NewOutputKafka_Secrets_Password) MergeNewOutputKafkaSecretsPassword0(v NewOutputKafkaSecretsPassword0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNewOutputKafkaSecretsPassword1 returns the union data inside the NewOutputKafka_Secrets_Password as a NewOutputKafkaSecretsPassword1
func (t NewOutputKafka_Secrets_Password) AsNewOutputKafkaSecretsPassword1() (NewOutputKafkaSecretsPassword1, error) {
	var body NewOutputKafkaSecretsPassword1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputKafkaSecretsPassword1 overwrites any union data inside the NewOutputKafka_Secrets_Password as the provided NewOutputKafkaSecretsPassword1
func (t *NewOutputKafka_Secrets_Password) FromNewOutputKafkaSecretsPassword1(v NewOutputKafkaSecretsPassword1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputKafkaSecretsPassword1 performs a merge with any union data inside the NewOutputKafka_Secrets_Password, using the provided NewOutputKafkaSecretsPassword1
func (t *NewOutputKafka_Secrets_Password) MergeNewOutputKafkaSecretsPassword1(v NewOutputKafkaSecretsPassword1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NewOutputKafka_Secrets_Password) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NewOutputKafka_Secrets_Password) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNewOutputKafkaSecretsSslKey0 returns the union data inside the NewOutputKafka_Secrets_Ssl_Key as a NewOutputKafkaSecretsSslKey0
func (t NewOutputKafka_Secrets_Ssl_Key) AsNewOutputKafkaSecretsSslKey0() (NewOutputKafkaSecretsSslKey0, error) {
	var body NewOutputKafkaSecretsSslKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputKafkaSecretsSslKey0 overwrites any union data inside the NewOutputKafka_Secrets_Ssl_Key as the provided NewOutputKafkaSecretsSslKey0
func (t *NewOutputKafka_Secrets_Ssl_Key) FromNewOutputKafkaSecretsSslKey0(v NewOutputKafkaSecretsSslKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputKafkaSecretsSslKey0 performs a merge with any union data inside the NewOutputKafka_Secrets_Ssl_Key, using the provided NewOutputKafkaSecretsSslKey0
func (t *NewOutputKafka_Secrets_Ssl_Key) MergeNewOutputKafkaSecretsSslKey0(v NewOutputKafkaSecretsSslKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNewOutputKafkaSecretsSslKey1 returns the union data inside the NewOutputKafka_Secrets_Ssl_Key as a NewOutputKafkaSecretsSslKey1
func (t NewOutputKafka_Secrets_Ssl_Key) AsNewOutputKafkaSecretsSslKey1() (NewOutputKafkaSecretsSslKey1, error) {
	var body NewOutputKafkaSecretsSslKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputKafkaSecretsSslKey1 overwrites any union data inside the NewOutputKafka_Secrets_Ssl_Key as the provided NewOutputKafkaSecretsSslKey1
func (t *NewOutputKafka_Secrets_Ssl_Key) FromNewOutputKafkaSecretsSslKey1(v NewOutputKafkaSecretsSslKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputKafkaSecretsSslKey1 performs a merge with any union data inside the NewOutputKafka_Secrets_Ssl_Key, using the provided NewOutputKafkaSecretsSslKey1
func (t *NewOutputKafka_Secrets_Ssl_Key) MergeNewOutputKafkaSecretsSslKey1(v NewOutputKafkaSecretsSslKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NewOutputKafka_Secrets_Ssl_Key) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NewOutputKafka_Secrets_Ssl_Key) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNewOutputLogstashSecretsSslKey0 returns the union data inside the NewOutputLogstash_Secrets_Ssl_Key as a NewOutputLogstashSecretsSslKey0
func (t NewOutputLogstash_Secrets_Ssl_Key) AsNewOutputLogstashSecretsSslKey0() (NewOutputLogstashSecretsSslKey0, error) {
	var body NewOutputLogstashSecretsSslKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputLogstashSecretsSslKey0 overwrites any union data inside the NewOutputLogstash_Secrets_Ssl_Key as the provided NewOutputLogstashSecretsSslKey0
func (t *NewOutputLogstash_Secrets_Ssl_Key) FromNewOutputLogstashSecretsSslKey0(v NewOutputLogstashSecretsSslKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputLogstashSecretsSslKey0 performs a merge with any union data inside the NewOutputLogstash_Secrets_Ssl_Key, using the provided NewOutputLogstashSecretsSslKey0
func (t *NewOutputLogstash_Secrets_Ssl_Key) MergeNewOutputLogstashSecretsSslKey0(v NewOutputLogstashSecretsSslKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNewOutputLogstashSecretsSslKey1 returns the union data inside the NewOutputLogstash_Secrets_Ssl_Key as a NewOutputLogstashSecretsSslKey1
func (t NewOutputLogstash_Secrets_Ssl_Key) AsNewOutputLogstashSecretsSslKey1() (NewOutputLogstashSecretsSslKey1, error) {
	var body NewOutputLogstashSecretsSslKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputLogstashSecretsSslKey1 overwrites any union data inside the NewOutputLogstash_Secrets_Ssl_Key as the provided NewOutputLogstashSecretsSslKey1
func (t *NewOutputLogstash_Secrets_Ssl_Key) FromNewOutputLogstashSecretsSslKey1(v NewOutputLogstashSecretsSslKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputLogstashSecretsSslKey1 performs a merge with any union data inside the NewOutputLogstash_Secrets_Ssl_Key, using the provided NewOutputLogstashSecretsSslKey1
func (t *NewOutputLogstash_Secrets_Ssl_Key) MergeNewOutputLogstashSecretsSslKey1(v NewOutputLogstashSecretsSslKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NewOutputLogstash_Secrets_Ssl_Key) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NewOutputLogstash_Secrets_Ssl_Key) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNewOutputRemoteElasticsearchSecretsServiceToken0 returns the union data inside the NewOutputRemoteElasticsearch_Secrets_ServiceToken as a NewOutputRemoteElasticsearchSecretsServiceToken0
func (t NewOutputRemoteElasticsearch_Secrets_ServiceToken) AsNewOutputRemoteElasticsearchSecretsServiceToken0() (NewOutputRemoteElasticsearchSecretsServiceToken0, error) {
	var body NewOutputRemoteElasticsearchSecretsServiceToken0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputRemoteElasticsearchSecretsServiceToken0 overwrites any union data inside the NewOutputRemoteElasticsearch_Secrets_ServiceToken as the provided NewOutputRemoteElasticsearchSecretsServiceToken0
func (t *NewOutputRemoteElasticsearch_Secrets_ServiceToken) FromNewOutputRemoteElasticsearchSecretsServiceToken0(v NewOutputRemoteElasticsearchSecretsServiceToken0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputRemoteElasticsearchSecretsServiceToken0 performs a merge with any union data inside the NewOutputRemoteElasticsearch_Secrets_ServiceToken, using the provided NewOutputRemoteElasticsearchSecretsServiceToken0
func (t *NewOutputRemoteElasticsearch_Secrets_ServiceToken) MergeNewOutputRemoteElasticsearchSecretsServiceToken0(v NewOutputRemoteElasticsearchSecretsServiceToken0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNewOutputRemoteElasticsearchSecretsServiceToken1 returns the union data inside the NewOutputRemoteElasticsearch_Secrets_ServiceToken as a NewOutputRemoteElasticsearchSecretsServiceToken1
func (t NewOutputRemoteElasticsearch_Secrets_ServiceToken) AsNewOutputRemoteElasticsearchSecretsServiceToken1() (NewOutputRemoteElasticsearchSecretsServiceToken1, error) {
	var body NewOutputRemoteElasticsearchSecretsServiceToken1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputRemoteElasticsearchSecretsServiceToken1 overwrites any union data inside the NewOutputRemoteElasticsearch_Secrets_ServiceToken as the provided NewOutputRemoteElasticsearchSecretsServiceToken1
func (t *NewOutputRemoteElasticsearch_Secrets_ServiceToken) FromNewOutputRemoteElasticsearchSecretsServiceToken1(v NewOutputRemoteElasticsearchSecretsServiceToken1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputRemoteElasticsearchSecretsServiceToken1 performs a merge with any union data inside the NewOutputRemoteElasticsearch_Secrets_ServiceToken, using the provided NewOutputRemoteElasticsearchSecretsServiceToken1
func (t *NewOutputRemoteElasticsearch_Secrets_ServiceToken) MergeNewOutputRemoteElasticsearchSecretsServiceToken1(v NewOutputRemoteElasticsearchSecretsServiceToken1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NewOutputRemoteElasticsearch_Secrets_ServiceToken) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NewOutputRemoteElasticsearch_Secrets_ServiceToken) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsNewOutputElasticsearch returns the union data inside the NewOutputUnion as a NewOutputElasticsearch
func (t NewOutputUnion) AsNewOutputElasticsearch() (NewOutputElasticsearch, error) {
	var body NewOutputElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputElasticsearch overwrites any union data inside the NewOutputUnion as the provided NewOutputElasticsearch
func (t *NewOutputUnion) FromNewOutputElasticsearch(v NewOutputElasticsearch) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputElasticsearch performs a merge with any union data inside the NewOutputUnion, using the provided NewOutputElasticsearch
func (t *NewOutputUnion) MergeNewOutputElasticsearch(v NewOutputElasticsearch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNewOutputRemoteElasticsearch returns the union data inside the NewOutputUnion as a NewOutputRemoteElasticsearch
func (t NewOutputUnion) AsNewOutputRemoteElasticsearch() (NewOutputRemoteElasticsearch, error) {
	var body NewOutputRemoteElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputRemoteElasticsearch overwrites any union data inside the NewOutputUnion as the provided NewOutputRemoteElasticsearch
func (t *NewOutputUnion) FromNewOutputRemoteElasticsearch(v NewOutputRemoteElasticsearch) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputRemoteElasticsearch performs a merge with any union data inside the NewOutputUnion, using the provided NewOutputRemoteElasticsearch
func (t *NewOutputUnion) MergeNewOutputRemoteElasticsearch(v NewOutputRemoteElasticsearch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNewOutputLogstash returns the union data inside the NewOutputUnion as a NewOutputLogstash
func (t NewOutputUnion) AsNewOutputLogstash() (NewOutputLogstash, error) {
	var body NewOutputLogstash
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputLogstash overwrites any union data inside the NewOutputUnion as the provided NewOutputLogstash
func (t *NewOutputUnion) FromNewOutputLogstash(v NewOutputLogstash) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputLogstash performs a merge with any union data inside the NewOutputUnion, using the provided NewOutputLogstash
func (t *NewOutputUnion) MergeNewOutputLogstash(v NewOutputLogstash) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsNewOutputKafka returns the union data inside the NewOutputUnion as a NewOutputKafka
func (t NewOutputUnion) AsNewOutputKafka() (NewOutputKafka, error) {
	var body NewOutputKafka
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromNewOutputKafka overwrites any union data inside the NewOutputUnion as the provided NewOutputKafka
func (t *NewOutputUnion) FromNewOutputKafka(v NewOutputKafka) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeNewOutputKafka performs a merge with any union data inside the NewOutputUnion, using the provided NewOutputKafka
func (t *NewOutputUnion) MergeNewOutputKafka(v NewOutputKafka) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t NewOutputUnion) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *NewOutputUnion) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOutputKafkaSecretsPassword0 returns the union data inside the OutputKafka_Secrets_Password as a OutputKafkaSecretsPassword0
func (t OutputKafka_Secrets_Password) AsOutputKafkaSecretsPassword0() (OutputKafkaSecretsPassword0, error) {
	var body OutputKafkaSecretsPassword0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputKafkaSecretsPassword0 overwrites any union data inside the OutputKafka_Secrets_Password as the provided OutputKafkaSecretsPassword0
func (t *OutputKafka_Secrets_Password) FromOutputKafkaSecretsPassword0(v OutputKafkaSecretsPassword0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputKafkaSecretsPassword0 performs a merge with any union data inside the OutputKafka_Secrets_Password, using the provided OutputKafkaSecretsPassword0
func (t *OutputKafka_Secrets_Password) MergeOutputKafkaSecretsPassword0(v OutputKafkaSecretsPassword0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputKafkaSecretsPassword1 returns the union data inside the OutputKafka_Secrets_Password as a OutputKafkaSecretsPassword1
func (t OutputKafka_Secrets_Password) AsOutputKafkaSecretsPassword1() (OutputKafkaSecretsPassword1, error) {
	var body OutputKafkaSecretsPassword1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputKafkaSecretsPassword1 overwrites any union data inside the OutputKafka_Secrets_Password as the provided OutputKafkaSecretsPassword1
func (t *OutputKafka_Secrets_Password) FromOutputKafkaSecretsPassword1(v OutputKafkaSecretsPassword1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputKafkaSecretsPassword1 performs a merge with any union data inside the OutputKafka_Secrets_Password, using the provided OutputKafkaSecretsPassword1
func (t *OutputKafka_Secrets_Password) MergeOutputKafkaSecretsPassword1(v OutputKafkaSecretsPassword1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OutputKafka_Secrets_Password) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OutputKafka_Secrets_Password) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOutputKafkaSecretsSslKey0 returns the union data inside the OutputKafka_Secrets_Ssl_Key as a OutputKafkaSecretsSslKey0
func (t OutputKafka_Secrets_Ssl_Key) AsOutputKafkaSecretsSslKey0() (OutputKafkaSecretsSslKey0, error) {
	var body OutputKafkaSecretsSslKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputKafkaSecretsSslKey0 overwrites any union data inside the OutputKafka_Secrets_Ssl_Key as the provided OutputKafkaSecretsSslKey0
func (t *OutputKafka_Secrets_Ssl_Key) FromOutputKafkaSecretsSslKey0(v OutputKafkaSecretsSslKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputKafkaSecretsSslKey0 performs a merge with any union data inside the OutputKafka_Secrets_Ssl_Key, using the provided OutputKafkaSecretsSslKey0
func (t *OutputKafka_Secrets_Ssl_Key) MergeOutputKafkaSecretsSslKey0(v OutputKafkaSecretsSslKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputKafkaSecretsSslKey1 returns the union data inside the OutputKafka_Secrets_Ssl_Key as a OutputKafkaSecretsSslKey1
func (t OutputKafka_Secrets_Ssl_Key) AsOutputKafkaSecretsSslKey1() (OutputKafkaSecretsSslKey1, error) {
	var body OutputKafkaSecretsSslKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputKafkaSecretsSslKey1 overwrites any union data inside the OutputKafka_Secrets_Ssl_Key as the provided OutputKafkaSecretsSslKey1
func (t *OutputKafka_Secrets_Ssl_Key) FromOutputKafkaSecretsSslKey1(v OutputKafkaSecretsSslKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputKafkaSecretsSslKey1 performs a merge with any union data inside the OutputKafka_Secrets_Ssl_Key, using the provided OutputKafkaSecretsSslKey1
func (t *OutputKafka_Secrets_Ssl_Key) MergeOutputKafkaSecretsSslKey1(v OutputKafkaSecretsSslKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OutputKafka_Secrets_Ssl_Key) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OutputKafka_Secrets_Ssl_Key) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOutputLogstashSecretsSslKey0 returns the union data inside the OutputLogstash_Secrets_Ssl_Key as a OutputLogstashSecretsSslKey0
func (t OutputLogstash_Secrets_Ssl_Key) AsOutputLogstashSecretsSslKey0() (OutputLogstashSecretsSslKey0, error) {
	var body OutputLogstashSecretsSslKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputLogstashSecretsSslKey0 overwrites any union data inside the OutputLogstash_Secrets_Ssl_Key as the provided OutputLogstashSecretsSslKey0
func (t *OutputLogstash_Secrets_Ssl_Key) FromOutputLogstashSecretsSslKey0(v OutputLogstashSecretsSslKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputLogstashSecretsSslKey0 performs a merge with any union data inside the OutputLogstash_Secrets_Ssl_Key, using the provided OutputLogstashSecretsSslKey0
func (t *OutputLogstash_Secrets_Ssl_Key) MergeOutputLogstashSecretsSslKey0(v OutputLogstashSecretsSslKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputLogstashSecretsSslKey1 returns the union data inside the OutputLogstash_Secrets_Ssl_Key as a OutputLogstashSecretsSslKey1
func (t OutputLogstash_Secrets_Ssl_Key) AsOutputLogstashSecretsSslKey1() (OutputLogstashSecretsSslKey1, error) {
	var body OutputLogstashSecretsSslKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputLogstashSecretsSslKey1 overwrites any union data inside the OutputLogstash_Secrets_Ssl_Key as the provided OutputLogstashSecretsSslKey1
func (t *OutputLogstash_Secrets_Ssl_Key) FromOutputLogstashSecretsSslKey1(v OutputLogstashSecretsSslKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputLogstashSecretsSslKey1 performs a merge with any union data inside the OutputLogstash_Secrets_Ssl_Key, using the provided OutputLogstashSecretsSslKey1
func (t *OutputLogstash_Secrets_Ssl_Key) MergeOutputLogstashSecretsSslKey1(v OutputLogstashSecretsSslKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OutputLogstash_Secrets_Ssl_Key) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OutputLogstash_Secrets_Ssl_Key) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOutputRemoteElasticsearchSecretsServiceToken0 returns the union data inside the OutputRemoteElasticsearch_Secrets_ServiceToken as a OutputRemoteElasticsearchSecretsServiceToken0
func (t OutputRemoteElasticsearch_Secrets_ServiceToken) AsOutputRemoteElasticsearchSecretsServiceToken0() (OutputRemoteElasticsearchSecretsServiceToken0, error) {
	var body OutputRemoteElasticsearchSecretsServiceToken0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputRemoteElasticsearchSecretsServiceToken0 overwrites any union data inside the OutputRemoteElasticsearch_Secrets_ServiceToken as the provided OutputRemoteElasticsearchSecretsServiceToken0
func (t *OutputRemoteElasticsearch_Secrets_ServiceToken) FromOutputRemoteElasticsearchSecretsServiceToken0(v OutputRemoteElasticsearchSecretsServiceToken0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputRemoteElasticsearchSecretsServiceToken0 performs a merge with any union data inside the OutputRemoteElasticsearch_Secrets_ServiceToken, using the provided OutputRemoteElasticsearchSecretsServiceToken0
func (t *OutputRemoteElasticsearch_Secrets_ServiceToken) MergeOutputRemoteElasticsearchSecretsServiceToken0(v OutputRemoteElasticsearchSecretsServiceToken0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputRemoteElasticsearchSecretsServiceToken1 returns the union data inside the OutputRemoteElasticsearch_Secrets_ServiceToken as a OutputRemoteElasticsearchSecretsServiceToken1
func (t OutputRemoteElasticsearch_Secrets_ServiceToken) AsOutputRemoteElasticsearchSecretsServiceToken1() (OutputRemoteElasticsearchSecretsServiceToken1, error) {
	var body OutputRemoteElasticsearchSecretsServiceToken1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputRemoteElasticsearchSecretsServiceToken1 overwrites any union data inside the OutputRemoteElasticsearch_Secrets_ServiceToken as the provided OutputRemoteElasticsearchSecretsServiceToken1
func (t *OutputRemoteElasticsearch_Secrets_ServiceToken) FromOutputRemoteElasticsearchSecretsServiceToken1(v OutputRemoteElasticsearchSecretsServiceToken1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputRemoteElasticsearchSecretsServiceToken1 performs a merge with any union data inside the OutputRemoteElasticsearch_Secrets_ServiceToken, using the provided OutputRemoteElasticsearchSecretsServiceToken1
func (t *OutputRemoteElasticsearch_Secrets_ServiceToken) MergeOutputRemoteElasticsearchSecretsServiceToken1(v OutputRemoteElasticsearchSecretsServiceToken1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OutputRemoteElasticsearch_Secrets_ServiceToken) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OutputRemoteElasticsearch_Secrets_ServiceToken) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsOutputElasticsearch returns the union data inside the OutputUnion as a OutputElasticsearch
func (t OutputUnion) AsOutputElasticsearch() (OutputElasticsearch, error) {
	var body OutputElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputElasticsearch overwrites any union data inside the OutputUnion as the provided OutputElasticsearch
func (t *OutputUnion) FromOutputElasticsearch(v OutputElasticsearch) error {
	v.Type = "elasticsearch"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputElasticsearch performs a merge with any union data inside the OutputUnion, using the provided OutputElasticsearch
func (t *OutputUnion) MergeOutputElasticsearch(v OutputElasticsearch) error {
	v.Type = "elasticsearch"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputRemoteElasticsearch returns the union data inside the OutputUnion as a OutputRemoteElasticsearch
func (t OutputUnion) AsOutputRemoteElasticsearch() (OutputRemoteElasticsearch, error) {
	var body OutputRemoteElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputRemoteElasticsearch overwrites any union data inside the OutputUnion as the provided OutputRemoteElasticsearch
func (t *OutputUnion) FromOutputRemoteElasticsearch(v OutputRemoteElasticsearch) error {
	v.Type = "remote_elasticsearch"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputRemoteElasticsearch performs a merge with any union data inside the OutputUnion, using the provided OutputRemoteElasticsearch
func (t *OutputUnion) MergeOutputRemoteElasticsearch(v OutputRemoteElasticsearch) error {
	v.Type = "remote_elasticsearch"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputLogstash returns the union data inside the OutputUnion as a OutputLogstash
func (t OutputUnion) AsOutputLogstash() (OutputLogstash, error) {
	var body OutputLogstash
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputLogstash overwrites any union data inside the OutputUnion as the provided OutputLogstash
func (t *OutputUnion) FromOutputLogstash(v OutputLogstash) error {
	v.Type = "logstash"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputLogstash performs a merge with any union data inside the OutputUnion, using the provided OutputLogstash
func (t *OutputUnion) MergeOutputLogstash(v OutputLogstash) error {
	v.Type = "logstash"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsOutputKafka returns the union data inside the OutputUnion as a OutputKafka
func (t OutputUnion) AsOutputKafka() (OutputKafka, error) {
	var body OutputKafka
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromOutputKafka overwrites any union data inside the OutputUnion as the provided OutputKafka
func (t *OutputUnion) FromOutputKafka(v OutputKafka) error {
	v.Type = "kafka"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeOutputKafka performs a merge with any union data inside the OutputUnion, using the provided OutputKafka
func (t *OutputUnion) MergeOutputKafka(v OutputKafka) error {
	v.Type = "kafka"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t OutputUnion) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t OutputUnion) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "elasticsearch":
		return t.AsOutputElasticsearch()
	case "kafka":
		return t.AsOutputKafka()
	case "logstash":
		return t.AsOutputLogstash()
	case "remote_elasticsearch":
		return t.AsOutputRemoteElasticsearch()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t OutputUnion) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *OutputUnion) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateOutputKafkaSecretsPassword0 returns the union data inside the UpdateOutputKafka_Secrets_Password as a UpdateOutputKafkaSecretsPassword0
func (t UpdateOutputKafka_Secrets_Password) AsUpdateOutputKafkaSecretsPassword0() (UpdateOutputKafkaSecretsPassword0, error) {
	var body UpdateOutputKafkaSecretsPassword0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputKafkaSecretsPassword0 overwrites any union data inside the UpdateOutputKafka_Secrets_Password as the provided UpdateOutputKafkaSecretsPassword0
func (t *UpdateOutputKafka_Secrets_Password) FromUpdateOutputKafkaSecretsPassword0(v UpdateOutputKafkaSecretsPassword0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputKafkaSecretsPassword0 performs a merge with any union data inside the UpdateOutputKafka_Secrets_Password, using the provided UpdateOutputKafkaSecretsPassword0
func (t *UpdateOutputKafka_Secrets_Password) MergeUpdateOutputKafkaSecretsPassword0(v UpdateOutputKafkaSecretsPassword0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOutputKafkaSecretsPassword1 returns the union data inside the UpdateOutputKafka_Secrets_Password as a UpdateOutputKafkaSecretsPassword1
func (t UpdateOutputKafka_Secrets_Password) AsUpdateOutputKafkaSecretsPassword1() (UpdateOutputKafkaSecretsPassword1, error) {
	var body UpdateOutputKafkaSecretsPassword1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputKafkaSecretsPassword1 overwrites any union data inside the UpdateOutputKafka_Secrets_Password as the provided UpdateOutputKafkaSecretsPassword1
func (t *UpdateOutputKafka_Secrets_Password) FromUpdateOutputKafkaSecretsPassword1(v UpdateOutputKafkaSecretsPassword1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputKafkaSecretsPassword1 performs a merge with any union data inside the UpdateOutputKafka_Secrets_Password, using the provided UpdateOutputKafkaSecretsPassword1
func (t *UpdateOutputKafka_Secrets_Password) MergeUpdateOutputKafkaSecretsPassword1(v UpdateOutputKafkaSecretsPassword1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateOutputKafka_Secrets_Password) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateOutputKafka_Secrets_Password) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateOutputKafkaSecretsSslKey0 returns the union data inside the UpdateOutputKafka_Secrets_Ssl_Key as a UpdateOutputKafkaSecretsSslKey0
func (t UpdateOutputKafka_Secrets_Ssl_Key) AsUpdateOutputKafkaSecretsSslKey0() (UpdateOutputKafkaSecretsSslKey0, error) {
	var body UpdateOutputKafkaSecretsSslKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputKafkaSecretsSslKey0 overwrites any union data inside the UpdateOutputKafka_Secrets_Ssl_Key as the provided UpdateOutputKafkaSecretsSslKey0
func (t *UpdateOutputKafka_Secrets_Ssl_Key) FromUpdateOutputKafkaSecretsSslKey0(v UpdateOutputKafkaSecretsSslKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputKafkaSecretsSslKey0 performs a merge with any union data inside the UpdateOutputKafka_Secrets_Ssl_Key, using the provided UpdateOutputKafkaSecretsSslKey0
func (t *UpdateOutputKafka_Secrets_Ssl_Key) MergeUpdateOutputKafkaSecretsSslKey0(v UpdateOutputKafkaSecretsSslKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOutputKafkaSecretsSslKey1 returns the union data inside the UpdateOutputKafka_Secrets_Ssl_Key as a UpdateOutputKafkaSecretsSslKey1
func (t UpdateOutputKafka_Secrets_Ssl_Key) AsUpdateOutputKafkaSecretsSslKey1() (UpdateOutputKafkaSecretsSslKey1, error) {
	var body UpdateOutputKafkaSecretsSslKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputKafkaSecretsSslKey1 overwrites any union data inside the UpdateOutputKafka_Secrets_Ssl_Key as the provided UpdateOutputKafkaSecretsSslKey1
func (t *UpdateOutputKafka_Secrets_Ssl_Key) FromUpdateOutputKafkaSecretsSslKey1(v UpdateOutputKafkaSecretsSslKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputKafkaSecretsSslKey1 performs a merge with any union data inside the UpdateOutputKafka_Secrets_Ssl_Key, using the provided UpdateOutputKafkaSecretsSslKey1
func (t *UpdateOutputKafka_Secrets_Ssl_Key) MergeUpdateOutputKafkaSecretsSslKey1(v UpdateOutputKafkaSecretsSslKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateOutputKafka_Secrets_Ssl_Key) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateOutputKafka_Secrets_Ssl_Key) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateOutputLogstashSecretsSslKey0 returns the union data inside the UpdateOutputLogstash_Secrets_Ssl_Key as a UpdateOutputLogstashSecretsSslKey0
func (t UpdateOutputLogstash_Secrets_Ssl_Key) AsUpdateOutputLogstashSecretsSslKey0() (UpdateOutputLogstashSecretsSslKey0, error) {
	var body UpdateOutputLogstashSecretsSslKey0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputLogstashSecretsSslKey0 overwrites any union data inside the UpdateOutputLogstash_Secrets_Ssl_Key as the provided UpdateOutputLogstashSecretsSslKey0
func (t *UpdateOutputLogstash_Secrets_Ssl_Key) FromUpdateOutputLogstashSecretsSslKey0(v UpdateOutputLogstashSecretsSslKey0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputLogstashSecretsSslKey0 performs a merge with any union data inside the UpdateOutputLogstash_Secrets_Ssl_Key, using the provided UpdateOutputLogstashSecretsSslKey0
func (t *UpdateOutputLogstash_Secrets_Ssl_Key) MergeUpdateOutputLogstashSecretsSslKey0(v UpdateOutputLogstashSecretsSslKey0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOutputLogstashSecretsSslKey1 returns the union data inside the UpdateOutputLogstash_Secrets_Ssl_Key as a UpdateOutputLogstashSecretsSslKey1
func (t UpdateOutputLogstash_Secrets_Ssl_Key) AsUpdateOutputLogstashSecretsSslKey1() (UpdateOutputLogstashSecretsSslKey1, error) {
	var body UpdateOutputLogstashSecretsSslKey1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputLogstashSecretsSslKey1 overwrites any union data inside the UpdateOutputLogstash_Secrets_Ssl_Key as the provided UpdateOutputLogstashSecretsSslKey1
func (t *UpdateOutputLogstash_Secrets_Ssl_Key) FromUpdateOutputLogstashSecretsSslKey1(v UpdateOutputLogstashSecretsSslKey1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputLogstashSecretsSslKey1 performs a merge with any union data inside the UpdateOutputLogstash_Secrets_Ssl_Key, using the provided UpdateOutputLogstashSecretsSslKey1
func (t *UpdateOutputLogstash_Secrets_Ssl_Key) MergeUpdateOutputLogstashSecretsSslKey1(v UpdateOutputLogstashSecretsSslKey1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateOutputLogstash_Secrets_Ssl_Key) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateOutputLogstash_Secrets_Ssl_Key) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateOutputRemoteElasticsearchSecretsServiceToken0 returns the union data inside the UpdateOutputRemoteElasticsearch_Secrets_ServiceToken as a UpdateOutputRemoteElasticsearchSecretsServiceToken0
func (t UpdateOutputRemoteElasticsearch_Secrets_ServiceToken) AsUpdateOutputRemoteElasticsearchSecretsServiceToken0() (UpdateOutputRemoteElasticsearchSecretsServiceToken0, error) {
	var body UpdateOutputRemoteElasticsearchSecretsServiceToken0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputRemoteElasticsearchSecretsServiceToken0 overwrites any union data inside the UpdateOutputRemoteElasticsearch_Secrets_ServiceToken as the provided UpdateOutputRemoteElasticsearchSecretsServiceToken0
func (t *UpdateOutputRemoteElasticsearch_Secrets_ServiceToken) FromUpdateOutputRemoteElasticsearchSecretsServiceToken0(v UpdateOutputRemoteElasticsearchSecretsServiceToken0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputRemoteElasticsearchSecretsServiceToken0 performs a merge with any union data inside the UpdateOutputRemoteElasticsearch_Secrets_ServiceToken, using the provided UpdateOutputRemoteElasticsearchSecretsServiceToken0
func (t *UpdateOutputRemoteElasticsearch_Secrets_ServiceToken) MergeUpdateOutputRemoteElasticsearchSecretsServiceToken0(v UpdateOutputRemoteElasticsearchSecretsServiceToken0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOutputRemoteElasticsearchSecretsServiceToken1 returns the union data inside the UpdateOutputRemoteElasticsearch_Secrets_ServiceToken as a UpdateOutputRemoteElasticsearchSecretsServiceToken1
func (t UpdateOutputRemoteElasticsearch_Secrets_ServiceToken) AsUpdateOutputRemoteElasticsearchSecretsServiceToken1() (UpdateOutputRemoteElasticsearchSecretsServiceToken1, error) {
	var body UpdateOutputRemoteElasticsearchSecretsServiceToken1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputRemoteElasticsearchSecretsServiceToken1 overwrites any union data inside the UpdateOutputRemoteElasticsearch_Secrets_ServiceToken as the provided UpdateOutputRemoteElasticsearchSecretsServiceToken1
func (t *UpdateOutputRemoteElasticsearch_Secrets_ServiceToken) FromUpdateOutputRemoteElasticsearchSecretsServiceToken1(v UpdateOutputRemoteElasticsearchSecretsServiceToken1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputRemoteElasticsearchSecretsServiceToken1 performs a merge with any union data inside the UpdateOutputRemoteElasticsearch_Secrets_ServiceToken, using the provided UpdateOutputRemoteElasticsearchSecretsServiceToken1
func (t *UpdateOutputRemoteElasticsearch_Secrets_ServiceToken) MergeUpdateOutputRemoteElasticsearchSecretsServiceToken1(v UpdateOutputRemoteElasticsearchSecretsServiceToken1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateOutputRemoteElasticsearch_Secrets_ServiceToken) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateOutputRemoteElasticsearch_Secrets_ServiceToken) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsUpdateOutputElasticsearch returns the union data inside the UpdateOutputUnion as a UpdateOutputElasticsearch
func (t UpdateOutputUnion) AsUpdateOutputElasticsearch() (UpdateOutputElasticsearch, error) {
	var body UpdateOutputElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputElasticsearch overwrites any union data inside the UpdateOutputUnion as the provided UpdateOutputElasticsearch
func (t *UpdateOutputUnion) FromUpdateOutputElasticsearch(v UpdateOutputElasticsearch) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputElasticsearch performs a merge with any union data inside the UpdateOutputUnion, using the provided UpdateOutputElasticsearch
func (t *UpdateOutputUnion) MergeUpdateOutputElasticsearch(v UpdateOutputElasticsearch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOutputRemoteElasticsearch returns the union data inside the UpdateOutputUnion as a UpdateOutputRemoteElasticsearch
func (t UpdateOutputUnion) AsUpdateOutputRemoteElasticsearch() (UpdateOutputRemoteElasticsearch, error) {
	var body UpdateOutputRemoteElasticsearch
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputRemoteElasticsearch overwrites any union data inside the UpdateOutputUnion as the provided UpdateOutputRemoteElasticsearch
func (t *UpdateOutputUnion) FromUpdateOutputRemoteElasticsearch(v UpdateOutputRemoteElasticsearch) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputRemoteElasticsearch performs a merge with any union data inside the UpdateOutputUnion, using the provided UpdateOutputRemoteElasticsearch
func (t *UpdateOutputUnion) MergeUpdateOutputRemoteElasticsearch(v UpdateOutputRemoteElasticsearch) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOutputLogstash returns the union data inside the UpdateOutputUnion as a UpdateOutputLogstash
func (t UpdateOutputUnion) AsUpdateOutputLogstash() (UpdateOutputLogstash, error) {
	var body UpdateOutputLogstash
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputLogstash overwrites any union data inside the UpdateOutputUnion as the provided UpdateOutputLogstash
func (t *UpdateOutputUnion) FromUpdateOutputLogstash(v UpdateOutputLogstash) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputLogstash performs a merge with any union data inside the UpdateOutputUnion, using the provided UpdateOutputLogstash
func (t *UpdateOutputUnion) MergeUpdateOutputLogstash(v UpdateOutputLogstash) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsUpdateOutputKafka returns the union data inside the UpdateOutputUnion as a UpdateOutputKafka
func (t UpdateOutputUnion) AsUpdateOutputKafka() (UpdateOutputKafka, error) {
	var body UpdateOutputKafka
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromUpdateOutputKafka overwrites any union data inside the UpdateOutputUnion as the provided UpdateOutputKafka
func (t *UpdateOutputUnion) FromUpdateOutputKafka(v UpdateOutputKafka) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeUpdateOutputKafka performs a merge with any union data inside the UpdateOutputUnion, using the provided UpdateOutputKafka
func (t *UpdateOutputUnion) MergeUpdateOutputKafka(v UpdateOutputKafka) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t UpdateOutputUnion) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *UpdateOutputUnion) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetFleetAgentPolicies request
	GetFleetAgentPolicies(ctx context.Context, params *GetFleetAgentPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFleetAgentPoliciesWithBody request with any body
	PostFleetAgentPoliciesWithBody(ctx context.Context, params *PostFleetAgentPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFleetAgentPolicies(ctx context.Context, params *PostFleetAgentPoliciesParams, body PostFleetAgentPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFleetAgentPoliciesDeleteWithBody request with any body
	PostFleetAgentPoliciesDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFleetAgentPoliciesDelete(ctx context.Context, body PostFleetAgentPoliciesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFleetAgentPoliciesAgentpolicyid request
	GetFleetAgentPoliciesAgentpolicyid(ctx context.Context, agentPolicyId string, params *GetFleetAgentPoliciesAgentpolicyidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutFleetAgentPoliciesAgentpolicyidWithBody request with any body
	PutFleetAgentPoliciesAgentpolicyidWithBody(ctx context.Context, agentPolicyId string, params *PutFleetAgentPoliciesAgentpolicyidParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutFleetAgentPoliciesAgentpolicyid(ctx context.Context, agentPolicyId string, params *PutFleetAgentPoliciesAgentpolicyidParams, body PutFleetAgentPoliciesAgentpolicyidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFleetEnrollmentApiKeys request
	GetFleetEnrollmentApiKeys(ctx context.Context, params *GetFleetEnrollmentApiKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFleetEpmPackages request
	GetFleetEpmPackages(ctx context.Context, params *GetFleetEpmPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFleetEpmPackagesWithBody request with any body
	PostFleetEpmPackagesWithBody(ctx context.Context, params *PostFleetEpmPackagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFleetEpmPackagesPkgnamePkgversion request
	DeleteFleetEpmPackagesPkgnamePkgversion(ctx context.Context, pkgName string, pkgVersion string, params *DeleteFleetEpmPackagesPkgnamePkgversionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFleetEpmPackagesPkgnamePkgversion request
	GetFleetEpmPackagesPkgnamePkgversion(ctx context.Context, pkgName string, pkgVersion string, params *GetFleetEpmPackagesPkgnamePkgversionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFleetEpmPackagesPkgnamePkgversionWithBody request with any body
	PostFleetEpmPackagesPkgnamePkgversionWithBody(ctx context.Context, pkgName string, pkgVersion string, params *PostFleetEpmPackagesPkgnamePkgversionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFleetEpmPackagesPkgnamePkgversion(ctx context.Context, pkgName string, pkgVersion string, params *PostFleetEpmPackagesPkgnamePkgversionParams, body PostFleetEpmPackagesPkgnamePkgversionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFleetFleetServerHosts request
	GetFleetFleetServerHosts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFleetFleetServerHostsWithBody request with any body
	PostFleetFleetServerHostsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFleetFleetServerHosts(ctx context.Context, body PostFleetFleetServerHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFleetFleetServerHostsItemid request
	DeleteFleetFleetServerHostsItemid(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFleetFleetServerHostsItemid request
	GetFleetFleetServerHostsItemid(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutFleetFleetServerHostsItemidWithBody request with any body
	PutFleetFleetServerHostsItemidWithBody(ctx context.Context, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutFleetFleetServerHostsItemid(ctx context.Context, itemId string, body PutFleetFleetServerHostsItemidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFleetOutputs request
	GetFleetOutputs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFleetOutputsWithBody request with any body
	PostFleetOutputsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFleetOutputs(ctx context.Context, body PostFleetOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFleetOutputsOutputid request
	DeleteFleetOutputsOutputid(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFleetOutputsOutputid request
	GetFleetOutputsOutputid(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutFleetOutputsOutputidWithBody request with any body
	PutFleetOutputsOutputidWithBody(ctx context.Context, outputId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutFleetOutputsOutputid(ctx context.Context, outputId string, body PutFleetOutputsOutputidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFleetPackagePolicies request
	GetFleetPackagePolicies(ctx context.Context, params *GetFleetPackagePoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFleetPackagePoliciesWithBody request with any body
	PostFleetPackagePoliciesWithBody(ctx context.Context, params *PostFleetPackagePoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFleetPackagePolicies(ctx context.Context, params *PostFleetPackagePoliciesParams, body PostFleetPackagePoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFleetPackagePoliciesPackagepolicyid request
	DeleteFleetPackagePoliciesPackagepolicyid(ctx context.Context, packagePolicyId string, params *DeleteFleetPackagePoliciesPackagepolicyidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFleetPackagePoliciesPackagepolicyid request
	GetFleetPackagePoliciesPackagepolicyid(ctx context.Context, packagePolicyId string, params *GetFleetPackagePoliciesPackagepolicyidParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutFleetPackagePoliciesPackagepolicyidWithBody request with any body
	PutFleetPackagePoliciesPackagepolicyidWithBody(ctx context.Context, packagePolicyId string, params *PutFleetPackagePoliciesPackagepolicyidParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutFleetPackagePoliciesPackagepolicyid(ctx context.Context, packagePolicyId string, params *PutFleetPackagePoliciesPackagepolicyidParams, body PutFleetPackagePoliciesPackagepolicyidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllDataViewsDefault request
	GetAllDataViewsDefault(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDataViewDefaultwWithBody request with any body
	CreateDataViewDefaultwWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDataViewDefaultw(ctx context.Context, spaceId SpaceId, body CreateDataViewDefaultwJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDataViewDefault request
	DeleteDataViewDefault(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDataViewDefault request
	GetDataViewDefault(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDataViewDefaultWithBody request with any body
	UpdateDataViewDefaultWithBody(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDataViewDefault(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, body UpdateDataViewDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetFleetAgentPolicies(ctx context.Context, params *GetFleetAgentPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetAgentPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetAgentPoliciesWithBody(ctx context.Context, params *PostFleetAgentPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetAgentPoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetAgentPolicies(ctx context.Context, params *PostFleetAgentPoliciesParams, body PostFleetAgentPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetAgentPoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetAgentPoliciesDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetAgentPoliciesDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetAgentPoliciesDelete(ctx context.Context, body PostFleetAgentPoliciesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetAgentPoliciesDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFleetAgentPoliciesAgentpolicyid(ctx context.Context, agentPolicyId string, params *GetFleetAgentPoliciesAgentpolicyidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetAgentPoliciesAgentpolicyidRequest(c.Server, agentPolicyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutFleetAgentPoliciesAgentpolicyidWithBody(ctx context.Context, agentPolicyId string, params *PutFleetAgentPoliciesAgentpolicyidParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutFleetAgentPoliciesAgentpolicyidRequestWithBody(c.Server, agentPolicyId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutFleetAgentPoliciesAgentpolicyid(ctx context.Context, agentPolicyId string, params *PutFleetAgentPoliciesAgentpolicyidParams, body PutFleetAgentPoliciesAgentpolicyidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutFleetAgentPoliciesAgentpolicyidRequest(c.Server, agentPolicyId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFleetEnrollmentApiKeys(ctx context.Context, params *GetFleetEnrollmentApiKeysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetEnrollmentApiKeysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFleetEpmPackages(ctx context.Context, params *GetFleetEpmPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetEpmPackagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetEpmPackagesWithBody(ctx context.Context, params *PostFleetEpmPackagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetEpmPackagesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFleetEpmPackagesPkgnamePkgversion(ctx context.Context, pkgName string, pkgVersion string, params *DeleteFleetEpmPackagesPkgnamePkgversionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFleetEpmPackagesPkgnamePkgversionRequest(c.Server, pkgName, pkgVersion, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFleetEpmPackagesPkgnamePkgversion(ctx context.Context, pkgName string, pkgVersion string, params *GetFleetEpmPackagesPkgnamePkgversionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetEpmPackagesPkgnamePkgversionRequest(c.Server, pkgName, pkgVersion, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetEpmPackagesPkgnamePkgversionWithBody(ctx context.Context, pkgName string, pkgVersion string, params *PostFleetEpmPackagesPkgnamePkgversionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetEpmPackagesPkgnamePkgversionRequestWithBody(c.Server, pkgName, pkgVersion, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetEpmPackagesPkgnamePkgversion(ctx context.Context, pkgName string, pkgVersion string, params *PostFleetEpmPackagesPkgnamePkgversionParams, body PostFleetEpmPackagesPkgnamePkgversionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetEpmPackagesPkgnamePkgversionRequest(c.Server, pkgName, pkgVersion, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFleetFleetServerHosts(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetFleetServerHostsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetFleetServerHostsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetFleetServerHostsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetFleetServerHosts(ctx context.Context, body PostFleetFleetServerHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetFleetServerHostsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFleetFleetServerHostsItemid(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFleetFleetServerHostsItemidRequest(c.Server, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFleetFleetServerHostsItemid(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetFleetServerHostsItemidRequest(c.Server, itemId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutFleetFleetServerHostsItemidWithBody(ctx context.Context, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutFleetFleetServerHostsItemidRequestWithBody(c.Server, itemId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutFleetFleetServerHostsItemid(ctx context.Context, itemId string, body PutFleetFleetServerHostsItemidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutFleetFleetServerHostsItemidRequest(c.Server, itemId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFleetOutputs(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetOutputsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetOutputsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetOutputsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetOutputs(ctx context.Context, body PostFleetOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetOutputsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFleetOutputsOutputid(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFleetOutputsOutputidRequest(c.Server, outputId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFleetOutputsOutputid(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetOutputsOutputidRequest(c.Server, outputId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutFleetOutputsOutputidWithBody(ctx context.Context, outputId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutFleetOutputsOutputidRequestWithBody(c.Server, outputId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutFleetOutputsOutputid(ctx context.Context, outputId string, body PutFleetOutputsOutputidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutFleetOutputsOutputidRequest(c.Server, outputId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFleetPackagePolicies(ctx context.Context, params *GetFleetPackagePoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetPackagePoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetPackagePoliciesWithBody(ctx context.Context, params *PostFleetPackagePoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetPackagePoliciesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFleetPackagePolicies(ctx context.Context, params *PostFleetPackagePoliciesParams, body PostFleetPackagePoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFleetPackagePoliciesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFleetPackagePoliciesPackagepolicyid(ctx context.Context, packagePolicyId string, params *DeleteFleetPackagePoliciesPackagepolicyidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFleetPackagePoliciesPackagepolicyidRequest(c.Server, packagePolicyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFleetPackagePoliciesPackagepolicyid(ctx context.Context, packagePolicyId string, params *GetFleetPackagePoliciesPackagepolicyidParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFleetPackagePoliciesPackagepolicyidRequest(c.Server, packagePolicyId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutFleetPackagePoliciesPackagepolicyidWithBody(ctx context.Context, packagePolicyId string, params *PutFleetPackagePoliciesPackagepolicyidParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutFleetPackagePoliciesPackagepolicyidRequestWithBody(c.Server, packagePolicyId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutFleetPackagePoliciesPackagepolicyid(ctx context.Context, packagePolicyId string, params *PutFleetPackagePoliciesPackagepolicyidParams, body PutFleetPackagePoliciesPackagepolicyidJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutFleetPackagePoliciesPackagepolicyidRequest(c.Server, packagePolicyId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllDataViewsDefault(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllDataViewsDefaultRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDataViewDefaultwWithBody(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDataViewDefaultwRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDataViewDefaultw(ctx context.Context, spaceId SpaceId, body CreateDataViewDefaultwJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDataViewDefaultwRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDataViewDefault(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDataViewDefaultRequest(c.Server, spaceId, viewId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDataViewDefault(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataViewDefaultRequest(c.Server, spaceId, viewId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDataViewDefaultWithBody(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDataViewDefaultRequestWithBody(c.Server, spaceId, viewId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDataViewDefault(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, body UpdateDataViewDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDataViewDefaultRequest(c.Server, spaceId, viewId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetFleetAgentPoliciesRequest generates requests for GetFleetAgentPolicies
func NewGetFleetAgentPoliciesRequest(server string, params *GetFleetAgentPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/agent_policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortField", runtime.ParamLocationQuery, *params.SortField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowUpgradeable != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "showUpgradeable", runtime.ParamLocationQuery, *params.ShowUpgradeable); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kuery != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kuery", runtime.ParamLocationQuery, *params.Kuery); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NoAgentCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "noAgentCount", runtime.ParamLocationQuery, *params.NoAgentCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithAgentCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withAgentCount", runtime.ParamLocationQuery, *params.WithAgentCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Full != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full", runtime.ParamLocationQuery, *params.Full); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostFleetAgentPoliciesRequest calls the generic PostFleetAgentPolicies builder with application/json body
func NewPostFleetAgentPoliciesRequest(server string, params *PostFleetAgentPoliciesParams, body PostFleetAgentPoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFleetAgentPoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostFleetAgentPoliciesRequestWithBody generates requests for PostFleetAgentPolicies with any type of body
func NewPostFleetAgentPoliciesRequestWithBody(server string, params *PostFleetAgentPoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/agent_policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SysMonitoring != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sys_monitoring", runtime.ParamLocationQuery, *params.SysMonitoring); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostFleetAgentPoliciesDeleteRequest calls the generic PostFleetAgentPoliciesDelete builder with application/json body
func NewPostFleetAgentPoliciesDeleteRequest(server string, body PostFleetAgentPoliciesDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFleetAgentPoliciesDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewPostFleetAgentPoliciesDeleteRequestWithBody generates requests for PostFleetAgentPoliciesDelete with any type of body
func NewPostFleetAgentPoliciesDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/agent_policies/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFleetAgentPoliciesAgentpolicyidRequest generates requests for GetFleetAgentPoliciesAgentpolicyid
func NewGetFleetAgentPoliciesAgentpolicyidRequest(server string, agentPolicyId string, params *GetFleetAgentPoliciesAgentpolicyidParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agentPolicyId", runtime.ParamLocationPath, agentPolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/agent_policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutFleetAgentPoliciesAgentpolicyidRequest calls the generic PutFleetAgentPoliciesAgentpolicyid builder with application/json body
func NewPutFleetAgentPoliciesAgentpolicyidRequest(server string, agentPolicyId string, params *PutFleetAgentPoliciesAgentpolicyidParams, body PutFleetAgentPoliciesAgentpolicyidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutFleetAgentPoliciesAgentpolicyidRequestWithBody(server, agentPolicyId, params, "application/json", bodyReader)
}

// NewPutFleetAgentPoliciesAgentpolicyidRequestWithBody generates requests for PutFleetAgentPoliciesAgentpolicyid with any type of body
func NewPutFleetAgentPoliciesAgentpolicyidRequestWithBody(server string, agentPolicyId string, params *PutFleetAgentPoliciesAgentpolicyidParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "agentPolicyId", runtime.ParamLocationPath, agentPolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/agent_policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFleetEnrollmentApiKeysRequest generates requests for GetFleetEnrollmentApiKeys
func NewGetFleetEnrollmentApiKeysRequest(server string, params *GetFleetEnrollmentApiKeysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/enrollment_api_keys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kuery != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kuery", runtime.ParamLocationQuery, *params.Kuery); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFleetEpmPackagesRequest generates requests for GetFleetEpmPackages
func NewGetFleetEpmPackagesRequest(server string, params *GetFleetEpmPackagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/epm/packages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Category != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category", runtime.ParamLocationQuery, *params.Category); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Prerelease != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prerelease", runtime.ParamLocationQuery, *params.Prerelease); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludeInstallStatus != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludeInstallStatus", runtime.ParamLocationQuery, *params.ExcludeInstallStatus); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostFleetEpmPackagesRequestWithBody generates requests for PostFleetEpmPackages with any type of body
func NewPostFleetEpmPackagesRequestWithBody(server string, params *PostFleetEpmPackagesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/epm/packages")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IgnoreMappingUpdateErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignoreMappingUpdateErrors", runtime.ParamLocationQuery, *params.IgnoreMappingUpdateErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipDataStreamRollover != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipDataStreamRollover", runtime.ParamLocationQuery, *params.SkipDataStreamRollover); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFleetEpmPackagesPkgnamePkgversionRequest generates requests for DeleteFleetEpmPackagesPkgnamePkgversion
func NewDeleteFleetEpmPackagesPkgnamePkgversionRequest(server string, pkgName string, pkgVersion string, params *DeleteFleetEpmPackagesPkgnamePkgversionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pkgName", runtime.ParamLocationPath, pkgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pkgVersion", runtime.ParamLocationPath, pkgVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/epm/packages/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFleetEpmPackagesPkgnamePkgversionRequest generates requests for GetFleetEpmPackagesPkgnamePkgversion
func NewGetFleetEpmPackagesPkgnamePkgversionRequest(server string, pkgName string, pkgVersion string, params *GetFleetEpmPackagesPkgnamePkgversionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pkgName", runtime.ParamLocationPath, pkgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pkgVersion", runtime.ParamLocationPath, pkgVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/epm/packages/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IgnoreUnverified != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignoreUnverified", runtime.ParamLocationQuery, *params.IgnoreUnverified); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Prerelease != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prerelease", runtime.ParamLocationQuery, *params.Prerelease); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Full != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "full", runtime.ParamLocationQuery, *params.Full); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithMetadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withMetadata", runtime.ParamLocationQuery, *params.WithMetadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostFleetEpmPackagesPkgnamePkgversionRequest calls the generic PostFleetEpmPackagesPkgnamePkgversion builder with application/json body
func NewPostFleetEpmPackagesPkgnamePkgversionRequest(server string, pkgName string, pkgVersion string, params *PostFleetEpmPackagesPkgnamePkgversionParams, body PostFleetEpmPackagesPkgnamePkgversionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFleetEpmPackagesPkgnamePkgversionRequestWithBody(server, pkgName, pkgVersion, params, "application/json", bodyReader)
}

// NewPostFleetEpmPackagesPkgnamePkgversionRequestWithBody generates requests for PostFleetEpmPackagesPkgnamePkgversion with any type of body
func NewPostFleetEpmPackagesPkgnamePkgversionRequestWithBody(server string, pkgName string, pkgVersion string, params *PostFleetEpmPackagesPkgnamePkgversionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "pkgName", runtime.ParamLocationPath, pkgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pkgVersion", runtime.ParamLocationPath, pkgVersion)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/epm/packages/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Prerelease != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prerelease", runtime.ParamLocationQuery, *params.Prerelease); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IgnoreMappingUpdateErrors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ignoreMappingUpdateErrors", runtime.ParamLocationQuery, *params.IgnoreMappingUpdateErrors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SkipDataStreamRollover != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skipDataStreamRollover", runtime.ParamLocationQuery, *params.SkipDataStreamRollover); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFleetFleetServerHostsRequest generates requests for GetFleetFleetServerHosts
func NewGetFleetFleetServerHostsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/fleet_server_hosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostFleetFleetServerHostsRequest calls the generic PostFleetFleetServerHosts builder with application/json body
func NewPostFleetFleetServerHostsRequest(server string, body PostFleetFleetServerHostsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFleetFleetServerHostsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostFleetFleetServerHostsRequestWithBody generates requests for PostFleetFleetServerHosts with any type of body
func NewPostFleetFleetServerHostsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/fleet_server_hosts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFleetFleetServerHostsItemidRequest generates requests for DeleteFleetFleetServerHostsItemid
func NewDeleteFleetFleetServerHostsItemidRequest(server string, itemId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/fleet_server_hosts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFleetFleetServerHostsItemidRequest generates requests for GetFleetFleetServerHostsItemid
func NewGetFleetFleetServerHostsItemidRequest(server string, itemId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/fleet_server_hosts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutFleetFleetServerHostsItemidRequest calls the generic PutFleetFleetServerHostsItemid builder with application/json body
func NewPutFleetFleetServerHostsItemidRequest(server string, itemId string, body PutFleetFleetServerHostsItemidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutFleetFleetServerHostsItemidRequestWithBody(server, itemId, "application/json", bodyReader)
}

// NewPutFleetFleetServerHostsItemidRequestWithBody generates requests for PutFleetFleetServerHostsItemid with any type of body
func NewPutFleetFleetServerHostsItemidRequestWithBody(server string, itemId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "itemId", runtime.ParamLocationPath, itemId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/fleet_server_hosts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFleetOutputsRequest generates requests for GetFleetOutputs
func NewGetFleetOutputsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/outputs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostFleetOutputsRequest calls the generic PostFleetOutputs builder with application/json body
func NewPostFleetOutputsRequest(server string, body PostFleetOutputsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFleetOutputsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostFleetOutputsRequestWithBody generates requests for PostFleetOutputs with any type of body
func NewPostFleetOutputsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/outputs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFleetOutputsOutputidRequest generates requests for DeleteFleetOutputsOutputid
func NewDeleteFleetOutputsOutputidRequest(server string, outputId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "outputId", runtime.ParamLocationPath, outputId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/outputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFleetOutputsOutputidRequest generates requests for GetFleetOutputsOutputid
func NewGetFleetOutputsOutputidRequest(server string, outputId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "outputId", runtime.ParamLocationPath, outputId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/outputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutFleetOutputsOutputidRequest calls the generic PutFleetOutputsOutputid builder with application/json body
func NewPutFleetOutputsOutputidRequest(server string, outputId string, body PutFleetOutputsOutputidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutFleetOutputsOutputidRequestWithBody(server, outputId, "application/json", bodyReader)
}

// NewPutFleetOutputsOutputidRequestWithBody generates requests for PutFleetOutputsOutputid with any type of body
func NewPutFleetOutputsOutputidRequestWithBody(server string, outputId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "outputId", runtime.ParamLocationPath, outputId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/outputs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFleetPackagePoliciesRequest generates requests for GetFleetPackagePolicies
func NewGetFleetPackagePoliciesRequest(server string, params *GetFleetPackagePoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/package_policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PerPage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "perPage", runtime.ParamLocationQuery, *params.PerPage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortField != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortField", runtime.ParamLocationQuery, *params.SortField); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortOrder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortOrder", runtime.ParamLocationQuery, *params.SortOrder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowUpgradeable != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "showUpgradeable", runtime.ParamLocationQuery, *params.ShowUpgradeable); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kuery != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kuery", runtime.ParamLocationQuery, *params.Kuery); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WithAgentCount != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "withAgentCount", runtime.ParamLocationQuery, *params.WithAgentCount); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostFleetPackagePoliciesRequest calls the generic PostFleetPackagePolicies builder with application/json body
func NewPostFleetPackagePoliciesRequest(server string, params *PostFleetPackagePoliciesParams, body PostFleetPackagePoliciesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFleetPackagePoliciesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostFleetPackagePoliciesRequestWithBody generates requests for PostFleetPackagePolicies with any type of body
func NewPostFleetPackagePoliciesRequestWithBody(server string, params *PostFleetPackagePoliciesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/package_policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFleetPackagePoliciesPackagepolicyidRequest generates requests for DeleteFleetPackagePoliciesPackagepolicyid
func NewDeleteFleetPackagePoliciesPackagepolicyidRequest(server string, packagePolicyId string, params *DeleteFleetPackagePoliciesPackagepolicyidParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "packagePolicyId", runtime.ParamLocationPath, packagePolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/package_policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Force != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "force", runtime.ParamLocationQuery, *params.Force); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFleetPackagePoliciesPackagepolicyidRequest generates requests for GetFleetPackagePoliciesPackagepolicyid
func NewGetFleetPackagePoliciesPackagepolicyidRequest(server string, packagePolicyId string, params *GetFleetPackagePoliciesPackagepolicyidParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "packagePolicyId", runtime.ParamLocationPath, packagePolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/package_policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutFleetPackagePoliciesPackagepolicyidRequest calls the generic PutFleetPackagePoliciesPackagepolicyid builder with application/json body
func NewPutFleetPackagePoliciesPackagepolicyidRequest(server string, packagePolicyId string, params *PutFleetPackagePoliciesPackagepolicyidParams, body PutFleetPackagePoliciesPackagepolicyidJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutFleetPackagePoliciesPackagepolicyidRequestWithBody(server, packagePolicyId, params, "application/json", bodyReader)
}

// NewPutFleetPackagePoliciesPackagepolicyidRequestWithBody generates requests for PutFleetPackagePoliciesPackagepolicyid with any type of body
func NewPutFleetPackagePoliciesPackagepolicyidRequestWithBody(server string, packagePolicyId string, params *PutFleetPackagePoliciesPackagepolicyidParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "packagePolicyId", runtime.ParamLocationPath, packagePolicyId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/api/fleet/package_policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Format != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "format", runtime.ParamLocationQuery, *params.Format); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAllDataViewsDefaultRequest generates requests for GetAllDataViewsDefault
func NewGetAllDataViewsDefaultRequest(server string, spaceId SpaceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/data_views", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDataViewDefaultwRequest calls the generic CreateDataViewDefaultw builder with application/json body
func NewCreateDataViewDefaultwRequest(server string, spaceId SpaceId, body CreateDataViewDefaultwJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDataViewDefaultwRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateDataViewDefaultwRequestWithBody generates requests for CreateDataViewDefaultw with any type of body
func NewCreateDataViewDefaultwRequestWithBody(server string, spaceId SpaceId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/data_views/data_view", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDataViewDefaultRequest generates requests for DeleteDataViewDefault
func NewDeleteDataViewDefaultRequest(server string, spaceId SpaceId, viewId DataViewsViewId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "viewId", runtime.ParamLocationPath, viewId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/data_views/data_view/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDataViewDefaultRequest generates requests for GetDataViewDefault
func NewGetDataViewDefaultRequest(server string, spaceId SpaceId, viewId DataViewsViewId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "viewId", runtime.ParamLocationPath, viewId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/data_views/data_view/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDataViewDefaultRequest calls the generic UpdateDataViewDefault builder with application/json body
func NewUpdateDataViewDefaultRequest(server string, spaceId SpaceId, viewId DataViewsViewId, body UpdateDataViewDefaultJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDataViewDefaultRequestWithBody(server, spaceId, viewId, "application/json", bodyReader)
}

// NewUpdateDataViewDefaultRequestWithBody generates requests for UpdateDataViewDefault with any type of body
func NewUpdateDataViewDefaultRequestWithBody(server string, spaceId SpaceId, viewId DataViewsViewId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "spaceId", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "viewId", runtime.ParamLocationPath, viewId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/s/%s/api/data_views/data_view/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetFleetAgentPoliciesWithResponse request
	GetFleetAgentPoliciesWithResponse(ctx context.Context, params *GetFleetAgentPoliciesParams, reqEditors ...RequestEditorFn) (*GetFleetAgentPoliciesResponse, error)

	// PostFleetAgentPoliciesWithBodyWithResponse request with any body
	PostFleetAgentPoliciesWithBodyWithResponse(ctx context.Context, params *PostFleetAgentPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetAgentPoliciesResponse, error)

	PostFleetAgentPoliciesWithResponse(ctx context.Context, params *PostFleetAgentPoliciesParams, body PostFleetAgentPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetAgentPoliciesResponse, error)

	// PostFleetAgentPoliciesDeleteWithBodyWithResponse request with any body
	PostFleetAgentPoliciesDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetAgentPoliciesDeleteResponse, error)

	PostFleetAgentPoliciesDeleteWithResponse(ctx context.Context, body PostFleetAgentPoliciesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetAgentPoliciesDeleteResponse, error)

	// GetFleetAgentPoliciesAgentpolicyidWithResponse request
	GetFleetAgentPoliciesAgentpolicyidWithResponse(ctx context.Context, agentPolicyId string, params *GetFleetAgentPoliciesAgentpolicyidParams, reqEditors ...RequestEditorFn) (*GetFleetAgentPoliciesAgentpolicyidResponse, error)

	// PutFleetAgentPoliciesAgentpolicyidWithBodyWithResponse request with any body
	PutFleetAgentPoliciesAgentpolicyidWithBodyWithResponse(ctx context.Context, agentPolicyId string, params *PutFleetAgentPoliciesAgentpolicyidParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutFleetAgentPoliciesAgentpolicyidResponse, error)

	PutFleetAgentPoliciesAgentpolicyidWithResponse(ctx context.Context, agentPolicyId string, params *PutFleetAgentPoliciesAgentpolicyidParams, body PutFleetAgentPoliciesAgentpolicyidJSONRequestBody, reqEditors ...RequestEditorFn) (*PutFleetAgentPoliciesAgentpolicyidResponse, error)

	// GetFleetEnrollmentApiKeysWithResponse request
	GetFleetEnrollmentApiKeysWithResponse(ctx context.Context, params *GetFleetEnrollmentApiKeysParams, reqEditors ...RequestEditorFn) (*GetFleetEnrollmentApiKeysResponse, error)

	// GetFleetEpmPackagesWithResponse request
	GetFleetEpmPackagesWithResponse(ctx context.Context, params *GetFleetEpmPackagesParams, reqEditors ...RequestEditorFn) (*GetFleetEpmPackagesResponse, error)

	// PostFleetEpmPackagesWithBodyWithResponse request with any body
	PostFleetEpmPackagesWithBodyWithResponse(ctx context.Context, params *PostFleetEpmPackagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetEpmPackagesResponse, error)

	// DeleteFleetEpmPackagesPkgnamePkgversionWithResponse request
	DeleteFleetEpmPackagesPkgnamePkgversionWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *DeleteFleetEpmPackagesPkgnamePkgversionParams, reqEditors ...RequestEditorFn) (*DeleteFleetEpmPackagesPkgnamePkgversionResponse, error)

	// GetFleetEpmPackagesPkgnamePkgversionWithResponse request
	GetFleetEpmPackagesPkgnamePkgversionWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *GetFleetEpmPackagesPkgnamePkgversionParams, reqEditors ...RequestEditorFn) (*GetFleetEpmPackagesPkgnamePkgversionResponse, error)

	// PostFleetEpmPackagesPkgnamePkgversionWithBodyWithResponse request with any body
	PostFleetEpmPackagesPkgnamePkgversionWithBodyWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *PostFleetEpmPackagesPkgnamePkgversionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetEpmPackagesPkgnamePkgversionResponse, error)

	PostFleetEpmPackagesPkgnamePkgversionWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *PostFleetEpmPackagesPkgnamePkgversionParams, body PostFleetEpmPackagesPkgnamePkgversionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetEpmPackagesPkgnamePkgversionResponse, error)

	// GetFleetFleetServerHostsWithResponse request
	GetFleetFleetServerHostsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFleetFleetServerHostsResponse, error)

	// PostFleetFleetServerHostsWithBodyWithResponse request with any body
	PostFleetFleetServerHostsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetFleetServerHostsResponse, error)

	PostFleetFleetServerHostsWithResponse(ctx context.Context, body PostFleetFleetServerHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetFleetServerHostsResponse, error)

	// DeleteFleetFleetServerHostsItemidWithResponse request
	DeleteFleetFleetServerHostsItemidWithResponse(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*DeleteFleetFleetServerHostsItemidResponse, error)

	// GetFleetFleetServerHostsItemidWithResponse request
	GetFleetFleetServerHostsItemidWithResponse(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*GetFleetFleetServerHostsItemidResponse, error)

	// PutFleetFleetServerHostsItemidWithBodyWithResponse request with any body
	PutFleetFleetServerHostsItemidWithBodyWithResponse(ctx context.Context, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutFleetFleetServerHostsItemidResponse, error)

	PutFleetFleetServerHostsItemidWithResponse(ctx context.Context, itemId string, body PutFleetFleetServerHostsItemidJSONRequestBody, reqEditors ...RequestEditorFn) (*PutFleetFleetServerHostsItemidResponse, error)

	// GetFleetOutputsWithResponse request
	GetFleetOutputsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFleetOutputsResponse, error)

	// PostFleetOutputsWithBodyWithResponse request with any body
	PostFleetOutputsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetOutputsResponse, error)

	PostFleetOutputsWithResponse(ctx context.Context, body PostFleetOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetOutputsResponse, error)

	// DeleteFleetOutputsOutputidWithResponse request
	DeleteFleetOutputsOutputidWithResponse(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*DeleteFleetOutputsOutputidResponse, error)

	// GetFleetOutputsOutputidWithResponse request
	GetFleetOutputsOutputidWithResponse(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*GetFleetOutputsOutputidResponse, error)

	// PutFleetOutputsOutputidWithBodyWithResponse request with any body
	PutFleetOutputsOutputidWithBodyWithResponse(ctx context.Context, outputId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutFleetOutputsOutputidResponse, error)

	PutFleetOutputsOutputidWithResponse(ctx context.Context, outputId string, body PutFleetOutputsOutputidJSONRequestBody, reqEditors ...RequestEditorFn) (*PutFleetOutputsOutputidResponse, error)

	// GetFleetPackagePoliciesWithResponse request
	GetFleetPackagePoliciesWithResponse(ctx context.Context, params *GetFleetPackagePoliciesParams, reqEditors ...RequestEditorFn) (*GetFleetPackagePoliciesResponse, error)

	// PostFleetPackagePoliciesWithBodyWithResponse request with any body
	PostFleetPackagePoliciesWithBodyWithResponse(ctx context.Context, params *PostFleetPackagePoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetPackagePoliciesResponse, error)

	PostFleetPackagePoliciesWithResponse(ctx context.Context, params *PostFleetPackagePoliciesParams, body PostFleetPackagePoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetPackagePoliciesResponse, error)

	// DeleteFleetPackagePoliciesPackagepolicyidWithResponse request
	DeleteFleetPackagePoliciesPackagepolicyidWithResponse(ctx context.Context, packagePolicyId string, params *DeleteFleetPackagePoliciesPackagepolicyidParams, reqEditors ...RequestEditorFn) (*DeleteFleetPackagePoliciesPackagepolicyidResponse, error)

	// GetFleetPackagePoliciesPackagepolicyidWithResponse request
	GetFleetPackagePoliciesPackagepolicyidWithResponse(ctx context.Context, packagePolicyId string, params *GetFleetPackagePoliciesPackagepolicyidParams, reqEditors ...RequestEditorFn) (*GetFleetPackagePoliciesPackagepolicyidResponse, error)

	// PutFleetPackagePoliciesPackagepolicyidWithBodyWithResponse request with any body
	PutFleetPackagePoliciesPackagepolicyidWithBodyWithResponse(ctx context.Context, packagePolicyId string, params *PutFleetPackagePoliciesPackagepolicyidParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutFleetPackagePoliciesPackagepolicyidResponse, error)

	PutFleetPackagePoliciesPackagepolicyidWithResponse(ctx context.Context, packagePolicyId string, params *PutFleetPackagePoliciesPackagepolicyidParams, body PutFleetPackagePoliciesPackagepolicyidJSONRequestBody, reqEditors ...RequestEditorFn) (*PutFleetPackagePoliciesPackagepolicyidResponse, error)

	// GetAllDataViewsDefaultWithResponse request
	GetAllDataViewsDefaultWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*GetAllDataViewsDefaultResponse, error)

	// CreateDataViewDefaultwWithBodyWithResponse request with any body
	CreateDataViewDefaultwWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDataViewDefaultwResponse, error)

	CreateDataViewDefaultwWithResponse(ctx context.Context, spaceId SpaceId, body CreateDataViewDefaultwJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDataViewDefaultwResponse, error)

	// DeleteDataViewDefaultWithResponse request
	DeleteDataViewDefaultWithResponse(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, reqEditors ...RequestEditorFn) (*DeleteDataViewDefaultResponse, error)

	// GetDataViewDefaultWithResponse request
	GetDataViewDefaultWithResponse(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, reqEditors ...RequestEditorFn) (*GetDataViewDefaultResponse, error)

	// UpdateDataViewDefaultWithBodyWithResponse request with any body
	UpdateDataViewDefaultWithBodyWithResponse(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDataViewDefaultResponse, error)

	UpdateDataViewDefaultWithResponse(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, body UpdateDataViewDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDataViewDefaultResponse, error)
}

type GetFleetAgentPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items   []AgentPolicy `json:"items"`
		Page    float32       `json:"page"`
		PerPage float32       `json:"perPage"`
		Total   float32       `json:"total"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFleetAgentPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetAgentPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFleetAgentPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item AgentPolicy `json:"item"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostFleetAgentPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFleetAgentPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFleetAgentPoliciesDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id   string `json:"id"`
		Name string `json:"name"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostFleetAgentPoliciesDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFleetAgentPoliciesDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFleetAgentPoliciesAgentpolicyidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item AgentPolicy `json:"item"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFleetAgentPoliciesAgentpolicyidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetAgentPoliciesAgentpolicyidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutFleetAgentPoliciesAgentpolicyidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item AgentPolicy `json:"item"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PutFleetAgentPoliciesAgentpolicyidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutFleetAgentPoliciesAgentpolicyidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFleetEnrollmentApiKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items []EnrollmentApiKey `json:"items"`
		// Deprecated:
		List []struct {
			// Active When false, the enrollment API key is revoked and cannot be used for enrolling Elastic Agents.
			Active bool `json:"active"`

			// ApiKey The enrollment API key (token) used for enrolling Elastic Agents.
			ApiKey string `json:"api_key"`

			// ApiKeyId The ID of the API key in the Security API.
			ApiKeyId  string `json:"api_key_id"`
			CreatedAt string `json:"created_at"`
			Id        string `json:"id"`

			// Name The name of the enrollment API key.
			Name *string `json:"name,omitempty"`

			// PolicyId The ID of the agent policy the Elastic Agent will be enrolled in.
			PolicyId *string `json:"policy_id,omitempty"`
		} `json:"list"`
		Page    float32 `json:"page"`
		PerPage float32 `json:"perPage"`
		Total   float32 `json:"total"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFleetEnrollmentApiKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetEnrollmentApiKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFleetEpmPackagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items []PackageListItem `json:"items"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFleetEpmPackagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetEpmPackagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFleetEpmPackagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostFleetEpmPackagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFleetEpmPackagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFleetEpmPackagesPkgnamePkgversionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items []DeleteFleetEpmPackagesPkgnamePkgversion_200_Items_Item `json:"items"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}
type DeleteFleetEpmPackagesPkgnamePkgversion200Items0 struct {
	Id       string                                               `json:"id"`
	OriginId *string                                              `json:"originId,omitempty"`
	Type     DeleteFleetEpmPackagesPkgnamePkgversion200Items0Type `json:"type"`
}
type DeleteFleetEpmPackagesPkgnamePkgversion200Items0Type string
type DeleteFleetEpmPackagesPkgnamePkgversion200Items1 struct {
	Deferred *bool                                                `json:"deferred,omitempty"`
	Id       string                                               `json:"id"`
	Type     DeleteFleetEpmPackagesPkgnamePkgversion200Items1Type `json:"type"`
	Version  *string                                              `json:"version,omitempty"`
}
type DeleteFleetEpmPackagesPkgnamePkgversion200Items1Type string
type DeleteFleetEpmPackagesPkgnamePkgversion_200_Items_Item struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r DeleteFleetEpmPackagesPkgnamePkgversionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFleetEpmPackagesPkgnamePkgversionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFleetEpmPackagesPkgnamePkgversionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item     PackageInfo `json:"item"`
		Metadata *struct {
			HasPolicies bool `json:"has_policies"`
		} `json:"metadata,omitempty"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFleetEpmPackagesPkgnamePkgversionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetEpmPackagesPkgnamePkgversionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFleetEpmPackagesPkgnamePkgversionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Meta struct {
			InstallSource string `json:"install_source"`
		} `json:"_meta"`
		Items []PostFleetEpmPackagesPkgnamePkgversion_200_Items_Item `json:"items"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}
type PostFleetEpmPackagesPkgnamePkgversion200Items0 struct {
	Id       string                                             `json:"id"`
	OriginId *string                                            `json:"originId,omitempty"`
	Type     PostFleetEpmPackagesPkgnamePkgversion200Items0Type `json:"type"`
}
type PostFleetEpmPackagesPkgnamePkgversion200Items0Type string
type PostFleetEpmPackagesPkgnamePkgversion200Items1 struct {
	Deferred *bool                                              `json:"deferred,omitempty"`
	Id       string                                             `json:"id"`
	Type     PostFleetEpmPackagesPkgnamePkgversion200Items1Type `json:"type"`
	Version  *string                                            `json:"version,omitempty"`
}
type PostFleetEpmPackagesPkgnamePkgversion200Items1Type string
type PostFleetEpmPackagesPkgnamePkgversion_200_Items_Item struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r PostFleetEpmPackagesPkgnamePkgversionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFleetEpmPackagesPkgnamePkgversionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFleetFleetServerHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items   []ServerHost `json:"items"`
		Page    float32      `json:"page"`
		PerPage float32      `json:"perPage"`
		Total   float32      `json:"total"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFleetFleetServerHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetFleetServerHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFleetFleetServerHostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item ServerHost `json:"item"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostFleetFleetServerHostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFleetFleetServerHostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFleetFleetServerHostsItemidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id string `json:"id"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteFleetFleetServerHostsItemidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFleetFleetServerHostsItemidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFleetFleetServerHostsItemidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item ServerHost `json:"item"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFleetFleetServerHostsItemidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetFleetServerHostsItemidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutFleetFleetServerHostsItemidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item ServerHost `json:"item"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PutFleetFleetServerHostsItemidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutFleetFleetServerHostsItemidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFleetOutputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items   []OutputUnion `json:"items"`
		Page    float32       `json:"page"`
		PerPage float32       `json:"perPage"`
		Total   float32       `json:"total"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFleetOutputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetOutputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFleetOutputsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item OutputUnion `json:"item"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostFleetOutputsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFleetOutputsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFleetOutputsOutputidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id string `json:"id"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
	JSON404 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteFleetOutputsOutputidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFleetOutputsOutputidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFleetOutputsOutputidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item OutputUnion `json:"item"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFleetOutputsOutputidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetOutputsOutputidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutFleetOutputsOutputidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item OutputUnion `json:"item"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PutFleetOutputsOutputidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutFleetOutputsOutputidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFleetPackagePoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Items   []PackagePolicy `json:"items"`
		Page    float32         `json:"page"`
		PerPage float32         `json:"perPage"`
		Total   float32         `json:"total"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFleetPackagePoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetPackagePoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFleetPackagePoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item PackagePolicy `json:"item"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
	JSON409 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostFleetPackagePoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFleetPackagePoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFleetPackagePoliciesPackagepolicyidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Id string `json:"id"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteFleetPackagePoliciesPackagepolicyidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFleetPackagePoliciesPackagepolicyidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFleetPackagePoliciesPackagepolicyidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item PackagePolicy `json:"item"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
	JSON404 *struct {
		Message string `json:"message"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFleetPackagePoliciesPackagepolicyidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFleetPackagePoliciesPackagepolicyidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutFleetPackagePoliciesPackagepolicyidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Item PackagePolicy `json:"item"`
	}
	JSON400 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
	JSON403 *struct {
		Error      *string  `json:"error,omitempty"`
		Message    string   `json:"message"`
		StatusCode *float32 `json:"statusCode,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PutFleetPackagePoliciesPackagepolicyidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutFleetPackagePoliciesPackagepolicyidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllDataViewsDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DataView *[]GetDataViewsResponseItem `json:"data_view,omitempty"`
	}
	JSON400 *DataViews400Response
}

// Status returns HTTPResponse.Status
func (r GetAllDataViewsDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllDataViewsDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDataViewDefaultwResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataViewsDataViewResponseObject
	JSON400      *DataViews400Response
}

// Status returns HTTPResponse.Status
func (r CreateDataViewDefaultwResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDataViewDefaultwResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDataViewDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *DataViews404Response
}

// Status returns HTTPResponse.Status
func (r DeleteDataViewDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDataViewDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataViewDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataViewsDataViewResponseObject
	JSON404      *DataViews404Response
}

// Status returns HTTPResponse.Status
func (r GetDataViewDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataViewDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDataViewDefaultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataViewsDataViewResponseObject
	JSON400      *DataViews400Response
}

// Status returns HTTPResponse.Status
func (r UpdateDataViewDefaultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDataViewDefaultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetFleetAgentPoliciesWithResponse request returning *GetFleetAgentPoliciesResponse
func (c *ClientWithResponses) GetFleetAgentPoliciesWithResponse(ctx context.Context, params *GetFleetAgentPoliciesParams, reqEditors ...RequestEditorFn) (*GetFleetAgentPoliciesResponse, error) {
	rsp, err := c.GetFleetAgentPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetAgentPoliciesResponse(rsp)
}

// PostFleetAgentPoliciesWithBodyWithResponse request with arbitrary body returning *PostFleetAgentPoliciesResponse
func (c *ClientWithResponses) PostFleetAgentPoliciesWithBodyWithResponse(ctx context.Context, params *PostFleetAgentPoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetAgentPoliciesResponse, error) {
	rsp, err := c.PostFleetAgentPoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetAgentPoliciesResponse(rsp)
}

func (c *ClientWithResponses) PostFleetAgentPoliciesWithResponse(ctx context.Context, params *PostFleetAgentPoliciesParams, body PostFleetAgentPoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetAgentPoliciesResponse, error) {
	rsp, err := c.PostFleetAgentPolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetAgentPoliciesResponse(rsp)
}

// PostFleetAgentPoliciesDeleteWithBodyWithResponse request with arbitrary body returning *PostFleetAgentPoliciesDeleteResponse
func (c *ClientWithResponses) PostFleetAgentPoliciesDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetAgentPoliciesDeleteResponse, error) {
	rsp, err := c.PostFleetAgentPoliciesDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetAgentPoliciesDeleteResponse(rsp)
}

func (c *ClientWithResponses) PostFleetAgentPoliciesDeleteWithResponse(ctx context.Context, body PostFleetAgentPoliciesDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetAgentPoliciesDeleteResponse, error) {
	rsp, err := c.PostFleetAgentPoliciesDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetAgentPoliciesDeleteResponse(rsp)
}

// GetFleetAgentPoliciesAgentpolicyidWithResponse request returning *GetFleetAgentPoliciesAgentpolicyidResponse
func (c *ClientWithResponses) GetFleetAgentPoliciesAgentpolicyidWithResponse(ctx context.Context, agentPolicyId string, params *GetFleetAgentPoliciesAgentpolicyidParams, reqEditors ...RequestEditorFn) (*GetFleetAgentPoliciesAgentpolicyidResponse, error) {
	rsp, err := c.GetFleetAgentPoliciesAgentpolicyid(ctx, agentPolicyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetAgentPoliciesAgentpolicyidResponse(rsp)
}

// PutFleetAgentPoliciesAgentpolicyidWithBodyWithResponse request with arbitrary body returning *PutFleetAgentPoliciesAgentpolicyidResponse
func (c *ClientWithResponses) PutFleetAgentPoliciesAgentpolicyidWithBodyWithResponse(ctx context.Context, agentPolicyId string, params *PutFleetAgentPoliciesAgentpolicyidParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutFleetAgentPoliciesAgentpolicyidResponse, error) {
	rsp, err := c.PutFleetAgentPoliciesAgentpolicyidWithBody(ctx, agentPolicyId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutFleetAgentPoliciesAgentpolicyidResponse(rsp)
}

func (c *ClientWithResponses) PutFleetAgentPoliciesAgentpolicyidWithResponse(ctx context.Context, agentPolicyId string, params *PutFleetAgentPoliciesAgentpolicyidParams, body PutFleetAgentPoliciesAgentpolicyidJSONRequestBody, reqEditors ...RequestEditorFn) (*PutFleetAgentPoliciesAgentpolicyidResponse, error) {
	rsp, err := c.PutFleetAgentPoliciesAgentpolicyid(ctx, agentPolicyId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutFleetAgentPoliciesAgentpolicyidResponse(rsp)
}

// GetFleetEnrollmentApiKeysWithResponse request returning *GetFleetEnrollmentApiKeysResponse
func (c *ClientWithResponses) GetFleetEnrollmentApiKeysWithResponse(ctx context.Context, params *GetFleetEnrollmentApiKeysParams, reqEditors ...RequestEditorFn) (*GetFleetEnrollmentApiKeysResponse, error) {
	rsp, err := c.GetFleetEnrollmentApiKeys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetEnrollmentApiKeysResponse(rsp)
}

// GetFleetEpmPackagesWithResponse request returning *GetFleetEpmPackagesResponse
func (c *ClientWithResponses) GetFleetEpmPackagesWithResponse(ctx context.Context, params *GetFleetEpmPackagesParams, reqEditors ...RequestEditorFn) (*GetFleetEpmPackagesResponse, error) {
	rsp, err := c.GetFleetEpmPackages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetEpmPackagesResponse(rsp)
}

// PostFleetEpmPackagesWithBodyWithResponse request with arbitrary body returning *PostFleetEpmPackagesResponse
func (c *ClientWithResponses) PostFleetEpmPackagesWithBodyWithResponse(ctx context.Context, params *PostFleetEpmPackagesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetEpmPackagesResponse, error) {
	rsp, err := c.PostFleetEpmPackagesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetEpmPackagesResponse(rsp)
}

// DeleteFleetEpmPackagesPkgnamePkgversionWithResponse request returning *DeleteFleetEpmPackagesPkgnamePkgversionResponse
func (c *ClientWithResponses) DeleteFleetEpmPackagesPkgnamePkgversionWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *DeleteFleetEpmPackagesPkgnamePkgversionParams, reqEditors ...RequestEditorFn) (*DeleteFleetEpmPackagesPkgnamePkgversionResponse, error) {
	rsp, err := c.DeleteFleetEpmPackagesPkgnamePkgversion(ctx, pkgName, pkgVersion, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFleetEpmPackagesPkgnamePkgversionResponse(rsp)
}

// GetFleetEpmPackagesPkgnamePkgversionWithResponse request returning *GetFleetEpmPackagesPkgnamePkgversionResponse
func (c *ClientWithResponses) GetFleetEpmPackagesPkgnamePkgversionWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *GetFleetEpmPackagesPkgnamePkgversionParams, reqEditors ...RequestEditorFn) (*GetFleetEpmPackagesPkgnamePkgversionResponse, error) {
	rsp, err := c.GetFleetEpmPackagesPkgnamePkgversion(ctx, pkgName, pkgVersion, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetEpmPackagesPkgnamePkgversionResponse(rsp)
}

// PostFleetEpmPackagesPkgnamePkgversionWithBodyWithResponse request with arbitrary body returning *PostFleetEpmPackagesPkgnamePkgversionResponse
func (c *ClientWithResponses) PostFleetEpmPackagesPkgnamePkgversionWithBodyWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *PostFleetEpmPackagesPkgnamePkgversionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetEpmPackagesPkgnamePkgversionResponse, error) {
	rsp, err := c.PostFleetEpmPackagesPkgnamePkgversionWithBody(ctx, pkgName, pkgVersion, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetEpmPackagesPkgnamePkgversionResponse(rsp)
}

func (c *ClientWithResponses) PostFleetEpmPackagesPkgnamePkgversionWithResponse(ctx context.Context, pkgName string, pkgVersion string, params *PostFleetEpmPackagesPkgnamePkgversionParams, body PostFleetEpmPackagesPkgnamePkgversionJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetEpmPackagesPkgnamePkgversionResponse, error) {
	rsp, err := c.PostFleetEpmPackagesPkgnamePkgversion(ctx, pkgName, pkgVersion, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetEpmPackagesPkgnamePkgversionResponse(rsp)
}

// GetFleetFleetServerHostsWithResponse request returning *GetFleetFleetServerHostsResponse
func (c *ClientWithResponses) GetFleetFleetServerHostsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFleetFleetServerHostsResponse, error) {
	rsp, err := c.GetFleetFleetServerHosts(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetFleetServerHostsResponse(rsp)
}

// PostFleetFleetServerHostsWithBodyWithResponse request with arbitrary body returning *PostFleetFleetServerHostsResponse
func (c *ClientWithResponses) PostFleetFleetServerHostsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetFleetServerHostsResponse, error) {
	rsp, err := c.PostFleetFleetServerHostsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetFleetServerHostsResponse(rsp)
}

func (c *ClientWithResponses) PostFleetFleetServerHostsWithResponse(ctx context.Context, body PostFleetFleetServerHostsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetFleetServerHostsResponse, error) {
	rsp, err := c.PostFleetFleetServerHosts(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetFleetServerHostsResponse(rsp)
}

// DeleteFleetFleetServerHostsItemidWithResponse request returning *DeleteFleetFleetServerHostsItemidResponse
func (c *ClientWithResponses) DeleteFleetFleetServerHostsItemidWithResponse(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*DeleteFleetFleetServerHostsItemidResponse, error) {
	rsp, err := c.DeleteFleetFleetServerHostsItemid(ctx, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFleetFleetServerHostsItemidResponse(rsp)
}

// GetFleetFleetServerHostsItemidWithResponse request returning *GetFleetFleetServerHostsItemidResponse
func (c *ClientWithResponses) GetFleetFleetServerHostsItemidWithResponse(ctx context.Context, itemId string, reqEditors ...RequestEditorFn) (*GetFleetFleetServerHostsItemidResponse, error) {
	rsp, err := c.GetFleetFleetServerHostsItemid(ctx, itemId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetFleetServerHostsItemidResponse(rsp)
}

// PutFleetFleetServerHostsItemidWithBodyWithResponse request with arbitrary body returning *PutFleetFleetServerHostsItemidResponse
func (c *ClientWithResponses) PutFleetFleetServerHostsItemidWithBodyWithResponse(ctx context.Context, itemId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutFleetFleetServerHostsItemidResponse, error) {
	rsp, err := c.PutFleetFleetServerHostsItemidWithBody(ctx, itemId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutFleetFleetServerHostsItemidResponse(rsp)
}

func (c *ClientWithResponses) PutFleetFleetServerHostsItemidWithResponse(ctx context.Context, itemId string, body PutFleetFleetServerHostsItemidJSONRequestBody, reqEditors ...RequestEditorFn) (*PutFleetFleetServerHostsItemidResponse, error) {
	rsp, err := c.PutFleetFleetServerHostsItemid(ctx, itemId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutFleetFleetServerHostsItemidResponse(rsp)
}

// GetFleetOutputsWithResponse request returning *GetFleetOutputsResponse
func (c *ClientWithResponses) GetFleetOutputsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFleetOutputsResponse, error) {
	rsp, err := c.GetFleetOutputs(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetOutputsResponse(rsp)
}

// PostFleetOutputsWithBodyWithResponse request with arbitrary body returning *PostFleetOutputsResponse
func (c *ClientWithResponses) PostFleetOutputsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetOutputsResponse, error) {
	rsp, err := c.PostFleetOutputsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetOutputsResponse(rsp)
}

func (c *ClientWithResponses) PostFleetOutputsWithResponse(ctx context.Context, body PostFleetOutputsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetOutputsResponse, error) {
	rsp, err := c.PostFleetOutputs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetOutputsResponse(rsp)
}

// DeleteFleetOutputsOutputidWithResponse request returning *DeleteFleetOutputsOutputidResponse
func (c *ClientWithResponses) DeleteFleetOutputsOutputidWithResponse(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*DeleteFleetOutputsOutputidResponse, error) {
	rsp, err := c.DeleteFleetOutputsOutputid(ctx, outputId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFleetOutputsOutputidResponse(rsp)
}

// GetFleetOutputsOutputidWithResponse request returning *GetFleetOutputsOutputidResponse
func (c *ClientWithResponses) GetFleetOutputsOutputidWithResponse(ctx context.Context, outputId string, reqEditors ...RequestEditorFn) (*GetFleetOutputsOutputidResponse, error) {
	rsp, err := c.GetFleetOutputsOutputid(ctx, outputId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetOutputsOutputidResponse(rsp)
}

// PutFleetOutputsOutputidWithBodyWithResponse request with arbitrary body returning *PutFleetOutputsOutputidResponse
func (c *ClientWithResponses) PutFleetOutputsOutputidWithBodyWithResponse(ctx context.Context, outputId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutFleetOutputsOutputidResponse, error) {
	rsp, err := c.PutFleetOutputsOutputidWithBody(ctx, outputId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutFleetOutputsOutputidResponse(rsp)
}

func (c *ClientWithResponses) PutFleetOutputsOutputidWithResponse(ctx context.Context, outputId string, body PutFleetOutputsOutputidJSONRequestBody, reqEditors ...RequestEditorFn) (*PutFleetOutputsOutputidResponse, error) {
	rsp, err := c.PutFleetOutputsOutputid(ctx, outputId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutFleetOutputsOutputidResponse(rsp)
}

// GetFleetPackagePoliciesWithResponse request returning *GetFleetPackagePoliciesResponse
func (c *ClientWithResponses) GetFleetPackagePoliciesWithResponse(ctx context.Context, params *GetFleetPackagePoliciesParams, reqEditors ...RequestEditorFn) (*GetFleetPackagePoliciesResponse, error) {
	rsp, err := c.GetFleetPackagePolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetPackagePoliciesResponse(rsp)
}

// PostFleetPackagePoliciesWithBodyWithResponse request with arbitrary body returning *PostFleetPackagePoliciesResponse
func (c *ClientWithResponses) PostFleetPackagePoliciesWithBodyWithResponse(ctx context.Context, params *PostFleetPackagePoliciesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFleetPackagePoliciesResponse, error) {
	rsp, err := c.PostFleetPackagePoliciesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetPackagePoliciesResponse(rsp)
}

func (c *ClientWithResponses) PostFleetPackagePoliciesWithResponse(ctx context.Context, params *PostFleetPackagePoliciesParams, body PostFleetPackagePoliciesJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFleetPackagePoliciesResponse, error) {
	rsp, err := c.PostFleetPackagePolicies(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFleetPackagePoliciesResponse(rsp)
}

// DeleteFleetPackagePoliciesPackagepolicyidWithResponse request returning *DeleteFleetPackagePoliciesPackagepolicyidResponse
func (c *ClientWithResponses) DeleteFleetPackagePoliciesPackagepolicyidWithResponse(ctx context.Context, packagePolicyId string, params *DeleteFleetPackagePoliciesPackagepolicyidParams, reqEditors ...RequestEditorFn) (*DeleteFleetPackagePoliciesPackagepolicyidResponse, error) {
	rsp, err := c.DeleteFleetPackagePoliciesPackagepolicyid(ctx, packagePolicyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFleetPackagePoliciesPackagepolicyidResponse(rsp)
}

// GetFleetPackagePoliciesPackagepolicyidWithResponse request returning *GetFleetPackagePoliciesPackagepolicyidResponse
func (c *ClientWithResponses) GetFleetPackagePoliciesPackagepolicyidWithResponse(ctx context.Context, packagePolicyId string, params *GetFleetPackagePoliciesPackagepolicyidParams, reqEditors ...RequestEditorFn) (*GetFleetPackagePoliciesPackagepolicyidResponse, error) {
	rsp, err := c.GetFleetPackagePoliciesPackagepolicyid(ctx, packagePolicyId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFleetPackagePoliciesPackagepolicyidResponse(rsp)
}

// PutFleetPackagePoliciesPackagepolicyidWithBodyWithResponse request with arbitrary body returning *PutFleetPackagePoliciesPackagepolicyidResponse
func (c *ClientWithResponses) PutFleetPackagePoliciesPackagepolicyidWithBodyWithResponse(ctx context.Context, packagePolicyId string, params *PutFleetPackagePoliciesPackagepolicyidParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutFleetPackagePoliciesPackagepolicyidResponse, error) {
	rsp, err := c.PutFleetPackagePoliciesPackagepolicyidWithBody(ctx, packagePolicyId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutFleetPackagePoliciesPackagepolicyidResponse(rsp)
}

func (c *ClientWithResponses) PutFleetPackagePoliciesPackagepolicyidWithResponse(ctx context.Context, packagePolicyId string, params *PutFleetPackagePoliciesPackagepolicyidParams, body PutFleetPackagePoliciesPackagepolicyidJSONRequestBody, reqEditors ...RequestEditorFn) (*PutFleetPackagePoliciesPackagepolicyidResponse, error) {
	rsp, err := c.PutFleetPackagePoliciesPackagepolicyid(ctx, packagePolicyId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutFleetPackagePoliciesPackagepolicyidResponse(rsp)
}

// GetAllDataViewsDefaultWithResponse request returning *GetAllDataViewsDefaultResponse
func (c *ClientWithResponses) GetAllDataViewsDefaultWithResponse(ctx context.Context, spaceId SpaceId, reqEditors ...RequestEditorFn) (*GetAllDataViewsDefaultResponse, error) {
	rsp, err := c.GetAllDataViewsDefault(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllDataViewsDefaultResponse(rsp)
}

// CreateDataViewDefaultwWithBodyWithResponse request with arbitrary body returning *CreateDataViewDefaultwResponse
func (c *ClientWithResponses) CreateDataViewDefaultwWithBodyWithResponse(ctx context.Context, spaceId SpaceId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDataViewDefaultwResponse, error) {
	rsp, err := c.CreateDataViewDefaultwWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDataViewDefaultwResponse(rsp)
}

func (c *ClientWithResponses) CreateDataViewDefaultwWithResponse(ctx context.Context, spaceId SpaceId, body CreateDataViewDefaultwJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDataViewDefaultwResponse, error) {
	rsp, err := c.CreateDataViewDefaultw(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDataViewDefaultwResponse(rsp)
}

// DeleteDataViewDefaultWithResponse request returning *DeleteDataViewDefaultResponse
func (c *ClientWithResponses) DeleteDataViewDefaultWithResponse(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, reqEditors ...RequestEditorFn) (*DeleteDataViewDefaultResponse, error) {
	rsp, err := c.DeleteDataViewDefault(ctx, spaceId, viewId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDataViewDefaultResponse(rsp)
}

// GetDataViewDefaultWithResponse request returning *GetDataViewDefaultResponse
func (c *ClientWithResponses) GetDataViewDefaultWithResponse(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, reqEditors ...RequestEditorFn) (*GetDataViewDefaultResponse, error) {
	rsp, err := c.GetDataViewDefault(ctx, spaceId, viewId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataViewDefaultResponse(rsp)
}

// UpdateDataViewDefaultWithBodyWithResponse request with arbitrary body returning *UpdateDataViewDefaultResponse
func (c *ClientWithResponses) UpdateDataViewDefaultWithBodyWithResponse(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDataViewDefaultResponse, error) {
	rsp, err := c.UpdateDataViewDefaultWithBody(ctx, spaceId, viewId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDataViewDefaultResponse(rsp)
}

func (c *ClientWithResponses) UpdateDataViewDefaultWithResponse(ctx context.Context, spaceId SpaceId, viewId DataViewsViewId, body UpdateDataViewDefaultJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDataViewDefaultResponse, error) {
	rsp, err := c.UpdateDataViewDefault(ctx, spaceId, viewId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDataViewDefaultResponse(rsp)
}

// ParseGetFleetAgentPoliciesResponse parses an HTTP response from a GetFleetAgentPoliciesWithResponse call
func ParseGetFleetAgentPoliciesResponse(rsp *http.Response) (*GetFleetAgentPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetAgentPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items   []AgentPolicy `json:"items"`
			Page    float32       `json:"page"`
			PerPage float32       `json:"perPage"`
			Total   float32       `json:"total"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostFleetAgentPoliciesResponse parses an HTTP response from a PostFleetAgentPoliciesWithResponse call
func ParsePostFleetAgentPoliciesResponse(rsp *http.Response) (*PostFleetAgentPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFleetAgentPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item AgentPolicy `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostFleetAgentPoliciesDeleteResponse parses an HTTP response from a PostFleetAgentPoliciesDeleteWithResponse call
func ParsePostFleetAgentPoliciesDeleteResponse(rsp *http.Response) (*PostFleetAgentPoliciesDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFleetAgentPoliciesDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id   string `json:"id"`
			Name string `json:"name"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFleetAgentPoliciesAgentpolicyidResponse parses an HTTP response from a GetFleetAgentPoliciesAgentpolicyidWithResponse call
func ParseGetFleetAgentPoliciesAgentpolicyidResponse(rsp *http.Response) (*GetFleetAgentPoliciesAgentpolicyidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetAgentPoliciesAgentpolicyidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item AgentPolicy `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePutFleetAgentPoliciesAgentpolicyidResponse parses an HTTP response from a PutFleetAgentPoliciesAgentpolicyidWithResponse call
func ParsePutFleetAgentPoliciesAgentpolicyidResponse(rsp *http.Response) (*PutFleetAgentPoliciesAgentpolicyidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutFleetAgentPoliciesAgentpolicyidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item AgentPolicy `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFleetEnrollmentApiKeysResponse parses an HTTP response from a GetFleetEnrollmentApiKeysWithResponse call
func ParseGetFleetEnrollmentApiKeysResponse(rsp *http.Response) (*GetFleetEnrollmentApiKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetEnrollmentApiKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items []EnrollmentApiKey `json:"items"`
			// Deprecated:
			List []struct {
				// Active When false, the enrollment API key is revoked and cannot be used for enrolling Elastic Agents.
				Active bool `json:"active"`

				// ApiKey The enrollment API key (token) used for enrolling Elastic Agents.
				ApiKey string `json:"api_key"`

				// ApiKeyId The ID of the API key in the Security API.
				ApiKeyId  string `json:"api_key_id"`
				CreatedAt string `json:"created_at"`
				Id        string `json:"id"`

				// Name The name of the enrollment API key.
				Name *string `json:"name,omitempty"`

				// PolicyId The ID of the agent policy the Elastic Agent will be enrolled in.
				PolicyId *string `json:"policy_id,omitempty"`
			} `json:"list"`
			Page    float32 `json:"page"`
			PerPage float32 `json:"perPage"`
			Total   float32 `json:"total"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFleetEpmPackagesResponse parses an HTTP response from a GetFleetEpmPackagesWithResponse call
func ParseGetFleetEpmPackagesResponse(rsp *http.Response) (*GetFleetEpmPackagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetEpmPackagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items []PackageListItem `json:"items"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostFleetEpmPackagesResponse parses an HTTP response from a PostFleetEpmPackagesWithResponse call
func ParsePostFleetEpmPackagesResponse(rsp *http.Response) (*PostFleetEpmPackagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFleetEpmPackagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteFleetEpmPackagesPkgnamePkgversionResponse parses an HTTP response from a DeleteFleetEpmPackagesPkgnamePkgversionWithResponse call
func ParseDeleteFleetEpmPackagesPkgnamePkgversionResponse(rsp *http.Response) (*DeleteFleetEpmPackagesPkgnamePkgversionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFleetEpmPackagesPkgnamePkgversionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items []DeleteFleetEpmPackagesPkgnamePkgversion_200_Items_Item `json:"items"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFleetEpmPackagesPkgnamePkgversionResponse parses an HTTP response from a GetFleetEpmPackagesPkgnamePkgversionWithResponse call
func ParseGetFleetEpmPackagesPkgnamePkgversionResponse(rsp *http.Response) (*GetFleetEpmPackagesPkgnamePkgversionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetEpmPackagesPkgnamePkgversionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item     PackageInfo `json:"item"`
			Metadata *struct {
				HasPolicies bool `json:"has_policies"`
			} `json:"metadata,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostFleetEpmPackagesPkgnamePkgversionResponse parses an HTTP response from a PostFleetEpmPackagesPkgnamePkgversionWithResponse call
func ParsePostFleetEpmPackagesPkgnamePkgversionResponse(rsp *http.Response) (*PostFleetEpmPackagesPkgnamePkgversionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFleetEpmPackagesPkgnamePkgversionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Meta struct {
				InstallSource string `json:"install_source"`
			} `json:"_meta"`
			Items []PostFleetEpmPackagesPkgnamePkgversion_200_Items_Item `json:"items"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFleetFleetServerHostsResponse parses an HTTP response from a GetFleetFleetServerHostsWithResponse call
func ParseGetFleetFleetServerHostsResponse(rsp *http.Response) (*GetFleetFleetServerHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetFleetServerHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items   []ServerHost `json:"items"`
			Page    float32      `json:"page"`
			PerPage float32      `json:"perPage"`
			Total   float32      `json:"total"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostFleetFleetServerHostsResponse parses an HTTP response from a PostFleetFleetServerHostsWithResponse call
func ParsePostFleetFleetServerHostsResponse(rsp *http.Response) (*PostFleetFleetServerHostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFleetFleetServerHostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item ServerHost `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteFleetFleetServerHostsItemidResponse parses an HTTP response from a DeleteFleetFleetServerHostsItemidWithResponse call
func ParseDeleteFleetFleetServerHostsItemidResponse(rsp *http.Response) (*DeleteFleetFleetServerHostsItemidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFleetFleetServerHostsItemidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFleetFleetServerHostsItemidResponse parses an HTTP response from a GetFleetFleetServerHostsItemidWithResponse call
func ParseGetFleetFleetServerHostsItemidResponse(rsp *http.Response) (*GetFleetFleetServerHostsItemidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetFleetServerHostsItemidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item ServerHost `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePutFleetFleetServerHostsItemidResponse parses an HTTP response from a PutFleetFleetServerHostsItemidWithResponse call
func ParsePutFleetFleetServerHostsItemidResponse(rsp *http.Response) (*PutFleetFleetServerHostsItemidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutFleetFleetServerHostsItemidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item ServerHost `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFleetOutputsResponse parses an HTTP response from a GetFleetOutputsWithResponse call
func ParseGetFleetOutputsResponse(rsp *http.Response) (*GetFleetOutputsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetOutputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items   []OutputUnion `json:"items"`
			Page    float32       `json:"page"`
			PerPage float32       `json:"perPage"`
			Total   float32       `json:"total"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostFleetOutputsResponse parses an HTTP response from a PostFleetOutputsWithResponse call
func ParsePostFleetOutputsResponse(rsp *http.Response) (*PostFleetOutputsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFleetOutputsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item OutputUnion `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteFleetOutputsOutputidResponse parses an HTTP response from a DeleteFleetOutputsOutputidWithResponse call
func ParseDeleteFleetOutputsOutputidResponse(rsp *http.Response) (*DeleteFleetOutputsOutputidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFleetOutputsOutputidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetFleetOutputsOutputidResponse parses an HTTP response from a GetFleetOutputsOutputidWithResponse call
func ParseGetFleetOutputsOutputidResponse(rsp *http.Response) (*GetFleetOutputsOutputidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetOutputsOutputidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item OutputUnion `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePutFleetOutputsOutputidResponse parses an HTTP response from a PutFleetOutputsOutputidWithResponse call
func ParsePutFleetOutputsOutputidResponse(rsp *http.Response) (*PutFleetOutputsOutputidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutFleetOutputsOutputidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item OutputUnion `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFleetPackagePoliciesResponse parses an HTTP response from a GetFleetPackagePoliciesWithResponse call
func ParseGetFleetPackagePoliciesResponse(rsp *http.Response) (*GetFleetPackagePoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetPackagePoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Items   []PackagePolicy `json:"items"`
			Page    float32         `json:"page"`
			PerPage float32         `json:"perPage"`
			Total   float32         `json:"total"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostFleetPackagePoliciesResponse parses an HTTP response from a PostFleetPackagePoliciesWithResponse call
func ParsePostFleetPackagePoliciesResponse(rsp *http.Response) (*PostFleetPackagePoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFleetPackagePoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item PackagePolicy `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteFleetPackagePoliciesPackagepolicyidResponse parses an HTTP response from a DeleteFleetPackagePoliciesPackagepolicyidWithResponse call
func ParseDeleteFleetPackagePoliciesPackagepolicyidResponse(rsp *http.Response) (*DeleteFleetPackagePoliciesPackagepolicyidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFleetPackagePoliciesPackagepolicyidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Id string `json:"id"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFleetPackagePoliciesPackagepolicyidResponse parses an HTTP response from a GetFleetPackagePoliciesPackagepolicyidWithResponse call
func ParseGetFleetPackagePoliciesPackagepolicyidResponse(rsp *http.Response) (*GetFleetPackagePoliciesPackagepolicyidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFleetPackagePoliciesPackagepolicyidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item PackagePolicy `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest struct {
			Message string `json:"message"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutFleetPackagePoliciesPackagepolicyidResponse parses an HTTP response from a PutFleetPackagePoliciesPackagepolicyidWithResponse call
func ParsePutFleetPackagePoliciesPackagepolicyidResponse(rsp *http.Response) (*PutFleetPackagePoliciesPackagepolicyidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutFleetPackagePoliciesPackagepolicyidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Item PackagePolicy `json:"item"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest struct {
			Error      *string  `json:"error,omitempty"`
			Message    string   `json:"message"`
			StatusCode *float32 `json:"statusCode,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetAllDataViewsDefaultResponse parses an HTTP response from a GetAllDataViewsDefaultWithResponse call
func ParseGetAllDataViewsDefaultResponse(rsp *http.Response) (*GetAllDataViewsDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllDataViewsDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DataView *[]GetDataViewsResponseItem `json:"data_view,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest DataViews400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateDataViewDefaultwResponse parses an HTTP response from a CreateDataViewDefaultwWithResponse call
func ParseCreateDataViewDefaultwResponse(rsp *http.Response) (*CreateDataViewDefaultwResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDataViewDefaultwResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataViewsDataViewResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest DataViews400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteDataViewDefaultResponse parses an HTTP response from a DeleteDataViewDefaultWithResponse call
func ParseDeleteDataViewDefaultResponse(rsp *http.Response) (*DeleteDataViewDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDataViewDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest DataViews404Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetDataViewDefaultResponse parses an HTTP response from a GetDataViewDefaultWithResponse call
func ParseGetDataViewDefaultResponse(rsp *http.Response) (*GetDataViewDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataViewDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataViewsDataViewResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest DataViews404Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateDataViewDefaultResponse parses an HTTP response from a UpdateDataViewDefaultWithResponse call
func ParseUpdateDataViewDefaultResponse(rsp *http.Response) (*UpdateDataViewDefaultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDataViewDefaultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataViewsDataViewResponseObject
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest DataViews400Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}
