/*
Alerting

OpenAPI schema for alerting endpoints

API version: 0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package alerting

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"strings"
)

type AlertingAPI interface {

	/*
		CreateRule Creates a rule.

		You must have `all` privileges for the appropriate Kibana features, depending on the `consumer` and `rule_type_id` of the rule you're creating. For example, you must have privileges for the **Management > Stack rules** feature, **Analytics > Discover** and **Machine Learning** features, **Observability** features, or **Security** features.  If the rule has actions, you must also have `read` privileges for the **Management > Actions and Connectors** feature. NOTE: This API supports only token-based authentication. When you create a rule, it identifies which roles you have at that point in time. Thereafter, when the rule performs queries, it uses those security privileges. If a user with different privileges updates the rule, its behavior might change.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@param ruleId An UUID v1 or v4 identifier for the rule. If you omit this parameter, an identifier is randomly generated.
		@return ApiCreateRuleRequest
	*/
	CreateRule(ctx context.Context, spaceId string, ruleId string) ApiCreateRuleRequest

	// CreateRuleExecute executes the request
	//  @return RuleResponseProperties
	CreateRuleExecute(r ApiCreateRuleRequest) (*RuleResponseProperties, *http.Response, error)

	/*
		DeleteRule Deletes a rule.

		You must have `all` privileges for the appropriate Kibana features, depending on the `consumer` and `rule_type_id` of the rule you're deleting. For example, the **Management** > **Stack Rules** feature, **Analytics** > **Discover** or **Machine Learning** features, **Observability**, or **Security** features. WARNING: After you delete a rule, you cannot recover it.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param ruleId An identifier for the rule.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiDeleteRuleRequest
	*/
	DeleteRule(ctx context.Context, ruleId string, spaceId string) ApiDeleteRuleRequest

	// DeleteRuleExecute executes the request
	DeleteRuleExecute(r ApiDeleteRuleRequest) (*http.Response, error)

	/*
		DisableRule Disables a rule.

		You must have `all` privileges for the appropriate Kibana features, depending on the `consumer` and `rule_type_id` of the rule. For example, the **Management > Stack Rules** feature, **Analytics > Discover** and **Machine Learning** features, **Observability**, and **Security** features.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param ruleId An identifier for the rule.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiDisableRuleRequest
	*/
	DisableRule(ctx context.Context, ruleId string, spaceId string) ApiDisableRuleRequest

	// DisableRuleExecute executes the request
	DisableRuleExecute(r ApiDisableRuleRequest) (*http.Response, error)

	/*
		EnableRule Enables a rule.

		This API supports token-based authentication only. You must have `all` privileges for the appropriate Kibana features, depending on the `consumer` and `rule_type_id` of the rule. For example, the **Management > Stack Rules** feature, **Analytics > Discover** and **Machine Learning** features, **Observability**, and **Security** features.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param ruleId An identifier for the rule.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiEnableRuleRequest
	*/
	EnableRule(ctx context.Context, ruleId string, spaceId string) ApiEnableRuleRequest

	// EnableRuleExecute executes the request
	EnableRuleExecute(r ApiEnableRuleRequest) (*http.Response, error)

	/*
		FindRules Retrieves information about rules.

		You must have `read` privileges for the appropriate Kibana features, depending on the `consumer` and `rule_type_id` of the rules you're seeking. For example, you must have privileges for the **Management > Stack rules** feature, **Analytics > Discover** and **Machine Learning** features, **Observability** features, or **Security** features. To find rules associated with the **Stack Monitoring** feature, use the `monitoring_user` built-in role.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiFindRulesRequest
	*/
	FindRules(ctx context.Context, spaceId string) ApiFindRulesRequest

	// FindRulesExecute executes the request
	//  @return FindRules200Response
	FindRulesExecute(r ApiFindRulesRequest) (*FindRules200Response, *http.Response, error)

	/*
		GetAlertingHealth Retrieves the health status of the alerting framework.

		You must have `read` privileges for the **Management > Stack Rules** feature or for at least one of the **Analytics > Discover**, **Analytics > Machine Learning**, **Observability**, or **Security** features.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiGetAlertingHealthRequest
	*/
	GetAlertingHealth(ctx context.Context, spaceId string) ApiGetAlertingHealthRequest

	// GetAlertingHealthExecute executes the request
	//  @return GetAlertingHealth200Response
	GetAlertingHealthExecute(r ApiGetAlertingHealthRequest) (*GetAlertingHealth200Response, *http.Response, error)

	/*
		GetRule Retrieves a rule by its identifier.

		You must have `read` privileges for the appropriate Kibana features, depending on the `consumer` and `rule_type_id` of the rules you're seeking. For example, the **Management > Stack Rules** feature, **Analytics > Discover** and **Machine Learning** features, **Observability** features, or **Security** features. To get rules associated with the **Stack Monitoring** feature, use the `monitoring_user` built-in role.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param ruleId An identifier for the rule.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiGetRuleRequest
	*/
	GetRule(ctx context.Context, ruleId string, spaceId string) ApiGetRuleRequest

	// GetRuleExecute executes the request
	//  @return RuleResponseProperties
	GetRuleExecute(r ApiGetRuleRequest) (*RuleResponseProperties, *http.Response, error)

	/*
		GetRuleTypes Retrieves a list of rule types.

		If you have `read` privileges for one or more Kibana features, the API response contains information about the appropriate rule types. For example, there are rule types associated with the **Management > Stack Rules** feature, **Analytics > Discover** and **Machine Learning** features, **Observability** features, and **Security** features. To get rule types associated with the **Stack Monitoring** feature, use the `monitoring_user` built-in role.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiGetRuleTypesRequest
	*/
	GetRuleTypes(ctx context.Context, spaceId string) ApiGetRuleTypesRequest

	// GetRuleTypesExecute executes the request
	//  @return []GetRuleTypes200ResponseInner
	GetRuleTypesExecute(r ApiGetRuleTypesRequest) ([]GetRuleTypes200ResponseInner, *http.Response, error)

	/*
		LegacyCreateAlert Create an alert.

		Deprecated in 7.13.0. Use the create rule API instead.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param alertId An UUID v1 or v4 identifier for the alert. If this parameter is omitted, the identifier is randomly generated.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiLegacyCreateAlertRequest

		Deprecated
	*/
	LegacyCreateAlert(ctx context.Context, alertId string, spaceId string) ApiLegacyCreateAlertRequest

	// LegacyCreateAlertExecute executes the request
	//  @return AlertResponseProperties
	// Deprecated
	LegacyCreateAlertExecute(r ApiLegacyCreateAlertRequest) (*AlertResponseProperties, *http.Response, error)

	/*
		LegacyDisableAlert Disables an alert.

		Deprecated in 7.13.0. Use the disable rule API instead.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@param alertId The identifier for the alert.
		@return ApiLegacyDisableAlertRequest

		Deprecated
	*/
	LegacyDisableAlert(ctx context.Context, spaceId string, alertId string) ApiLegacyDisableAlertRequest

	// LegacyDisableAlertExecute executes the request
	// Deprecated
	LegacyDisableAlertExecute(r ApiLegacyDisableAlertRequest) (*http.Response, error)

	/*
		LegacyEnableAlert Enables an alert.

		Deprecated in 7.13.0. Use the enable rule API instead.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@param alertId The identifier for the alert.
		@return ApiLegacyEnableAlertRequest

		Deprecated
	*/
	LegacyEnableAlert(ctx context.Context, spaceId string, alertId string) ApiLegacyEnableAlertRequest

	// LegacyEnableAlertExecute executes the request
	// Deprecated
	LegacyEnableAlertExecute(r ApiLegacyEnableAlertRequest) (*http.Response, error)

	/*
		LegacyFindAlerts Retrieves a paginated set of alerts.

		Deprecated in 7.13.0. Use the find rules API instead. NOTE: Alert `params` are stored as a flattened field type and analyzed as keywords. As alerts change in Kibana, the results on each page of the response also change. Use the find API for traditional paginated results, but avoid using it to export large amounts of data.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiLegacyFindAlertsRequest

		Deprecated
	*/
	LegacyFindAlerts(ctx context.Context, spaceId string) ApiLegacyFindAlertsRequest

	// LegacyFindAlertsExecute executes the request
	//  @return LegacyFindAlerts200Response
	// Deprecated
	LegacyFindAlertsExecute(r ApiLegacyFindAlertsRequest) (*LegacyFindAlerts200Response, *http.Response, error)

	/*
		LegacyGetAlert Retrieves an alert by its identifier.

		Deprecated in 7.13.0. Use the get rule API instead.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@param alertId The identifier for the alert.
		@return ApiLegacyGetAlertRequest

		Deprecated
	*/
	LegacyGetAlert(ctx context.Context, spaceId string, alertId string) ApiLegacyGetAlertRequest

	// LegacyGetAlertExecute executes the request
	//  @return AlertResponseProperties
	// Deprecated
	LegacyGetAlertExecute(r ApiLegacyGetAlertRequest) (*AlertResponseProperties, *http.Response, error)

	/*
		LegacyGetAlertTypes Retrieves a list of alert types.

		Deprecated in 7.13.0. Use the get rule types API instead.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiLegacyGetAlertTypesRequest

		Deprecated
	*/
	LegacyGetAlertTypes(ctx context.Context, spaceId string) ApiLegacyGetAlertTypesRequest

	// LegacyGetAlertTypesExecute executes the request
	//  @return []LegacyGetAlertTypes200ResponseInner
	// Deprecated
	LegacyGetAlertTypesExecute(r ApiLegacyGetAlertTypesRequest) ([]LegacyGetAlertTypes200ResponseInner, *http.Response, error)

	/*
		LegacyGetAlertingHealth Retrieves the health status of the alerting framework.

		Deprecated in 7.13.0. Use the get alerting framework health API instead.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiLegacyGetAlertingHealthRequest

		Deprecated
	*/
	LegacyGetAlertingHealth(ctx context.Context, spaceId string) ApiLegacyGetAlertingHealthRequest

	// LegacyGetAlertingHealthExecute executes the request
	//  @return LegacyGetAlertingHealth200Response
	// Deprecated
	LegacyGetAlertingHealthExecute(r ApiLegacyGetAlertingHealthRequest) (*LegacyGetAlertingHealth200Response, *http.Response, error)

	/*
		LegacyMuteAlertInstance Mutes an alert instance.

		Deprecated in 7.13.0. Use the mute alert API instead.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@param alertId An identifier for the alert.
		@param alertInstanceId An identifier for the alert instance.
		@return ApiLegacyMuteAlertInstanceRequest

		Deprecated
	*/
	LegacyMuteAlertInstance(ctx context.Context, spaceId string, alertId string, alertInstanceId string) ApiLegacyMuteAlertInstanceRequest

	// LegacyMuteAlertInstanceExecute executes the request
	// Deprecated
	LegacyMuteAlertInstanceExecute(r ApiLegacyMuteAlertInstanceRequest) (*http.Response, error)

	/*
		LegacyMuteAllAlertInstances Mutes all alert instances.

		Deprecated in 7.13.0. Use the mute all alerts API instead.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@param alertId The identifier for the alert.
		@return ApiLegacyMuteAllAlertInstancesRequest

		Deprecated
	*/
	LegacyMuteAllAlertInstances(ctx context.Context, spaceId string, alertId string) ApiLegacyMuteAllAlertInstancesRequest

	// LegacyMuteAllAlertInstancesExecute executes the request
	// Deprecated
	LegacyMuteAllAlertInstancesExecute(r ApiLegacyMuteAllAlertInstancesRequest) (*http.Response, error)

	/*
		LegacyUnmuteAlertInstance Unmutes an alert instance.

		Deprecated in 7.13.0. Use the unmute alert API instead.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@param alertId An identifier for the alert.
		@param alertInstanceId An identifier for the alert instance.
		@return ApiLegacyUnmuteAlertInstanceRequest

		Deprecated
	*/
	LegacyUnmuteAlertInstance(ctx context.Context, spaceId string, alertId string, alertInstanceId string) ApiLegacyUnmuteAlertInstanceRequest

	// LegacyUnmuteAlertInstanceExecute executes the request
	// Deprecated
	LegacyUnmuteAlertInstanceExecute(r ApiLegacyUnmuteAlertInstanceRequest) (*http.Response, error)

	/*
		LegacyUnmuteAllAlertInstances Unmutes all alert instances.

		Deprecated in 7.13.0. Use the unmute all alerts API instead.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@param alertId The identifier for the alert.
		@return ApiLegacyUnmuteAllAlertInstancesRequest

		Deprecated
	*/
	LegacyUnmuteAllAlertInstances(ctx context.Context, spaceId string, alertId string) ApiLegacyUnmuteAllAlertInstancesRequest

	// LegacyUnmuteAllAlertInstancesExecute executes the request
	// Deprecated
	LegacyUnmuteAllAlertInstancesExecute(r ApiLegacyUnmuteAllAlertInstancesRequest) (*http.Response, error)

	/*
		LegacyUpdateAlert Updates the attributes for an alert.

		Deprecated in 7.13.0. Use the update rule API instead.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@param alertId The identifier for the alert.
		@return ApiLegacyUpdateAlertRequest

		Deprecated
	*/
	LegacyUpdateAlert(ctx context.Context, spaceId string, alertId string) ApiLegacyUpdateAlertRequest

	// LegacyUpdateAlertExecute executes the request
	//  @return AlertResponseProperties
	// Deprecated
	LegacyUpdateAlertExecute(r ApiLegacyUpdateAlertRequest) (*AlertResponseProperties, *http.Response, error)

	/*
		LegaryDeleteAlert Permanently removes an alert.

		Deprecated in 7.13.0. Use the delete rule API instead. WARNING: After you delete an alert, you cannot recover it.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@param alertId The identifier for the alert.
		@return ApiLegaryDeleteAlertRequest

		Deprecated
	*/
	LegaryDeleteAlert(ctx context.Context, spaceId string, alertId string) ApiLegaryDeleteAlertRequest

	// LegaryDeleteAlertExecute executes the request
	// Deprecated
	LegaryDeleteAlertExecute(r ApiLegaryDeleteAlertRequest) (*http.Response, error)

	/*
		MuteAlert Mutes an alert.

		You must have `all` privileges for the appropriate Kibana features, depending on the `consumer` and `rule_type_id` of the rule. For example, the **Management > Stack Rules** feature, **Analytics > Discover** and **Machine Learning** features, **Observability**, and **Security** features. If the rule has actions, you must also have `read` privileges for the **Management > Actions and Connectors** feature.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param alertId An identifier for the alert. The identifier is generated by the rule and might be any arbitrary string.
		@param ruleId An identifier for the rule.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiMuteAlertRequest
	*/
	MuteAlert(ctx context.Context, alertId string, ruleId string, spaceId string) ApiMuteAlertRequest

	// MuteAlertExecute executes the request
	MuteAlertExecute(r ApiMuteAlertRequest) (*http.Response, error)

	/*
		MuteAllAlerts Mutes all alerts.

		This API snoozes the notifications for the rule indefinitely. The rule checks continue to occur but alerts will not trigger any actions. You must have `all` privileges for the appropriate Kibana features, depending on the `consumer` and `rule_type_id` of the rule. For example, the **Management > Stack Rules** feature, **Analytics > Discover** and **Machine Learning** features, **Observability**, and **Security** features. If the rule has actions, you must also have `read` privileges for the **Management > Actions and Connectors** feature.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param ruleId An identifier for the rule.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiMuteAllAlertsRequest
	*/
	MuteAllAlerts(ctx context.Context, ruleId string, spaceId string) ApiMuteAllAlertsRequest

	// MuteAllAlertsExecute executes the request
	MuteAllAlertsExecute(r ApiMuteAllAlertsRequest) (*http.Response, error)

	/*
		UnmuteAlert Unmutes an alert.

		You must have `all` privileges for the appropriate Kibana features, depending on the `consumer` and `rule_type_id` of the rule. For example, the **Management > Stack Rules** feature, **Analytics > Discover** and **Machine Learning** features, **Observability**, and **Security** features. If the rule has actions, you must also have `read` privileges for the **Management > Actions and Connectors** feature.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param alertId An identifier for the alert. The identifier is generated by the rule and might be any arbitrary string.
		@param ruleId An identifier for the rule.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiUnmuteAlertRequest
	*/
	UnmuteAlert(ctx context.Context, alertId string, ruleId string, spaceId string) ApiUnmuteAlertRequest

	// UnmuteAlertExecute executes the request
	UnmuteAlertExecute(r ApiUnmuteAlertRequest) (*http.Response, error)

	/*
		UnmuteAllAlerts Unmutes all alerts.

		If the rule has its notifications snoozed indefinitely, this API cancels the snooze. You must have `all` privileges for the appropriate Kibana features, depending on the `consumer` and `rule_type_id` of the rule. For example, the **Management > Stack Rules** feature, **Analytics > Discover** and **Machine Learning** features, **Observability**, and **Security** features. If the rule has actions, you must also have `read` privileges for the **Management > Actions and Connectors** feature.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param ruleId An identifier for the rule.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiUnmuteAllAlertsRequest
	*/
	UnmuteAllAlerts(ctx context.Context, ruleId string, spaceId string) ApiUnmuteAllAlertsRequest

	// UnmuteAllAlertsExecute executes the request
	UnmuteAllAlertsExecute(r ApiUnmuteAllAlertsRequest) (*http.Response, error)

	/*
		UpdateRule Updates the attributes for a rule.

		You must have `all` privileges for the appropriate Kibana features, depending on the `consumer` and `rule_type_id` of the rule you're updating. For example, you must have privileges for the **Management > Stack rules** feature, **Analytics > Discover** and **Machine Learning** features, **Observability** features, or **Security** features.  If the rule has actions, you must also have `read` privileges for the **Management > Actions and Connectors** feature. NOTE: This API supports only token-based authentication. When you update a rule, it identifies which roles you have at that point in time. Thereafter, when the rule performs queries, it uses those security privileges. If you have different privileges than the user that created or most recently updated the rule, you might change its behavior. Though some properties are optional, when you update the rule the existing property values are overwritten with default values. Therefore, it is recommended to explicitly set all property values.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param ruleId An identifier for the rule.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiUpdateRuleRequest
	*/
	UpdateRule(ctx context.Context, ruleId string, spaceId string) ApiUpdateRuleRequest

	// UpdateRuleExecute executes the request
	//  @return RuleResponseProperties
	UpdateRuleExecute(r ApiUpdateRuleRequest) (*RuleResponseProperties, *http.Response, error)
}

// AlertingAPIService AlertingAPI service
type AlertingAPIService service

type ApiCreateRuleRequest struct {
	ctx               context.Context
	ApiService        AlertingAPI
	kbnXsrf           *string
	spaceId           string
	ruleId            string
	createRuleRequest *CreateRuleRequest
}

// Cross-site request forgery protection
func (r ApiCreateRuleRequest) KbnXsrf(kbnXsrf string) ApiCreateRuleRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiCreateRuleRequest) CreateRuleRequest(createRuleRequest CreateRuleRequest) ApiCreateRuleRequest {
	r.createRuleRequest = &createRuleRequest
	return r
}

func (r ApiCreateRuleRequest) Execute() (*RuleResponseProperties, *http.Response, error) {
	return r.ApiService.CreateRuleExecute(r)
}

/*
CreateRule Creates a rule.

You must have `all` privileges for the appropriate Kibana features, depending on the `consumer` and `rule_type_id` of the rule you're creating. For example, you must have privileges for the **Management > Stack rules** feature, **Analytics > Discover** and **Machine Learning** features, **Observability** features, or **Security** features.  If the rule has actions, you must also have `read` privileges for the **Management > Actions and Connectors** feature. NOTE: This API supports only token-based authentication. When you create a rule, it identifies which roles you have at that point in time. Thereafter, when the rule performs queries, it uses those security privileges. If a user with different privileges updates the rule, its behavior might change.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@param ruleId An UUID v1 or v4 identifier for the rule. If you omit this parameter, an identifier is randomly generated.
	@return ApiCreateRuleRequest
*/
func (a *AlertingAPIService) CreateRule(ctx context.Context, spaceId string, ruleId string) ApiCreateRuleRequest {
	return ApiCreateRuleRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
		ruleId:     ruleId,
	}
}

// Execute executes the request
//
//	@return RuleResponseProperties
func (a *AlertingAPIService) CreateRuleExecute(r ApiCreateRuleRequest) (*RuleResponseProperties, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RuleResponseProperties
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.CreateRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerting/rule/{ruleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return localVarReturnValue, nil, reportError("kbnXsrf is required and must be specified")
	}
	if r.createRuleRequest == nil {
		return localVarReturnValue, nil, reportError("createRuleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	// body params
	localVarPostBody = r.createRuleRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Model404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteRuleRequest struct {
	ctx        context.Context
	ApiService AlertingAPI
	kbnXsrf    *string
	ruleId     string
	spaceId    string
}

// Cross-site request forgery protection
func (r ApiDeleteRuleRequest) KbnXsrf(kbnXsrf string) ApiDeleteRuleRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiDeleteRuleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRuleExecute(r)
}

/*
DeleteRule Deletes a rule.

You must have `all` privileges for the appropriate Kibana features, depending on the `consumer` and `rule_type_id` of the rule you're deleting. For example, the **Management** > **Stack Rules** feature, **Analytics** > **Discover** or **Machine Learning** features, **Observability**, or **Security** features. WARNING: After you delete a rule, you cannot recover it.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ruleId An identifier for the rule.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiDeleteRuleRequest
*/
func (a *AlertingAPIService) DeleteRule(ctx context.Context, ruleId string, spaceId string) ApiDeleteRuleRequest {
	return ApiDeleteRuleRequest{
		ApiService: a,
		ctx:        ctx,
		ruleId:     ruleId,
		spaceId:    spaceId,
	}
}

// Execute executes the request
func (a *AlertingAPIService) DeleteRuleExecute(r ApiDeleteRuleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.DeleteRule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerting/rule/{ruleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return nil, reportError("kbnXsrf is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Model404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDisableRuleRequest struct {
	ctx        context.Context
	ApiService AlertingAPI
	kbnXsrf    *string
	ruleId     string
	spaceId    string
}

// Cross-site request forgery protection
func (r ApiDisableRuleRequest) KbnXsrf(kbnXsrf string) ApiDisableRuleRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiDisableRuleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DisableRuleExecute(r)
}

/*
DisableRule Disables a rule.

You must have `all` privileges for the appropriate Kibana features, depending on the `consumer` and `rule_type_id` of the rule. For example, the **Management > Stack Rules** feature, **Analytics > Discover** and **Machine Learning** features, **Observability**, and **Security** features.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ruleId An identifier for the rule.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiDisableRuleRequest
*/
func (a *AlertingAPIService) DisableRule(ctx context.Context, ruleId string, spaceId string) ApiDisableRuleRequest {
	return ApiDisableRuleRequest{
		ApiService: a,
		ctx:        ctx,
		ruleId:     ruleId,
		spaceId:    spaceId,
	}
}

// Execute executes the request
func (a *AlertingAPIService) DisableRuleExecute(r ApiDisableRuleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.DisableRule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerting/rule/{ruleId}/_disable"
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return nil, reportError("kbnXsrf is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Model404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnableRuleRequest struct {
	ctx        context.Context
	ApiService AlertingAPI
	kbnXsrf    *string
	ruleId     string
	spaceId    string
}

// Cross-site request forgery protection
func (r ApiEnableRuleRequest) KbnXsrf(kbnXsrf string) ApiEnableRuleRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiEnableRuleRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnableRuleExecute(r)
}

/*
EnableRule Enables a rule.

This API supports token-based authentication only. You must have `all` privileges for the appropriate Kibana features, depending on the `consumer` and `rule_type_id` of the rule. For example, the **Management > Stack Rules** feature, **Analytics > Discover** and **Machine Learning** features, **Observability**, and **Security** features.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ruleId An identifier for the rule.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiEnableRuleRequest
*/
func (a *AlertingAPIService) EnableRule(ctx context.Context, ruleId string, spaceId string) ApiEnableRuleRequest {
	return ApiEnableRuleRequest{
		ApiService: a,
		ctx:        ctx,
		ruleId:     ruleId,
		spaceId:    spaceId,
	}
}

// Execute executes the request
func (a *AlertingAPIService) EnableRuleExecute(r ApiEnableRuleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.EnableRule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerting/rule/{ruleId}/_enable"
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return nil, reportError("kbnXsrf is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiFindRulesRequest struct {
	ctx                   context.Context
	ApiService            AlertingAPI
	spaceId               string
	defaultSearchOperator *string
	fields                *[]string
	filter                *string
	hasReference          *FindRulesHasReferenceParameter
	page                  *int32
	perPage               *int32
	search                *string
	searchFields          *FindRulesSearchFieldsParameter
	sortField             *string
	sortOrder             *string
}

// The default operator to use for the simple_query_string.
func (r ApiFindRulesRequest) DefaultSearchOperator(defaultSearchOperator string) ApiFindRulesRequest {
	r.defaultSearchOperator = &defaultSearchOperator
	return r
}

// The fields to return in the &#x60;attributes&#x60; key of the response.
func (r ApiFindRulesRequest) Fields(fields []string) ApiFindRulesRequest {
	r.fields = &fields
	return r
}

// A KQL string that you filter with an attribute from your saved object. It should look like &#x60;savedObjectType.attributes.title: \&quot;myTitle\&quot;&#x60;. However, if you used a direct attribute of a saved object, such as &#x60;updatedAt&#x60;, you must define your filter, for example, &#x60;savedObjectType.updatedAt &gt; 2018-12-22&#x60;.
func (r ApiFindRulesRequest) Filter(filter string) ApiFindRulesRequest {
	r.filter = &filter
	return r
}

// Filters the rules that have a relation with the reference objects with a specific type and identifier.
func (r ApiFindRulesRequest) HasReference(hasReference FindRulesHasReferenceParameter) ApiFindRulesRequest {
	r.hasReference = &hasReference
	return r
}

// The page number to return.
func (r ApiFindRulesRequest) Page(page int32) ApiFindRulesRequest {
	r.page = &page
	return r
}

// The number of rules to return per page.
func (r ApiFindRulesRequest) PerPage(perPage int32) ApiFindRulesRequest {
	r.perPage = &perPage
	return r
}

// An Elasticsearch simple_query_string query that filters the objects in the response.
func (r ApiFindRulesRequest) Search(search string) ApiFindRulesRequest {
	r.search = &search
	return r
}

// The fields to perform the simple_query_string parsed query against.
func (r ApiFindRulesRequest) SearchFields(searchFields FindRulesSearchFieldsParameter) ApiFindRulesRequest {
	r.searchFields = &searchFields
	return r
}

// Determines which field is used to sort the results. The field must exist in the &#x60;attributes&#x60; key of the response.
func (r ApiFindRulesRequest) SortField(sortField string) ApiFindRulesRequest {
	r.sortField = &sortField
	return r
}

// Determines the sort order.
func (r ApiFindRulesRequest) SortOrder(sortOrder string) ApiFindRulesRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r ApiFindRulesRequest) Execute() (*FindRules200Response, *http.Response, error) {
	return r.ApiService.FindRulesExecute(r)
}

/*
FindRules Retrieves information about rules.

You must have `read` privileges for the appropriate Kibana features, depending on the `consumer` and `rule_type_id` of the rules you're seeking. For example, you must have privileges for the **Management > Stack rules** feature, **Analytics > Discover** and **Machine Learning** features, **Observability** features, or **Security** features. To find rules associated with the **Stack Monitoring** feature, use the `monitoring_user` built-in role.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiFindRulesRequest
*/
func (a *AlertingAPIService) FindRules(ctx context.Context, spaceId string) ApiFindRulesRequest {
	return ApiFindRulesRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return FindRules200Response
func (a *AlertingAPIService) FindRulesExecute(r ApiFindRulesRequest) (*FindRules200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *FindRules200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.FindRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerting/rules/_find"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.defaultSearchOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_search_operator", r.defaultSearchOperator, "")
	} else {
		var defaultValue string = "OR"
		r.defaultSearchOperator = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.hasReference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_reference", r.hasReference, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	} else {
		var defaultValue int32 = 20
		r.perPage = &defaultValue
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.searchFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_fields", r.searchFields, "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_field", r.sortField, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", r.sortOrder, "")
	} else {
		var defaultValue string = "desc"
		r.sortOrder = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAlertingHealthRequest struct {
	ctx        context.Context
	ApiService AlertingAPI
	spaceId    string
}

func (r ApiGetAlertingHealthRequest) Execute() (*GetAlertingHealth200Response, *http.Response, error) {
	return r.ApiService.GetAlertingHealthExecute(r)
}

/*
GetAlertingHealth Retrieves the health status of the alerting framework.

You must have `read` privileges for the **Management > Stack Rules** feature or for at least one of the **Analytics > Discover**, **Analytics > Machine Learning**, **Observability**, or **Security** features.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiGetAlertingHealthRequest
*/
func (a *AlertingAPIService) GetAlertingHealth(ctx context.Context, spaceId string) ApiGetAlertingHealthRequest {
	return ApiGetAlertingHealthRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return GetAlertingHealth200Response
func (a *AlertingAPIService) GetAlertingHealthExecute(r ApiGetAlertingHealthRequest) (*GetAlertingHealth200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *GetAlertingHealth200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.GetAlertingHealth")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerting/_health"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRuleRequest struct {
	ctx        context.Context
	ApiService AlertingAPI
	ruleId     string
	spaceId    string
}

func (r ApiGetRuleRequest) Execute() (*RuleResponseProperties, *http.Response, error) {
	return r.ApiService.GetRuleExecute(r)
}

/*
GetRule Retrieves a rule by its identifier.

You must have `read` privileges for the appropriate Kibana features, depending on the `consumer` and `rule_type_id` of the rules you're seeking. For example, the **Management > Stack Rules** feature, **Analytics > Discover** and **Machine Learning** features, **Observability** features, or **Security** features. To get rules associated with the **Stack Monitoring** feature, use the `monitoring_user` built-in role.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ruleId An identifier for the rule.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiGetRuleRequest
*/
func (a *AlertingAPIService) GetRule(ctx context.Context, ruleId string, spaceId string) ApiGetRuleRequest {
	return ApiGetRuleRequest{
		ApiService: a,
		ctx:        ctx,
		ruleId:     ruleId,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return RuleResponseProperties
func (a *AlertingAPIService) GetRuleExecute(r ApiGetRuleRequest) (*RuleResponseProperties, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RuleResponseProperties
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.GetRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerting/rule/{ruleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Model404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRuleTypesRequest struct {
	ctx        context.Context
	ApiService AlertingAPI
	spaceId    string
}

func (r ApiGetRuleTypesRequest) Execute() ([]GetRuleTypes200ResponseInner, *http.Response, error) {
	return r.ApiService.GetRuleTypesExecute(r)
}

/*
GetRuleTypes Retrieves a list of rule types.

If you have `read` privileges for one or more Kibana features, the API response contains information about the appropriate rule types. For example, there are rule types associated with the **Management > Stack Rules** feature, **Analytics > Discover** and **Machine Learning** features, **Observability** features, and **Security** features. To get rule types associated with the **Stack Monitoring** feature, use the `monitoring_user` built-in role.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiGetRuleTypesRequest
*/
func (a *AlertingAPIService) GetRuleTypes(ctx context.Context, spaceId string) ApiGetRuleTypesRequest {
	return ApiGetRuleTypesRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return []GetRuleTypes200ResponseInner
func (a *AlertingAPIService) GetRuleTypesExecute(r ApiGetRuleTypesRequest) ([]GetRuleTypes200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []GetRuleTypes200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.GetRuleTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerting/rule_types"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegacyCreateAlertRequest struct {
	ctx                                context.Context
	ApiService                         AlertingAPI
	kbnXsrf                            *string
	alertId                            string
	spaceId                            string
	legacyCreateAlertRequestProperties *LegacyCreateAlertRequestProperties
}

// Cross-site request forgery protection
func (r ApiLegacyCreateAlertRequest) KbnXsrf(kbnXsrf string) ApiLegacyCreateAlertRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiLegacyCreateAlertRequest) LegacyCreateAlertRequestProperties(legacyCreateAlertRequestProperties LegacyCreateAlertRequestProperties) ApiLegacyCreateAlertRequest {
	r.legacyCreateAlertRequestProperties = &legacyCreateAlertRequestProperties
	return r
}

func (r ApiLegacyCreateAlertRequest) Execute() (*AlertResponseProperties, *http.Response, error) {
	return r.ApiService.LegacyCreateAlertExecute(r)
}

/*
LegacyCreateAlert Create an alert.

Deprecated in 7.13.0. Use the create rule API instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param alertId An UUID v1 or v4 identifier for the alert. If this parameter is omitted, the identifier is randomly generated.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiLegacyCreateAlertRequest

Deprecated
*/
func (a *AlertingAPIService) LegacyCreateAlert(ctx context.Context, alertId string, spaceId string) ApiLegacyCreateAlertRequest {
	return ApiLegacyCreateAlertRequest{
		ApiService: a,
		ctx:        ctx,
		alertId:    alertId,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return AlertResponseProperties
//
// Deprecated
func (a *AlertingAPIService) LegacyCreateAlertExecute(r ApiLegacyCreateAlertRequest) (*AlertResponseProperties, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertResponseProperties
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.LegacyCreateAlert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerts/alert/{alertId}"
	localVarPath = strings.Replace(localVarPath, "{"+"alertId"+"}", url.PathEscape(parameterValueToString(r.alertId, "alertId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return localVarReturnValue, nil, reportError("kbnXsrf is required and must be specified")
	}
	if r.legacyCreateAlertRequestProperties == nil {
		return localVarReturnValue, nil, reportError("legacyCreateAlertRequestProperties is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	// body params
	localVarPostBody = r.legacyCreateAlertRequestProperties
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegacyDisableAlertRequest struct {
	ctx        context.Context
	ApiService AlertingAPI
	kbnXsrf    *string
	spaceId    string
	alertId    string
}

// Cross-site request forgery protection
func (r ApiLegacyDisableAlertRequest) KbnXsrf(kbnXsrf string) ApiLegacyDisableAlertRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiLegacyDisableAlertRequest) Execute() (*http.Response, error) {
	return r.ApiService.LegacyDisableAlertExecute(r)
}

/*
LegacyDisableAlert Disables an alert.

Deprecated in 7.13.0. Use the disable rule API instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@param alertId The identifier for the alert.
	@return ApiLegacyDisableAlertRequest

Deprecated
*/
func (a *AlertingAPIService) LegacyDisableAlert(ctx context.Context, spaceId string, alertId string) ApiLegacyDisableAlertRequest {
	return ApiLegacyDisableAlertRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
		alertId:    alertId,
	}
}

// Execute executes the request
// Deprecated
func (a *AlertingAPIService) LegacyDisableAlertExecute(r ApiLegacyDisableAlertRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.LegacyDisableAlert")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerts/alert/{alertId}/_disable"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertId"+"}", url.PathEscape(parameterValueToString(r.alertId, "alertId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return nil, reportError("kbnXsrf is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLegacyEnableAlertRequest struct {
	ctx        context.Context
	ApiService AlertingAPI
	kbnXsrf    *string
	spaceId    string
	alertId    string
}

// Cross-site request forgery protection
func (r ApiLegacyEnableAlertRequest) KbnXsrf(kbnXsrf string) ApiLegacyEnableAlertRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiLegacyEnableAlertRequest) Execute() (*http.Response, error) {
	return r.ApiService.LegacyEnableAlertExecute(r)
}

/*
LegacyEnableAlert Enables an alert.

Deprecated in 7.13.0. Use the enable rule API instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@param alertId The identifier for the alert.
	@return ApiLegacyEnableAlertRequest

Deprecated
*/
func (a *AlertingAPIService) LegacyEnableAlert(ctx context.Context, spaceId string, alertId string) ApiLegacyEnableAlertRequest {
	return ApiLegacyEnableAlertRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
		alertId:    alertId,
	}
}

// Execute executes the request
// Deprecated
func (a *AlertingAPIService) LegacyEnableAlertExecute(r ApiLegacyEnableAlertRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.LegacyEnableAlert")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerts/alert/{alertId}/_enable"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertId"+"}", url.PathEscape(parameterValueToString(r.alertId, "alertId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return nil, reportError("kbnXsrf is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLegacyFindAlertsRequest struct {
	ctx                   context.Context
	ApiService            AlertingAPI
	spaceId               string
	defaultSearchOperator *string
	fields                *[]string
	filter                *string
	hasReference          *FindRulesHasReferenceParameter
	page                  *int32
	perPage               *int32
	search                *string
	searchFields          *FindRulesSearchFieldsParameter
	sortField             *string
	sortOrder             *string
}

// The default operator to use for the &#x60;simple_query_string&#x60;.
func (r ApiLegacyFindAlertsRequest) DefaultSearchOperator(defaultSearchOperator string) ApiLegacyFindAlertsRequest {
	r.defaultSearchOperator = &defaultSearchOperator
	return r
}

// The fields to return in the &#x60;attributes&#x60; key of the response.
func (r ApiLegacyFindAlertsRequest) Fields(fields []string) ApiLegacyFindAlertsRequest {
	r.fields = &fields
	return r
}

// A KQL string that you filter with an attribute from your saved object. It should look like &#x60;savedObjectType.attributes.title: \&quot;myTitle\&quot;&#x60;. However, if you used a direct attribute of a saved object, such as &#x60;updatedAt&#x60;, you must define your filter, for example, &#x60;savedObjectType.updatedAt &gt; 2018-12-22&#x60;.
func (r ApiLegacyFindAlertsRequest) Filter(filter string) ApiLegacyFindAlertsRequest {
	r.filter = &filter
	return r
}

// Filters the rules that have a relation with the reference objects with a specific type and identifier.
func (r ApiLegacyFindAlertsRequest) HasReference(hasReference FindRulesHasReferenceParameter) ApiLegacyFindAlertsRequest {
	r.hasReference = &hasReference
	return r
}

// The page number to return.
func (r ApiLegacyFindAlertsRequest) Page(page int32) ApiLegacyFindAlertsRequest {
	r.page = &page
	return r
}

// The number of alerts to return per page.
func (r ApiLegacyFindAlertsRequest) PerPage(perPage int32) ApiLegacyFindAlertsRequest {
	r.perPage = &perPage
	return r
}

// An Elasticsearch &#x60;simple_query_string&#x60; query that filters the alerts in the response.
func (r ApiLegacyFindAlertsRequest) Search(search string) ApiLegacyFindAlertsRequest {
	r.search = &search
	return r
}

// The fields to perform the &#x60;simple_query_string&#x60; parsed query against.
func (r ApiLegacyFindAlertsRequest) SearchFields(searchFields FindRulesSearchFieldsParameter) ApiLegacyFindAlertsRequest {
	r.searchFields = &searchFields
	return r
}

// Determines which field is used to sort the results. The field must exist in the &#x60;attributes&#x60; key of the response.
func (r ApiLegacyFindAlertsRequest) SortField(sortField string) ApiLegacyFindAlertsRequest {
	r.sortField = &sortField
	return r
}

// Determines the sort order.
func (r ApiLegacyFindAlertsRequest) SortOrder(sortOrder string) ApiLegacyFindAlertsRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r ApiLegacyFindAlertsRequest) Execute() (*LegacyFindAlerts200Response, *http.Response, error) {
	return r.ApiService.LegacyFindAlertsExecute(r)
}

/*
LegacyFindAlerts Retrieves a paginated set of alerts.

Deprecated in 7.13.0. Use the find rules API instead. NOTE: Alert `params` are stored as a flattened field type and analyzed as keywords. As alerts change in Kibana, the results on each page of the response also change. Use the find API for traditional paginated results, but avoid using it to export large amounts of data.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiLegacyFindAlertsRequest

Deprecated
*/
func (a *AlertingAPIService) LegacyFindAlerts(ctx context.Context, spaceId string) ApiLegacyFindAlertsRequest {
	return ApiLegacyFindAlertsRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return LegacyFindAlerts200Response
//
// Deprecated
func (a *AlertingAPIService) LegacyFindAlertsExecute(r ApiLegacyFindAlertsRequest) (*LegacyFindAlerts200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LegacyFindAlerts200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.LegacyFindAlerts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerts/alerts/_find"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.defaultSearchOperator != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "default_search_operator", r.defaultSearchOperator, "")
	} else {
		var defaultValue string = "OR"
		r.defaultSearchOperator = &defaultValue
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.filter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter", r.filter, "")
	}
	if r.hasReference != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "has_reference", r.hasReference, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	} else {
		var defaultValue int32 = 20
		r.perPage = &defaultValue
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.searchFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search_fields", r.searchFields, "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_field", r.sortField, "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_order", r.sortOrder, "")
	} else {
		var defaultValue string = "desc"
		r.sortOrder = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegacyGetAlertRequest struct {
	ctx        context.Context
	ApiService AlertingAPI
	spaceId    string
	alertId    string
}

func (r ApiLegacyGetAlertRequest) Execute() (*AlertResponseProperties, *http.Response, error) {
	return r.ApiService.LegacyGetAlertExecute(r)
}

/*
LegacyGetAlert Retrieves an alert by its identifier.

Deprecated in 7.13.0. Use the get rule API instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@param alertId The identifier for the alert.
	@return ApiLegacyGetAlertRequest

Deprecated
*/
func (a *AlertingAPIService) LegacyGetAlert(ctx context.Context, spaceId string, alertId string) ApiLegacyGetAlertRequest {
	return ApiLegacyGetAlertRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
		alertId:    alertId,
	}
}

// Execute executes the request
//
//	@return AlertResponseProperties
//
// Deprecated
func (a *AlertingAPIService) LegacyGetAlertExecute(r ApiLegacyGetAlertRequest) (*AlertResponseProperties, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertResponseProperties
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.LegacyGetAlert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerts/alert/{alertId}"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertId"+"}", url.PathEscape(parameterValueToString(r.alertId, "alertId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegacyGetAlertTypesRequest struct {
	ctx        context.Context
	ApiService AlertingAPI
	spaceId    string
}

func (r ApiLegacyGetAlertTypesRequest) Execute() ([]LegacyGetAlertTypes200ResponseInner, *http.Response, error) {
	return r.ApiService.LegacyGetAlertTypesExecute(r)
}

/*
LegacyGetAlertTypes Retrieves a list of alert types.

Deprecated in 7.13.0. Use the get rule types API instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiLegacyGetAlertTypesRequest

Deprecated
*/
func (a *AlertingAPIService) LegacyGetAlertTypes(ctx context.Context, spaceId string) ApiLegacyGetAlertTypesRequest {
	return ApiLegacyGetAlertTypesRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return []LegacyGetAlertTypes200ResponseInner
//
// Deprecated
func (a *AlertingAPIService) LegacyGetAlertTypesExecute(r ApiLegacyGetAlertTypesRequest) ([]LegacyGetAlertTypes200ResponseInner, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []LegacyGetAlertTypes200ResponseInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.LegacyGetAlertTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerts/alerts/list_alert_types"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegacyGetAlertingHealthRequest struct {
	ctx        context.Context
	ApiService AlertingAPI
	spaceId    string
}

func (r ApiLegacyGetAlertingHealthRequest) Execute() (*LegacyGetAlertingHealth200Response, *http.Response, error) {
	return r.ApiService.LegacyGetAlertingHealthExecute(r)
}

/*
LegacyGetAlertingHealth Retrieves the health status of the alerting framework.

Deprecated in 7.13.0. Use the get alerting framework health API instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiLegacyGetAlertingHealthRequest

Deprecated
*/
func (a *AlertingAPIService) LegacyGetAlertingHealth(ctx context.Context, spaceId string) ApiLegacyGetAlertingHealthRequest {
	return ApiLegacyGetAlertingHealthRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return LegacyGetAlertingHealth200Response
//
// Deprecated
func (a *AlertingAPIService) LegacyGetAlertingHealthExecute(r ApiLegacyGetAlertingHealthRequest) (*LegacyGetAlertingHealth200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LegacyGetAlertingHealth200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.LegacyGetAlertingHealth")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerts/alerts/_health"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegacyMuteAlertInstanceRequest struct {
	ctx             context.Context
	ApiService      AlertingAPI
	kbnXsrf         *string
	spaceId         string
	alertId         string
	alertInstanceId string
}

// Cross-site request forgery protection
func (r ApiLegacyMuteAlertInstanceRequest) KbnXsrf(kbnXsrf string) ApiLegacyMuteAlertInstanceRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiLegacyMuteAlertInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.LegacyMuteAlertInstanceExecute(r)
}

/*
LegacyMuteAlertInstance Mutes an alert instance.

Deprecated in 7.13.0. Use the mute alert API instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@param alertId An identifier for the alert.
	@param alertInstanceId An identifier for the alert instance.
	@return ApiLegacyMuteAlertInstanceRequest

Deprecated
*/
func (a *AlertingAPIService) LegacyMuteAlertInstance(ctx context.Context, spaceId string, alertId string, alertInstanceId string) ApiLegacyMuteAlertInstanceRequest {
	return ApiLegacyMuteAlertInstanceRequest{
		ApiService:      a,
		ctx:             ctx,
		spaceId:         spaceId,
		alertId:         alertId,
		alertInstanceId: alertInstanceId,
	}
}

// Execute executes the request
// Deprecated
func (a *AlertingAPIService) LegacyMuteAlertInstanceExecute(r ApiLegacyMuteAlertInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.LegacyMuteAlertInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerts/alert/{alertId}/alert_instance/{alertInstanceId}/_mute"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertId"+"}", url.PathEscape(parameterValueToString(r.alertId, "alertId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertInstanceId"+"}", url.PathEscape(parameterValueToString(r.alertInstanceId, "alertInstanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return nil, reportError("kbnXsrf is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLegacyMuteAllAlertInstancesRequest struct {
	ctx        context.Context
	ApiService AlertingAPI
	kbnXsrf    *string
	spaceId    string
	alertId    string
}

// Cross-site request forgery protection
func (r ApiLegacyMuteAllAlertInstancesRequest) KbnXsrf(kbnXsrf string) ApiLegacyMuteAllAlertInstancesRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiLegacyMuteAllAlertInstancesRequest) Execute() (*http.Response, error) {
	return r.ApiService.LegacyMuteAllAlertInstancesExecute(r)
}

/*
LegacyMuteAllAlertInstances Mutes all alert instances.

Deprecated in 7.13.0. Use the mute all alerts API instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@param alertId The identifier for the alert.
	@return ApiLegacyMuteAllAlertInstancesRequest

Deprecated
*/
func (a *AlertingAPIService) LegacyMuteAllAlertInstances(ctx context.Context, spaceId string, alertId string) ApiLegacyMuteAllAlertInstancesRequest {
	return ApiLegacyMuteAllAlertInstancesRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
		alertId:    alertId,
	}
}

// Execute executes the request
// Deprecated
func (a *AlertingAPIService) LegacyMuteAllAlertInstancesExecute(r ApiLegacyMuteAllAlertInstancesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.LegacyMuteAllAlertInstances")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerts/alert/{alertId}/_mute_all"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertId"+"}", url.PathEscape(parameterValueToString(r.alertId, "alertId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return nil, reportError("kbnXsrf is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLegacyUnmuteAlertInstanceRequest struct {
	ctx             context.Context
	ApiService      AlertingAPI
	kbnXsrf         *string
	spaceId         string
	alertId         string
	alertInstanceId string
}

// Cross-site request forgery protection
func (r ApiLegacyUnmuteAlertInstanceRequest) KbnXsrf(kbnXsrf string) ApiLegacyUnmuteAlertInstanceRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiLegacyUnmuteAlertInstanceRequest) Execute() (*http.Response, error) {
	return r.ApiService.LegacyUnmuteAlertInstanceExecute(r)
}

/*
LegacyUnmuteAlertInstance Unmutes an alert instance.

Deprecated in 7.13.0. Use the unmute alert API instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@param alertId An identifier for the alert.
	@param alertInstanceId An identifier for the alert instance.
	@return ApiLegacyUnmuteAlertInstanceRequest

Deprecated
*/
func (a *AlertingAPIService) LegacyUnmuteAlertInstance(ctx context.Context, spaceId string, alertId string, alertInstanceId string) ApiLegacyUnmuteAlertInstanceRequest {
	return ApiLegacyUnmuteAlertInstanceRequest{
		ApiService:      a,
		ctx:             ctx,
		spaceId:         spaceId,
		alertId:         alertId,
		alertInstanceId: alertInstanceId,
	}
}

// Execute executes the request
// Deprecated
func (a *AlertingAPIService) LegacyUnmuteAlertInstanceExecute(r ApiLegacyUnmuteAlertInstanceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.LegacyUnmuteAlertInstance")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerts/alert/{alertId}/alert_instance/{alertInstanceId}/_unmute"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertId"+"}", url.PathEscape(parameterValueToString(r.alertId, "alertId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertInstanceId"+"}", url.PathEscape(parameterValueToString(r.alertInstanceId, "alertInstanceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return nil, reportError("kbnXsrf is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLegacyUnmuteAllAlertInstancesRequest struct {
	ctx        context.Context
	ApiService AlertingAPI
	kbnXsrf    *string
	spaceId    string
	alertId    string
}

// Cross-site request forgery protection
func (r ApiLegacyUnmuteAllAlertInstancesRequest) KbnXsrf(kbnXsrf string) ApiLegacyUnmuteAllAlertInstancesRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiLegacyUnmuteAllAlertInstancesRequest) Execute() (*http.Response, error) {
	return r.ApiService.LegacyUnmuteAllAlertInstancesExecute(r)
}

/*
LegacyUnmuteAllAlertInstances Unmutes all alert instances.

Deprecated in 7.13.0. Use the unmute all alerts API instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@param alertId The identifier for the alert.
	@return ApiLegacyUnmuteAllAlertInstancesRequest

Deprecated
*/
func (a *AlertingAPIService) LegacyUnmuteAllAlertInstances(ctx context.Context, spaceId string, alertId string) ApiLegacyUnmuteAllAlertInstancesRequest {
	return ApiLegacyUnmuteAllAlertInstancesRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
		alertId:    alertId,
	}
}

// Execute executes the request
// Deprecated
func (a *AlertingAPIService) LegacyUnmuteAllAlertInstancesExecute(r ApiLegacyUnmuteAllAlertInstancesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.LegacyUnmuteAllAlertInstances")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerts/alert/{alertId}/_unmute_all"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertId"+"}", url.PathEscape(parameterValueToString(r.alertId, "alertId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return nil, reportError("kbnXsrf is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLegacyUpdateAlertRequest struct {
	ctx                                context.Context
	ApiService                         AlertingAPI
	kbnXsrf                            *string
	spaceId                            string
	alertId                            string
	legacyUpdateAlertRequestProperties *LegacyUpdateAlertRequestProperties
}

// Cross-site request forgery protection
func (r ApiLegacyUpdateAlertRequest) KbnXsrf(kbnXsrf string) ApiLegacyUpdateAlertRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiLegacyUpdateAlertRequest) LegacyUpdateAlertRequestProperties(legacyUpdateAlertRequestProperties LegacyUpdateAlertRequestProperties) ApiLegacyUpdateAlertRequest {
	r.legacyUpdateAlertRequestProperties = &legacyUpdateAlertRequestProperties
	return r
}

func (r ApiLegacyUpdateAlertRequest) Execute() (*AlertResponseProperties, *http.Response, error) {
	return r.ApiService.LegacyUpdateAlertExecute(r)
}

/*
LegacyUpdateAlert Updates the attributes for an alert.

Deprecated in 7.13.0. Use the update rule API instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@param alertId The identifier for the alert.
	@return ApiLegacyUpdateAlertRequest

Deprecated
*/
func (a *AlertingAPIService) LegacyUpdateAlert(ctx context.Context, spaceId string, alertId string) ApiLegacyUpdateAlertRequest {
	return ApiLegacyUpdateAlertRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
		alertId:    alertId,
	}
}

// Execute executes the request
//
//	@return AlertResponseProperties
//
// Deprecated
func (a *AlertingAPIService) LegacyUpdateAlertExecute(r ApiLegacyUpdateAlertRequest) (*AlertResponseProperties, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AlertResponseProperties
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.LegacyUpdateAlert")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerts/alert/{alertId}"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertId"+"}", url.PathEscape(parameterValueToString(r.alertId, "alertId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return localVarReturnValue, nil, reportError("kbnXsrf is required and must be specified")
	}
	if r.legacyUpdateAlertRequestProperties == nil {
		return localVarReturnValue, nil, reportError("legacyUpdateAlertRequestProperties is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	// body params
	localVarPostBody = r.legacyUpdateAlertRequestProperties
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegaryDeleteAlertRequest struct {
	ctx        context.Context
	ApiService AlertingAPI
	kbnXsrf    *string
	spaceId    string
	alertId    string
}

// Cross-site request forgery protection
func (r ApiLegaryDeleteAlertRequest) KbnXsrf(kbnXsrf string) ApiLegaryDeleteAlertRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiLegaryDeleteAlertRequest) Execute() (*http.Response, error) {
	return r.ApiService.LegaryDeleteAlertExecute(r)
}

/*
LegaryDeleteAlert Permanently removes an alert.

Deprecated in 7.13.0. Use the delete rule API instead. WARNING: After you delete an alert, you cannot recover it.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@param alertId The identifier for the alert.
	@return ApiLegaryDeleteAlertRequest

Deprecated
*/
func (a *AlertingAPIService) LegaryDeleteAlert(ctx context.Context, spaceId string, alertId string) ApiLegaryDeleteAlertRequest {
	return ApiLegaryDeleteAlertRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
		alertId:    alertId,
	}
}

// Execute executes the request
// Deprecated
func (a *AlertingAPIService) LegaryDeleteAlertExecute(r ApiLegaryDeleteAlertRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.LegaryDeleteAlert")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerts/alert/{alertId}"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"alertId"+"}", url.PathEscape(parameterValueToString(r.alertId, "alertId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return nil, reportError("kbnXsrf is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMuteAlertRequest struct {
	ctx        context.Context
	ApiService AlertingAPI
	kbnXsrf    *string
	alertId    string
	ruleId     string
	spaceId    string
}

// Cross-site request forgery protection
func (r ApiMuteAlertRequest) KbnXsrf(kbnXsrf string) ApiMuteAlertRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiMuteAlertRequest) Execute() (*http.Response, error) {
	return r.ApiService.MuteAlertExecute(r)
}

/*
MuteAlert Mutes an alert.

You must have `all` privileges for the appropriate Kibana features, depending on the `consumer` and `rule_type_id` of the rule. For example, the **Management > Stack Rules** feature, **Analytics > Discover** and **Machine Learning** features, **Observability**, and **Security** features. If the rule has actions, you must also have `read` privileges for the **Management > Actions and Connectors** feature.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param alertId An identifier for the alert. The identifier is generated by the rule and might be any arbitrary string.
	@param ruleId An identifier for the rule.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiMuteAlertRequest
*/
func (a *AlertingAPIService) MuteAlert(ctx context.Context, alertId string, ruleId string, spaceId string) ApiMuteAlertRequest {
	return ApiMuteAlertRequest{
		ApiService: a,
		ctx:        ctx,
		alertId:    alertId,
		ruleId:     ruleId,
		spaceId:    spaceId,
	}
}

// Execute executes the request
func (a *AlertingAPIService) MuteAlertExecute(r ApiMuteAlertRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.MuteAlert")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerting/rule/{ruleId}/alert/{alertId}/_mute"
	localVarPath = strings.Replace(localVarPath, "{"+"alertId"+"}", url.PathEscape(parameterValueToString(r.alertId, "alertId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return nil, reportError("kbnXsrf is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiMuteAllAlertsRequest struct {
	ctx        context.Context
	ApiService AlertingAPI
	kbnXsrf    *string
	ruleId     string
	spaceId    string
}

// Cross-site request forgery protection
func (r ApiMuteAllAlertsRequest) KbnXsrf(kbnXsrf string) ApiMuteAllAlertsRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiMuteAllAlertsRequest) Execute() (*http.Response, error) {
	return r.ApiService.MuteAllAlertsExecute(r)
}

/*
MuteAllAlerts Mutes all alerts.

This API snoozes the notifications for the rule indefinitely. The rule checks continue to occur but alerts will not trigger any actions. You must have `all` privileges for the appropriate Kibana features, depending on the `consumer` and `rule_type_id` of the rule. For example, the **Management > Stack Rules** feature, **Analytics > Discover** and **Machine Learning** features, **Observability**, and **Security** features. If the rule has actions, you must also have `read` privileges for the **Management > Actions and Connectors** feature.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ruleId An identifier for the rule.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiMuteAllAlertsRequest
*/
func (a *AlertingAPIService) MuteAllAlerts(ctx context.Context, ruleId string, spaceId string) ApiMuteAllAlertsRequest {
	return ApiMuteAllAlertsRequest{
		ApiService: a,
		ctx:        ctx,
		ruleId:     ruleId,
		spaceId:    spaceId,
	}
}

// Execute executes the request
func (a *AlertingAPIService) MuteAllAlertsExecute(r ApiMuteAllAlertsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.MuteAllAlerts")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerting/rule/{ruleId}/_mute_all"
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return nil, reportError("kbnXsrf is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUnmuteAlertRequest struct {
	ctx        context.Context
	ApiService AlertingAPI
	kbnXsrf    *string
	alertId    string
	ruleId     string
	spaceId    string
}

// Cross-site request forgery protection
func (r ApiUnmuteAlertRequest) KbnXsrf(kbnXsrf string) ApiUnmuteAlertRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiUnmuteAlertRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnmuteAlertExecute(r)
}

/*
UnmuteAlert Unmutes an alert.

You must have `all` privileges for the appropriate Kibana features, depending on the `consumer` and `rule_type_id` of the rule. For example, the **Management > Stack Rules** feature, **Analytics > Discover** and **Machine Learning** features, **Observability**, and **Security** features. If the rule has actions, you must also have `read` privileges for the **Management > Actions and Connectors** feature.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param alertId An identifier for the alert. The identifier is generated by the rule and might be any arbitrary string.
	@param ruleId An identifier for the rule.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiUnmuteAlertRequest
*/
func (a *AlertingAPIService) UnmuteAlert(ctx context.Context, alertId string, ruleId string, spaceId string) ApiUnmuteAlertRequest {
	return ApiUnmuteAlertRequest{
		ApiService: a,
		ctx:        ctx,
		alertId:    alertId,
		ruleId:     ruleId,
		spaceId:    spaceId,
	}
}

// Execute executes the request
func (a *AlertingAPIService) UnmuteAlertExecute(r ApiUnmuteAlertRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.UnmuteAlert")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerting/rule/{ruleId}/alert/{alertId}/_unmute"
	localVarPath = strings.Replace(localVarPath, "{"+"alertId"+"}", url.PathEscape(parameterValueToString(r.alertId, "alertId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return nil, reportError("kbnXsrf is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUnmuteAllAlertsRequest struct {
	ctx        context.Context
	ApiService AlertingAPI
	kbnXsrf    *string
	ruleId     string
	spaceId    string
}

// Cross-site request forgery protection
func (r ApiUnmuteAllAlertsRequest) KbnXsrf(kbnXsrf string) ApiUnmuteAllAlertsRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiUnmuteAllAlertsRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnmuteAllAlertsExecute(r)
}

/*
UnmuteAllAlerts Unmutes all alerts.

If the rule has its notifications snoozed indefinitely, this API cancels the snooze. You must have `all` privileges for the appropriate Kibana features, depending on the `consumer` and `rule_type_id` of the rule. For example, the **Management > Stack Rules** feature, **Analytics > Discover** and **Machine Learning** features, **Observability**, and **Security** features. If the rule has actions, you must also have `read` privileges for the **Management > Actions and Connectors** feature.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ruleId An identifier for the rule.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiUnmuteAllAlertsRequest
*/
func (a *AlertingAPIService) UnmuteAllAlerts(ctx context.Context, ruleId string, spaceId string) ApiUnmuteAllAlertsRequest {
	return ApiUnmuteAllAlertsRequest{
		ApiService: a,
		ctx:        ctx,
		ruleId:     ruleId,
		spaceId:    spaceId,
	}
}

// Execute executes the request
func (a *AlertingAPIService) UnmuteAllAlertsExecute(r ApiUnmuteAllAlertsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.UnmuteAllAlerts")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerting/rule/{ruleId}/_unmute_all"
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return nil, reportError("kbnXsrf is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateRuleRequest struct {
	ctx               context.Context
	ApiService        AlertingAPI
	kbnXsrf           *string
	ruleId            string
	spaceId           string
	updateRuleRequest *UpdateRuleRequest
}

// Cross-site request forgery protection
func (r ApiUpdateRuleRequest) KbnXsrf(kbnXsrf string) ApiUpdateRuleRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiUpdateRuleRequest) UpdateRuleRequest(updateRuleRequest UpdateRuleRequest) ApiUpdateRuleRequest {
	r.updateRuleRequest = &updateRuleRequest
	return r
}

func (r ApiUpdateRuleRequest) Execute() (*RuleResponseProperties, *http.Response, error) {
	return r.ApiService.UpdateRuleExecute(r)
}

/*
UpdateRule Updates the attributes for a rule.

You must have `all` privileges for the appropriate Kibana features, depending on the `consumer` and `rule_type_id` of the rule you're updating. For example, you must have privileges for the **Management > Stack rules** feature, **Analytics > Discover** and **Machine Learning** features, **Observability** features, or **Security** features.  If the rule has actions, you must also have `read` privileges for the **Management > Actions and Connectors** feature. NOTE: This API supports only token-based authentication. When you update a rule, it identifies which roles you have at that point in time. Thereafter, when the rule performs queries, it uses those security privileges. If you have different privileges than the user that created or most recently updated the rule, you might change its behavior. Though some properties are optional, when you update the rule the existing property values are overwritten with default values. Therefore, it is recommended to explicitly set all property values.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param ruleId An identifier for the rule.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiUpdateRuleRequest
*/
func (a *AlertingAPIService) UpdateRule(ctx context.Context, ruleId string, spaceId string) ApiUpdateRuleRequest {
	return ApiUpdateRuleRequest{
		ApiService: a,
		ctx:        ctx,
		ruleId:     ruleId,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return RuleResponseProperties
func (a *AlertingAPIService) UpdateRuleExecute(r ApiUpdateRuleRequest) (*RuleResponseProperties, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RuleResponseProperties
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AlertingAPIService.UpdateRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/alerting/rule/{ruleId}"
	localVarPath = strings.Replace(localVarPath, "{"+"ruleId"+"}", url.PathEscape(parameterValueToString(r.ruleId, "ruleId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return localVarReturnValue, nil, reportError("kbnXsrf is required and must be specified")
	}
	if r.updateRuleRequest == nil {
		return localVarReturnValue, nil, reportError("updateRuleRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	// body params
	localVarPostBody = r.updateRuleRequest
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Model404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
