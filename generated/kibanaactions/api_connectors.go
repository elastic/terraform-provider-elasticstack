/*
Connectors

OpenAPI schema for Connectors endpoints

API version: 0.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package kibanaactions

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type ConnectorsApi interface {

	/*
		CreateConnector Creates a connector.

		You must have `all` privileges for the **Actions and Connectors** feature in the **Management** section of the Kibana feature privileges.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiCreateConnectorRequest
	*/
	CreateConnector(ctx context.Context, spaceId string) ApiCreateConnectorRequest

	// CreateConnectorExecute executes the request
	//  @return ConnectorResponseProperties
	CreateConnectorExecute(r ApiCreateConnectorRequest) (*ConnectorResponseProperties, *http.Response, error)

	/*
		DeleteConnector Deletes a connector.

		You must have `all` privileges for the **Actions and Connectors** feature in the **Management** section of the Kibana feature privileges. WARNING: When you delete a connector, it cannot be recovered.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param connectorId An identifier for the connector.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiDeleteConnectorRequest
	*/
	DeleteConnector(ctx context.Context, connectorId string, spaceId string) ApiDeleteConnectorRequest

	// DeleteConnectorExecute executes the request
	DeleteConnectorExecute(r ApiDeleteConnectorRequest) (*http.Response, error)

	/*
		GetConnector Retrieves a connector by ID.

		You must have `read` privileges for the **Actions and Connectors** feature in the **Management** section of the Kibana feature privileges.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param connectorId An identifier for the connector.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiGetConnectorRequest
	*/
	GetConnector(ctx context.Context, connectorId string, spaceId string) ApiGetConnectorRequest

	// GetConnectorExecute executes the request
	//  @return ConnectorResponseProperties
	GetConnectorExecute(r ApiGetConnectorRequest) (*ConnectorResponseProperties, *http.Response, error)

	/*
		GetConnectorTypes Retrieves a list of all connector types.

		You do not need any Kibana feature privileges to run this API.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiGetConnectorTypesRequest
	*/
	GetConnectorTypes(ctx context.Context, spaceId string) ApiGetConnectorTypesRequest

	// GetConnectorTypesExecute executes the request
	//  @return []GetConnectorTypesResponseBodyPropertiesInner
	GetConnectorTypesExecute(r ApiGetConnectorTypesRequest) ([]GetConnectorTypesResponseBodyPropertiesInner, *http.Response, error)

	/*
		GetConnectors Retrieves all connectors.

		You must have `read` privileges for the **Actions and Connectors** feature in the **Management** section of the Kibana feature privileges.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiGetConnectorsRequest
	*/
	GetConnectors(ctx context.Context, spaceId string) ApiGetConnectorsRequest

	// GetConnectorsExecute executes the request
	//  @return []GetConnectorsResponseBodyProperties
	GetConnectorsExecute(r ApiGetConnectorsRequest) ([]GetConnectorsResponseBodyProperties, *http.Response, error)

	/*
		LegacyCreateConnector Creates a connector.

		Deprecated in 7.13.0. Use the create connector API instead.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiLegacyCreateConnectorRequest

		Deprecated
	*/
	LegacyCreateConnector(ctx context.Context, spaceId string) ApiLegacyCreateConnectorRequest

	// LegacyCreateConnectorExecute executes the request
	//  @return ActionResponseProperties
	// Deprecated
	LegacyCreateConnectorExecute(r ApiLegacyCreateConnectorRequest) (*ActionResponseProperties, *http.Response, error)

	/*
		LegacyDeleteConnector Deletes a connector.

		Deprecated in 7.13.0. Use the delete connector API instead. WARNING: When you delete a connector, it cannot be recovered.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param actionId An identifier for the action.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiLegacyDeleteConnectorRequest

		Deprecated
	*/
	LegacyDeleteConnector(ctx context.Context, actionId string, spaceId string) ApiLegacyDeleteConnectorRequest

	// LegacyDeleteConnectorExecute executes the request
	// Deprecated
	LegacyDeleteConnectorExecute(r ApiLegacyDeleteConnectorRequest) (*http.Response, error)

	/*
		LegacyGetConnector Retrieves a connector by ID.

		Deprecated in 7.13.0. Use the get connector API instead.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param actionId An identifier for the action.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiLegacyGetConnectorRequest

		Deprecated
	*/
	LegacyGetConnector(ctx context.Context, actionId string, spaceId string) ApiLegacyGetConnectorRequest

	// LegacyGetConnectorExecute executes the request
	//  @return ActionResponseProperties
	// Deprecated
	LegacyGetConnectorExecute(r ApiLegacyGetConnectorRequest) (*ActionResponseProperties, *http.Response, error)

	/*
		LegacyGetConnectorTypes Retrieves a list of all connector types.

		Deprecated in 7.13.0. Use the get all connector types API instead.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiLegacyGetConnectorTypesRequest

		Deprecated
	*/
	LegacyGetConnectorTypes(ctx context.Context, spaceId string) ApiLegacyGetConnectorTypesRequest

	// LegacyGetConnectorTypesExecute executes the request
	//  @return []LegacyGetConnectorTypesResponseBodyPropertiesInner
	// Deprecated
	LegacyGetConnectorTypesExecute(r ApiLegacyGetConnectorTypesRequest) ([]LegacyGetConnectorTypesResponseBodyPropertiesInner, *http.Response, error)

	/*
		LegacyGetConnectors Retrieves all connectors.

		Deprecated in 7.13.0. Use the get all connectors API instead.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiLegacyGetConnectorsRequest

		Deprecated
	*/
	LegacyGetConnectors(ctx context.Context, spaceId string) ApiLegacyGetConnectorsRequest

	// LegacyGetConnectorsExecute executes the request
	//  @return []ActionResponseProperties
	// Deprecated
	LegacyGetConnectorsExecute(r ApiLegacyGetConnectorsRequest) ([]ActionResponseProperties, *http.Response, error)

	/*
		LegacyRunConnector Runs a connector.

		Deprecated in 7.13.0. Use the run connector API instead.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param actionId An identifier for the action.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiLegacyRunConnectorRequest

		Deprecated
	*/
	LegacyRunConnector(ctx context.Context, actionId string, spaceId string) ApiLegacyRunConnectorRequest

	// LegacyRunConnectorExecute executes the request
	//  @return LegacyRunConnector200Response
	// Deprecated
	LegacyRunConnectorExecute(r ApiLegacyRunConnectorRequest) (*LegacyRunConnector200Response, *http.Response, error)

	/*
		LegacyUpdateConnector Updates the attributes for a connector.

		Deprecated in 7.13.0. Use the update connector API instead.

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param actionId An identifier for the action.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiLegacyUpdateConnectorRequest

		Deprecated
	*/
	LegacyUpdateConnector(ctx context.Context, actionId string, spaceId string) ApiLegacyUpdateConnectorRequest

	// LegacyUpdateConnectorExecute executes the request
	//  @return ActionResponseProperties
	// Deprecated
	LegacyUpdateConnectorExecute(r ApiLegacyUpdateConnectorRequest) (*ActionResponseProperties, *http.Response, error)

	/*
		RunConnector Runs a connector.

		You can use this API to test an action that involves interaction with Kibana services or integrations with third-party systems. You must have `read` privileges for the **Actions and Connectors** feature in the **Management** section of the Kibana feature privileges. If you use an index connector, you must also have `all`, `create`, `index`, or `write` indices privileges.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param connectorId An identifier for the connector.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiRunConnectorRequest
	*/
	RunConnector(ctx context.Context, connectorId string, spaceId string) ApiRunConnectorRequest

	// RunConnectorExecute executes the request
	//  @return RunConnector200Response
	RunConnectorExecute(r ApiRunConnectorRequest) (*RunConnector200Response, *http.Response, error)

	/*
		UpdateConnector Updates the attributes for a connector.

		You must have `all` privileges for the **Actions and Connectors** feature in the **Management** section of the Kibana feature privileges.


		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@param connectorId An identifier for the connector.
		@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
		@return ApiUpdateConnectorRequest
	*/
	UpdateConnector(ctx context.Context, connectorId string, spaceId string) ApiUpdateConnectorRequest

	// UpdateConnectorExecute executes the request
	//  @return ConnectorResponseProperties
	UpdateConnectorExecute(r ApiUpdateConnectorRequest) (*ConnectorResponseProperties, *http.Response, error)
}

// ConnectorsApiService ConnectorsApi service
type ConnectorsApiService service

type ApiCreateConnectorRequest struct {
	ctx                                  context.Context
	ApiService                           ConnectorsApi
	kbnXsrf                              *string
	spaceId                              string
	createConnectorRequestBodyProperties *CreateConnectorRequestBodyProperties
}

// Cross-site request forgery protection
func (r ApiCreateConnectorRequest) KbnXsrf(kbnXsrf string) ApiCreateConnectorRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiCreateConnectorRequest) CreateConnectorRequestBodyProperties(createConnectorRequestBodyProperties CreateConnectorRequestBodyProperties) ApiCreateConnectorRequest {
	r.createConnectorRequestBodyProperties = &createConnectorRequestBodyProperties
	return r
}

func (r ApiCreateConnectorRequest) Execute() (*ConnectorResponseProperties, *http.Response, error) {
	return r.ApiService.CreateConnectorExecute(r)
}

/*
CreateConnector Creates a connector.

You must have `all` privileges for the **Actions and Connectors** feature in the **Management** section of the Kibana feature privileges.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiCreateConnectorRequest
*/
func (a *ConnectorsApiService) CreateConnector(ctx context.Context, spaceId string) ApiCreateConnectorRequest {
	return ApiCreateConnectorRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return ConnectorResponseProperties
func (a *ConnectorsApiService) CreateConnectorExecute(r ApiCreateConnectorRequest) (*ConnectorResponseProperties, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ConnectorResponseProperties
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorsApiService.CreateConnector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/actions/connector"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return localVarReturnValue, nil, reportError("kbnXsrf is required and must be specified")
	}
	if r.createConnectorRequestBodyProperties == nil {
		return localVarReturnValue, nil, reportError("createConnectorRequestBodyProperties is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	// body params
	localVarPostBody = r.createConnectorRequestBodyProperties
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["ApiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteConnectorRequest struct {
	ctx         context.Context
	ApiService  ConnectorsApi
	kbnXsrf     *string
	connectorId string
	spaceId     string
}

// Cross-site request forgery protection
func (r ApiDeleteConnectorRequest) KbnXsrf(kbnXsrf string) ApiDeleteConnectorRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiDeleteConnectorRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteConnectorExecute(r)
}

/*
DeleteConnector Deletes a connector.

You must have `all` privileges for the **Actions and Connectors** feature in the **Management** section of the Kibana feature privileges. WARNING: When you delete a connector, it cannot be recovered.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectorId An identifier for the connector.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiDeleteConnectorRequest
*/
func (a *ConnectorsApiService) DeleteConnector(ctx context.Context, connectorId string, spaceId string) ApiDeleteConnectorRequest {
	return ApiDeleteConnectorRequest{
		ApiService:  a,
		ctx:         ctx,
		connectorId: connectorId,
		spaceId:     spaceId,
	}
}

// Execute executes the request
func (a *ConnectorsApiService) DeleteConnectorExecute(r ApiDeleteConnectorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorsApiService.DeleteConnector")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/actions/connector/{connectorId}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectorId"+"}", url.PathEscape(parameterValueToString(r.connectorId, "connectorId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return nil, reportError("kbnXsrf is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["ApiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetConnector404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetConnectorRequest struct {
	ctx         context.Context
	ApiService  ConnectorsApi
	connectorId string
	spaceId     string
}

func (r ApiGetConnectorRequest) Execute() (*ConnectorResponseProperties, *http.Response, error) {
	return r.ApiService.GetConnectorExecute(r)
}

/*
GetConnector Retrieves a connector by ID.

You must have `read` privileges for the **Actions and Connectors** feature in the **Management** section of the Kibana feature privileges.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectorId An identifier for the connector.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiGetConnectorRequest
*/
func (a *ConnectorsApiService) GetConnector(ctx context.Context, connectorId string, spaceId string) ApiGetConnectorRequest {
	return ApiGetConnectorRequest{
		ApiService:  a,
		ctx:         ctx,
		connectorId: connectorId,
		spaceId:     spaceId,
	}
}

// Execute executes the request
//
//	@return ConnectorResponseProperties
func (a *ConnectorsApiService) GetConnectorExecute(r ApiGetConnectorRequest) (*ConnectorResponseProperties, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ConnectorResponseProperties
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorsApiService.GetConnector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/actions/connector/{connectorId}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectorId"+"}", url.PathEscape(parameterValueToString(r.connectorId, "connectorId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["ApiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v GetConnector404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConnectorTypesRequest struct {
	ctx        context.Context
	ApiService ConnectorsApi
	spaceId    string
	featureId  *Features
}

// A filter to limit the retrieved connector types to those that support a specific feature (such as alerting or cases).
func (r ApiGetConnectorTypesRequest) FeatureId(featureId Features) ApiGetConnectorTypesRequest {
	r.featureId = &featureId
	return r
}

func (r ApiGetConnectorTypesRequest) Execute() ([]GetConnectorTypesResponseBodyPropertiesInner, *http.Response, error) {
	return r.ApiService.GetConnectorTypesExecute(r)
}

/*
GetConnectorTypes Retrieves a list of all connector types.

You do not need any Kibana feature privileges to run this API.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiGetConnectorTypesRequest
*/
func (a *ConnectorsApiService) GetConnectorTypes(ctx context.Context, spaceId string) ApiGetConnectorTypesRequest {
	return ApiGetConnectorTypesRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return []GetConnectorTypesResponseBodyPropertiesInner
func (a *ConnectorsApiService) GetConnectorTypesExecute(r ApiGetConnectorTypesRequest) ([]GetConnectorTypesResponseBodyPropertiesInner, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []GetConnectorTypesResponseBodyPropertiesInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorsApiService.GetConnectorTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/actions/connector_types"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.featureId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "feature_id", r.featureId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["ApiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetConnectorsRequest struct {
	ctx        context.Context
	ApiService ConnectorsApi
	spaceId    string
}

func (r ApiGetConnectorsRequest) Execute() ([]GetConnectorsResponseBodyProperties, *http.Response, error) {
	return r.ApiService.GetConnectorsExecute(r)
}

/*
GetConnectors Retrieves all connectors.

You must have `read` privileges for the **Actions and Connectors** feature in the **Management** section of the Kibana feature privileges.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiGetConnectorsRequest
*/
func (a *ConnectorsApiService) GetConnectors(ctx context.Context, spaceId string) ApiGetConnectorsRequest {
	return ApiGetConnectorsRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return []GetConnectorsResponseBodyProperties
func (a *ConnectorsApiService) GetConnectorsExecute(r ApiGetConnectorsRequest) ([]GetConnectorsResponseBodyProperties, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []GetConnectorsResponseBodyProperties
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorsApiService.GetConnectors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/actions/connectors"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["ApiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegacyCreateConnectorRequest struct {
	ctx                                    context.Context
	ApiService                             ConnectorsApi
	kbnXsrf                                *string
	spaceId                                string
	legacyCreateConnectorRequestProperties *LegacyCreateConnectorRequestProperties
}

// Cross-site request forgery protection
func (r ApiLegacyCreateConnectorRequest) KbnXsrf(kbnXsrf string) ApiLegacyCreateConnectorRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiLegacyCreateConnectorRequest) LegacyCreateConnectorRequestProperties(legacyCreateConnectorRequestProperties LegacyCreateConnectorRequestProperties) ApiLegacyCreateConnectorRequest {
	r.legacyCreateConnectorRequestProperties = &legacyCreateConnectorRequestProperties
	return r
}

func (r ApiLegacyCreateConnectorRequest) Execute() (*ActionResponseProperties, *http.Response, error) {
	return r.ApiService.LegacyCreateConnectorExecute(r)
}

/*
LegacyCreateConnector Creates a connector.

Deprecated in 7.13.0. Use the create connector API instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiLegacyCreateConnectorRequest

Deprecated
*/
func (a *ConnectorsApiService) LegacyCreateConnector(ctx context.Context, spaceId string) ApiLegacyCreateConnectorRequest {
	return ApiLegacyCreateConnectorRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return ActionResponseProperties
//
// Deprecated
func (a *ConnectorsApiService) LegacyCreateConnectorExecute(r ApiLegacyCreateConnectorRequest) (*ActionResponseProperties, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ActionResponseProperties
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorsApiService.LegacyCreateConnector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/actions"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return localVarReturnValue, nil, reportError("kbnXsrf is required and must be specified")
	}
	if r.legacyCreateConnectorRequestProperties == nil {
		return localVarReturnValue, nil, reportError("legacyCreateConnectorRequestProperties is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	// body params
	localVarPostBody = r.legacyCreateConnectorRequestProperties
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["ApiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegacyDeleteConnectorRequest struct {
	ctx        context.Context
	ApiService ConnectorsApi
	kbnXsrf    *string
	actionId   string
	spaceId    string
}

// Cross-site request forgery protection
func (r ApiLegacyDeleteConnectorRequest) KbnXsrf(kbnXsrf string) ApiLegacyDeleteConnectorRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiLegacyDeleteConnectorRequest) Execute() (*http.Response, error) {
	return r.ApiService.LegacyDeleteConnectorExecute(r)
}

/*
LegacyDeleteConnector Deletes a connector.

Deprecated in 7.13.0. Use the delete connector API instead. WARNING: When you delete a connector, it cannot be recovered.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param actionId An identifier for the action.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiLegacyDeleteConnectorRequest

Deprecated
*/
func (a *ConnectorsApiService) LegacyDeleteConnector(ctx context.Context, actionId string, spaceId string) ApiLegacyDeleteConnectorRequest {
	return ApiLegacyDeleteConnectorRequest{
		ApiService: a,
		ctx:        ctx,
		actionId:   actionId,
		spaceId:    spaceId,
	}
}

// Execute executes the request
// Deprecated
func (a *ConnectorsApiService) LegacyDeleteConnectorExecute(r ApiLegacyDeleteConnectorRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorsApiService.LegacyDeleteConnector")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/actions/action/{actionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"actionId"+"}", url.PathEscape(parameterValueToString(r.actionId, "actionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return nil, reportError("kbnXsrf is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["ApiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLegacyGetConnectorRequest struct {
	ctx        context.Context
	ApiService ConnectorsApi
	actionId   string
	spaceId    string
}

func (r ApiLegacyGetConnectorRequest) Execute() (*ActionResponseProperties, *http.Response, error) {
	return r.ApiService.LegacyGetConnectorExecute(r)
}

/*
LegacyGetConnector Retrieves a connector by ID.

Deprecated in 7.13.0. Use the get connector API instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param actionId An identifier for the action.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiLegacyGetConnectorRequest

Deprecated
*/
func (a *ConnectorsApiService) LegacyGetConnector(ctx context.Context, actionId string, spaceId string) ApiLegacyGetConnectorRequest {
	return ApiLegacyGetConnectorRequest{
		ApiService: a,
		ctx:        ctx,
		actionId:   actionId,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return ActionResponseProperties
//
// Deprecated
func (a *ConnectorsApiService) LegacyGetConnectorExecute(r ApiLegacyGetConnectorRequest) (*ActionResponseProperties, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ActionResponseProperties
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorsApiService.LegacyGetConnector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/actions/action/{actionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"actionId"+"}", url.PathEscape(parameterValueToString(r.actionId, "actionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["ApiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegacyGetConnectorTypesRequest struct {
	ctx        context.Context
	ApiService ConnectorsApi
	spaceId    string
}

func (r ApiLegacyGetConnectorTypesRequest) Execute() ([]LegacyGetConnectorTypesResponseBodyPropertiesInner, *http.Response, error) {
	return r.ApiService.LegacyGetConnectorTypesExecute(r)
}

/*
LegacyGetConnectorTypes Retrieves a list of all connector types.

Deprecated in 7.13.0. Use the get all connector types API instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiLegacyGetConnectorTypesRequest

Deprecated
*/
func (a *ConnectorsApiService) LegacyGetConnectorTypes(ctx context.Context, spaceId string) ApiLegacyGetConnectorTypesRequest {
	return ApiLegacyGetConnectorTypesRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return []LegacyGetConnectorTypesResponseBodyPropertiesInner
//
// Deprecated
func (a *ConnectorsApiService) LegacyGetConnectorTypesExecute(r ApiLegacyGetConnectorTypesRequest) ([]LegacyGetConnectorTypesResponseBodyPropertiesInner, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []LegacyGetConnectorTypesResponseBodyPropertiesInner
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorsApiService.LegacyGetConnectorTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/actions/list_action_types"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["ApiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegacyGetConnectorsRequest struct {
	ctx        context.Context
	ApiService ConnectorsApi
	spaceId    string
}

func (r ApiLegacyGetConnectorsRequest) Execute() ([]ActionResponseProperties, *http.Response, error) {
	return r.ApiService.LegacyGetConnectorsExecute(r)
}

/*
LegacyGetConnectors Retrieves all connectors.

Deprecated in 7.13.0. Use the get all connectors API instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiLegacyGetConnectorsRequest

Deprecated
*/
func (a *ConnectorsApiService) LegacyGetConnectors(ctx context.Context, spaceId string) ApiLegacyGetConnectorsRequest {
	return ApiLegacyGetConnectorsRequest{
		ApiService: a,
		ctx:        ctx,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return []ActionResponseProperties
//
// Deprecated
func (a *ConnectorsApiService) LegacyGetConnectorsExecute(r ApiLegacyGetConnectorsRequest) ([]ActionResponseProperties, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []ActionResponseProperties
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorsApiService.LegacyGetConnectors")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/actions"
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["ApiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegacyRunConnectorRequest struct {
	ctx                                     context.Context
	ApiService                              ConnectorsApi
	kbnXsrf                                 *string
	actionId                                string
	spaceId                                 string
	legacyRunConnectorRequestBodyProperties *LegacyRunConnectorRequestBodyProperties
}

// Cross-site request forgery protection
func (r ApiLegacyRunConnectorRequest) KbnXsrf(kbnXsrf string) ApiLegacyRunConnectorRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiLegacyRunConnectorRequest) LegacyRunConnectorRequestBodyProperties(legacyRunConnectorRequestBodyProperties LegacyRunConnectorRequestBodyProperties) ApiLegacyRunConnectorRequest {
	r.legacyRunConnectorRequestBodyProperties = &legacyRunConnectorRequestBodyProperties
	return r
}

func (r ApiLegacyRunConnectorRequest) Execute() (*LegacyRunConnector200Response, *http.Response, error) {
	return r.ApiService.LegacyRunConnectorExecute(r)
}

/*
LegacyRunConnector Runs a connector.

Deprecated in 7.13.0. Use the run connector API instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param actionId An identifier for the action.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiLegacyRunConnectorRequest

Deprecated
*/
func (a *ConnectorsApiService) LegacyRunConnector(ctx context.Context, actionId string, spaceId string) ApiLegacyRunConnectorRequest {
	return ApiLegacyRunConnectorRequest{
		ApiService: a,
		ctx:        ctx,
		actionId:   actionId,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return LegacyRunConnector200Response
//
// Deprecated
func (a *ConnectorsApiService) LegacyRunConnectorExecute(r ApiLegacyRunConnectorRequest) (*LegacyRunConnector200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *LegacyRunConnector200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorsApiService.LegacyRunConnector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/actions/action/{actionId}/_execute"
	localVarPath = strings.Replace(localVarPath, "{"+"actionId"+"}", url.PathEscape(parameterValueToString(r.actionId, "actionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return localVarReturnValue, nil, reportError("kbnXsrf is required and must be specified")
	}
	if r.legacyRunConnectorRequestBodyProperties == nil {
		return localVarReturnValue, nil, reportError("legacyRunConnectorRequestBodyProperties is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	// body params
	localVarPostBody = r.legacyRunConnectorRequestBodyProperties
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["ApiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLegacyUpdateConnectorRequest struct {
	ctx                                        context.Context
	ApiService                                 ConnectorsApi
	kbnXsrf                                    *string
	actionId                                   string
	spaceId                                    string
	legacyUpdateConnectorRequestBodyProperties *LegacyUpdateConnectorRequestBodyProperties
}

// Cross-site request forgery protection
func (r ApiLegacyUpdateConnectorRequest) KbnXsrf(kbnXsrf string) ApiLegacyUpdateConnectorRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiLegacyUpdateConnectorRequest) LegacyUpdateConnectorRequestBodyProperties(legacyUpdateConnectorRequestBodyProperties LegacyUpdateConnectorRequestBodyProperties) ApiLegacyUpdateConnectorRequest {
	r.legacyUpdateConnectorRequestBodyProperties = &legacyUpdateConnectorRequestBodyProperties
	return r
}

func (r ApiLegacyUpdateConnectorRequest) Execute() (*ActionResponseProperties, *http.Response, error) {
	return r.ApiService.LegacyUpdateConnectorExecute(r)
}

/*
LegacyUpdateConnector Updates the attributes for a connector.

Deprecated in 7.13.0. Use the update connector API instead.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param actionId An identifier for the action.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiLegacyUpdateConnectorRequest

Deprecated
*/
func (a *ConnectorsApiService) LegacyUpdateConnector(ctx context.Context, actionId string, spaceId string) ApiLegacyUpdateConnectorRequest {
	return ApiLegacyUpdateConnectorRequest{
		ApiService: a,
		ctx:        ctx,
		actionId:   actionId,
		spaceId:    spaceId,
	}
}

// Execute executes the request
//
//	@return ActionResponseProperties
//
// Deprecated
func (a *ConnectorsApiService) LegacyUpdateConnectorExecute(r ApiLegacyUpdateConnectorRequest) (*ActionResponseProperties, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ActionResponseProperties
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorsApiService.LegacyUpdateConnector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/actions/action/{actionId}"
	localVarPath = strings.Replace(localVarPath, "{"+"actionId"+"}", url.PathEscape(parameterValueToString(r.actionId, "actionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return localVarReturnValue, nil, reportError("kbnXsrf is required and must be specified")
	}
	if r.legacyUpdateConnectorRequestBodyProperties == nil {
		return localVarReturnValue, nil, reportError("legacyUpdateConnectorRequestBodyProperties is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	// body params
	localVarPostBody = r.legacyUpdateConnectorRequestBodyProperties
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["ApiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Model404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRunConnectorRequest struct {
	ctx                               context.Context
	ApiService                        ConnectorsApi
	kbnXsrf                           *string
	connectorId                       string
	spaceId                           string
	runConnectorRequestBodyProperties *RunConnectorRequestBodyProperties
}

// Cross-site request forgery protection
func (r ApiRunConnectorRequest) KbnXsrf(kbnXsrf string) ApiRunConnectorRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiRunConnectorRequest) RunConnectorRequestBodyProperties(runConnectorRequestBodyProperties RunConnectorRequestBodyProperties) ApiRunConnectorRequest {
	r.runConnectorRequestBodyProperties = &runConnectorRequestBodyProperties
	return r
}

func (r ApiRunConnectorRequest) Execute() (*RunConnector200Response, *http.Response, error) {
	return r.ApiService.RunConnectorExecute(r)
}

/*
RunConnector Runs a connector.

You can use this API to test an action that involves interaction with Kibana services or integrations with third-party systems. You must have `read` privileges for the **Actions and Connectors** feature in the **Management** section of the Kibana feature privileges. If you use an index connector, you must also have `all`, `create`, `index`, or `write` indices privileges.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectorId An identifier for the connector.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiRunConnectorRequest
*/
func (a *ConnectorsApiService) RunConnector(ctx context.Context, connectorId string, spaceId string) ApiRunConnectorRequest {
	return ApiRunConnectorRequest{
		ApiService:  a,
		ctx:         ctx,
		connectorId: connectorId,
		spaceId:     spaceId,
	}
}

// Execute executes the request
//
//	@return RunConnector200Response
func (a *ConnectorsApiService) RunConnectorExecute(r ApiRunConnectorRequest) (*RunConnector200Response, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *RunConnector200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorsApiService.RunConnector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/actions/connector/{connectorId}/_execute"
	localVarPath = strings.Replace(localVarPath, "{"+"connectorId"+"}", url.PathEscape(parameterValueToString(r.connectorId, "connectorId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return localVarReturnValue, nil, reportError("kbnXsrf is required and must be specified")
	}
	if r.runConnectorRequestBodyProperties == nil {
		return localVarReturnValue, nil, reportError("runConnectorRequestBodyProperties is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	// body params
	localVarPostBody = r.runConnectorRequestBodyProperties
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["ApiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateConnectorRequest struct {
	ctx                                  context.Context
	ApiService                           ConnectorsApi
	kbnXsrf                              *string
	connectorId                          string
	spaceId                              string
	updateConnectorRequestBodyProperties *UpdateConnectorRequestBodyProperties
}

// Cross-site request forgery protection
func (r ApiUpdateConnectorRequest) KbnXsrf(kbnXsrf string) ApiUpdateConnectorRequest {
	r.kbnXsrf = &kbnXsrf
	return r
}

func (r ApiUpdateConnectorRequest) UpdateConnectorRequestBodyProperties(updateConnectorRequestBodyProperties UpdateConnectorRequestBodyProperties) ApiUpdateConnectorRequest {
	r.updateConnectorRequestBodyProperties = &updateConnectorRequestBodyProperties
	return r
}

func (r ApiUpdateConnectorRequest) Execute() (*ConnectorResponseProperties, *http.Response, error) {
	return r.ApiService.UpdateConnectorExecute(r)
}

/*
UpdateConnector Updates the attributes for a connector.

You must have `all` privileges for the **Actions and Connectors** feature in the **Management** section of the Kibana feature privileges.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param connectorId An identifier for the connector.
	@param spaceId An identifier for the space. If `/s/` and the identifier are omitted from the path, the default space is used.
	@return ApiUpdateConnectorRequest
*/
func (a *ConnectorsApiService) UpdateConnector(ctx context.Context, connectorId string, spaceId string) ApiUpdateConnectorRequest {
	return ApiUpdateConnectorRequest{
		ApiService:  a,
		ctx:         ctx,
		connectorId: connectorId,
		spaceId:     spaceId,
	}
}

// Execute executes the request
//
//	@return ConnectorResponseProperties
func (a *ConnectorsApiService) UpdateConnectorExecute(r ApiUpdateConnectorRequest) (*ConnectorResponseProperties, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ConnectorResponseProperties
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ConnectorsApiService.UpdateConnector")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/s/{spaceId}/api/actions/connector/{connectorId}"
	localVarPath = strings.Replace(localVarPath, "{"+"connectorId"+"}", url.PathEscape(parameterValueToString(r.connectorId, "connectorId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"spaceId"+"}", url.PathEscape(parameterValueToString(r.spaceId, "spaceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.kbnXsrf == nil {
		return localVarReturnValue, nil, reportError("kbnXsrf is required and must be specified")
	}
	if r.updateConnectorRequestBodyProperties == nil {
		return localVarReturnValue, nil, reportError("updateConnectorRequestBodyProperties is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "kbn-xsrf", r.kbnXsrf, "")
	// body params
	localVarPostBody = r.updateConnectorRequestBodyProperties
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["ApiKey"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v UpdateConnector400Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Model401Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Model404Response
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
